"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@formkit";
exports.ids = ["vendor-chunks/@formkit"];
exports.modules = {

/***/ "(ssr)/./node_modules/@formkit/auto-animate/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@formkit/auto-animate/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ autoAnimate),\n/* harmony export */   getTransitionSizes: () => (/* binding */ getTransitionSizes),\n/* harmony export */   vAutoAnimate: () => (/* binding */ vAutoAnimate)\n/* harmony export */ });\n/**\n * A set of all the parents currently being observe. This is the only non weak\n * registry.\n */ const parents = new Set();\n/**\n * Element coordinates that is constantly kept up to date.\n */ const coords = new WeakMap();\n/**\n * Siblings of elements that have been removed from the dom.\n */ const siblings = new WeakMap();\n/**\n * Animations that are currently running.\n */ const animations = new WeakMap();\n/**\n * A map of existing intersection observers used to track element movements.\n */ const intersections = new WeakMap();\n/**\n * Intervals for automatically checking the position of elements occasionally.\n */ const intervals = new WeakMap();\n/**\n * The configuration options for each group of elements.\n */ const options = new WeakMap();\n/**\n * Debounce counters by id, used to debounce calls to update positions.\n */ const debounces = new WeakMap();\n/**\n * All parents that are currently enabled are tracked here.\n */ const enabled = new WeakSet();\n/**\n * The document used to calculate transitions.\n */ let root;\n/**\n * The root’s XY scroll positions.\n */ let scrollX = 0;\nlet scrollY = 0;\n/**\n * Used to sign an element as the target.\n */ const TGT = \"__aa_tgt\";\n/**\n * Used to sign an element as being part of a removal.\n */ const DEL = \"__aa_del\";\n/**\n * Used to sign an element as being \"new\". When an element is removed from the\n * dom, but may cycle back in we can sign it with new to ensure the next time\n * it is recognized we consider it new.\n */ const NEW = \"__aa_new\";\n/**\n * Callback for handling all mutations.\n * @param mutations - A mutation list\n */ const handleMutations = (mutations)=>{\n    const elements = getElements(mutations);\n    // If elements is \"false\" that means this mutation that should be ignored.\n    if (elements) {\n        elements.forEach((el)=>animate(el));\n    }\n};\n/**\n *\n * @param entries - Elements that have been resized.\n */ const handleResizes = (entries)=>{\n    entries.forEach((entry)=>{\n        if (entry.target === root) updateAllPos();\n        if (coords.has(entry.target)) updatePos(entry.target);\n    });\n};\n/**\n * Observe this elements position.\n * @param el - The element to observe the position of.\n */ function observePosition(el) {\n    const oldObserver = intersections.get(el);\n    oldObserver === null || oldObserver === void 0 ? void 0 : oldObserver.disconnect();\n    let rect = coords.get(el);\n    let invocations = 0;\n    const buffer = 5;\n    if (!rect) {\n        rect = getCoords(el);\n        coords.set(el, rect);\n    }\n    const { offsetWidth, offsetHeight } = root;\n    const rootMargins = [\n        rect.top - buffer,\n        offsetWidth - (rect.left + buffer + rect.width),\n        offsetHeight - (rect.top + buffer + rect.height),\n        rect.left - buffer\n    ];\n    const rootMargin = rootMargins.map((px)=>`${-1 * Math.floor(px)}px`).join(\" \");\n    const observer = new IntersectionObserver(()=>{\n        ++invocations > 1 && updatePos(el);\n    }, {\n        root,\n        threshold: 1,\n        rootMargin\n    });\n    observer.observe(el);\n    intersections.set(el, observer);\n}\n/**\n * Update the exact position of a given element.\n * @param el - An element to update the position of.\n */ function updatePos(el) {\n    clearTimeout(debounces.get(el));\n    const optionsOrPlugin = getOptions(el);\n    const delay = isPlugin(optionsOrPlugin) ? 500 : optionsOrPlugin.duration;\n    debounces.set(el, setTimeout(async ()=>{\n        const currentAnimation = animations.get(el);\n        try {\n            await (currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.finished);\n            coords.set(el, getCoords(el));\n            observePosition(el);\n        } catch  {\n        // ignore errors as the `.finished` promise is rejected when animations were cancelled\n        }\n    }, delay));\n}\n/**\n * Updates all positions that are currently being tracked.\n */ function updateAllPos() {\n    clearTimeout(debounces.get(root));\n    debounces.set(root, setTimeout(()=>{\n        parents.forEach((parent)=>forEach(parent, (el)=>lowPriority(()=>updatePos(el))));\n    }, 100));\n}\n/**\n * Its possible for a quick scroll or other fast events to get past the\n * intersection observer, so occasionally we need want \"cold-poll\" for the\n * latests and greatest position. We try to do this in the most non-disruptive\n * fashion possible. First we only do this ever couple seconds, staggard by a\n * random offset.\n * @param el - Element\n */ function poll(el) {\n    setTimeout(()=>{\n        intervals.set(el, setInterval(()=>lowPriority(updatePos.bind(null, el)), 2000));\n    }, Math.round(2000 * Math.random()));\n}\n/**\n * Perform some operation that is non critical at some point.\n * @param callback\n */ function lowPriority(callback) {\n    if (typeof requestIdleCallback === \"function\") {\n        requestIdleCallback(()=>callback());\n    } else {\n        requestAnimationFrame(()=>callback());\n    }\n}\n/**\n * The mutation observer responsible for watching each root element.\n */ let mutations;\n/**\n * A resize observer, responsible for recalculating elements on resize.\n */ let resize;\n/**\n * If this is in a browser, initialize our Web APIs\n */ if (false) {}\n/**\n * Retrieves all the elements that may have been affected by the last mutation\n * including ones that have been removed and are no longer in the DOM.\n * @param mutations - A mutation list.\n * @returns\n */ function getElements(mutations) {\n    const observedNodes = mutations.reduce((nodes, mutation)=>{\n        return [\n            ...nodes,\n            ...Array.from(mutation.addedNodes),\n            ...Array.from(mutation.removedNodes)\n        ];\n    }, []);\n    // Short circuit if _only_ comment nodes are observed\n    const onlyCommentNodesObserved = observedNodes.every((node)=>node.nodeName === \"#comment\");\n    if (onlyCommentNodesObserved) return false;\n    return mutations.reduce((elements, mutation)=>{\n        // Short circuit if we find a purposefully deleted node.\n        if (elements === false) return false;\n        if (mutation.target instanceof Element) {\n            target(mutation.target);\n            if (!elements.has(mutation.target)) {\n                elements.add(mutation.target);\n                for(let i = 0; i < mutation.target.children.length; i++){\n                    const child = mutation.target.children.item(i);\n                    if (!child) continue;\n                    if (DEL in child) {\n                        return false;\n                    }\n                    target(mutation.target, child);\n                    elements.add(child);\n                }\n            }\n            if (mutation.removedNodes.length) {\n                for(let i = 0; i < mutation.removedNodes.length; i++){\n                    const child = mutation.removedNodes[i];\n                    if (DEL in child) {\n                        return false;\n                    }\n                    if (child instanceof Element) {\n                        elements.add(child);\n                        target(mutation.target, child);\n                        siblings.set(child, [\n                            mutation.previousSibling,\n                            mutation.nextSibling\n                        ]);\n                    }\n                }\n            }\n        }\n        return elements;\n    }, new Set());\n}\n/**\n * Assign the target to an element.\n * @param el - The root element\n * @param child\n */ function target(el, child) {\n    if (!child && !(TGT in el)) Object.defineProperty(el, TGT, {\n        value: el\n    });\n    else if (child && !(TGT in child)) Object.defineProperty(child, TGT, {\n        value: el\n    });\n}\n/**\n * Determines what kind of change took place on the given element and then\n * performs the proper animation based on that.\n * @param el - The specific element to animate.\n */ function animate(el) {\n    var _a;\n    const isMounted = el.isConnected;\n    const preExisting = coords.has(el);\n    if (isMounted && siblings.has(el)) siblings.delete(el);\n    if (animations.has(el)) {\n        (_a = animations.get(el)) === null || _a === void 0 ? void 0 : _a.cancel();\n    }\n    if (NEW in el) {\n        add(el);\n    } else if (preExisting && isMounted) {\n        remain(el);\n    } else if (preExisting && !isMounted) {\n        remove(el);\n    } else {\n        add(el);\n    }\n}\n/**\n * Removes all non-digits from a string and casts to a number.\n * @param str - A string containing a pixel value.\n * @returns\n */ function raw(str) {\n    return Number(str.replace(/[^0-9.\\-]/g, \"\"));\n}\n/**\n * Get the scroll offset of elements\n * @param el - Element\n * @returns\n */ function getScrollOffset(el) {\n    let p = el.parentElement;\n    while(p){\n        if (p.scrollLeft || p.scrollTop) {\n            return {\n                x: p.scrollLeft,\n                y: p.scrollTop\n            };\n        }\n        p = p.parentElement;\n    }\n    return {\n        x: 0,\n        y: 0\n    };\n}\n/**\n * Get the coordinates of elements adjusted for scroll position.\n * @param el - Element\n * @returns\n */ function getCoords(el) {\n    const rect = el.getBoundingClientRect();\n    const { x, y } = getScrollOffset(el);\n    return {\n        top: rect.top + y,\n        left: rect.left + x,\n        width: rect.width,\n        height: rect.height\n    };\n}\n/**\n * Returns the width/height that the element should be transitioned between.\n * This takes into account box-sizing.\n * @param el - Element being animated\n * @param oldCoords - Old set of Coordinates coordinates\n * @param newCoords - New set of Coordinates coordinates\n * @returns\n */ function getTransitionSizes(el, oldCoords, newCoords) {\n    let widthFrom = oldCoords.width;\n    let heightFrom = oldCoords.height;\n    let widthTo = newCoords.width;\n    let heightTo = newCoords.height;\n    const styles = getComputedStyle(el);\n    const sizing = styles.getPropertyValue(\"box-sizing\");\n    if (sizing === \"content-box\") {\n        const paddingY = raw(styles.paddingTop) + raw(styles.paddingBottom) + raw(styles.borderTopWidth) + raw(styles.borderBottomWidth);\n        const paddingX = raw(styles.paddingLeft) + raw(styles.paddingRight) + raw(styles.borderRightWidth) + raw(styles.borderLeftWidth);\n        widthFrom -= paddingX;\n        widthTo -= paddingX;\n        heightFrom -= paddingY;\n        heightTo -= paddingY;\n    }\n    return [\n        widthFrom,\n        widthTo,\n        heightFrom,\n        heightTo\n    ].map(Math.round);\n}\n/**\n * Retrieves animation options for the current element.\n * @param el - Element to retrieve options for.\n * @returns\n */ function getOptions(el) {\n    return TGT in el && options.has(el[TGT]) ? options.get(el[TGT]) : {\n        duration: 250,\n        easing: \"ease-in-out\"\n    };\n}\n/**\n * Returns the target of a given animation (generally the parent).\n * @param el - An element to check for a target\n * @returns\n */ function getTarget(el) {\n    if (TGT in el) return el[TGT];\n    return undefined;\n}\n/**\n * Checks if animations are enabled or disabled for a given element.\n * @param el - Any element\n * @returns\n */ function isEnabled(el) {\n    const target = getTarget(el);\n    return target ? enabled.has(target) : false;\n}\n/**\n * Iterate over the children of a given parent.\n * @param parent - A parent element\n * @param callback - A callback\n */ function forEach(parent, ...callbacks) {\n    callbacks.forEach((callback)=>callback(parent, options.has(parent)));\n    for(let i = 0; i < parent.children.length; i++){\n        const child = parent.children.item(i);\n        if (child) {\n            callbacks.forEach((callback)=>callback(child, options.has(child)));\n        }\n    }\n}\n/**\n * Always return tuple to provide consistent interface\n */ function getPluginTuple(pluginReturn) {\n    if (Array.isArray(pluginReturn)) return pluginReturn;\n    return [\n        pluginReturn\n    ];\n}\n/**\n * Determine if config is plugin\n */ function isPlugin(config) {\n    return typeof config === \"function\";\n}\n/**\n * The element in question is remaining in the DOM.\n * @param el - Element to flip\n * @returns\n */ function remain(el) {\n    const oldCoords = coords.get(el);\n    const newCoords = getCoords(el);\n    if (!isEnabled(el)) return coords.set(el, newCoords);\n    let animation;\n    if (!oldCoords) return;\n    const pluginOrOptions = getOptions(el);\n    if (typeof pluginOrOptions !== \"function\") {\n        const deltaX = oldCoords.left - newCoords.left;\n        const deltaY = oldCoords.top - newCoords.top;\n        const [widthFrom, widthTo, heightFrom, heightTo] = getTransitionSizes(el, oldCoords, newCoords);\n        const start = {\n            transform: `translate(${deltaX}px, ${deltaY}px)`\n        };\n        const end = {\n            transform: `translate(0, 0)`\n        };\n        if (widthFrom !== widthTo) {\n            start.width = `${widthFrom}px`;\n            end.width = `${widthTo}px`;\n        }\n        if (heightFrom !== heightTo) {\n            start.height = `${heightFrom}px`;\n            end.height = `${heightTo}px`;\n        }\n        animation = el.animate([\n            start,\n            end\n        ], {\n            duration: pluginOrOptions.duration,\n            easing: pluginOrOptions.easing\n        });\n    } else {\n        const [keyframes] = getPluginTuple(pluginOrOptions(el, \"remain\", oldCoords, newCoords));\n        animation = new Animation(keyframes);\n        animation.play();\n    }\n    animations.set(el, animation);\n    coords.set(el, newCoords);\n    animation.addEventListener(\"finish\", updatePos.bind(null, el));\n}\n/**\n * Adds the element with a transition.\n * @param el - Animates the element being added.\n */ function add(el) {\n    if (NEW in el) delete el[NEW];\n    const newCoords = getCoords(el);\n    coords.set(el, newCoords);\n    const pluginOrOptions = getOptions(el);\n    if (!isEnabled(el)) return;\n    let animation;\n    if (typeof pluginOrOptions !== \"function\") {\n        animation = el.animate([\n            {\n                transform: \"scale(.98)\",\n                opacity: 0\n            },\n            {\n                transform: \"scale(0.98)\",\n                opacity: 0,\n                offset: 0.5\n            },\n            {\n                transform: \"scale(1)\",\n                opacity: 1\n            }\n        ], {\n            duration: pluginOrOptions.duration * 1.5,\n            easing: \"ease-in\"\n        });\n    } else {\n        const [keyframes] = getPluginTuple(pluginOrOptions(el, \"add\", newCoords));\n        animation = new Animation(keyframes);\n        animation.play();\n    }\n    animations.set(el, animation);\n    animation.addEventListener(\"finish\", updatePos.bind(null, el));\n}\n/**\n * Clean up after removing an element from the dom.\n * @param el - Element being removed\n * @param styles - Optional styles that should be removed from the element.\n */ function cleanUp(el, styles) {\n    var _a;\n    el.remove();\n    coords.delete(el);\n    siblings.delete(el);\n    animations.delete(el);\n    (_a = intersections.get(el)) === null || _a === void 0 ? void 0 : _a.disconnect();\n    setTimeout(()=>{\n        if (DEL in el) delete el[DEL];\n        Object.defineProperty(el, NEW, {\n            value: true,\n            configurable: true\n        });\n        if (styles && el instanceof HTMLElement) {\n            for(const style in styles){\n                el.style[style] = \"\";\n            }\n        }\n    }, 0);\n}\n/**\n * Animates the removal of an element.\n * @param el - Element to remove\n */ function remove(el) {\n    var _a;\n    if (!siblings.has(el) || !coords.has(el)) return;\n    const [prev, next] = siblings.get(el);\n    Object.defineProperty(el, DEL, {\n        value: true,\n        configurable: true\n    });\n    const finalX = window.scrollX;\n    const finalY = window.scrollY;\n    if (next && next.parentNode && next.parentNode instanceof Element) {\n        next.parentNode.insertBefore(el, next);\n    } else if (prev && prev.parentNode) {\n        prev.parentNode.appendChild(el);\n    } else {\n        (_a = getTarget(el)) === null || _a === void 0 ? void 0 : _a.appendChild(el);\n    }\n    if (!isEnabled(el)) return cleanUp(el);\n    const [top, left, width, height] = deletePosition(el);\n    const optionsOrPlugin = getOptions(el);\n    const oldCoords = coords.get(el);\n    if (finalX !== scrollX || finalY !== scrollY) {\n        adjustScroll(el, finalX, finalY, optionsOrPlugin);\n    }\n    let animation;\n    let styleReset = {\n        position: \"absolute\",\n        top: `${top}px`,\n        left: `${left}px`,\n        width: `${width}px`,\n        height: `${height}px`,\n        margin: \"0\",\n        pointerEvents: \"none\",\n        transformOrigin: \"center\",\n        zIndex: \"100\"\n    };\n    if (!isPlugin(optionsOrPlugin)) {\n        Object.assign(el.style, styleReset);\n        animation = el.animate([\n            {\n                transform: \"scale(1)\",\n                opacity: 1\n            },\n            {\n                transform: \"scale(.98)\",\n                opacity: 0\n            }\n        ], {\n            duration: optionsOrPlugin.duration,\n            easing: \"ease-out\"\n        });\n    } else {\n        const [keyframes, options] = getPluginTuple(optionsOrPlugin(el, \"remove\", oldCoords));\n        if ((options === null || options === void 0 ? void 0 : options.styleReset) !== false) {\n            styleReset = (options === null || options === void 0 ? void 0 : options.styleReset) || styleReset;\n            Object.assign(el.style, styleReset);\n        }\n        animation = new Animation(keyframes);\n        animation.play();\n    }\n    animations.set(el, animation);\n    animation.addEventListener(\"finish\", cleanUp.bind(null, el, styleReset));\n}\n/**\n * If the element being removed is at the very bottom of the page, and the\n * the page was scrolled into a space being \"made available\" by the element\n * that was removed, the page scroll will have jumped up some amount. We need\n * to offset the jump by the amount that the page was \"automatically\" scrolled\n * up. We can do this by comparing the scroll position before and after the\n * element was removed, and then offsetting by that amount.\n *\n * @param el - The element being deleted\n * @param finalX - The final X scroll position\n * @param finalY - The final Y scroll position\n * @param optionsOrPlugin - The options or plugin\n * @returns\n */ function adjustScroll(el, finalX, finalY, optionsOrPlugin) {\n    const scrollDeltaX = scrollX - finalX;\n    const scrollDeltaY = scrollY - finalY;\n    const scrollBefore = document.documentElement.style.scrollBehavior;\n    const scrollBehavior = getComputedStyle(root).scrollBehavior;\n    if (scrollBehavior === \"smooth\") {\n        document.documentElement.style.scrollBehavior = \"auto\";\n    }\n    window.scrollTo(window.scrollX + scrollDeltaX, window.scrollY + scrollDeltaY);\n    if (!el.parentElement) return;\n    const parent = el.parentElement;\n    let lastHeight = parent.clientHeight;\n    let lastWidth = parent.clientWidth;\n    const startScroll = performance.now();\n    // Here we use a manual scroll animation to keep the element using the same\n    // easing and timing as the parent’s scroll animation.\n    function smoothScroll() {\n        requestAnimationFrame(()=>{\n            if (!isPlugin(optionsOrPlugin)) {\n                const deltaY = lastHeight - parent.clientHeight;\n                const deltaX = lastWidth - parent.clientWidth;\n                if (startScroll + optionsOrPlugin.duration > performance.now()) {\n                    window.scrollTo({\n                        left: window.scrollX - deltaX,\n                        top: window.scrollY - deltaY\n                    });\n                    lastHeight = parent.clientHeight;\n                    lastWidth = parent.clientWidth;\n                    smoothScroll();\n                } else {\n                    document.documentElement.style.scrollBehavior = scrollBefore;\n                }\n            }\n        });\n    }\n    smoothScroll();\n}\n/**\n * Determines the position of the element being removed.\n * @param el - The element being deleted\n * @returns\n */ function deletePosition(el) {\n    const oldCoords = coords.get(el);\n    const [width, , height] = getTransitionSizes(el, oldCoords, getCoords(el));\n    let offsetParent = el.parentElement;\n    while(offsetParent && (getComputedStyle(offsetParent).position === \"static\" || offsetParent instanceof HTMLBodyElement)){\n        offsetParent = offsetParent.parentElement;\n    }\n    if (!offsetParent) offsetParent = document.body;\n    const parentStyles = getComputedStyle(offsetParent);\n    const parentCoords = coords.get(offsetParent) || getCoords(offsetParent);\n    const top = Math.round(oldCoords.top - parentCoords.top) - raw(parentStyles.borderTopWidth);\n    const left = Math.round(oldCoords.left - parentCoords.left) - raw(parentStyles.borderLeftWidth);\n    return [\n        top,\n        left,\n        width,\n        height\n    ];\n}\n/**\n * A function that automatically adds animation effects to itself and its\n * immediate children. Specifically it adds effects for adding, moving, and\n * removing DOM elements.\n * @param el - A parent element to add animations to.\n * @param options - An optional object of options.\n */ function autoAnimate(el, config = {}) {\n    if (mutations && resize) {\n        const mediaQuery = window.matchMedia(\"(prefers-reduced-motion: reduce)\");\n        const isDisabledDueToReduceMotion = mediaQuery.matches && !isPlugin(config) && !config.disrespectUserMotionPreference;\n        if (!isDisabledDueToReduceMotion) {\n            enabled.add(el);\n            if (getComputedStyle(el).position === \"static\") {\n                Object.assign(el.style, {\n                    position: \"relative\"\n                });\n            }\n            forEach(el, updatePos, poll, (element)=>resize === null || resize === void 0 ? void 0 : resize.observe(element));\n            if (isPlugin(config)) {\n                options.set(el, config);\n            } else {\n                options.set(el, {\n                    duration: 250,\n                    easing: \"ease-in-out\",\n                    ...config\n                });\n            }\n            mutations.observe(el, {\n                childList: true\n            });\n            parents.add(el);\n        }\n    }\n    return Object.freeze({\n        parent: el,\n        enable: ()=>{\n            enabled.add(el);\n        },\n        disable: ()=>{\n            enabled.delete(el);\n        },\n        isEnabled: ()=>enabled.has(el)\n    });\n}\n/**\n * The vue directive.\n */ const vAutoAnimate = {\n    mounted: (el, binding)=>{\n        autoAnimate(el, binding.value || {});\n    },\n    // ignore ssr see #96:\n    getSSRProps: ()=>({})\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvYXV0by1hbmltYXRlL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7O0NBR0MsR0FDRCxNQUFNQSxVQUFVLElBQUlDO0FBQ3BCOztDQUVDLEdBQ0QsTUFBTUMsU0FBUyxJQUFJQztBQUNuQjs7Q0FFQyxHQUNELE1BQU1DLFdBQVcsSUFBSUQ7QUFDckI7O0NBRUMsR0FDRCxNQUFNRSxhQUFhLElBQUlGO0FBQ3ZCOztDQUVDLEdBQ0QsTUFBTUcsZ0JBQWdCLElBQUlIO0FBQzFCOztDQUVDLEdBQ0QsTUFBTUksWUFBWSxJQUFJSjtBQUN0Qjs7Q0FFQyxHQUNELE1BQU1LLFVBQVUsSUFBSUw7QUFDcEI7O0NBRUMsR0FDRCxNQUFNTSxZQUFZLElBQUlOO0FBQ3RCOztDQUVDLEdBQ0QsTUFBTU8sVUFBVSxJQUFJQztBQUNwQjs7Q0FFQyxHQUNELElBQUlDO0FBQ0o7O0NBRUMsR0FDRCxJQUFJQyxVQUFVO0FBQ2QsSUFBSUMsVUFBVTtBQUNkOztDQUVDLEdBQ0QsTUFBTUMsTUFBTTtBQUNaOztDQUVDLEdBQ0QsTUFBTUMsTUFBTTtBQUNaOzs7O0NBSUMsR0FDRCxNQUFNQyxNQUFNO0FBQ1o7OztDQUdDLEdBQ0QsTUFBTUMsa0JBQWtCLENBQUNDO0lBQ3JCLE1BQU1DLFdBQVdDLFlBQVlGO0lBQzdCLDBFQUEwRTtJQUMxRSxJQUFJQyxVQUFVO1FBQ1ZBLFNBQVNFLE9BQU8sQ0FBQyxDQUFDQyxLQUFPQyxRQUFRRDtJQUNyQztBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUUsZ0JBQWdCLENBQUNDO0lBQ25CQSxRQUFRSixPQUFPLENBQUMsQ0FBQ0s7UUFDYixJQUFJQSxNQUFNQyxNQUFNLEtBQUtoQixNQUNqQmlCO1FBQ0osSUFBSTNCLE9BQU80QixHQUFHLENBQUNILE1BQU1DLE1BQU0sR0FDdkJHLFVBQVVKLE1BQU1DLE1BQU07SUFDOUI7QUFDSjtBQUNBOzs7Q0FHQyxHQUNELFNBQVNJLGdCQUFnQlQs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QUFPLEVBQUM7QUFDekI7QUFFb0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvYXV0by1hbmltYXRlL2luZGV4Lm1qcz9hOGQ2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBzZXQgb2YgYWxsIHRoZSBwYXJlbnRzIGN1cnJlbnRseSBiZWluZyBvYnNlcnZlLiBUaGlzIGlzIHRoZSBvbmx5IG5vbiB3ZWFrXG4gKiByZWdpc3RyeS5cbiAqL1xuY29uc3QgcGFyZW50cyA9IG5ldyBTZXQoKTtcbi8qKlxuICogRWxlbWVudCBjb29yZGluYXRlcyB0aGF0IGlzIGNvbnN0YW50bHkga2VwdCB1cCB0byBkYXRlLlxuICovXG5jb25zdCBjb29yZHMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBTaWJsaW5ncyBvZiBlbGVtZW50cyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIGRvbS5cbiAqL1xuY29uc3Qgc2libGluZ3MgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBBbmltYXRpb25zIHRoYXQgYXJlIGN1cnJlbnRseSBydW5uaW5nLlxuICovXG5jb25zdCBhbmltYXRpb25zID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQSBtYXAgb2YgZXhpc3RpbmcgaW50ZXJzZWN0aW9uIG9ic2VydmVycyB1c2VkIHRvIHRyYWNrIGVsZW1lbnQgbW92ZW1lbnRzLlxuICovXG5jb25zdCBpbnRlcnNlY3Rpb25zID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogSW50ZXJ2YWxzIGZvciBhdXRvbWF0aWNhbGx5IGNoZWNraW5nIHRoZSBwb3NpdGlvbiBvZiBlbGVtZW50cyBvY2Nhc2lvbmFsbHkuXG4gKi9cbmNvbnN0IGludGVydmFscyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGVhY2ggZ3JvdXAgb2YgZWxlbWVudHMuXG4gKi9cbmNvbnN0IG9wdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBEZWJvdW5jZSBjb3VudGVycyBieSBpZCwgdXNlZCB0byBkZWJvdW5jZSBjYWxscyB0byB1cGRhdGUgcG9zaXRpb25zLlxuICovXG5jb25zdCBkZWJvdW5jZXMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBBbGwgcGFyZW50cyB0aGF0IGFyZSBjdXJyZW50bHkgZW5hYmxlZCBhcmUgdHJhY2tlZCBoZXJlLlxuICovXG5jb25zdCBlbmFibGVkID0gbmV3IFdlYWtTZXQoKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IHVzZWQgdG8gY2FsY3VsYXRlIHRyYW5zaXRpb25zLlxuICovXG5sZXQgcm9vdDtcbi8qKlxuICogVGhlIHJvb3TigJlzIFhZIHNjcm9sbCBwb3NpdGlvbnMuXG4gKi9cbmxldCBzY3JvbGxYID0gMDtcbmxldCBzY3JvbGxZID0gMDtcbi8qKlxuICogVXNlZCB0byBzaWduIGFuIGVsZW1lbnQgYXMgdGhlIHRhcmdldC5cbiAqL1xuY29uc3QgVEdUID0gXCJfX2FhX3RndFwiO1xuLyoqXG4gKiBVc2VkIHRvIHNpZ24gYW4gZWxlbWVudCBhcyBiZWluZyBwYXJ0IG9mIGEgcmVtb3ZhbC5cbiAqL1xuY29uc3QgREVMID0gXCJfX2FhX2RlbFwiO1xuLyoqXG4gKiBVc2VkIHRvIHNpZ24gYW4gZWxlbWVudCBhcyBiZWluZyBcIm5ld1wiLiBXaGVuIGFuIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZVxuICogZG9tLCBidXQgbWF5IGN5Y2xlIGJhY2sgaW4gd2UgY2FuIHNpZ24gaXQgd2l0aCBuZXcgdG8gZW5zdXJlIHRoZSBuZXh0IHRpbWVcbiAqIGl0IGlzIHJlY29nbml6ZWQgd2UgY29uc2lkZXIgaXQgbmV3LlxuICovXG5jb25zdCBORVcgPSBcIl9fYWFfbmV3XCI7XG4vKipcbiAqIENhbGxiYWNrIGZvciBoYW5kbGluZyBhbGwgbXV0YXRpb25zLlxuICogQHBhcmFtIG11dGF0aW9ucyAtIEEgbXV0YXRpb24gbGlzdFxuICovXG5jb25zdCBoYW5kbGVNdXRhdGlvbnMgPSAobXV0YXRpb25zKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBnZXRFbGVtZW50cyhtdXRhdGlvbnMpO1xuICAgIC8vIElmIGVsZW1lbnRzIGlzIFwiZmFsc2VcIiB0aGF0IG1lYW5zIHRoaXMgbXV0YXRpb24gdGhhdCBzaG91bGQgYmUgaWdub3JlZC5cbiAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IGFuaW1hdGUoZWwpKTtcbiAgICB9XG59O1xuLyoqXG4gKlxuICogQHBhcmFtIGVudHJpZXMgLSBFbGVtZW50cyB0aGF0IGhhdmUgYmVlbiByZXNpemVkLlxuICovXG5jb25zdCBoYW5kbGVSZXNpemVzID0gKGVudHJpZXMpID0+IHtcbiAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgIGlmIChlbnRyeS50YXJnZXQgPT09IHJvb3QpXG4gICAgICAgICAgICB1cGRhdGVBbGxQb3MoKTtcbiAgICAgICAgaWYgKGNvb3Jkcy5oYXMoZW50cnkudGFyZ2V0KSlcbiAgICAgICAgICAgIHVwZGF0ZVBvcyhlbnRyeS50YXJnZXQpO1xuICAgIH0pO1xufTtcbi8qKlxuICogT2JzZXJ2ZSB0aGlzIGVsZW1lbnRzIHBvc2l0aW9uLlxuICogQHBhcmFtIGVsIC0gVGhlIGVsZW1lbnQgdG8gb2JzZXJ2ZSB0aGUgcG9zaXRpb24gb2YuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmVQb3NpdGlvbihlbCkge1xuICAgIGNvbnN0IG9sZE9ic2VydmVyID0gaW50ZXJzZWN0aW9ucy5nZXQoZWwpO1xuICAgIG9sZE9ic2VydmVyID09PSBudWxsIHx8IG9sZE9ic2VydmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgbGV0IHJlY3QgPSBjb29yZHMuZ2V0KGVsKTtcbiAgICBsZXQgaW52b2NhdGlvbnMgPSAwO1xuICAgIGNvbnN0IGJ1ZmZlciA9IDU7XG4gICAgaWYgKCFyZWN0KSB7XG4gICAgICAgIHJlY3QgPSBnZXRDb29yZHMoZWwpO1xuICAgICAgICBjb29yZHMuc2V0KGVsLCByZWN0KTtcbiAgICB9XG4gICAgY29uc3QgeyBvZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0IH0gPSByb290O1xuICAgIGNvbnN0IHJvb3RNYXJnaW5zID0gW1xuICAgICAgICByZWN0LnRvcCAtIGJ1ZmZlcixcbiAgICAgICAgb2Zmc2V0V2lkdGggLSAocmVjdC5sZWZ0ICsgYnVmZmVyICsgcmVjdC53aWR0aCksXG4gICAgICAgIG9mZnNldEhlaWdodCAtIChyZWN0LnRvcCArIGJ1ZmZlciArIHJlY3QuaGVpZ2h0KSxcbiAgICAgICAgcmVjdC5sZWZ0IC0gYnVmZmVyLFxuICAgIF07XG4gICAgY29uc3Qgcm9vdE1hcmdpbiA9IHJvb3RNYXJnaW5zXG4gICAgICAgIC5tYXAoKHB4KSA9PiBgJHstMSAqIE1hdGguZmxvb3IocHgpfXB4YClcbiAgICAgICAgLmpvaW4oXCIgXCIpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgKytpbnZvY2F0aW9ucyA+IDEgJiYgdXBkYXRlUG9zKGVsKTtcbiAgICB9LCB7XG4gICAgICAgIHJvb3QsXG4gICAgICAgIHRocmVzaG9sZDogMSxcbiAgICAgICAgcm9vdE1hcmdpbixcbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGVsKTtcbiAgICBpbnRlcnNlY3Rpb25zLnNldChlbCwgb2JzZXJ2ZXIpO1xufVxuLyoqXG4gKiBVcGRhdGUgdGhlIGV4YWN0IHBvc2l0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudC5cbiAqIEBwYXJhbSBlbCAtIEFuIGVsZW1lbnQgdG8gdXBkYXRlIHRoZSBwb3NpdGlvbiBvZi5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlUG9zKGVsKSB7XG4gICAgY2xlYXJUaW1lb3V0KGRlYm91bmNlcy5nZXQoZWwpKTtcbiAgICBjb25zdCBvcHRpb25zT3JQbHVnaW4gPSBnZXRPcHRpb25zKGVsKTtcbiAgICBjb25zdCBkZWxheSA9IGlzUGx1Z2luKG9wdGlvbnNPclBsdWdpbikgPyA1MDAgOiBvcHRpb25zT3JQbHVnaW4uZHVyYXRpb247XG4gICAgZGVib3VuY2VzLnNldChlbCwgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBbmltYXRpb24gPSBhbmltYXRpb25zLmdldChlbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCAoY3VycmVudEFuaW1hdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50QW5pbWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50QW5pbWF0aW9uLmZpbmlzaGVkKTtcbiAgICAgICAgICAgIGNvb3Jkcy5zZXQoZWwsIGdldENvb3JkcyhlbCkpO1xuICAgICAgICAgICAgb2JzZXJ2ZVBvc2l0aW9uKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGFzIHRoZSBgLmZpbmlzaGVkYCBwcm9taXNlIGlzIHJlamVjdGVkIHdoZW4gYW5pbWF0aW9ucyB3ZXJlIGNhbmNlbGxlZFxuICAgICAgICB9XG4gICAgfSwgZGVsYXkpKTtcbn1cbi8qKlxuICogVXBkYXRlcyBhbGwgcG9zaXRpb25zIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyB0cmFja2VkLlxuICovXG5mdW5jdGlvbiB1cGRhdGVBbGxQb3MoKSB7XG4gICAgY2xlYXJUaW1lb3V0KGRlYm91bmNlcy5nZXQocm9vdCkpO1xuICAgIGRlYm91bmNlcy5zZXQocm9vdCwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHBhcmVudHMuZm9yRWFjaCgocGFyZW50KSA9PiBmb3JFYWNoKHBhcmVudCwgKGVsKSA9PiBsb3dQcmlvcml0eSgoKSA9PiB1cGRhdGVQb3MoZWwpKSkpO1xuICAgIH0sIDEwMCkpO1xufVxuLyoqXG4gKiBJdHMgcG9zc2libGUgZm9yIGEgcXVpY2sgc2Nyb2xsIG9yIG90aGVyIGZhc3QgZXZlbnRzIHRvIGdldCBwYXN0IHRoZVxuICogaW50ZXJzZWN0aW9uIG9ic2VydmVyLCBzbyBvY2Nhc2lvbmFsbHkgd2UgbmVlZCB3YW50IFwiY29sZC1wb2xsXCIgZm9yIHRoZVxuICogbGF0ZXN0cyBhbmQgZ3JlYXRlc3QgcG9zaXRpb24uIFdlIHRyeSB0byBkbyB0aGlzIGluIHRoZSBtb3N0IG5vbi1kaXNydXB0aXZlXG4gKiBmYXNoaW9uIHBvc3NpYmxlLiBGaXJzdCB3ZSBvbmx5IGRvIHRoaXMgZXZlciBjb3VwbGUgc2Vjb25kcywgc3RhZ2dhcmQgYnkgYVxuICogcmFuZG9tIG9mZnNldC5cbiAqIEBwYXJhbSBlbCAtIEVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gcG9sbChlbCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpbnRlcnZhbHMuc2V0KGVsLCBzZXRJbnRlcnZhbCgoKSA9PiBsb3dQcmlvcml0eSh1cGRhdGVQb3MuYmluZChudWxsLCBlbCkpLCAyMDAwKSk7XG4gICAgfSwgTWF0aC5yb3VuZCgyMDAwICogTWF0aC5yYW5kb20oKSkpO1xufVxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIHRoYXQgaXMgbm9uIGNyaXRpY2FsIGF0IHNvbWUgcG9pbnQuXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gbG93UHJpb3JpdHkoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IGNhbGxiYWNrKCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGNhbGxiYWNrKCkpO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIG11dGF0aW9uIG9ic2VydmVyIHJlc3BvbnNpYmxlIGZvciB3YXRjaGluZyBlYWNoIHJvb3QgZWxlbWVudC5cbiAqL1xubGV0IG11dGF0aW9ucztcbi8qKlxuICogQSByZXNpemUgb2JzZXJ2ZXIsIHJlc3BvbnNpYmxlIGZvciByZWNhbGN1bGF0aW5nIGVsZW1lbnRzIG9uIHJlc2l6ZS5cbiAqL1xubGV0IHJlc2l6ZTtcbi8qKlxuICogSWYgdGhpcyBpcyBpbiBhIGJyb3dzZXIsIGluaXRpYWxpemUgb3VyIFdlYiBBUElzXG4gKi9cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBtdXRhdGlvbnMgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVNdXRhdGlvbnMpO1xuICAgIHJlc2l6ZSA9IG5ldyBSZXNpemVPYnNlcnZlcihoYW5kbGVSZXNpemVzKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICAgIHNjcm9sbFkgPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgc2Nyb2xsWCA9IHdpbmRvdy5zY3JvbGxYO1xuICAgIH0pO1xuICAgIHJlc2l6ZS5vYnNlcnZlKHJvb3QpO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgYWxsIHRoZSBlbGVtZW50cyB0aGF0IG1heSBoYXZlIGJlZW4gYWZmZWN0ZWQgYnkgdGhlIGxhc3QgbXV0YXRpb25cbiAqIGluY2x1ZGluZyBvbmVzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgYW5kIGFyZSBubyBsb25nZXIgaW4gdGhlIERPTS5cbiAqIEBwYXJhbSBtdXRhdGlvbnMgLSBBIG11dGF0aW9uIGxpc3QuXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRFbGVtZW50cyhtdXRhdGlvbnMpIHtcbiAgICBjb25zdCBvYnNlcnZlZE5vZGVzID0gbXV0YXRpb25zLnJlZHVjZSgobm9kZXMsIG11dGF0aW9uKSA9PiB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi5ub2RlcyxcbiAgICAgICAgICAgIC4uLkFycmF5LmZyb20obXV0YXRpb24uYWRkZWROb2RlcyksXG4gICAgICAgICAgICAuLi5BcnJheS5mcm9tKG11dGF0aW9uLnJlbW92ZWROb2RlcyksXG4gICAgICAgIF07XG4gICAgfSwgW10pO1xuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgX29ubHlfIGNvbW1lbnQgbm9kZXMgYXJlIG9ic2VydmVkXG4gICAgY29uc3Qgb25seUNvbW1lbnROb2Rlc09ic2VydmVkID0gb2JzZXJ2ZWROb2Rlcy5ldmVyeSgobm9kZSkgPT4gbm9kZS5ub2RlTmFtZSA9PT0gXCIjY29tbWVudFwiKTtcbiAgICBpZiAob25seUNvbW1lbnROb2Rlc09ic2VydmVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIG11dGF0aW9ucy5yZWR1Y2UoKGVsZW1lbnRzLCBtdXRhdGlvbikgPT4ge1xuICAgICAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHdlIGZpbmQgYSBwdXJwb3NlZnVsbHkgZGVsZXRlZCBub2RlLlxuICAgICAgICBpZiAoZWxlbWVudHMgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobXV0YXRpb24udGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgdGFyZ2V0KG11dGF0aW9uLnRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnRzLmhhcyhtdXRhdGlvbi50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMuYWRkKG11dGF0aW9uLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi50YXJnZXQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBtdXRhdGlvbi50YXJnZXQuY2hpbGRyZW4uaXRlbShpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoREVMIGluIGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0KG11dGF0aW9uLnRhcmdldCwgY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChERUwgaW4gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0KG11dGF0aW9uLnRhcmdldCwgY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZ3Muc2V0KGNoaWxkLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24ucHJldmlvdXNTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uLm5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH0sIG5ldyBTZXQoKSk7XG59XG4vKipcbiAqIEFzc2lnbiB0aGUgdGFyZ2V0IHRvIGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0gZWwgLSBUaGUgcm9vdCBlbGVtZW50XG4gKiBAcGFyYW0gY2hpbGRcbiAqL1xuZnVuY3Rpb24gdGFyZ2V0KGVsLCBjaGlsZCkge1xuICAgIGlmICghY2hpbGQgJiYgIShUR1QgaW4gZWwpKVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsIFRHVCwgeyB2YWx1ZTogZWwgfSk7XG4gICAgZWxzZSBpZiAoY2hpbGQgJiYgIShUR1QgaW4gY2hpbGQpKVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hpbGQsIFRHVCwgeyB2YWx1ZTogZWwgfSk7XG59XG4vKipcbiAqIERldGVybWluZXMgd2hhdCBraW5kIG9mIGNoYW5nZSB0b29rIHBsYWNlIG9uIHRoZSBnaXZlbiBlbGVtZW50IGFuZCB0aGVuXG4gKiBwZXJmb3JtcyB0aGUgcHJvcGVyIGFuaW1hdGlvbiBiYXNlZCBvbiB0aGF0LlxuICogQHBhcmFtIGVsIC0gVGhlIHNwZWNpZmljIGVsZW1lbnQgdG8gYW5pbWF0ZS5cbiAqL1xuZnVuY3Rpb24gYW5pbWF0ZShlbCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBpc01vdW50ZWQgPSBlbC5pc0Nvbm5lY3RlZDtcbiAgICBjb25zdCBwcmVFeGlzdGluZyA9IGNvb3Jkcy5oYXMoZWwpO1xuICAgIGlmIChpc01vdW50ZWQgJiYgc2libGluZ3MuaGFzKGVsKSlcbiAgICAgICAgc2libGluZ3MuZGVsZXRlKGVsKTtcbiAgICBpZiAoYW5pbWF0aW9ucy5oYXMoZWwpKSB7XG4gICAgICAgIChfYSA9IGFuaW1hdGlvbnMuZ2V0KGVsKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbCgpO1xuICAgIH1cbiAgICBpZiAoTkVXIGluIGVsKSB7XG4gICAgICAgIGFkZChlbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByZUV4aXN0aW5nICYmIGlzTW91bnRlZCkge1xuICAgICAgICByZW1haW4oZWwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcmVFeGlzdGluZyAmJiAhaXNNb3VudGVkKSB7XG4gICAgICAgIHJlbW92ZShlbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhZGQoZWwpO1xuICAgIH1cbn1cbi8qKlxuICogUmVtb3ZlcyBhbGwgbm9uLWRpZ2l0cyBmcm9tIGEgc3RyaW5nIGFuZCBjYXN0cyB0byBhIG51bWJlci5cbiAqIEBwYXJhbSBzdHIgLSBBIHN0cmluZyBjb250YWluaW5nIGEgcGl4ZWwgdmFsdWUuXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiByYXcoc3RyKSB7XG4gICAgcmV0dXJuIE51bWJlcihzdHIucmVwbGFjZSgvW14wLTkuXFwtXS9nLCBcIlwiKSk7XG59XG4vKipcbiAqIEdldCB0aGUgc2Nyb2xsIG9mZnNldCBvZiBlbGVtZW50c1xuICogQHBhcmFtIGVsIC0gRWxlbWVudFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsT2Zmc2V0KGVsKSB7XG4gICAgbGV0IHAgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgIHdoaWxlIChwKSB7XG4gICAgICAgIGlmIChwLnNjcm9sbExlZnQgfHwgcC5zY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IHAuc2Nyb2xsTGVmdCwgeTogcC5zY3JvbGxUb3AgfTtcbiAgICAgICAgfVxuICAgICAgICBwID0gcC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG59XG4vKipcbiAqIEdldCB0aGUgY29vcmRpbmF0ZXMgb2YgZWxlbWVudHMgYWRqdXN0ZWQgZm9yIHNjcm9sbCBwb3NpdGlvbi5cbiAqIEBwYXJhbSBlbCAtIEVsZW1lbnRcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGdldENvb3JkcyhlbCkge1xuICAgIGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldFNjcm9sbE9mZnNldChlbCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIHksXG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHgsXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHdpZHRoL2hlaWdodCB0aGF0IHRoZSBlbGVtZW50IHNob3VsZCBiZSB0cmFuc2l0aW9uZWQgYmV0d2Vlbi5cbiAqIFRoaXMgdGFrZXMgaW50byBhY2NvdW50IGJveC1zaXppbmcuXG4gKiBAcGFyYW0gZWwgLSBFbGVtZW50IGJlaW5nIGFuaW1hdGVkXG4gKiBAcGFyYW0gb2xkQ29vcmRzIC0gT2xkIHNldCBvZiBDb29yZGluYXRlcyBjb29yZGluYXRlc1xuICogQHBhcmFtIG5ld0Nvb3JkcyAtIE5ldyBzZXQgb2YgQ29vcmRpbmF0ZXMgY29vcmRpbmF0ZXNcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25TaXplcyhlbCwgb2xkQ29vcmRzLCBuZXdDb29yZHMpIHtcbiAgICBsZXQgd2lkdGhGcm9tID0gb2xkQ29vcmRzLndpZHRoO1xuICAgIGxldCBoZWlnaHRGcm9tID0gb2xkQ29vcmRzLmhlaWdodDtcbiAgICBsZXQgd2lkdGhUbyA9IG5ld0Nvb3Jkcy53aWR0aDtcbiAgICBsZXQgaGVpZ2h0VG8gPSBuZXdDb29yZHMuaGVpZ2h0O1xuICAgIGNvbnN0IHN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIGNvbnN0IHNpemluZyA9IHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKFwiYm94LXNpemluZ1wiKTtcbiAgICBpZiAoc2l6aW5nID09PSBcImNvbnRlbnQtYm94XCIpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZ1kgPSByYXcoc3R5bGVzLnBhZGRpbmdUb3ApICtcbiAgICAgICAgICAgIHJhdyhzdHlsZXMucGFkZGluZ0JvdHRvbSkgK1xuICAgICAgICAgICAgcmF3KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCkgK1xuICAgICAgICAgICAgcmF3KHN0eWxlcy5ib3JkZXJCb3R0b21XaWR0aCk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdYID0gcmF3KHN0eWxlcy5wYWRkaW5nTGVmdCkgK1xuICAgICAgICAgICAgcmF3KHN0eWxlcy5wYWRkaW5nUmlnaHQpICtcbiAgICAgICAgICAgIHJhdyhzdHlsZXMuYm9yZGVyUmlnaHRXaWR0aCkgK1xuICAgICAgICAgICAgcmF3KHN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgpO1xuICAgICAgICB3aWR0aEZyb20gLT0gcGFkZGluZ1g7XG4gICAgICAgIHdpZHRoVG8gLT0gcGFkZGluZ1g7XG4gICAgICAgIGhlaWdodEZyb20gLT0gcGFkZGluZ1k7XG4gICAgICAgIGhlaWdodFRvIC09IHBhZGRpbmdZO1xuICAgIH1cbiAgICByZXR1cm4gW3dpZHRoRnJvbSwgd2lkdGhUbywgaGVpZ2h0RnJvbSwgaGVpZ2h0VG9dLm1hcChNYXRoLnJvdW5kKTtcbn1cbi8qKlxuICogUmV0cmlldmVzIGFuaW1hdGlvbiBvcHRpb25zIGZvciB0aGUgY3VycmVudCBlbGVtZW50LlxuICogQHBhcmFtIGVsIC0gRWxlbWVudCB0byByZXRyaWV2ZSBvcHRpb25zIGZvci5cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGdldE9wdGlvbnMoZWwpIHtcbiAgICByZXR1cm4gVEdUIGluIGVsICYmIG9wdGlvbnMuaGFzKGVsW1RHVF0pXG4gICAgICAgID8gb3B0aW9ucy5nZXQoZWxbVEdUXSlcbiAgICAgICAgOiB7IGR1cmF0aW9uOiAyNTAsIGVhc2luZzogXCJlYXNlLWluLW91dFwiIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHRhcmdldCBvZiBhIGdpdmVuIGFuaW1hdGlvbiAoZ2VuZXJhbGx5IHRoZSBwYXJlbnQpLlxuICogQHBhcmFtIGVsIC0gQW4gZWxlbWVudCB0byBjaGVjayBmb3IgYSB0YXJnZXRcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGdldFRhcmdldChlbCkge1xuICAgIGlmIChUR1QgaW4gZWwpXG4gICAgICAgIHJldHVybiBlbFtUR1RdO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIENoZWNrcyBpZiBhbmltYXRpb25zIGFyZSBlbmFibGVkIG9yIGRpc2FibGVkIGZvciBhIGdpdmVuIGVsZW1lbnQuXG4gKiBAcGFyYW0gZWwgLSBBbnkgZWxlbWVudFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gaXNFbmFibGVkKGVsKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGVsKTtcbiAgICByZXR1cm4gdGFyZ2V0ID8gZW5hYmxlZC5oYXModGFyZ2V0KSA6IGZhbHNlO1xufVxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgdGhlIGNoaWxkcmVuIG9mIGEgZ2l2ZW4gcGFyZW50LlxuICogQHBhcmFtIHBhcmVudCAtIEEgcGFyZW50IGVsZW1lbnRcbiAqIEBwYXJhbSBjYWxsYmFjayAtIEEgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChwYXJlbnQsIC4uLmNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2socGFyZW50LCBvcHRpb25zLmhhcyhwYXJlbnQpKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW4uaXRlbShpKTtcbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICBjYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGNoaWxkLCBvcHRpb25zLmhhcyhjaGlsZCkpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQWx3YXlzIHJldHVybiB0dXBsZSB0byBwcm92aWRlIGNvbnNpc3RlbnQgaW50ZXJmYWNlXG4gKi9cbmZ1bmN0aW9uIGdldFBsdWdpblR1cGxlKHBsdWdpblJldHVybikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBsdWdpblJldHVybikpXG4gICAgICAgIHJldHVybiBwbHVnaW5SZXR1cm47XG4gICAgcmV0dXJuIFtwbHVnaW5SZXR1cm5dO1xufVxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgY29uZmlnIGlzIHBsdWdpblxuICovXG5mdW5jdGlvbiBpc1BsdWdpbihjb25maWcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNvbmZpZyA9PT0gXCJmdW5jdGlvblwiO1xufVxuLyoqXG4gKiBUaGUgZWxlbWVudCBpbiBxdWVzdGlvbiBpcyByZW1haW5pbmcgaW4gdGhlIERPTS5cbiAqIEBwYXJhbSBlbCAtIEVsZW1lbnQgdG8gZmxpcFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gcmVtYWluKGVsKSB7XG4gICAgY29uc3Qgb2xkQ29vcmRzID0gY29vcmRzLmdldChlbCk7XG4gICAgY29uc3QgbmV3Q29vcmRzID0gZ2V0Q29vcmRzKGVsKTtcbiAgICBpZiAoIWlzRW5hYmxlZChlbCkpXG4gICAgICAgIHJldHVybiBjb29yZHMuc2V0KGVsLCBuZXdDb29yZHMpO1xuICAgIGxldCBhbmltYXRpb247XG4gICAgaWYgKCFvbGRDb29yZHMpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBwbHVnaW5Pck9wdGlvbnMgPSBnZXRPcHRpb25zKGVsKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbk9yT3B0aW9ucyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhWCA9IG9sZENvb3Jkcy5sZWZ0IC0gbmV3Q29vcmRzLmxlZnQ7XG4gICAgICAgIGNvbnN0IGRlbHRhWSA9IG9sZENvb3Jkcy50b3AgLSBuZXdDb29yZHMudG9wO1xuICAgICAgICBjb25zdCBbd2lkdGhGcm9tLCB3aWR0aFRvLCBoZWlnaHRGcm9tLCBoZWlnaHRUb10gPSBnZXRUcmFuc2l0aW9uU2l6ZXMoZWwsIG9sZENvb3JkcywgbmV3Q29vcmRzKTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtkZWx0YVh9cHgsICR7ZGVsdGFZfXB4KWAsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVuZCA9IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgwLCAwKWAsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh3aWR0aEZyb20gIT09IHdpZHRoVG8pIHtcbiAgICAgICAgICAgIHN0YXJ0LndpZHRoID0gYCR7d2lkdGhGcm9tfXB4YDtcbiAgICAgICAgICAgIGVuZC53aWR0aCA9IGAke3dpZHRoVG99cHhgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRGcm9tICE9PSBoZWlnaHRUbykge1xuICAgICAgICAgICAgc3RhcnQuaGVpZ2h0ID0gYCR7aGVpZ2h0RnJvbX1weGA7XG4gICAgICAgICAgICBlbmQuaGVpZ2h0ID0gYCR7aGVpZ2h0VG99cHhgO1xuICAgICAgICB9XG4gICAgICAgIGFuaW1hdGlvbiA9IGVsLmFuaW1hdGUoW3N0YXJ0LCBlbmRdLCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogcGx1Z2luT3JPcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nOiBwbHVnaW5Pck9wdGlvbnMuZWFzaW5nLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IFtrZXlmcmFtZXNdID0gZ2V0UGx1Z2luVHVwbGUocGx1Z2luT3JPcHRpb25zKGVsLCBcInJlbWFpblwiLCBvbGRDb29yZHMsIG5ld0Nvb3JkcykpO1xuICAgICAgICBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKGtleWZyYW1lcyk7XG4gICAgICAgIGFuaW1hdGlvbi5wbGF5KCk7XG4gICAgfVxuICAgIGFuaW1hdGlvbnMuc2V0KGVsLCBhbmltYXRpb24pO1xuICAgIGNvb3Jkcy5zZXQoZWwsIG5ld0Nvb3Jkcyk7XG4gICAgYW5pbWF0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJmaW5pc2hcIiwgdXBkYXRlUG9zLmJpbmQobnVsbCwgZWwpKTtcbn1cbi8qKlxuICogQWRkcyB0aGUgZWxlbWVudCB3aXRoIGEgdHJhbnNpdGlvbi5cbiAqIEBwYXJhbSBlbCAtIEFuaW1hdGVzIHRoZSBlbGVtZW50IGJlaW5nIGFkZGVkLlxuICovXG5mdW5jdGlvbiBhZGQoZWwpIHtcbiAgICBpZiAoTkVXIGluIGVsKVxuICAgICAgICBkZWxldGUgZWxbTkVXXTtcbiAgICBjb25zdCBuZXdDb29yZHMgPSBnZXRDb29yZHMoZWwpO1xuICAgIGNvb3Jkcy5zZXQoZWwsIG5ld0Nvb3Jkcyk7XG4gICAgY29uc3QgcGx1Z2luT3JPcHRpb25zID0gZ2V0T3B0aW9ucyhlbCk7XG4gICAgaWYgKCFpc0VuYWJsZWQoZWwpKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGFuaW1hdGlvbjtcbiAgICBpZiAodHlwZW9mIHBsdWdpbk9yT3B0aW9ucyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGFuaW1hdGlvbiA9IGVsLmFuaW1hdGUoW1xuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IFwic2NhbGUoLjk4KVwiLCBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogXCJzY2FsZSgwLjk4KVwiLCBvcGFjaXR5OiAwLCBvZmZzZXQ6IDAuNSB9LFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IFwic2NhbGUoMSlcIiwgb3BhY2l0eTogMSB9LFxuICAgICAgICBdLCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogcGx1Z2luT3JPcHRpb25zLmR1cmF0aW9uICogMS41LFxuICAgICAgICAgICAgZWFzaW5nOiBcImVhc2UtaW5cIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBba2V5ZnJhbWVzXSA9IGdldFBsdWdpblR1cGxlKHBsdWdpbk9yT3B0aW9ucyhlbCwgXCJhZGRcIiwgbmV3Q29vcmRzKSk7XG4gICAgICAgIGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oa2V5ZnJhbWVzKTtcbiAgICAgICAgYW5pbWF0aW9uLnBsYXkoKTtcbiAgICB9XG4gICAgYW5pbWF0aW9ucy5zZXQoZWwsIGFuaW1hdGlvbik7XG4gICAgYW5pbWF0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJmaW5pc2hcIiwgdXBkYXRlUG9zLmJpbmQobnVsbCwgZWwpKTtcbn1cbi8qKlxuICogQ2xlYW4gdXAgYWZ0ZXIgcmVtb3ZpbmcgYW4gZWxlbWVudCBmcm9tIHRoZSBkb20uXG4gKiBAcGFyYW0gZWwgLSBFbGVtZW50IGJlaW5nIHJlbW92ZWRcbiAqIEBwYXJhbSBzdHlsZXMgLSBPcHRpb25hbCBzdHlsZXMgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBjbGVhblVwKGVsLCBzdHlsZXMpIHtcbiAgICB2YXIgX2E7XG4gICAgZWwucmVtb3ZlKCk7XG4gICAgY29vcmRzLmRlbGV0ZShlbCk7XG4gICAgc2libGluZ3MuZGVsZXRlKGVsKTtcbiAgICBhbmltYXRpb25zLmRlbGV0ZShlbCk7XG4gICAgKF9hID0gaW50ZXJzZWN0aW9ucy5nZXQoZWwpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoREVMIGluIGVsKVxuICAgICAgICAgICAgZGVsZXRlIGVsW0RFTF07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgTkVXLCB7IHZhbHVlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgICAgIGlmIChzdHlsZXMgJiYgZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdHlsZSBpbiBzdHlsZXMpIHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZVtzdHlsZV0gPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgMCk7XG59XG4vKipcbiAqIEFuaW1hdGVzIHRoZSByZW1vdmFsIG9mIGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0gZWwgLSBFbGVtZW50IHRvIHJlbW92ZVxuICovXG5mdW5jdGlvbiByZW1vdmUoZWwpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFzaWJsaW5ncy5oYXMoZWwpIHx8ICFjb29yZHMuaGFzKGVsKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IFtwcmV2LCBuZXh0XSA9IHNpYmxpbmdzLmdldChlbCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCBERUwsIHsgdmFsdWU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICBjb25zdCBmaW5hbFggPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICBjb25zdCBmaW5hbFkgPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICBpZiAobmV4dCAmJiBuZXh0LnBhcmVudE5vZGUgJiYgbmV4dC5wYXJlbnROb2RlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICBuZXh0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCBuZXh0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJldiAmJiBwcmV2LnBhcmVudE5vZGUpIHtcbiAgICAgICAgcHJldi5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIChfYSA9IGdldFRhcmdldChlbCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcHBlbmRDaGlsZChlbCk7XG4gICAgfVxuICAgIGlmICghaXNFbmFibGVkKGVsKSlcbiAgICAgICAgcmV0dXJuIGNsZWFuVXAoZWwpO1xuICAgIGNvbnN0IFt0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHRdID0gZGVsZXRlUG9zaXRpb24oZWwpO1xuICAgIGNvbnN0IG9wdGlvbnNPclBsdWdpbiA9IGdldE9wdGlvbnMoZWwpO1xuICAgIGNvbnN0IG9sZENvb3JkcyA9IGNvb3Jkcy5nZXQoZWwpO1xuICAgIGlmIChmaW5hbFggIT09IHNjcm9sbFggfHwgZmluYWxZICE9PSBzY3JvbGxZKSB7XG4gICAgICAgIGFkanVzdFNjcm9sbChlbCwgZmluYWxYLCBmaW5hbFksIG9wdGlvbnNPclBsdWdpbik7XG4gICAgfVxuICAgIGxldCBhbmltYXRpb247XG4gICAgbGV0IHN0eWxlUmVzZXQgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHRvcDogYCR7dG9wfXB4YCxcbiAgICAgICAgbGVmdDogYCR7bGVmdH1weGAsXG4gICAgICAgIHdpZHRoOiBgJHt3aWR0aH1weGAsXG4gICAgICAgIGhlaWdodDogYCR7aGVpZ2h0fXB4YCxcbiAgICAgICAgbWFyZ2luOiBcIjBcIixcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbjogXCJjZW50ZXJcIixcbiAgICAgICAgekluZGV4OiBcIjEwMFwiLFxuICAgIH07XG4gICAgaWYgKCFpc1BsdWdpbihvcHRpb25zT3JQbHVnaW4pKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZWwuc3R5bGUsIHN0eWxlUmVzZXQpO1xuICAgICAgICBhbmltYXRpb24gPSBlbC5hbmltYXRlKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoMSlcIixcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoLjk4KVwiLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLCB7IGR1cmF0aW9uOiBvcHRpb25zT3JQbHVnaW4uZHVyYXRpb24sIGVhc2luZzogXCJlYXNlLW91dFwiIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgW2tleWZyYW1lcywgb3B0aW9uc10gPSBnZXRQbHVnaW5UdXBsZShvcHRpb25zT3JQbHVnaW4oZWwsIFwicmVtb3ZlXCIsIG9sZENvb3JkcykpO1xuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zdHlsZVJlc2V0KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0eWxlUmVzZXQgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnN0eWxlUmVzZXQpIHx8IHN0eWxlUmVzZXQ7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGVsLnN0eWxlLCBzdHlsZVJlc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKGtleWZyYW1lcyk7XG4gICAgICAgIGFuaW1hdGlvbi5wbGF5KCk7XG4gICAgfVxuICAgIGFuaW1hdGlvbnMuc2V0KGVsLCBhbmltYXRpb24pO1xuICAgIGFuaW1hdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiZmluaXNoXCIsIGNsZWFuVXAuYmluZChudWxsLCBlbCwgc3R5bGVSZXNldCkpO1xufVxuLyoqXG4gKiBJZiB0aGUgZWxlbWVudCBiZWluZyByZW1vdmVkIGlzIGF0IHRoZSB2ZXJ5IGJvdHRvbSBvZiB0aGUgcGFnZSwgYW5kIHRoZVxuICogdGhlIHBhZ2Ugd2FzIHNjcm9sbGVkIGludG8gYSBzcGFjZSBiZWluZyBcIm1hZGUgYXZhaWxhYmxlXCIgYnkgdGhlIGVsZW1lbnRcbiAqIHRoYXQgd2FzIHJlbW92ZWQsIHRoZSBwYWdlIHNjcm9sbCB3aWxsIGhhdmUganVtcGVkIHVwIHNvbWUgYW1vdW50LiBXZSBuZWVkXG4gKiB0byBvZmZzZXQgdGhlIGp1bXAgYnkgdGhlIGFtb3VudCB0aGF0IHRoZSBwYWdlIHdhcyBcImF1dG9tYXRpY2FsbHlcIiBzY3JvbGxlZFxuICogdXAuIFdlIGNhbiBkbyB0aGlzIGJ5IGNvbXBhcmluZyB0aGUgc2Nyb2xsIHBvc2l0aW9uIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlXG4gKiBlbGVtZW50IHdhcyByZW1vdmVkLCBhbmQgdGhlbiBvZmZzZXR0aW5nIGJ5IHRoYXQgYW1vdW50LlxuICpcbiAqIEBwYXJhbSBlbCAtIFRoZSBlbGVtZW50IGJlaW5nIGRlbGV0ZWRcbiAqIEBwYXJhbSBmaW5hbFggLSBUaGUgZmluYWwgWCBzY3JvbGwgcG9zaXRpb25cbiAqIEBwYXJhbSBmaW5hbFkgLSBUaGUgZmluYWwgWSBzY3JvbGwgcG9zaXRpb25cbiAqIEBwYXJhbSBvcHRpb25zT3JQbHVnaW4gLSBUaGUgb3B0aW9ucyBvciBwbHVnaW5cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGFkanVzdFNjcm9sbChlbCwgZmluYWxYLCBmaW5hbFksIG9wdGlvbnNPclBsdWdpbikge1xuICAgIGNvbnN0IHNjcm9sbERlbHRhWCA9IHNjcm9sbFggLSBmaW5hbFg7XG4gICAgY29uc3Qgc2Nyb2xsRGVsdGFZID0gc2Nyb2xsWSAtIGZpbmFsWTtcbiAgICBjb25zdCBzY3JvbGxCZWZvcmUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3I7XG4gICAgY29uc3Qgc2Nyb2xsQmVoYXZpb3IgPSBnZXRDb21wdXRlZFN0eWxlKHJvb3QpLnNjcm9sbEJlaGF2aW9yO1xuICAgIGlmIChzY3JvbGxCZWhhdmlvciA9PT0gXCJzbW9vdGhcIikge1xuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBcImF1dG9cIjtcbiAgICB9XG4gICAgd2luZG93LnNjcm9sbFRvKHdpbmRvdy5zY3JvbGxYICsgc2Nyb2xsRGVsdGFYLCB3aW5kb3cuc2Nyb2xsWSArIHNjcm9sbERlbHRhWSk7XG4gICAgaWYgKCFlbC5wYXJlbnRFbGVtZW50KVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcGFyZW50ID0gZWwucGFyZW50RWxlbWVudDtcbiAgICBsZXQgbGFzdEhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHQ7XG4gICAgbGV0IGxhc3RXaWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aDtcbiAgICBjb25zdCBzdGFydFNjcm9sbCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIC8vIEhlcmUgd2UgdXNlIGEgbWFudWFsIHNjcm9sbCBhbmltYXRpb24gdG8ga2VlcCB0aGUgZWxlbWVudCB1c2luZyB0aGUgc2FtZVxuICAgIC8vIGVhc2luZyBhbmQgdGltaW5nIGFzIHRoZSBwYXJlbnTigJlzIHNjcm9sbCBhbmltYXRpb24uXG4gICAgZnVuY3Rpb24gc21vb3RoU2Nyb2xsKCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc1BsdWdpbihvcHRpb25zT3JQbHVnaW4pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFZID0gbGFzdEhlaWdodCAtIHBhcmVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFYID0gbGFzdFdpZHRoIC0gcGFyZW50LmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydFNjcm9sbCArIG9wdGlvbnNPclBsdWdpbi5kdXJhdGlvbiA+IHBlcmZvcm1hbmNlLm5vdygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB3aW5kb3cuc2Nyb2xsWCAtIGRlbHRhWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogd2luZG93LnNjcm9sbFkgLSBkZWx0YVksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsYXN0SGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFdpZHRoID0gcGFyZW50LmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBzbW9vdGhTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IHNjcm9sbEJlZm9yZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzbW9vdGhTY3JvbGwoKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgYmVpbmcgcmVtb3ZlZC5cbiAqIEBwYXJhbSBlbCAtIFRoZSBlbGVtZW50IGJlaW5nIGRlbGV0ZWRcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZVBvc2l0aW9uKGVsKSB7XG4gICAgY29uc3Qgb2xkQ29vcmRzID0gY29vcmRzLmdldChlbCk7XG4gICAgY29uc3QgW3dpZHRoLCAsIGhlaWdodF0gPSBnZXRUcmFuc2l0aW9uU2l6ZXMoZWwsIG9sZENvb3JkcywgZ2V0Q29vcmRzKGVsKSk7XG4gICAgbGV0IG9mZnNldFBhcmVudCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgd2hpbGUgKG9mZnNldFBhcmVudCAmJlxuICAgICAgICAoZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiIHx8XG4gICAgICAgICAgICBvZmZzZXRQYXJlbnQgaW5zdGFuY2VvZiBIVE1MQm9keUVsZW1lbnQpKSB7XG4gICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICBpZiAoIW9mZnNldFBhcmVudClcbiAgICAgICAgb2Zmc2V0UGFyZW50ID0gZG9jdW1lbnQuYm9keTtcbiAgICBjb25zdCBwYXJlbnRTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCk7XG4gICAgY29uc3QgcGFyZW50Q29vcmRzID0gY29vcmRzLmdldChvZmZzZXRQYXJlbnQpIHx8IGdldENvb3JkcyhvZmZzZXRQYXJlbnQpO1xuICAgIGNvbnN0IHRvcCA9IE1hdGgucm91bmQob2xkQ29vcmRzLnRvcCAtIHBhcmVudENvb3Jkcy50b3ApIC1cbiAgICAgICAgcmF3KHBhcmVudFN0eWxlcy5ib3JkZXJUb3BXaWR0aCk7XG4gICAgY29uc3QgbGVmdCA9IE1hdGgucm91bmQob2xkQ29vcmRzLmxlZnQgLSBwYXJlbnRDb29yZHMubGVmdCkgLVxuICAgICAgICByYXcocGFyZW50U3R5bGVzLmJvcmRlckxlZnRXaWR0aCk7XG4gICAgcmV0dXJuIFt0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHRdO1xufVxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgYXV0b21hdGljYWxseSBhZGRzIGFuaW1hdGlvbiBlZmZlY3RzIHRvIGl0c2VsZiBhbmQgaXRzXG4gKiBpbW1lZGlhdGUgY2hpbGRyZW4uIFNwZWNpZmljYWxseSBpdCBhZGRzIGVmZmVjdHMgZm9yIGFkZGluZywgbW92aW5nLCBhbmRcbiAqIHJlbW92aW5nIERPTSBlbGVtZW50cy5cbiAqIEBwYXJhbSBlbCAtIEEgcGFyZW50IGVsZW1lbnQgdG8gYWRkIGFuaW1hdGlvbnMgdG8uXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCBvZiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBhdXRvQW5pbWF0ZShlbCwgY29uZmlnID0ge30pIHtcbiAgICBpZiAobXV0YXRpb25zICYmIHJlc2l6ZSkge1xuICAgICAgICBjb25zdCBtZWRpYVF1ZXJ5ID0gd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiKTtcbiAgICAgICAgY29uc3QgaXNEaXNhYmxlZER1ZVRvUmVkdWNlTW90aW9uID0gbWVkaWFRdWVyeS5tYXRjaGVzICYmXG4gICAgICAgICAgICAhaXNQbHVnaW4oY29uZmlnKSAmJlxuICAgICAgICAgICAgIWNvbmZpZy5kaXNyZXNwZWN0VXNlck1vdGlvblByZWZlcmVuY2U7XG4gICAgICAgIGlmICghaXNEaXNhYmxlZER1ZVRvUmVkdWNlTW90aW9uKSB7XG4gICAgICAgICAgICBlbmFibGVkLmFkZChlbCk7XG4gICAgICAgICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShlbCkucG9zaXRpb24gPT09IFwic3RhdGljXCIpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGVsLnN0eWxlLCB7IHBvc2l0aW9uOiBcInJlbGF0aXZlXCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3JFYWNoKGVsLCB1cGRhdGVQb3MsIHBvbGwsIChlbGVtZW50KSA9PiByZXNpemUgPT09IG51bGwgfHwgcmVzaXplID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNpemUub2JzZXJ2ZShlbGVtZW50KSk7XG4gICAgICAgICAgICBpZiAoaXNQbHVnaW4oY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2V0KGVsLCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zZXQoZWwsIHsgZHVyYXRpb246IDI1MCwgZWFzaW5nOiBcImVhc2UtaW4tb3V0XCIsIC4uLmNvbmZpZyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG11dGF0aW9ucy5vYnNlcnZlKGVsLCB7IGNoaWxkTGlzdDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHBhcmVudHMuYWRkKGVsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHBhcmVudDogZWwsXG4gICAgICAgIGVuYWJsZTogKCkgPT4ge1xuICAgICAgICAgICAgZW5hYmxlZC5hZGQoZWwpO1xuICAgICAgICB9LFxuICAgICAgICBkaXNhYmxlOiAoKSA9PiB7XG4gICAgICAgICAgICBlbmFibGVkLmRlbGV0ZShlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRW5hYmxlZDogKCkgPT4gZW5hYmxlZC5oYXMoZWwpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBUaGUgdnVlIGRpcmVjdGl2ZS5cbiAqL1xuY29uc3QgdkF1dG9BbmltYXRlID0ge1xuICAgIG1vdW50ZWQ6IChlbCwgYmluZGluZykgPT4ge1xuICAgICAgICBhdXRvQW5pbWF0ZShlbCwgYmluZGluZy52YWx1ZSB8fCB7fSk7XG4gICAgfSxcbiAgICAvLyBpZ25vcmUgc3NyIHNlZSAjOTY6XG4gICAgZ2V0U1NSUHJvcHM6ICgpID0+ICh7fSksXG59O1xuXG5leHBvcnQgeyBhdXRvQW5pbWF0ZSBhcyBkZWZhdWx0LCBnZXRUcmFuc2l0aW9uU2l6ZXMsIHZBdXRvQW5pbWF0ZSB9O1xuIl0sIm5hbWVzIjpbInBhcmVudHMiLCJTZXQiLCJjb29yZHMiLCJXZWFrTWFwIiwic2libGluZ3MiLCJhbmltYXRpb25zIiwiaW50ZXJzZWN0aW9ucyIsImludGVydmFscyIsIm9wdGlvbnMiLCJkZWJvdW5jZXMiLCJlbmFibGVkIiwiV2Vha1NldCIsInJvb3QiLCJzY3JvbGxYIiwic2Nyb2xsWSIsIlRHVCIsIkRFTCIsIk5FVyIsImhhbmRsZU11dGF0aW9ucyIsIm11dGF0aW9ucyIsImVsZW1lbnRzIiwiZ2V0RWxlbWVudHMiLCJmb3JFYWNoIiwiZWwiLCJhbmltYXRlIiwiaGFuZGxlUmVzaXplcyIsImVudHJpZXMiLCJlbnRyeSIsInRhcmdldCIsInVwZGF0ZUFsbFBvcyIsImhhcyIsInVwZGF0ZVBvcyIsIm9ic2VydmVQb3NpdGlvbiIsIm9sZE9ic2VydmVyIiwiZ2V0IiwiZGlzY29ubmVjdCIsInJlY3QiLCJpbnZvY2F0aW9ucyIsImJ1ZmZlciIsImdldENvb3JkcyIsInNldCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0Iiwicm9vdE1hcmdpbnMiLCJ0b3AiLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJyb290TWFyZ2luIiwibWFwIiwicHgiLCJNYXRoIiwiZmxvb3IiLCJqb2luIiwib2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsInRocmVzaG9sZCIsIm9ic2VydmUiLCJjbGVhclRpbWVvdXQiLCJvcHRpb25zT3JQbHVnaW4iLCJnZXRPcHRpb25zIiwiZGVsYXkiLCJpc1BsdWdpbiIsImR1cmF0aW9uIiwic2V0VGltZW91dCIsImN1cnJlbnRBbmltYXRpb24iLCJmaW5pc2hlZCIsInBhcmVudCIsImxvd1ByaW9yaXR5IiwicG9sbCIsInNldEludGVydmFsIiwiYmluZCIsInJvdW5kIiwicmFuZG9tIiwiY2FsbGJhY2siLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVzaXplIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJNdXRhdGlvbk9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwib2JzZXJ2ZWROb2RlcyIsInJlZHVjZSIsIm5vZGVzIiwibXV0YXRpb24iLCJBcnJheSIsImZyb20iLCJhZGRlZE5vZGVzIiwicmVtb3ZlZE5vZGVzIiwib25seUNvbW1lbnROb2Rlc09ic2VydmVkIiwiZXZlcnkiLCJub2RlIiwibm9kZU5hbWUiLCJFbGVtZW50IiwiYWRkIiwiaSIsImNoaWxkcmVuIiwibGVuZ3RoIiwiY2hpbGQiLCJpdGVtIiwicHJldmlvdXNTaWJsaW5nIiwibmV4dFNpYmxpbmciLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiX2EiLCJpc01vdW50ZWQiLCJpc0Nvbm5lY3RlZCIsInByZUV4aXN0aW5nIiwiZGVsZXRlIiwiY2FuY2VsIiwicmVtYWluIiwicmVtb3ZlIiwicmF3Iiwic3RyIiwiTnVtYmVyIiwicmVwbGFjZSIsImdldFNjcm9sbE9mZnNldCIsInAiLCJwYXJlbnRFbGVtZW50Iiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsIngiLCJ5IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0VHJhbnNpdGlvblNpemVzIiwib2xkQ29vcmRzIiwibmV3Q29vcmRzIiwid2lkdGhGcm9tIiwiaGVpZ2h0RnJvbSIsIndpZHRoVG8iLCJoZWlnaHRUbyIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJzaXppbmciLCJnZXRQcm9wZXJ0eVZhbHVlIiwicGFkZGluZ1kiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJwYWRkaW5nWCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwiYm9yZGVyUmlnaHRXaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsImVhc2luZyIsImdldFRhcmdldCIsInVuZGVmaW5lZCIsImlzRW5hYmxlZCIsImNhbGxiYWNrcyIsImdldFBsdWdpblR1cGxlIiwicGx1Z2luUmV0dXJuIiwiaXNBcnJheSIsImNvbmZpZyIsImFuaW1hdGlvbiIsInBsdWdpbk9yT3B0aW9ucyIsImRlbHRhWCIsImRlbHRhWSIsInN0YXJ0IiwidHJhbnNmb3JtIiwiZW5kIiwia2V5ZnJhbWVzIiwiQW5pbWF0aW9uIiwicGxheSIsIm9wYWNpdHkiLCJvZmZzZXQiLCJjbGVhblVwIiwiY29uZmlndXJhYmxlIiwiSFRNTEVsZW1lbnQiLCJzdHlsZSIsInByZXYiLCJuZXh0IiwiZmluYWxYIiwiZmluYWxZIiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsImFwcGVuZENoaWxkIiwiZGVsZXRlUG9zaXRpb24iLCJhZGp1c3RTY3JvbGwiLCJzdHlsZVJlc2V0IiwicG9zaXRpb24iLCJtYXJnaW4iLCJwb2ludGVyRXZlbnRzIiwidHJhbnNmb3JtT3JpZ2luIiwiekluZGV4IiwiYXNzaWduIiwic2Nyb2xsRGVsdGFYIiwic2Nyb2xsRGVsdGFZIiwic2Nyb2xsQmVmb3JlIiwic2Nyb2xsQmVoYXZpb3IiLCJzY3JvbGxUbyIsImxhc3RIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJsYXN0V2lkdGgiLCJjbGllbnRXaWR0aCIsInN0YXJ0U2Nyb2xsIiwicGVyZm9ybWFuY2UiLCJub3ciLCJzbW9vdGhTY3JvbGwiLCJvZmZzZXRQYXJlbnQiLCJIVE1MQm9keUVsZW1lbnQiLCJib2R5IiwicGFyZW50U3R5bGVzIiwicGFyZW50Q29vcmRzIiwiYXV0b0FuaW1hdGUiLCJtZWRpYVF1ZXJ5IiwibWF0Y2hNZWRpYSIsImlzRGlzYWJsZWREdWVUb1JlZHVjZU1vdGlvbiIsIm1hdGNoZXMiLCJkaXNyZXNwZWN0VXNlck1vdGlvblByZWZlcmVuY2UiLCJlbGVtZW50IiwiY2hpbGRMaXN0IiwiZnJlZXplIiwiZW5hYmxlIiwiZGlzYWJsZSIsInZBdXRvQW5pbWF0ZSIsIm1vdW50ZWQiLCJiaW5kaW5nIiwiZ2V0U1NSUHJvcHMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@formkit/auto-animate/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@formkit/auto-animate/react/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@formkit/auto-animate/react/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAutoAnimate: () => (/* binding */ useAutoAnimate)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.mjs */ \"(ssr)/./node_modules/@formkit/auto-animate/index.mjs\");\n\n\n/**\n * AutoAnimate hook for adding dead-simple transitions and animations to react.\n * @param options - Auto animate options or a plugin\n * @returns\n */ function useAutoAnimate(options) {\n    const [controller, setController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    const memoizedOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>options, []);\n    const element = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((node)=>{\n        if (node instanceof HTMLElement) {\n            setController((0,_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node, memoizedOptions));\n        } else {\n            setController(undefined);\n        }\n    }, [\n        memoizedOptions\n    ]);\n    const setEnabled = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((enabled)=>{\n        if (controller) {\n            enabled ? controller.enable() : controller.disable();\n        }\n    }, [\n        controller\n    ]);\n    return [\n        element,\n        setEnabled\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvYXV0by1hbmltYXRlL3JlYWN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUQ7QUFDaEI7QUFFdkM7Ozs7Q0FJQyxHQUNELFNBQVNJLGVBQWVDLE9BQU87SUFDM0IsTUFBTSxDQUFDQyxZQUFZQyxjQUFjLEdBQUdQLCtDQUFRQTtJQUM1QyxNQUFNUSxrQkFBa0JQLDhDQUFPQSxDQUFDLElBQU1JLFNBQVMsRUFBRTtJQUNqRCxNQUFNSSxVQUFVUCxrREFBV0EsQ0FBQyxDQUFDUTtRQUN6QixJQUFJQSxnQkFBZ0JDLGFBQWE7WUFDN0JKLGNBQWNKLHNEQUFXQSxDQUFDTyxNQUFNRjtRQUNwQyxPQUNLO1lBQ0RELGNBQWNLO1FBQ2xCO0lBQ0osR0FBRztRQUFDSjtLQUFnQjtJQUNwQixNQUFNSyxhQUFhWCxrREFBV0EsQ0FBQyxDQUFDWTtRQUM1QixJQUFJUixZQUFZO1lBQ1pRLFVBQVVSLFdBQVdTLE1BQU0sS0FBS1QsV0FBV1UsT0FBTztRQUN0RDtJQUNKLEdBQUc7UUFBQ1Y7S0FBVztJQUNmLE9BQU87UUFBQ0c7UUFBU0k7S0FBVztBQUNoQztBQUUwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9AZm9ybWtpdC9hdXRvLWFuaW1hdGUvcmVhY3QvaW5kZXgubWpzPzM1NDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZU1lbW8sIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGF1dG9BbmltYXRlIGZyb20gJy4uL2luZGV4Lm1qcyc7XG5cbi8qKlxuICogQXV0b0FuaW1hdGUgaG9vayBmb3IgYWRkaW5nIGRlYWQtc2ltcGxlIHRyYW5zaXRpb25zIGFuZCBhbmltYXRpb25zIHRvIHJlYWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBBdXRvIGFuaW1hdGUgb3B0aW9ucyBvciBhIHBsdWdpblxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gdXNlQXV0b0FuaW1hdGUob3B0aW9ucykge1xuICAgIGNvbnN0IFtjb250cm9sbGVyLCBzZXRDb250cm9sbGVyXSA9IHVzZVN0YXRlKCk7XG4gICAgY29uc3QgbWVtb2l6ZWRPcHRpb25zID0gdXNlTWVtbygoKSA9PiBvcHRpb25zLCBbXSk7XG4gICAgY29uc3QgZWxlbWVudCA9IHVzZUNhbGxiYWNrKChub2RlKSA9PiB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHNldENvbnRyb2xsZXIoYXV0b0FuaW1hdGUobm9kZSwgbWVtb2l6ZWRPcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRDb250cm9sbGVyKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9LCBbbWVtb2l6ZWRPcHRpb25zXSk7XG4gICAgY29uc3Qgc2V0RW5hYmxlZCA9IHVzZUNhbGxiYWNrKChlbmFibGVkKSA9PiB7XG4gICAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBlbmFibGVkID8gY29udHJvbGxlci5lbmFibGUoKSA6IGNvbnRyb2xsZXIuZGlzYWJsZSgpO1xuICAgICAgICB9XG4gICAgfSwgW2NvbnRyb2xsZXJdKTtcbiAgICByZXR1cm4gW2VsZW1lbnQsIHNldEVuYWJsZWRdO1xufVxuXG5leHBvcnQgeyB1c2VBdXRvQW5pbWF0ZSB9O1xuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlTWVtbyIsInVzZUNhbGxiYWNrIiwiYXV0b0FuaW1hdGUiLCJ1c2VBdXRvQW5pbWF0ZSIsIm9wdGlvbnMiLCJjb250cm9sbGVyIiwic2V0Q29udHJvbGxlciIsIm1lbW9pemVkT3B0aW9ucyIsImVsZW1lbnQiLCJub2RlIiwiSFRNTEVsZW1lbnQiLCJ1bmRlZmluZWQiLCJzZXRFbmFibGVkIiwiZW5hYmxlZCIsImVuYWJsZSIsImRpc2FibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@formkit/auto-animate/react/index.mjs\n");

/***/ })

};
;