"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/livekit-client";
exports.ids = ["vendor-chunks/livekit-client"];
exports.modules = {

/***/ "(ssr)/./node_modules/livekit-client/dist/livekit-client.esm.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/livekit-client/dist/livekit-client.esm.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioPresets: () => (/* binding */ AudioPresets),\n/* harmony export */   BaseKeyProvider: () => (/* binding */ BaseKeyProvider),\n/* harmony export */   ConnectionCheck: () => (/* binding */ ConnectionCheck),\n/* harmony export */   ConnectionError: () => (/* binding */ ConnectionError),\n/* harmony export */   ConnectionQuality: () => (/* binding */ ConnectionQuality),\n/* harmony export */   ConnectionState: () => (/* binding */ ConnectionState),\n/* harmony export */   CriticalTimers: () => (/* binding */ CriticalTimers),\n/* harmony export */   CryptorEvent: () => (/* binding */ CryptorEvent),\n/* harmony export */   DataPacket_Kind: () => (/* binding */ DataPacket_Kind),\n/* harmony export */   DefaultReconnectPolicy: () => (/* binding */ DefaultReconnectPolicy),\n/* harmony export */   DeviceUnsupportedError: () => (/* binding */ DeviceUnsupportedError),\n/* harmony export */   DisconnectReason: () => (/* binding */ DisconnectReason),\n/* harmony export */   EncryptionEvent: () => (/* binding */ EncryptionEvent),\n/* harmony export */   EngineEvent: () => (/* binding */ EngineEvent),\n/* harmony export */   ExternalE2EEKeyProvider: () => (/* binding */ ExternalE2EEKeyProvider),\n/* harmony export */   KeyHandlerEvent: () => (/* binding */ KeyHandlerEvent),\n/* harmony export */   KeyProviderEvent: () => (/* binding */ KeyProviderEvent),\n/* harmony export */   LivekitError: () => (/* binding */ LivekitError),\n/* harmony export */   LocalAudioTrack: () => (/* binding */ LocalAudioTrack),\n/* harmony export */   LocalParticipant: () => (/* binding */ LocalParticipant),\n/* harmony export */   LocalTrack: () => (/* binding */ LocalTrack),\n/* harmony export */   LocalTrackPublication: () => (/* binding */ LocalTrackPublication),\n/* harmony export */   LocalVideoTrack: () => (/* binding */ LocalVideoTrack),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   MediaDeviceFailure: () => (/* binding */ MediaDeviceFailure),\n/* harmony export */   NegotiationError: () => (/* binding */ NegotiationError),\n/* harmony export */   Participant: () => (/* binding */ Participant),\n/* harmony export */   ParticipantEvent: () => (/* binding */ ParticipantEvent),\n/* harmony export */   PublishDataError: () => (/* binding */ PublishDataError),\n/* harmony export */   RemoteAudioTrack: () => (/* binding */ RemoteAudioTrack),\n/* harmony export */   RemoteParticipant: () => (/* binding */ RemoteParticipant),\n/* harmony export */   RemoteTrack: () => (/* binding */ RemoteTrack),\n/* harmony export */   RemoteTrackPublication: () => (/* binding */ RemoteTrackPublication),\n/* harmony export */   RemoteVideoTrack: () => (/* binding */ RemoteVideoTrack),\n/* harmony export */   Room: () => (/* binding */ Room),\n/* harmony export */   RoomEvent: () => (/* binding */ RoomEvent),\n/* harmony export */   RoomState: () => (/* binding */ RoomState),\n/* harmony export */   ScreenSharePresets: () => (/* binding */ ScreenSharePresets),\n/* harmony export */   Track: () => (/* binding */ Track),\n/* harmony export */   TrackEvent: () => (/* binding */ TrackEvent),\n/* harmony export */   TrackInvalidError: () => (/* binding */ TrackInvalidError),\n/* harmony export */   TrackPublication: () => (/* binding */ TrackPublication),\n/* harmony export */   UnexpectedConnectionState: () => (/* binding */ UnexpectedConnectionState),\n/* harmony export */   UnsupportedServer: () => (/* binding */ UnsupportedServer),\n/* harmony export */   VideoPreset: () => (/* binding */ VideoPreset),\n/* harmony export */   VideoPresets: () => (/* binding */ VideoPresets),\n/* harmony export */   VideoPresets43: () => (/* binding */ VideoPresets43),\n/* harmony export */   VideoQuality: () => (/* binding */ VideoQuality),\n/* harmony export */   attachToElement: () => (/* binding */ attachToElement),\n/* harmony export */   createAudioAnalyser: () => (/* binding */ createAudioAnalyser),\n/* harmony export */   createE2EEKey: () => (/* binding */ createE2EEKey),\n/* harmony export */   createKeyMaterialFromBuffer: () => (/* binding */ createKeyMaterialFromBuffer),\n/* harmony export */   createKeyMaterialFromString: () => (/* binding */ createKeyMaterialFromString),\n/* harmony export */   createLocalAudioTrack: () => (/* binding */ createLocalAudioTrack),\n/* harmony export */   createLocalScreenTracks: () => (/* binding */ createLocalScreenTracks),\n/* harmony export */   createLocalTracks: () => (/* binding */ createLocalTracks),\n/* harmony export */   createLocalVideoTrack: () => (/* binding */ createLocalVideoTrack),\n/* harmony export */   deriveKeys: () => (/* binding */ deriveKeys),\n/* harmony export */   detachTrack: () => (/* binding */ detachTrack),\n/* harmony export */   facingModeFromDeviceLabel: () => (/* binding */ facingModeFromDeviceLabel),\n/* harmony export */   facingModeFromLocalTrack: () => (/* binding */ facingModeFromLocalTrack),\n/* harmony export */   getEmptyAudioStreamTrack: () => (/* binding */ getEmptyAudioStreamTrack),\n/* harmony export */   getEmptyVideoStreamTrack: () => (/* binding */ getEmptyVideoStreamTrack),\n/* harmony export */   getLogger: () => (/* binding */ getLogger),\n/* harmony export */   importKey: () => (/* binding */ importKey),\n/* harmony export */   isBackupCodec: () => (/* binding */ isBackupCodec),\n/* harmony export */   isBrowserSupported: () => (/* binding */ isBrowserSupported),\n/* harmony export */   isE2EESupported: () => (/* binding */ isE2EESupported),\n/* harmony export */   isInsertableStreamSupported: () => (/* binding */ isInsertableStreamSupported),\n/* harmony export */   isScriptTransformSupported: () => (/* binding */ isScriptTransformSupported),\n/* harmony export */   isVideoFrame: () => (/* binding */ isVideoFrame),\n/* harmony export */   needsRbspUnescaping: () => (/* binding */ needsRbspUnescaping),\n/* harmony export */   parseRbsp: () => (/* binding */ parseRbsp),\n/* harmony export */   protocolVersion: () => (/* binding */ protocolVersion),\n/* harmony export */   ratchet: () => (/* binding */ ratchet),\n/* harmony export */   setLogExtension: () => (/* binding */ setLogExtension),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   supportsAV1: () => (/* binding */ supportsAV1),\n/* harmony export */   supportsAdaptiveStream: () => (/* binding */ supportsAdaptiveStream),\n/* harmony export */   supportsDynacast: () => (/* binding */ supportsDynacast),\n/* harmony export */   supportsVP9: () => (/* binding */ supportsVP9),\n/* harmony export */   version: () => (/* binding */ version),\n/* harmony export */   videoCodecs: () => (/* binding */ videoCodecs),\n/* harmony export */   writeRbsp: () => (/* binding */ writeRbsp)\n/* harmony export */ });\nfunction _mergeNamespaces(n, m) {\n    m.forEach(function(e) {\n        e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n            if (k !== \"default\" && !(k in n)) {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    });\n    return Object.freeze(n);\n}\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar loglevel = {\n    exports: {}\n};\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/ (function(module) {\n    (function(root, definition) {\n        if (module.exports) {\n            module.exports = definition();\n        } else {\n            root.log = definition();\n        }\n    })(commonjsGlobal, function() {\n        // Slightly dubious tricks to cut down minimized file size\n        var noop = function() {};\n        var undefinedType = \"undefined\";\n        var isIE = \"undefined\" !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n        var logMethods = [\n            \"trace\",\n            \"debug\",\n            \"info\",\n            \"warn\",\n            \"error\"\n        ];\n        // Cross-browser bind equivalent that works at least back to IE6\n        function bindMethod(obj, methodName) {\n            var method = obj[methodName];\n            if (typeof method.bind === \"function\") {\n                return method.bind(obj);\n            } else {\n                try {\n                    return Function.prototype.bind.call(method, obj);\n                } catch (e) {\n                    // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                    return function() {\n                        return Function.prototype.apply.apply(method, [\n                            obj,\n                            arguments\n                        ]);\n                    };\n                }\n            }\n        }\n        // Trace() doesn't print the message in IE, so for that case we need to wrap it\n        function traceForIE() {\n            if (console.log) {\n                if (console.log.apply) {\n                    console.log.apply(console, arguments);\n                } else {\n                    // In old IE, native console methods themselves don't have apply().\n                    Function.prototype.apply.apply(console.log, [\n                        console,\n                        arguments\n                    ]);\n                }\n            }\n            if (console.trace) console.trace();\n        }\n        // Build the best logging method possible for this env\n        // Wherever possible we want to bind, not wrap, to preserve stack traces\n        function realMethod(methodName) {\n            if (methodName === \"debug\") {\n                methodName = \"log\";\n            }\n            if (typeof console === undefinedType) {\n                return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n            } else if (methodName === \"trace\" && isIE) {\n                return traceForIE;\n            } else if (console[methodName] !== undefined) {\n                return bindMethod(console, methodName);\n            } else if (console.log !== undefined) {\n                return bindMethod(console, \"log\");\n            } else {\n                return noop;\n            }\n        }\n        // These private functions always need `this` to be set properly\n        function replaceLoggingMethods(level, loggerName) {\n            /*jshint validthis:true */ for(var i = 0; i < logMethods.length; i++){\n                var methodName = logMethods[i];\n                this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);\n            }\n            // Define log.log as an alias for log.debug\n            this.log = this.debug;\n        }\n        // In old IE versions, the console isn't present until you first open it.\n        // We build realMethod() replacements here that regenerate logging methods\n        function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n            return function() {\n                if (typeof console !== undefinedType) {\n                    replaceLoggingMethods.call(this, level, loggerName);\n                    this[methodName].apply(this, arguments);\n                }\n            };\n        }\n        // By default, we use closely bound real methods wherever possible, and\n        // otherwise we wait for a console to appear, and then try again.\n        function defaultMethodFactory(methodName, level, loggerName) {\n            /*jshint validthis:true */ return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n        }\n        function Logger(name, defaultLevel, factory) {\n            var self1 = this;\n            var currentLevel;\n            defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n            var storageKey = \"loglevel\";\n            if (typeof name === \"string\") {\n                storageKey += \":\" + name;\n            } else if (typeof name === \"symbol\") {\n                storageKey = undefined;\n            }\n            function persistLevelIfPossible(levelNum) {\n                var levelName = (logMethods[levelNum] || \"silent\").toUpperCase();\n                if (\"undefined\" === undefinedType || !storageKey) return;\n                // Use localStorage if available\n                try {\n                    window.localStorage[storageKey] = levelName;\n                    return;\n                } catch (ignore) {}\n                // Use session cookie as fallback\n                try {\n                    window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n                } catch (ignore) {}\n            }\n            function getPersistedLevel() {\n                var storedLevel;\n                if (\"undefined\" === undefinedType || !storageKey) return;\n                try {\n                    storedLevel = window.localStorage[storageKey];\n                } catch (ignore) {}\n                // Fallback to cookies if local storage gives us nothing\n                if (typeof storedLevel === undefinedType) {\n                    try {\n                        var cookie = window.document.cookie;\n                        var location = cookie.indexOf(encodeURIComponent(storageKey) + \"=\");\n                        if (location !== -1) {\n                            storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                        }\n                    } catch (ignore) {}\n                }\n                // If the stored level is not valid, treat it as if nothing was stored.\n                if (self1.levels[storedLevel] === undefined) {\n                    storedLevel = undefined;\n                }\n                return storedLevel;\n            }\n            function clearPersistedLevel() {\n                if (\"undefined\" === undefinedType || !storageKey) return;\n                // Use localStorage if available\n                try {\n                    window.localStorage.removeItem(storageKey);\n                    return;\n                } catch (ignore) {}\n                // Use session cookie as fallback\n                try {\n                    window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n                } catch (ignore) {}\n            }\n            /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */ self1.name = name;\n            self1.levels = {\n                \"TRACE\": 0,\n                \"DEBUG\": 1,\n                \"INFO\": 2,\n                \"WARN\": 3,\n                \"ERROR\": 4,\n                \"SILENT\": 5\n            };\n            self1.methodFactory = factory || defaultMethodFactory;\n            self1.getLevel = function() {\n                return currentLevel;\n            };\n            self1.setLevel = function(level, persist) {\n                if (typeof level === \"string\" && self1.levels[level.toUpperCase()] !== undefined) {\n                    level = self1.levels[level.toUpperCase()];\n                }\n                if (typeof level === \"number\" && level >= 0 && level <= self1.levels.SILENT) {\n                    currentLevel = level;\n                    if (persist !== false) {\n                        // defaults to true\n                        persistLevelIfPossible(level);\n                    }\n                    replaceLoggingMethods.call(self1, level, name);\n                    if (typeof console === undefinedType && level < self1.levels.SILENT) {\n                        return \"No console available for logging\";\n                    }\n                } else {\n                    throw \"log.setLevel() called with invalid level: \" + level;\n                }\n            };\n            self1.setDefaultLevel = function(level) {\n                defaultLevel = level;\n                if (!getPersistedLevel()) {\n                    self1.setLevel(level, false);\n                }\n            };\n            self1.resetLevel = function() {\n                self1.setLevel(defaultLevel, false);\n                clearPersistedLevel();\n            };\n            self1.enableAll = function(persist) {\n                self1.setLevel(self1.levels.TRACE, persist);\n            };\n            self1.disableAll = function(persist) {\n                self1.setLevel(self1.levels.SILENT, persist);\n            };\n            // Initialize with the right level\n            var initialLevel = getPersistedLevel();\n            if (initialLevel == null) {\n                initialLevel = defaultLevel;\n            }\n            self1.setLevel(initialLevel, false);\n        }\n        /*\n     *\n     * Top-level API\n     *\n     */ var defaultLogger = new Logger();\n        var _loggersByName = {};\n        defaultLogger.getLogger = function getLogger(name) {\n            if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n                throw new TypeError(\"You must supply a name when creating a logger.\");\n            }\n            var logger = _loggersByName[name];\n            if (!logger) {\n                logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n            }\n            return logger;\n        };\n        // Grab the current global log variable in case of overwrite\n        var _log = \"undefined\" !== undefinedType ? window.log : undefined;\n        defaultLogger.noConflict = function() {\n            if (\"undefined\" !== undefinedType && window.log === defaultLogger) {\n                window.log = _log;\n            }\n            return defaultLogger;\n        };\n        defaultLogger.getLoggers = function getLoggers() {\n            return _loggersByName;\n        };\n        // ES6 default export, for compatibility\n        defaultLogger[\"default\"] = defaultLogger;\n        return defaultLogger;\n    });\n})(loglevel);\nvar loglevelExports = loglevel.exports;\nvar LogLevel;\n(function(LogLevel) {\n    LogLevel[LogLevel[\"trace\"] = 0] = \"trace\";\n    LogLevel[LogLevel[\"debug\"] = 1] = \"debug\";\n    LogLevel[LogLevel[\"info\"] = 2] = \"info\";\n    LogLevel[LogLevel[\"warn\"] = 3] = \"warn\";\n    LogLevel[LogLevel[\"error\"] = 4] = \"error\";\n    LogLevel[LogLevel[\"silent\"] = 5] = \"silent\";\n})(LogLevel || (LogLevel = {}));\nvar LoggerNames;\n(function(LoggerNames) {\n    LoggerNames[\"Default\"] = \"livekit\";\n    LoggerNames[\"Room\"] = \"livekit-room\";\n    LoggerNames[\"Participant\"] = \"livekit-participant\";\n    LoggerNames[\"Track\"] = \"livekit-track\";\n    LoggerNames[\"Publication\"] = \"livekit-track-publication\";\n    LoggerNames[\"Engine\"] = \"livekit-engine\";\n    LoggerNames[\"Signal\"] = \"livekit-signal\";\n    LoggerNames[\"PCManager\"] = \"livekit-pc-manager\";\n    LoggerNames[\"PCTransport\"] = \"livekit-pc-transport\";\n    LoggerNames[\"E2EE\"] = \"lk-e2ee\";\n})(LoggerNames || (LoggerNames = {}));\nlet livekitLogger = loglevelExports.getLogger(\"livekit\");\nlivekitLogger.setDefaultLevel(LogLevel.info);\n/**\n * @internal\n */ function getLogger(name) {\n    const logger = loglevelExports.getLogger(name);\n    logger.setDefaultLevel(livekitLogger.getLevel());\n    return logger;\n}\nfunction setLogLevel(level, loggerName) {\n    if (loggerName) {\n        loglevelExports.getLogger(loggerName).setLevel(level);\n    }\n    for (const logger of Object.entries(loglevelExports.getLoggers()).filter((_ref)=>{\n        let [logrName] = _ref;\n        return logrName.startsWith(\"livekit\");\n    }).map((_ref2)=>{\n        let [, logr] = _ref2;\n        return logr;\n    })){\n        logger.setLevel(level);\n    }\n}\n/**\n * use this to hook into the logging function to allow sending internal livekit logs to third party services\n * if set, the browser logs will lose their stacktrace information (see https://github.com/pimterry/loglevel#writing-plugins)\n */ function setLogExtension(extension) {\n    let logger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : livekitLogger;\n    const originalFactory = logger.methodFactory;\n    logger.methodFactory = (methodName, configLevel, loggerName)=>{\n        const rawMethod = originalFactory(methodName, configLevel, loggerName);\n        const logLevel = LogLevel[methodName];\n        const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;\n        return (msg, context)=>{\n            if (context) rawMethod(msg, context);\n            else rawMethod(msg);\n            if (needLog) {\n                extension(logLevel, msg, context);\n            }\n        };\n    };\n    logger.setLevel(logger.getLevel()); // Be sure to call setLevel method in order to apply plugin\n}\nloglevelExports.getLogger(\"lk-e2ee\");\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Assert that condition is truthy or throw error (with message)\n */ function assert(condition, msg) {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- we want the implicit conversion to boolean\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\nconst FLOAT32_MAX = 3.4028234663852886e38, FLOAT32_MIN = -3.4028234663852886e38, UINT32_MAX = 0xffffffff, INT32_MAX = 0x7fffffff, INT32_MIN = -0x80000000;\n/**\n * Assert a valid signed protobuf 32-bit integer.\n */ function assertInt32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid int 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error(\"invalid int 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid unsigned protobuf 32-bit integer.\n */ function assertUInt32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid uint 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error(\"invalid uint 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid protobuf float value.\n */ function assertFloat32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid float 32: \" + typeof arg);\n    if (!Number.isFinite(arg)) return;\n    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error(\"invalid float 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst enumTypeSymbol = Symbol(\"@bufbuild/protobuf/enum-type\");\n/**\n * Get reflection information from a generated enum.\n * If this function is called on something other than a generated\n * enum, it raises an error.\n */ function getEnumType(enumObject) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any\n    const t = enumObject[enumTypeSymbol];\n    assert(t, \"missing enum type on enum object\");\n    return t; // eslint-disable-line @typescript-eslint/no-unsafe-return\n}\n/**\n * Sets reflection information on a generated enum.\n */ function setEnumType(enumObject, typeName, values, opt) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v)=>({\n            no: v.no,\n            name: v.name,\n            localName: enumObject[v.no]\n        })));\n}\n/**\n * Create a new EnumType with the given values.\n */ function makeEnumType(typeName, values, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n_opt) {\n    const names = Object.create(null);\n    const numbers = Object.create(null);\n    const normalValues = [];\n    for (const value of values){\n        // We do not surface options at this time\n        // const value: EnumValueInfo = {...v, options: v.options ?? emptyReadonlyObject};\n        const n = normalizeEnumValue(value);\n        normalValues.push(n);\n        names[value.name] = n;\n        numbers[value.no] = n;\n    }\n    return {\n        typeName,\n        values: normalValues,\n        // We do not surface options at this time\n        // options: opt?.options ?? Object.create(null),\n        findName (name) {\n            return names[name];\n        },\n        findNumber (no) {\n            return numbers[no];\n        }\n    };\n}\n/**\n * Create a new enum object with the given values.\n * Sets reflection information.\n */ function makeEnum(typeName, values, opt) {\n    const enumObject = {};\n    for (const value of values){\n        const n = normalizeEnumValue(value);\n        enumObject[n.localName] = n.no;\n        enumObject[n.no] = n.localName;\n    }\n    setEnumType(enumObject, typeName, values);\n    return enumObject;\n}\nfunction normalizeEnumValue(value) {\n    if (\"localName\" in value) {\n        return value;\n    }\n    return Object.assign(Object.assign({}, value), {\n        localName: value.name\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Message is the base class of every message, generated, or created at\n * runtime.\n *\n * It is _not_ safe to extend this class. If you want to create a message at\n * run time, use proto3.makeMessageType().\n */ class Message {\n    /**\n   * Compare with a message of the same type.\n   */ equals(other) {\n        return this.getType().runtime.util.equals(this.getType(), this, other);\n    }\n    /**\n   * Create a deep copy.\n   */ clone() {\n        return this.getType().runtime.util.clone(this);\n    }\n    /**\n   * Parse from binary data, merging fields.\n   *\n   * Repeated fields are appended. Map entries are added, overwriting\n   * existing keys.\n   *\n   * If a message field is already present, it will be merged with the\n   * new data.\n   */ fromBinary(bytes, options) {\n        const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);\n        format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);\n        return this;\n    }\n    /**\n   * Parse a message from a JSON value.\n   */ fromJson(jsonValue, options) {\n        const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);\n        format.readMessage(type, jsonValue, opt, this);\n        return this;\n    }\n    /**\n   * Parse a message from a JSON string.\n   */ fromJsonString(jsonString, options) {\n        let json;\n        try {\n            json = JSON.parse(jsonString);\n        } catch (e) {\n            throw new Error(\"cannot decode \".concat(this.getType().typeName, \" from JSON: \").concat(e instanceof Error ? e.message : String(e)));\n        }\n        return this.fromJson(json, options);\n    }\n    /**\n   * Serialize the message to binary data.\n   */ toBinary(options) {\n        const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();\n        bin.writeMessage(this, writer, opt);\n        return writer.finish();\n    }\n    /**\n   * Serialize the message to a JSON value, a JavaScript value that can be\n   * passed to JSON.stringify().\n   */ toJson(options) {\n        const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);\n        return json.writeMessage(this, opt);\n    }\n    /**\n   * Serialize the message to a JSON string.\n   */ toJsonString(options) {\n        var _a;\n        const value = this.toJson(options);\n        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);\n    }\n    /**\n   * Override for serialization behavior. This will be invoked when calling\n   * JSON.stringify on this message (i.e. JSON.stringify(msg)).\n   *\n   * Note that this will not serialize google.protobuf.Any with a packed\n   * message because the protobuf JSON format specifies that it needs to be\n   * unpacked, and this is only possible with a type registry to look up the\n   * message type.  As a result, attempting to serialize a message with this\n   * type will throw an Error.\n   *\n   * This method is protected because you should not need to invoke it\n   * directly -- instead use JSON.stringify or toJsonString for\n   * stringified JSON.  Alternatively, if actual JSON is desired, you should\n   * use toJson.\n   */ toJSON() {\n        return this.toJson({\n            emitDefaultValues: true\n        });\n    }\n    /**\n   * Retrieve the MessageType of this message - a singleton that represents\n   * the protobuf message declaration and provides metadata for reflection-\n   * based operations.\n   */ getType() {\n        // Any class that extends Message _must_ provide a complete static\n        // implementation of MessageType.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\n        return Object.getPrototypeOf(this).constructor;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new message type using the given runtime.\n */ function makeMessageType(runtime, typeName, fields, opt) {\n    var _a;\n    const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(\".\") + 1);\n    const type = {\n        [localName]: function(data) {\n            runtime.util.initFields(this);\n            runtime.util.initPartial(data, this);\n        }\n    }[localName];\n    Object.setPrototypeOf(type.prototype, new Message());\n    Object.assign(type, {\n        runtime,\n        typeName,\n        fields: runtime.util.newFieldList(fields),\n        fromBinary (bytes, options) {\n            return new type().fromBinary(bytes, options);\n        },\n        fromJson (jsonValue, options) {\n            return new type().fromJson(jsonValue, options);\n        },\n        fromJsonString (jsonString, options) {\n            return new type().fromJsonString(jsonString, options);\n        },\n        equals (a, b) {\n            return runtime.util.equals(type, a, b);\n        }\n    });\n    return type;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeProtoRuntime(syntax, json, bin, util) {\n    return {\n        syntax,\n        json,\n        bin,\n        util,\n        makeMessageType (typeName, fields, opt) {\n            return makeMessageType(this, typeName, fields, opt);\n        },\n        makeEnum,\n        makeEnumType,\n        getEnumType\n    };\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Scalar value types. This is a subset of field types declared by protobuf\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\n * are omitted, but the numerical values are identical.\n */ var ScalarType;\n(function(ScalarType) {\n    // 0 is reserved for errors.\n    // Order is weird for historical reasons.\n    ScalarType[ScalarType[\"DOUBLE\"] = 1] = \"DOUBLE\";\n    ScalarType[ScalarType[\"FLOAT\"] = 2] = \"FLOAT\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT64\"] = 3] = \"INT64\";\n    ScalarType[ScalarType[\"UINT64\"] = 4] = \"UINT64\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT32\"] = 5] = \"INT32\";\n    ScalarType[ScalarType[\"FIXED64\"] = 6] = \"FIXED64\";\n    ScalarType[ScalarType[\"FIXED32\"] = 7] = \"FIXED32\";\n    ScalarType[ScalarType[\"BOOL\"] = 8] = \"BOOL\";\n    ScalarType[ScalarType[\"STRING\"] = 9] = \"STRING\";\n    // Tag-delimited aggregate.\n    // Group type is deprecated and not supported in proto3. However, Proto3\n    // implementations should still be able to parse the group wire format and\n    // treat group fields as unknown fields.\n    // TYPE_GROUP = 10,\n    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\n    // New in version 2.\n    ScalarType[ScalarType[\"BYTES\"] = 12] = \"BYTES\";\n    ScalarType[ScalarType[\"UINT32\"] = 13] = \"UINT32\";\n    // TYPE_ENUM = 14,\n    ScalarType[ScalarType[\"SFIXED32\"] = 15] = \"SFIXED32\";\n    ScalarType[ScalarType[\"SFIXED64\"] = 16] = \"SFIXED64\";\n    ScalarType[ScalarType[\"SINT32\"] = 17] = \"SINT32\";\n    ScalarType[ScalarType[\"SINT64\"] = 18] = \"SINT64\";\n})(ScalarType || (ScalarType = {}));\n/**\n * JavaScript representation of fields with 64 bit integral types (int64, uint64,\n * sint64, fixed64, sfixed64).\n *\n * This is a subset of google.protobuf.FieldOptions.JSType, which defines JS_NORMAL,\n * JS_STRING, and JS_NUMBER. Protobuf-ES uses BigInt by default, but will use\n * String if `[jstype = JS_STRING]` is specified.\n *\n * ```protobuf\n * uint64 field_a = 1; // BigInt\n * uint64 field_b = 2 [jstype = JS_NORMAL]; // BigInt\n * uint64 field_b = 2 [jstype = JS_NUMBER]; // BigInt\n * uint64 field_b = 2 [jstype = JS_STRING]; // String\n * ```\n */ var LongType;\n(function(LongType) {\n    /**\n   * Use JavaScript BigInt.\n   */ LongType[LongType[\"BIGINT\"] = 0] = \"BIGINT\";\n    /**\n   * Use JavaScript String.\n   *\n   * Field option `[jstype = JS_STRING]`.\n   */ LongType[LongType[\"STRING\"] = 1] = \"STRING\";\n})(LongType || (LongType = {}));\n// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */ /**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [1]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */ function varint64read() {\n    let lowBits = 0;\n    let highBits = 0;\n    for(let shift = 0; shift < 28; shift += 7){\n        let b = this.buf[this.pos++];\n        lowBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    let middleByte = this.buf[this.pos++];\n    // last four bits of the first 32 bit number\n    lowBits |= (middleByte & 0x0f) << 28;\n    // 3 upper bits are part of the next 32 bit number\n    highBits = (middleByte & 0x70) >> 4;\n    if ((middleByte & 0x80) == 0) {\n        this.assertBounds();\n        return [\n            lowBits,\n            highBits\n        ];\n    }\n    for(let shift = 3; shift <= 31; shift += 7){\n        let b = this.buf[this.pos++];\n        highBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    throw new Error(\"invalid varint\");\n}\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */ function varint64write(lo, hi, bytes) {\n    for(let i = 0; i < 28; i = i + 7){\n        const shift = lo >>> i;\n        const hasNext = !(shift >>> 7 == 0 && hi == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    const splitBits = lo >>> 28 & 0x0f | (hi & 0x07) << 4;\n    const hasMoreBits = !(hi >> 3 == 0);\n    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\n    if (!hasMoreBits) {\n        return;\n    }\n    for(let i = 3; i < 31; i = i + 7){\n        const shift = hi >>> i;\n        const hasNext = !(shift >>> 7 == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    bytes.push(hi >>> 31 & 0x01);\n}\n// constants for binary math\nconst TWO_PWR_32_DBL = 0x100000000;\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64FromString(dec) {\n    // Check for minus sign.\n    const minus = dec[0] === \"-\";\n    if (minus) {\n        dec = dec.slice(1);\n    }\n    // Work 6 decimal digits at a time, acting like we're converting base 1e6\n    // digits to binary. This is safe to do with floating point math because\n    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n    const base = 1e6;\n    let lowBits = 0;\n    let highBits = 0;\n    function add1e6digit(begin, end) {\n        // Note: Number('') is 0.\n        const digit1e6 = Number(dec.slice(begin, end));\n        highBits *= base;\n        lowBits = lowBits * base + digit1e6;\n        // Carry bits from lowBits to\n        if (lowBits >= TWO_PWR_32_DBL) {\n            highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);\n            lowBits = lowBits % TWO_PWR_32_DBL;\n        }\n    }\n    add1e6digit(-24, -18);\n    add1e6digit(-18, -12);\n    add1e6digit(-12, -6);\n    add1e6digit(-6);\n    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\n}\n/**\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64ToString(lo, hi) {\n    let bits = newBits(lo, hi);\n    // If we're treating the input as a signed value and the high bit is set, do\n    // a manual two's complement conversion before the decimal conversion.\n    const negative = bits.hi & 0x80000000;\n    if (negative) {\n        bits = negate(bits.lo, bits.hi);\n    }\n    const result = uInt64ToString(bits.lo, bits.hi);\n    return negative ? \"-\" + result : result;\n}\n/**\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function uInt64ToString(lo, hi) {\n    ({ lo, hi } = toUnsigned(lo, hi));\n    // Skip the expensive conversion if the number is small enough to use the\n    // built-in conversions.\n    // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\n    // highBits <= 0x1FFFFF can be safely expressed with a double and retain\n    // integer precision.\n    // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\n    if (hi <= 0x1FFFFF) {\n        return String(TWO_PWR_32_DBL * hi + lo);\n    }\n    // What this code is doing is essentially converting the input number from\n    // base-2 to base-1e7, which allows us to represent the 64-bit range with\n    // only 3 (very large) digits. Those digits are then trivial to convert to\n    // a base-10 string.\n    // The magic numbers used here are -\n    // 2^24 = 16777216 = (1,6777216) in base-1e7.\n    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n    // Split 32:32 representation into 16:24:24 representation so our\n    // intermediate digits don't overflow.\n    const low = lo & 0xFFFFFF;\n    const mid = (lo >>> 24 | hi << 8) & 0xFFFFFF;\n    const high = hi >> 16 & 0xFFFF;\n    // Assemble our three base-1e7 digits, ignoring carries. The maximum\n    // value in a digit at this step is representable as a 48-bit integer, which\n    // can be stored in a 64-bit floating point number.\n    let digitA = low + mid * 6777216 + high * 6710656;\n    let digitB = mid + high * 8147497;\n    let digitC = high * 2;\n    // Apply carries from A to B and from B to C.\n    const base = 10000000;\n    if (digitA >= base) {\n        digitB += Math.floor(digitA / base);\n        digitA %= base;\n    }\n    if (digitB >= base) {\n        digitC += Math.floor(digitB / base);\n        digitB %= base;\n    }\n    // If digitC is 0, then we should have returned in the trivial code path\n    // at the top for non-safe integers. Given this, we can assume both digitB\n    // and digitA need leading zeros.\n    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);\n}\nfunction toUnsigned(lo, hi) {\n    return {\n        lo: lo >>> 0,\n        hi: hi >>> 0\n    };\n}\nfunction newBits(lo, hi) {\n    return {\n        lo: lo | 0,\n        hi: hi | 0\n    };\n}\n/**\n * Returns two's compliment negation of input.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n */ function negate(lowBits, highBits) {\n    highBits = ~highBits;\n    if (lowBits) {\n        lowBits = ~lowBits + 1;\n    } else {\n        // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\n        // adding 1 to that, results in 0x100000000, which leaves\n        // the low bits 0x0 and simply adds one to the high bits.\n        highBits += 1;\n    }\n    return newBits(lowBits, highBits);\n}\n/**\n * Returns decimal representation of digit1e7 with leading zeros.\n */ const decimalFrom1e7WithLeadingZeros = (digit1e7)=>{\n    const partial = String(digit1e7);\n    return \"0000000\".slice(partial.length) + partial;\n};\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */ function varint32write(value, bytes) {\n    if (value >= 0) {\n        // write value as varint 32\n        while(value > 0x7f){\n            bytes.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        bytes.push(value);\n    } else {\n        for(let i = 0; i < 9; i++){\n            bytes.push(value & 127 | 128);\n            value = value >> 7;\n        }\n        bytes.push(1);\n    }\n}\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */ function varint32read() {\n    let b = this.buf[this.pos++];\n    let result = b & 0x7f;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 7;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 14;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 21;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    // Extract only last 4 bits\n    b = this.buf[this.pos++];\n    result |= (b & 0x0f) << 28;\n    for(let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)b = this.buf[this.pos++];\n    if ((b & 0x80) != 0) throw new Error(\"invalid varint\");\n    this.assertBounds();\n    // Result can have 32 bits, convert it to unsigned\n    return result >>> 0;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeInt64Support() {\n    const dv = new DataView(new ArrayBuffer(8));\n    // note that Safari 14 implements BigInt, but not the DataView methods\n    const ok = typeof BigInt === \"function\" && typeof dv.getBigInt64 === \"function\" && typeof dv.getBigUint64 === \"function\" && typeof dv.setBigInt64 === \"function\" && typeof dv.setBigUint64 === \"function\" && (typeof process != \"object\" || typeof process.env != \"object\" || process.env.BUF_BIGINT_DISABLE !== \"1\");\n    if (ok) {\n        const MIN = BigInt(\"-9223372036854775808\"), MAX = BigInt(\"9223372036854775807\"), UMIN = BigInt(\"0\"), UMAX = BigInt(\"18446744073709551615\");\n        return {\n            zero: BigInt(0),\n            supported: true,\n            parse (value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > MAX || bi < MIN) {\n                    throw new Error(\"int64 invalid: \".concat(value));\n                }\n                return bi;\n            },\n            uParse (value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > UMAX || bi < UMIN) {\n                    throw new Error(\"uint64 invalid: \".concat(value));\n                }\n                return bi;\n            },\n            enc (value) {\n                dv.setBigInt64(0, this.parse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            uEnc (value) {\n                dv.setBigInt64(0, this.uParse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            dec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigInt64(0, true);\n            },\n            uDec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigUint64(0, true);\n            }\n        };\n    }\n    const assertInt64String = (value)=>assert(/^-?[0-9]+$/.test(value), \"int64 invalid: \".concat(value));\n    const assertUInt64String = (value)=>assert(/^[0-9]+$/.test(value), \"uint64 invalid: \".concat(value));\n    return {\n        zero: \"0\",\n        supported: false,\n        parse (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return value;\n        },\n        uParse (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return value;\n        },\n        enc (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return int64FromString(value);\n        },\n        uEnc (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return int64FromString(value);\n        },\n        dec (lo, hi) {\n            return int64ToString(lo, hi);\n        },\n        uDec (lo, hi) {\n            return uInt64ToString(lo, hi);\n        }\n    };\n}\nconst protoInt64 = makeInt64Support();\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/restrict-plus-operands */ /**\n * Protobuf binary format wire types.\n *\n * A wire type provides just enough information to find the length of the\n * following value.\n *\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\n */ var WireType;\n(function(WireType) {\n    /**\n   * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\n   */ WireType[WireType[\"Varint\"] = 0] = \"Varint\";\n    /**\n   * Used for fixed64, sfixed64, double.\n   * Always 8 bytes with little-endian byte order.\n   */ WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\n    /**\n   * Used for string, bytes, embedded messages, packed repeated fields\n   *\n   * Only repeated numeric types (types which use the varint, 32-bit,\n   * or 64-bit wire types) can be packed. In proto3, such fields are\n   * packed by default.\n   */ WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\n    /**\n   * Used for groups\n   * @deprecated\n   */ WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\n    /**\n   * Used for groups\n   * @deprecated\n   */ WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\n    /**\n   * Used for fixed32, sfixed32, float.\n   * Always 4 bytes with little-endian byte order.\n   */ WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\n})(WireType || (WireType = {}));\nclass BinaryWriter {\n    constructor(textEncoder){\n        /**\n     * Previous fork states.\n     */ this.stack = [];\n        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();\n        this.chunks = [];\n        this.buf = [];\n    }\n    /**\n   * Return all bytes written and reset this writer.\n   */ finish() {\n        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\n        let len = 0;\n        for(let i = 0; i < this.chunks.length; i++)len += this.chunks[i].length;\n        let bytes = new Uint8Array(len);\n        let offset = 0;\n        for(let i = 0; i < this.chunks.length; i++){\n            bytes.set(this.chunks[i], offset);\n            offset += this.chunks[i].length;\n        }\n        this.chunks = [];\n        return bytes;\n    }\n    /**\n   * Start a new fork for length-delimited data like a message\n   * or a packed repeated field.\n   *\n   * Must be joined later with `join()`.\n   */ fork() {\n        this.stack.push({\n            chunks: this.chunks,\n            buf: this.buf\n        });\n        this.chunks = [];\n        this.buf = [];\n        return this;\n    }\n    /**\n   * Join the last fork. Write its length and bytes, then\n   * return to the previous state.\n   */ join() {\n        // get chunk of fork\n        let chunk = this.finish();\n        // restore previous state\n        let prev = this.stack.pop();\n        if (!prev) throw new Error(\"invalid state, fork stack empty\");\n        this.chunks = prev.chunks;\n        this.buf = prev.buf;\n        // write length of chunk as varint\n        this.uint32(chunk.byteLength);\n        return this.raw(chunk);\n    }\n    /**\n   * Writes a tag (field number and wire type).\n   *\n   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\n   *\n   * Generated code should compute the tag ahead of time and call `uint32()`.\n   */ tag(fieldNo, type) {\n        return this.uint32((fieldNo << 3 | type) >>> 0);\n    }\n    /**\n   * Write a chunk of raw bytes.\n   */ raw(chunk) {\n        if (this.buf.length) {\n            this.chunks.push(new Uint8Array(this.buf));\n            this.buf = [];\n        }\n        this.chunks.push(chunk);\n        return this;\n    }\n    /**\n   * Write a `uint32` value, an unsigned 32 bit varint.\n   */ uint32(value) {\n        assertUInt32(value);\n        // write value as varint 32, inlined for speed\n        while(value > 0x7f){\n            this.buf.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        this.buf.push(value);\n        return this;\n    }\n    /**\n   * Write a `int32` value, a signed 32 bit varint.\n   */ int32(value) {\n        assertInt32(value);\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n   * Write a `bool` value, a variant.\n   */ bool(value) {\n        this.buf.push(value ? 1 : 0);\n        return this;\n    }\n    /**\n   * Write a `bytes` value, length-delimited arbitrary data.\n   */ bytes(value) {\n        this.uint32(value.byteLength); // write length of chunk as varint\n        return this.raw(value);\n    }\n    /**\n   * Write a `string` value, length-delimited data converted to UTF-8 text.\n   */ string(value) {\n        let chunk = this.textEncoder.encode(value);\n        this.uint32(chunk.byteLength); // write length of chunk as varint\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `float` value, 32-bit floating point number.\n   */ float(value) {\n        assertFloat32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setFloat32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `double` value, a 64-bit floating point number.\n   */ double(value) {\n        let chunk = new Uint8Array(8);\n        new DataView(chunk.buffer).setFloat64(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\n   */ fixed32(value) {\n        assertUInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setUint32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\n   */ sfixed32(value) {\n        assertInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setInt32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\n   */ sint32(value) {\n        assertInt32(value);\n        // zigzag encode\n        value = (value << 1 ^ value >> 31) >>> 0;\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\n   */ sfixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\n   */ fixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `int64` value, a signed 64-bit varint.\n   */ int64(value) {\n        let tc = protoInt64.enc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n    /**\n   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\n   */ sint64(value) {\n        let tc = protoInt64.enc(value), // zigzag encode\n        sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;\n        varint64write(lo, hi, this.buf);\n        return this;\n    }\n    /**\n   * Write a `uint64` value, an unsigned 64-bit varint.\n   */ uint64(value) {\n        let tc = protoInt64.uEnc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n}\nclass BinaryReader {\n    constructor(buf, textDecoder){\n        this.varint64 = varint64read; // dirty cast for `this`\n        /**\n     * Read a `uint32` field, an unsigned 32 bit varint.\n     */ this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`\n        this.buf = buf;\n        this.len = buf.length;\n        this.pos = 0;\n        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();\n    }\n    /**\n   * Reads a tag - field number and wire type.\n   */ tag() {\n        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;\n        if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\n        return [\n            fieldNo,\n            wireType\n        ];\n    }\n    /**\n   * Skip one element on the wire and return the skipped data.\n   * Supports WireType.StartGroup since v2.0.0-alpha.23.\n   */ skip(wireType) {\n        let start = this.pos;\n        switch(wireType){\n            case WireType.Varint:\n                while(this.buf[this.pos++] & 0x80){\n                // ignore\n                }\n                break;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit64:\n                this.pos += 4;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit32:\n                this.pos += 4;\n                break;\n            case WireType.LengthDelimited:\n                let len = this.uint32();\n                this.pos += len;\n                break;\n            case WireType.StartGroup:\n                // From descriptor.proto: Group type is deprecated, not supported in proto3.\n                // But we must still be able to parse and treat as unknown.\n                let t;\n                while((t = this.tag()[1]) !== WireType.EndGroup){\n                    this.skip(t);\n                }\n                break;\n            default:\n                throw new Error(\"cant skip wire type \" + wireType);\n        }\n        this.assertBounds();\n        return this.buf.subarray(start, this.pos);\n    }\n    /**\n   * Throws error if position in byte array is out of range.\n   */ assertBounds() {\n        if (this.pos > this.len) throw new RangeError(\"premature EOF\");\n    }\n    /**\n   * Read a `int32` field, a signed 32 bit varint.\n   */ int32() {\n        return this.uint32() | 0;\n    }\n    /**\n   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\n   */ sint32() {\n        let zze = this.uint32();\n        // decode zigzag\n        return zze >>> 1 ^ -(zze & 1);\n    }\n    /**\n   * Read a `int64` field, a signed 64-bit varint.\n   */ int64() {\n        return protoInt64.dec(...this.varint64());\n    }\n    /**\n   * Read a `uint64` field, an unsigned 64-bit varint.\n   */ uint64() {\n        return protoInt64.uDec(...this.varint64());\n    }\n    /**\n   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\n   */ sint64() {\n        let [lo, hi] = this.varint64();\n        // decode zig zag\n        let s = -(lo & 1);\n        lo = (lo >>> 1 | (hi & 1) << 31) ^ s;\n        hi = hi >>> 1 ^ s;\n        return protoInt64.dec(lo, hi);\n    }\n    /**\n   * Read a `bool` field, a variant.\n   */ bool() {\n        let [lo, hi] = this.varint64();\n        return lo !== 0 || hi !== 0;\n    }\n    /**\n   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\n   */ fixed32() {\n        return this.view.getUint32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\n   */ sfixed32() {\n        return this.view.getInt32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\n   */ fixed64() {\n        return protoInt64.uDec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\n   */ sfixed64() {\n        return protoInt64.dec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n   * Read a `float` field, 32-bit floating point number.\n   */ float() {\n        return this.view.getFloat32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `double` field, a 64-bit floating point number.\n   */ double() {\n        return this.view.getFloat64((this.pos += 8) - 8, true);\n    }\n    /**\n   * Read a `bytes` field, length-delimited arbitrary data.\n   */ bytes() {\n        let len = this.uint32(), start = this.pos;\n        this.pos += len;\n        this.assertBounds();\n        return this.buf.subarray(start, start + len);\n    }\n    /**\n   * Read a `string` field, length-delimited data converted to UTF-8 text.\n   */ string() {\n        return this.textDecoder.decode(this.bytes());\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Wrap a primitive message field value in its corresponding wrapper\n * message. This function is idempotent.\n */ function wrapField(type, value) {\n    if (value instanceof Message || !type.fieldWrapper) {\n        return value;\n    }\n    return type.fieldWrapper.wrapField(value);\n}\n({\n    \"google.protobuf.DoubleValue\": ScalarType.DOUBLE,\n    \"google.protobuf.FloatValue\": ScalarType.FLOAT,\n    \"google.protobuf.Int64Value\": ScalarType.INT64,\n    \"google.protobuf.UInt64Value\": ScalarType.UINT64,\n    \"google.protobuf.Int32Value\": ScalarType.INT32,\n    \"google.protobuf.UInt32Value\": ScalarType.UINT32,\n    \"google.protobuf.BoolValue\": ScalarType.BOOL,\n    \"google.protobuf.StringValue\": ScalarType.STRING,\n    \"google.protobuf.BytesValue\": ScalarType.BYTES\n});\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any */ /**\n * Returns true if both scalar values are equal.\n */ function scalarEquals(type, a, b) {\n    if (a === b) {\n        // This correctly matches equal values except BYTES and (possibly) 64-bit integers.\n        return true;\n    }\n    // Special case BYTES - we need to compare each byte individually\n    if (type == ScalarType.BYTES) {\n        if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {\n            return false;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length; i++){\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Special case 64-bit integers - we support number, string and bigint representation.\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(type){\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // Loose comparison will match between 0n, 0 and \"0\".\n            return a == b;\n    }\n    // Anything that hasn't been caught by strict comparison or special cased\n    // BYTES and 64-bit integers is not equal.\n    return false;\n}\n/**\n * Returns the default value for the given scalar type, following\n * proto3 semantics.\n */ function scalarDefaultValue(type, longType) {\n    switch(type){\n        case ScalarType.BOOL:\n            return false;\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n            return longType == 0 ? protoInt64.zero : \"0\";\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            return 0.0;\n        case ScalarType.BYTES:\n            return new Uint8Array(0);\n        case ScalarType.STRING:\n            return \"\";\n        default:\n            // Handles INT32, UINT32, SINT32, FIXED32, SFIXED32.\n            // We do not use individual cases to save a few bytes code size.\n            return 0;\n    }\n}\n/**\n * Get information for writing a scalar value.\n *\n * Returns tuple:\n * [0]: appropriate WireType\n * [1]: name of the appropriate method of IBinaryWriter\n * [2]: whether the given value is a default value for proto3 semantics\n *\n * If argument `value` is omitted, [2] is always false.\n */ function scalarTypeInfo(type, value) {\n    const isUndefined = value === undefined;\n    let wireType = WireType.Varint;\n    let isIntrinsicDefault = value === 0;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- INT32, UINT32, SINT32 are covered by the defaults\n    switch(type){\n        case ScalarType.STRING:\n            isIntrinsicDefault = isUndefined || !value.length;\n            wireType = WireType.LengthDelimited;\n            break;\n        case ScalarType.BOOL:\n            isIntrinsicDefault = value === false;\n            break;\n        case ScalarType.DOUBLE:\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.FLOAT:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.INT64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            break;\n        case ScalarType.UINT64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            break;\n        case ScalarType.FIXED64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.BYTES:\n            isIntrinsicDefault = isUndefined || !value.byteLength;\n            wireType = WireType.LengthDelimited;\n            break;\n        case ScalarType.FIXED32:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.SFIXED32:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.SFIXED64:\n            isIntrinsicDefault = isUndefined || value == 0;\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.SINT64:\n            isIntrinsicDefault = isUndefined || value == 0;\n            break;\n    }\n    const method = ScalarType[type].toLowerCase();\n    return [\n        wireType,\n        method,\n        isUndefined || isIntrinsicDefault\n    ];\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unnecessary-condition, no-case-declarations, prefer-const */ const unknownFieldsSymbol = Symbol(\"@bufbuild/protobuf/unknown-fields\");\n// Default options for parsing binary data.\nconst readDefaults = {\n    readUnknownFields: true,\n    readerFactory: (bytes)=>new BinaryReader(bytes)\n};\n// Default options for serializing binary data.\nconst writeDefaults = {\n    writeUnknownFields: true,\n    writerFactory: ()=>new BinaryWriter()\n};\nfunction makeReadOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;\n}\nfunction makeWriteOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;\n}\nfunction makeBinaryFormatCommon() {\n    return {\n        makeReadOptions: makeReadOptions$1,\n        makeWriteOptions: makeWriteOptions$1,\n        listUnknownFields (message) {\n            var _a;\n            return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];\n        },\n        discardUnknownFields (message) {\n            delete message[unknownFieldsSymbol];\n        },\n        writeUnknownFields (message, writer) {\n            const m = message;\n            const c = m[unknownFieldsSymbol];\n            if (c) {\n                for (const f of c){\n                    writer.tag(f.no, f.wireType).raw(f.data);\n                }\n            }\n        },\n        onUnknownField (message, no, wireType, data) {\n            const m = message;\n            if (!Array.isArray(m[unknownFieldsSymbol])) {\n                m[unknownFieldsSymbol] = [];\n            }\n            m[unknownFieldsSymbol].push({\n                no,\n                wireType,\n                data\n            });\n        },\n        readMessage (message, reader, length, options) {\n            const type = message.getType();\n            const end = length === undefined ? reader.len : reader.pos + length;\n            while(reader.pos < end){\n                const [fieldNo, wireType] = reader.tag(), field = type.fields.find(fieldNo);\n                if (!field) {\n                    const data = reader.skip(wireType);\n                    if (options.readUnknownFields) {\n                        this.onUnknownField(message, fieldNo, wireType, data);\n                    }\n                    continue;\n                }\n                let target = message, repeated = field.repeated, localName = field.localName;\n                if (field.oneof) {\n                    target = target[field.oneof.localName];\n                    if (target.case != localName) {\n                        delete target.value;\n                    }\n                    target.case = localName;\n                    localName = \"value\";\n                }\n                switch(field.kind){\n                    case \"scalar\":\n                    case \"enum\":\n                        const scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n                        let read = readScalar$1;\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n                        if (field.kind == \"scalar\" && field.L > 0) {\n                            read = readScalarLTString;\n                        }\n                        if (repeated) {\n                            let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\n                            if (wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES) {\n                                let e = reader.uint32() + reader.pos;\n                                while(reader.pos < e){\n                                    arr.push(read(reader, scalarType));\n                                }\n                            } else {\n                                arr.push(read(reader, scalarType));\n                            }\n                        } else {\n                            target[localName] = read(reader, scalarType);\n                        }\n                        break;\n                    case \"message\":\n                        const messageType = field.T;\n                        if (repeated) {\n                            // safe to assume presence of array, oneof cannot contain repeated values\n                            target[localName].push(readMessageField(reader, new messageType(), options));\n                        } else {\n                            if (target[localName] instanceof Message) {\n                                readMessageField(reader, target[localName], options);\n                            } else {\n                                target[localName] = readMessageField(reader, new messageType(), options);\n                                if (messageType.fieldWrapper && !field.oneof && !field.repeated) {\n                                    target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n                                }\n                            }\n                        }\n                        break;\n                    case \"map\":\n                        let [mapKey, mapVal] = readMapEntry(field, reader, options);\n                        // safe to assume presence of map object, oneof cannot contain repeated values\n                        target[localName][mapKey] = mapVal;\n                        break;\n                }\n            }\n        }\n    };\n}\n// Read a message, avoiding MessageType.fromBinary() to re-use the\n// BinaryReadOptions and the IBinaryReader.\nfunction readMessageField(reader, message, options) {\n    const format = message.getType().runtime.bin;\n    format.readMessage(message, reader, reader.uint32(), options);\n    return message;\n}\n// Read a map field, expecting key field = 1, value field = 2\nfunction readMapEntry(field, reader, options) {\n    const length = reader.uint32(), end = reader.pos + length;\n    let key, val;\n    while(reader.pos < end){\n        let [fieldNo] = reader.tag();\n        switch(fieldNo){\n            case 1:\n                key = readScalar$1(reader, field.K);\n                break;\n            case 2:\n                switch(field.V.kind){\n                    case \"scalar\":\n                        val = readScalar$1(reader, field.V.T);\n                        break;\n                    case \"enum\":\n                        val = reader.int32();\n                        break;\n                    case \"message\":\n                        val = readMessageField(reader, new field.V.T(), options);\n                        break;\n                }\n                break;\n        }\n    }\n    if (key === undefined) {\n        let keyRaw = scalarDefaultValue(field.K, LongType.BIGINT);\n        key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;\n    }\n    if (typeof key != \"string\" && typeof key != \"number\") {\n        key = key.toString();\n    }\n    if (val === undefined) {\n        switch(field.V.kind){\n            case \"scalar\":\n                val = scalarDefaultValue(field.V.T, LongType.BIGINT);\n                break;\n            case \"enum\":\n                val = 0;\n                break;\n            case \"message\":\n                val = new field.V.T();\n                break;\n        }\n    }\n    return [\n        key,\n        val\n    ];\n}\n// Read a scalar value, but return 64 bit integral types (int64, uint64,\n// sint64, fixed64, sfixed64) as string instead of bigint.\nfunction readScalarLTString(reader, type) {\n    const v = readScalar$1(reader, type);\n    return typeof v == \"bigint\" ? v.toString() : v;\n}\n// Does not use scalarTypeInfo() for better performance.\nfunction readScalar$1(reader, type) {\n    switch(type){\n        case ScalarType.STRING:\n            return reader.string();\n        case ScalarType.BOOL:\n            return reader.bool();\n        case ScalarType.DOUBLE:\n            return reader.double();\n        case ScalarType.FLOAT:\n            return reader.float();\n        case ScalarType.INT32:\n            return reader.int32();\n        case ScalarType.INT64:\n            return reader.int64();\n        case ScalarType.UINT64:\n            return reader.uint64();\n        case ScalarType.FIXED64:\n            return reader.fixed64();\n        case ScalarType.BYTES:\n            return reader.bytes();\n        case ScalarType.FIXED32:\n            return reader.fixed32();\n        case ScalarType.SFIXED32:\n            return reader.sfixed32();\n        case ScalarType.SFIXED64:\n            return reader.sfixed64();\n        case ScalarType.SINT64:\n            return reader.sint64();\n        case ScalarType.UINT32:\n            return reader.uint32();\n        case ScalarType.SINT32:\n            return reader.sint32();\n    }\n}\nfunction writeMapEntry(writer, options, field, key, value) {\n    writer.tag(field.no, WireType.LengthDelimited);\n    writer.fork();\n    // javascript only allows number or string for object properties\n    // we convert from our representation to the protobuf type\n    let keyValue = key;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- we deliberately handle just the special cases for map keys\n    switch(field.K){\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n            keyValue = Number.parseInt(key);\n            break;\n        case ScalarType.BOOL:\n            assert(key == \"true\" || key == \"false\");\n            keyValue = key == \"true\";\n            break;\n    }\n    // write key, expecting key field number = 1\n    writeScalar$1(writer, field.K, 1, keyValue, true);\n    // write value, expecting value field number = 2\n    switch(field.V.kind){\n        case \"scalar\":\n            writeScalar$1(writer, field.V.T, 2, value, true);\n            break;\n        case \"enum\":\n            writeScalar$1(writer, ScalarType.INT32, 2, value, true);\n            break;\n        case \"message\":\n            writeMessageField(writer, options, field.V.T, 2, value);\n            break;\n    }\n    writer.join();\n}\nfunction writeMessageField(writer, options, type, fieldNo, value) {\n    if (value !== undefined) {\n        const message = wrapField(type, value);\n        writer.tag(fieldNo, WireType.LengthDelimited).bytes(message.toBinary(options));\n    }\n}\nfunction writeScalar$1(writer, type, fieldNo, value, emitIntrinsicDefault) {\n    let [wireType, method, isIntrinsicDefault] = scalarTypeInfo(type, value);\n    if (!isIntrinsicDefault || emitIntrinsicDefault) {\n        writer.tag(fieldNo, wireType)[method](value);\n    }\n}\nfunction writePacked(writer, type, fieldNo, value) {\n    if (!value.length) {\n        return;\n    }\n    writer.tag(fieldNo, WireType.LengthDelimited).fork();\n    let [, method] = scalarTypeInfo(type);\n    for(let i = 0; i < value.length; i++){\n        writer[method](value[i]);\n    }\n    writer.join();\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unnecessary-condition, @typescript-eslint/strict-boolean-expressions, prefer-const, no-case-declarations */ function makeBinaryFormatProto3() {\n    return Object.assign(Object.assign({}, makeBinaryFormatCommon()), {\n        writeMessage (message, writer, options) {\n            const type = message.getType();\n            for (const field of type.fields.byNumber()){\n                let value, // this will be our field value, whether it is member of a oneof or regular field\n                repeated = field.repeated, localName = field.localName;\n                if (field.oneof) {\n                    const oneof = message[field.oneof.localName];\n                    if (oneof.case !== localName) {\n                        continue; // field is not selected, skip\n                    }\n                    value = oneof.value;\n                } else {\n                    value = message[localName];\n                }\n                switch(field.kind){\n                    case \"scalar\":\n                    case \"enum\":\n                        let scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n                        if (repeated) {\n                            if (field.packed) {\n                                writePacked(writer, scalarType, field.no, value);\n                            } else {\n                                for (const item of value){\n                                    writeScalar$1(writer, scalarType, field.no, item, true);\n                                }\n                            }\n                        } else {\n                            if (value !== undefined) {\n                                writeScalar$1(writer, scalarType, field.no, value, !!field.oneof || field.opt);\n                            }\n                        }\n                        break;\n                    case \"message\":\n                        if (repeated) {\n                            for (const item of value){\n                                writeMessageField(writer, options, field.T, field.no, item);\n                            }\n                        } else {\n                            writeMessageField(writer, options, field.T, field.no, value);\n                        }\n                        break;\n                    case \"map\":\n                        for (const [key, val] of Object.entries(value)){\n                            writeMapEntry(writer, options, field, key, val);\n                        }\n                        break;\n                }\n            }\n            if (options.writeUnknownFields) {\n                this.writeUnknownFields(message, writer);\n            }\n            return writer;\n        }\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unnecessary-condition, prefer-const */ // lookup table from base64 character to byte\nlet encTable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n// lookup table from base64 character *code* to byte because lookup by number is fast\nlet decTable = [];\nfor(let i = 0; i < encTable.length; i++)decTable[encTable[i].charCodeAt(0)] = i;\n// support base64url variants\ndecTable[\"-\".charCodeAt(0)] = encTable.indexOf(\"+\");\ndecTable[\"_\".charCodeAt(0)] = encTable.indexOf(\"/\");\nconst protoBase64 = {\n    /**\n   * Decodes a base64 string to a byte array.\n   *\n   * - ignores white-space, including line breaks and tabs\n   * - allows inner padding (can decode concatenated base64 strings)\n   * - does not require padding\n   * - understands base64url encoding:\n   *   \"-\" instead of \"+\",\n   *   \"_\" instead of \"/\",\n   *   no padding\n   */ dec (base64Str) {\n        // estimate byte size, not accounting for inner padding and whitespace\n        let es = base64Str.length * 3 / 4;\n        if (base64Str[base64Str.length - 2] == \"=\") es -= 2;\n        else if (base64Str[base64Str.length - 1] == \"=\") es -= 1;\n        let bytes = new Uint8Array(es), bytePos = 0, // position in byte array\n        groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // previous byte\n        for(let i = 0; i < base64Str.length; i++){\n            b = decTable[base64Str.charCodeAt(i)];\n            if (b === undefined) {\n                switch(base64Str[i]){\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"=\":\n                        groupPos = 0;\n                    // reset state when padding found\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"\\n\":\n                    case \"\\r\":\n                    case \"\t\":\n                    case \" \":\n                        continue;\n                    // skip white-space, and padding\n                    default:\n                        throw Error(\"invalid base64 string.\");\n                }\n            }\n            switch(groupPos){\n                case 0:\n                    p = b;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    bytes[bytePos++] = p << 2 | (b & 48) >> 4;\n                    p = b;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;\n                    p = b;\n                    groupPos = 3;\n                    break;\n                case 3:\n                    bytes[bytePos++] = (p & 3) << 6 | b;\n                    groupPos = 0;\n                    break;\n            }\n        }\n        if (groupPos == 1) throw Error(\"invalid base64 string.\");\n        return bytes.subarray(0, bytePos);\n    },\n    /**\n   * Encode a byte array to a base64 string.\n   */ enc (bytes) {\n        let base64 = \"\", groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // carry over from previous byte\n        for(let i = 0; i < bytes.length; i++){\n            b = bytes[i];\n            switch(groupPos){\n                case 0:\n                    base64 += encTable[b >> 2];\n                    p = (b & 3) << 4;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    base64 += encTable[p | b >> 4];\n                    p = (b & 15) << 2;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    base64 += encTable[p | b >> 6];\n                    base64 += encTable[b & 63];\n                    groupPos = 0;\n                    break;\n            }\n        }\n        // add output padding\n        if (groupPos) {\n            base64 += encTable[p];\n            base64 += \"=\";\n            if (groupPos == 1) base64 += \"=\";\n        }\n        return base64;\n    }\n};\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations, @typescript-eslint/restrict-plus-operands,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ // Default options for parsing JSON.\nconst jsonReadDefaults = {\n    ignoreUnknownFields: false\n};\n// Default options for serializing to JSON.\nconst jsonWriteDefaults = {\n    emitDefaultValues: false,\n    enumAsInteger: false,\n    useProtoFieldName: false,\n    prettySpaces: 0\n};\nfunction makeReadOptions(options) {\n    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;\n}\nfunction makeWriteOptions(options) {\n    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;\n}\nfunction makeJsonFormatCommon(makeWriteField) {\n    const writeField = makeWriteField(writeEnum, writeScalar);\n    return {\n        makeReadOptions,\n        makeWriteOptions,\n        readMessage (type, json, options, message) {\n            if (json == null || Array.isArray(json) || typeof json != \"object\") {\n                throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: \").concat(this.debug(json)));\n            }\n            message = message !== null && message !== void 0 ? message : new type();\n            const oneofSeen = {};\n            for (const [jsonKey, jsonValue] of Object.entries(json)){\n                const field = type.fields.findJsonName(jsonKey);\n                if (!field) {\n                    if (!options.ignoreUnknownFields) {\n                        throw new Error(\"cannot decode message \".concat(type.typeName, ' from JSON: key \"').concat(jsonKey, '\" is unknown'));\n                    }\n                    continue;\n                }\n                let localName = field.localName;\n                let target = message;\n                if (field.oneof) {\n                    if (jsonValue === null && field.kind == \"scalar\") {\n                        continue;\n                    }\n                    const seen = oneofSeen[field.oneof.localName];\n                    if (seen) {\n                        throw new Error(\"cannot decode message \".concat(type.typeName, ' from JSON: multiple keys for oneof \"').concat(field.oneof.name, '\" present: \"').concat(seen, '\", \"').concat(jsonKey, '\"'));\n                    }\n                    oneofSeen[field.oneof.localName] = jsonKey;\n                    target = target[field.oneof.localName] = {\n                        case: localName\n                    };\n                    localName = \"value\";\n                }\n                if (field.repeated) {\n                    if (jsonValue === null) {\n                        continue;\n                    }\n                    if (!Array.isArray(jsonValue)) {\n                        throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue)));\n                    }\n                    const targetArray = target[localName];\n                    for (const jsonItem of jsonValue){\n                        if (jsonItem === null) {\n                            throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonItem)));\n                        }\n                        let val;\n                        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- \"map\" is invalid for repeated fields\n                        switch(field.kind){\n                            case \"message\":\n                                val = field.T.fromJson(jsonItem, options);\n                                break;\n                            case \"enum\":\n                                val = readEnum(field.T, jsonItem, options.ignoreUnknownFields);\n                                if (val === undefined) continue;\n                                break;\n                            case \"scalar\":\n                                try {\n                                    val = readScalar(field.T, jsonItem, field.L);\n                                } catch (e) {\n                                    let m = \"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonItem));\n                                    if (e instanceof Error && e.message.length > 0) {\n                                        m += \": \".concat(e.message);\n                                    }\n                                    throw new Error(m);\n                                }\n                                break;\n                        }\n                        targetArray.push(val);\n                    }\n                } else if (field.kind == \"map\") {\n                    if (jsonValue === null) {\n                        continue;\n                    }\n                    if (Array.isArray(jsonValue) || typeof jsonValue != \"object\") {\n                        throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue)));\n                    }\n                    const targetMap = target[localName];\n                    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)){\n                        if (jsonMapValue === null) {\n                            throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: map value null\"));\n                        }\n                        let val;\n                        switch(field.V.kind){\n                            case \"message\":\n                                val = field.V.T.fromJson(jsonMapValue, options);\n                                break;\n                            case \"enum\":\n                                val = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields);\n                                if (val === undefined) continue;\n                                break;\n                            case \"scalar\":\n                                try {\n                                    val = readScalar(field.V.T, jsonMapValue, LongType.BIGINT);\n                                } catch (e) {\n                                    let m = \"cannot decode map value for field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue));\n                                    if (e instanceof Error && e.message.length > 0) {\n                                        m += \": \".concat(e.message);\n                                    }\n                                    throw new Error(m);\n                                }\n                                break;\n                        }\n                        try {\n                            targetMap[readScalar(field.K, field.K == ScalarType.BOOL ? jsonMapKey == \"true\" ? true : jsonMapKey == \"false\" ? false : jsonMapKey : jsonMapKey, LongType.BIGINT).toString()] = val;\n                        } catch (e) {\n                            let m = \"cannot decode map key for field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue));\n                            if (e instanceof Error && e.message.length > 0) {\n                                m += \": \".concat(e.message);\n                            }\n                            throw new Error(m);\n                        }\n                    }\n                } else {\n                    switch(field.kind){\n                        case \"message\":\n                            const messageType = field.T;\n                            if (jsonValue === null && messageType.typeName != \"google.protobuf.Value\") {\n                                if (field.oneof) {\n                                    throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, ' from JSON: null is invalid for oneof field \"').concat(jsonKey, '\"'));\n                                }\n                                continue;\n                            }\n                            if (target[localName] instanceof Message) {\n                                target[localName].fromJson(jsonValue, options);\n                            } else {\n                                target[localName] = messageType.fromJson(jsonValue, options);\n                                if (messageType.fieldWrapper && !field.oneof) {\n                                    target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n                                }\n                            }\n                            break;\n                        case \"enum\":\n                            const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields);\n                            if (enumValue !== undefined) {\n                                target[localName] = enumValue;\n                            }\n                            break;\n                        case \"scalar\":\n                            try {\n                                target[localName] = readScalar(field.T, jsonValue, field.L);\n                            } catch (e) {\n                                let m = \"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue));\n                                if (e instanceof Error && e.message.length > 0) {\n                                    m += \": \".concat(e.message);\n                                }\n                                throw new Error(m);\n                            }\n                            break;\n                    }\n                }\n            }\n            return message;\n        },\n        writeMessage (message, options) {\n            const type = message.getType();\n            const json = {};\n            let field;\n            try {\n                for (const member of type.fields.byMember()){\n                    let jsonValue;\n                    if (member.kind == \"oneof\") {\n                        const oneof = message[member.localName];\n                        if (oneof.value === undefined) {\n                            continue;\n                        }\n                        field = member.findField(oneof.case);\n                        if (!field) {\n                            throw \"oneof case not found: \" + oneof.case;\n                        }\n                        jsonValue = writeField(field, oneof.value, options);\n                    } else {\n                        field = member;\n                        jsonValue = writeField(field, message[field.localName], options);\n                    }\n                    if (jsonValue !== undefined) {\n                        json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\n                    }\n                }\n            } catch (e) {\n                const m = field ? \"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to JSON\") : \"cannot encode message \".concat(type.typeName, \" to JSON\");\n                const r = e instanceof Error ? e.message : String(e);\n                throw new Error(m + (r.length > 0 ? \": \".concat(r) : \"\"));\n            }\n            return json;\n        },\n        readScalar,\n        writeScalar,\n        debug: debugJsonValue\n    };\n}\nfunction debugJsonValue(json) {\n    if (json === null) {\n        return \"null\";\n    }\n    switch(typeof json){\n        case \"object\":\n            return Array.isArray(json) ? \"array\" : \"object\";\n        case \"string\":\n            return json.length > 100 ? \"string\" : '\"'.concat(json.split('\"').join('\\\\\"'), '\"');\n        default:\n            return String(json);\n    }\n}\n// May throw an error. If the error message is non-blank, it should be shown.\n// It is up to the caller to provide context.\nfunction readScalar(type, json, longType) {\n    // every valid case in the switch below returns, and every fall\n    // through is regarded as a failure.\n    switch(type){\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            if (json === null) return 0.0;\n            if (json === \"NaN\") return Number.NaN;\n            if (json === \"Infinity\") return Number.POSITIVE_INFINITY;\n            if (json === \"-Infinity\") return Number.NEGATIVE_INFINITY;\n            if (json === \"\") {\n                break;\n            }\n            if (typeof json == \"string\" && json.trim().length !== json.length) {\n                break;\n            }\n            if (typeof json != \"string\" && typeof json != \"number\") {\n                break;\n            }\n            const float = Number(json);\n            if (Number.isNaN(float)) {\n                break;\n            }\n            if (!Number.isFinite(float)) {\n                break;\n            }\n            if (type == ScalarType.FLOAT) assertFloat32(float);\n            return float;\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.UINT32:\n            if (json === null) return 0;\n            let int32;\n            if (typeof json == \"number\") int32 = json;\n            else if (typeof json == \"string\" && json.length > 0) {\n                if (json.trim().length === json.length) int32 = Number(json);\n            }\n            if (int32 === undefined) break;\n            if (type == ScalarType.UINT32) assertUInt32(int32);\n            else assertInt32(int32);\n            return int32;\n        // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            if (json === null) return protoInt64.zero;\n            if (typeof json != \"number\" && typeof json != \"string\") break;\n            const long = protoInt64.parse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? long.toString() : long;\n        case ScalarType.FIXED64:\n        case ScalarType.UINT64:\n            if (json === null) return protoInt64.zero;\n            if (typeof json != \"number\" && typeof json != \"string\") break;\n            const uLong = protoInt64.uParse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? uLong.toString() : uLong;\n        // bool:\n        case ScalarType.BOOL:\n            if (json === null) return false;\n            if (typeof json !== \"boolean\") break;\n            return json;\n        // string:\n        case ScalarType.STRING:\n            if (json === null) return \"\";\n            if (typeof json !== \"string\") {\n                break;\n            }\n            // A string must always contain UTF-8 encoded or 7-bit ASCII.\n            // We validate with encodeURIComponent, which appears to be the fastest widely available option.\n            try {\n                encodeURIComponent(json);\n            } catch (e) {\n                throw new Error(\"invalid UTF8\");\n            }\n            return json;\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            if (json === null || json === \"\") return new Uint8Array(0);\n            if (typeof json !== \"string\") break;\n            return protoBase64.dec(json);\n    }\n    throw new Error();\n}\nfunction readEnum(type, json, ignoreUnknownFields) {\n    if (json === null) {\n        // proto3 requires 0 to be default value for all enums\n        return 0;\n    }\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(typeof json){\n        case \"number\":\n            if (Number.isInteger(json)) {\n                return json;\n            }\n            break;\n        case \"string\":\n            const value = type.findName(json);\n            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n            if (value || ignoreUnknownFields) {\n                return value === null || value === void 0 ? void 0 : value.no;\n            }\n            break;\n    }\n    throw new Error(\"cannot decode enum \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\n}\nfunction writeEnum(type, value, emitIntrinsicDefault, enumAsInteger) {\n    var _a;\n    if (value === undefined) {\n        return value;\n    }\n    if (value === 0 && !emitIntrinsicDefault) {\n        // proto3 requires 0 to be default value for all enums\n        return undefined;\n    }\n    if (enumAsInteger) {\n        return value;\n    }\n    if (type.typeName == \"google.protobuf.NullValue\") {\n        return null;\n    }\n    const val = type.findNumber(value);\n    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value; // if we don't know the enum value, just return the number\n}\nfunction writeScalar(type, value, emitIntrinsicDefault) {\n    if (value === undefined) {\n        return undefined;\n    }\n    switch(type){\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n            assert(typeof value == \"number\");\n            return value != 0 || emitIntrinsicDefault ? value : undefined;\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.FLOAT:\n        // assertFloat32(value);\n        case ScalarType.DOUBLE:\n            // eslint-disable-line no-fallthrough\n            assert(typeof value == \"number\");\n            if (Number.isNaN(value)) return \"NaN\";\n            if (value === Number.POSITIVE_INFINITY) return \"Infinity\";\n            if (value === Number.NEGATIVE_INFINITY) return \"-Infinity\";\n            return value !== 0 || emitIntrinsicDefault ? value : undefined;\n        // string:\n        case ScalarType.STRING:\n            assert(typeof value == \"string\");\n            return value.length > 0 || emitIntrinsicDefault ? value : undefined;\n        // bool:\n        case ScalarType.BOOL:\n            assert(typeof value == \"boolean\");\n            return value || emitIntrinsicDefault ? value : undefined;\n        // JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            assert(typeof value == \"bigint\" || typeof value == \"string\" || typeof value == \"number\");\n            // We use implicit conversion with `value != 0` to catch both 0n and \"0\"\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            return emitIntrinsicDefault || value != 0 ? value.toString(10) : undefined;\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            assert(value instanceof Uint8Array);\n            return emitIntrinsicDefault || value.byteLength > 0 ? protoBase64.enc(value) : undefined;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations, @typescript-eslint/restrict-plus-operands,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ function makeJsonFormatProto3() {\n    return makeJsonFormatCommon((writeEnum, writeScalar)=>{\n        return function writeField(field, value, options) {\n            if (field.kind == \"map\") {\n                const jsonObj = {};\n                switch(field.V.kind){\n                    case \"scalar\":\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            const val = writeScalar(field.V.T, entryValue, true);\n                            assert(val !== undefined);\n                            jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                        }\n                        break;\n                    case \"message\":\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            // JSON standard allows only (double quoted) string as property key\n                            jsonObj[entryKey.toString()] = entryValue.toJson(options);\n                        }\n                        break;\n                    case \"enum\":\n                        const enumType = field.V.T;\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            assert(entryValue === undefined || typeof entryValue == \"number\");\n                            const val = writeEnum(enumType, entryValue, true, options.enumAsInteger);\n                            assert(val !== undefined);\n                            jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                        }\n                        break;\n                }\n                return options.emitDefaultValues || Object.keys(jsonObj).length > 0 ? jsonObj : undefined;\n            } else if (field.repeated) {\n                const jsonArr = [];\n                switch(field.kind){\n                    case \"scalar\":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(writeScalar(field.T, value[i], true));\n                        }\n                        break;\n                    case \"enum\":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(writeEnum(field.T, value[i], true, options.enumAsInteger));\n                        }\n                        break;\n                    case \"message\":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(wrapField(field.T, value[i]).toJson(options));\n                        }\n                        break;\n                }\n                return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : undefined;\n            } else {\n                switch(field.kind){\n                    case \"scalar\":\n                        return writeScalar(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues);\n                    case \"enum\":\n                        return writeEnum(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues, options.enumAsInteger);\n                    case \"message\":\n                        return value !== undefined ? wrapField(field.T, value).toJson(options) : undefined;\n                }\n            }\n        };\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-argument,no-case-declarations */ function makeUtilCommon() {\n    return {\n        setEnumType,\n        initPartial (source, target) {\n            if (source === undefined) {\n                return;\n            }\n            const type = target.getType();\n            for (const member of type.fields.byMember()){\n                const localName = member.localName, t = target, s = source;\n                if (s[localName] === undefined) {\n                    continue;\n                }\n                switch(member.kind){\n                    case \"oneof\":\n                        const sk = s[localName].case;\n                        if (sk === undefined) {\n                            continue;\n                        }\n                        const sourceField = member.findField(sk);\n                        let val = s[localName].value;\n                        if (sourceField && sourceField.kind == \"message\" && !(val instanceof sourceField.T)) {\n                            val = new sourceField.T(val);\n                        } else if (sourceField && sourceField.kind === \"scalar\" && sourceField.T === ScalarType.BYTES) {\n                            val = toU8Arr(val);\n                        }\n                        t[localName] = {\n                            case: sk,\n                            value: val\n                        };\n                        break;\n                    case \"scalar\":\n                    case \"enum\":\n                        let copy = s[localName];\n                        if (member.T === ScalarType.BYTES) {\n                            copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);\n                        }\n                        t[localName] = copy;\n                        break;\n                    case \"map\":\n                        switch(member.V.kind){\n                            case \"scalar\":\n                            case \"enum\":\n                                if (member.V.T === ScalarType.BYTES) {\n                                    for (const [k, v] of Object.entries(s[localName])){\n                                        t[localName][k] = toU8Arr(v);\n                                    }\n                                } else {\n                                    Object.assign(t[localName], s[localName]);\n                                }\n                                break;\n                            case \"message\":\n                                const messageType = member.V.T;\n                                for (const k of Object.keys(s[localName])){\n                                    let val = s[localName][k];\n                                    if (!messageType.fieldWrapper) {\n                                        // We only take partial input for messages that are not a wrapper type.\n                                        // For those messages, we recursively normalize the partial input.\n                                        val = new messageType(val);\n                                    }\n                                    t[localName][k] = val;\n                                }\n                                break;\n                        }\n                        break;\n                    case \"message\":\n                        const mt = member.T;\n                        if (member.repeated) {\n                            t[localName] = s[localName].map((val)=>val instanceof mt ? val : new mt(val));\n                        } else if (s[localName] !== undefined) {\n                            const val = s[localName];\n                            if (mt.fieldWrapper) {\n                                if (// We can't use BytesValue.typeName as that will create a circular import\n                                mt.typeName === \"google.protobuf.BytesValue\") {\n                                    t[localName] = toU8Arr(val);\n                                } else {\n                                    t[localName] = val;\n                                }\n                            } else {\n                                t[localName] = val instanceof mt ? val : new mt(val);\n                            }\n                        }\n                        break;\n                }\n            }\n        },\n        equals (type, a, b) {\n            if (a === b) {\n                return true;\n            }\n            if (!a || !b) {\n                return false;\n            }\n            return type.fields.byMember().every((m)=>{\n                const va = a[m.localName];\n                const vb = b[m.localName];\n                if (m.repeated) {\n                    if (va.length !== vb.length) {\n                        return false;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- repeated fields are never \"map\"\n                    switch(m.kind){\n                        case \"message\":\n                            return va.every((a, i)=>m.T.equals(a, vb[i]));\n                        case \"scalar\":\n                            return va.every((a, i)=>scalarEquals(m.T, a, vb[i]));\n                        case \"enum\":\n                            return va.every((a, i)=>scalarEquals(ScalarType.INT32, a, vb[i]));\n                    }\n                    throw new Error(\"repeated cannot contain \".concat(m.kind));\n                }\n                switch(m.kind){\n                    case \"message\":\n                        return m.T.equals(va, vb);\n                    case \"enum\":\n                        return scalarEquals(ScalarType.INT32, va, vb);\n                    case \"scalar\":\n                        return scalarEquals(m.T, va, vb);\n                    case \"oneof\":\n                        if (va.case !== vb.case) {\n                            return false;\n                        }\n                        const s = m.findField(va.case);\n                        if (s === undefined) {\n                            return true;\n                        }\n                        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- oneof fields are never \"map\"\n                        switch(s.kind){\n                            case \"message\":\n                                return s.T.equals(va.value, vb.value);\n                            case \"enum\":\n                                return scalarEquals(ScalarType.INT32, va.value, vb.value);\n                            case \"scalar\":\n                                return scalarEquals(s.T, va.value, vb.value);\n                        }\n                        throw new Error(\"oneof cannot contain \".concat(s.kind));\n                    case \"map\":\n                        const keys = Object.keys(va).concat(Object.keys(vb));\n                        switch(m.V.kind){\n                            case \"message\":\n                                const messageType = m.V.T;\n                                return keys.every((k)=>messageType.equals(va[k], vb[k]));\n                            case \"enum\":\n                                return keys.every((k)=>scalarEquals(ScalarType.INT32, va[k], vb[k]));\n                            case \"scalar\":\n                                const scalarType = m.V.T;\n                                return keys.every((k)=>scalarEquals(scalarType, va[k], vb[k]));\n                        }\n                        break;\n                }\n            });\n        },\n        clone (message) {\n            const type = message.getType(), target = new type(), any = target;\n            for (const member of type.fields.byMember()){\n                const source = message[member.localName];\n                let copy;\n                if (member.repeated) {\n                    copy = source.map(cloneSingularField);\n                } else if (member.kind == \"map\") {\n                    copy = any[member.localName];\n                    for (const [key, v] of Object.entries(source)){\n                        copy[key] = cloneSingularField(v);\n                    }\n                } else if (member.kind == \"oneof\") {\n                    const f = member.findField(source.case);\n                    copy = f ? {\n                        case: source.case,\n                        value: cloneSingularField(source.value)\n                    } : {\n                        case: undefined\n                    };\n                } else {\n                    copy = cloneSingularField(source);\n                }\n                any[member.localName] = copy;\n            }\n            return target;\n        }\n    };\n}\n// clone a single field value - i.e. the element type of repeated fields, the value type of maps\nfunction cloneSingularField(value) {\n    if (value === undefined) {\n        return value;\n    }\n    if (value instanceof Message) {\n        return value.clone();\n    }\n    if (value instanceof Uint8Array) {\n        const c = new Uint8Array(value.byteLength);\n        c.set(value);\n        return c;\n    }\n    return value;\n}\n// converts any ArrayLike<number> to Uint8Array if necessary.\nfunction toU8Arr(input) {\n    return input instanceof Uint8Array ? input : new Uint8Array(input);\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalFieldList {\n    constructor(fields, normalizer){\n        this._fields = fields;\n        this._normalizer = normalizer;\n    }\n    findJsonName(jsonName) {\n        if (!this.jsonNames) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.jsonName] = t[f.name] = f;\n            }\n            this.jsonNames = t;\n        }\n        return this.jsonNames[jsonName];\n    }\n    find(fieldNo) {\n        if (!this.numbers) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.no] = f;\n            }\n            this.numbers = t;\n        }\n        return this.numbers[fieldNo];\n    }\n    list() {\n        if (!this.all) {\n            this.all = this._normalizer(this._fields);\n        }\n        return this.all;\n    }\n    byNumber() {\n        if (!this.numbersAsc) {\n            this.numbersAsc = this.list().concat().sort((a, b)=>a.no - b.no);\n        }\n        return this.numbersAsc;\n    }\n    byMember() {\n        if (!this.members) {\n            this.members = [];\n            const a = this.members;\n            let o;\n            for (const f of this.list()){\n                if (f.oneof) {\n                    if (f.oneof !== o) {\n                        o = f.oneof;\n                        a.push(o);\n                    }\n                } else {\n                    a.push(f);\n                }\n            }\n        }\n        return this.members;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns the name of a protobuf element in generated code.\n *\n * Field names - including oneofs - are converted to lowerCamelCase. For\n * messages, enumerations and services, the package name is stripped from\n * the type name. For nested messages and enumerations, the names are joined\n * with an underscore. For methods, the first character is made lowercase.\n */ /**\n * Returns the name of a field in generated code.\n */ function localFieldName(protoName, inOneof) {\n    const name = protoCamelCase(protoName);\n    if (inOneof) {\n        // oneof member names are not properties, but values of the `case` property.\n        return name;\n    }\n    return safeObjectProperty(safeMessageProperty(name));\n}\n/**\n * Returns the name of a oneof group in generated code.\n */ function localOneofName(protoName) {\n    return localFieldName(protoName, false);\n}\n/**\n * Returns the JSON name for a protobuf field, exactly like protoc does.\n */ const fieldJsonName = protoCamelCase;\n/**\n * Converts snake_case to protoCamelCase according to the convention\n * used by protoc to convert a field name to a JSON name.\n */ function protoCamelCase(snakeCase) {\n    let capNext = false;\n    const b = [];\n    for(let i = 0; i < snakeCase.length; i++){\n        let c = snakeCase.charAt(i);\n        switch(c){\n            case \"_\":\n                capNext = true;\n                break;\n            case \"0\":\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n                b.push(c);\n                capNext = false;\n                break;\n            default:\n                if (capNext) {\n                    capNext = false;\n                    c = c.toUpperCase();\n                }\n                b.push(c);\n                break;\n        }\n    }\n    return b.join(\"\");\n}\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const reservedObjectProperties = new Set([\n    // names reserved by JavaScript\n    \"constructor\",\n    \"toString\",\n    \"toJSON\",\n    \"valueOf\"\n]);\n/**\n * Names that cannot be used for object properties because they are reserved\n * by the runtime.\n */ const reservedMessageProperties = new Set([\n    // names reserved by the runtime\n    \"getType\",\n    \"clone\",\n    \"equals\",\n    \"fromBinary\",\n    \"fromJson\",\n    \"fromJsonString\",\n    \"toBinary\",\n    \"toJson\",\n    \"toJsonString\",\n    // names reserved by the runtime for the future\n    \"toObject\"\n]);\nconst fallback = (name)=>\"\".concat(name, \"$\");\n/**\n * Will wrap names that are Object prototype properties or names reserved\n * for `Message`s.\n */ const safeMessageProperty = (name)=>{\n    if (reservedMessageProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const safeObjectProperty = (name)=>{\n    if (reservedObjectProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalOneofInfo {\n    constructor(name){\n        this.kind = \"oneof\";\n        this.repeated = false;\n        this.packed = false;\n        this.opt = false;\n        this.default = undefined;\n        this.fields = [];\n        this.name = name;\n        this.localName = localOneofName(name);\n    }\n    addField(field) {\n        assert(field.oneof === this, \"field \".concat(field.name, \" not one of \").concat(this.name));\n        this.fields.push(field);\n    }\n    findField(localName) {\n        if (!this._lookup) {\n            this._lookup = Object.create(null);\n            for(let i = 0; i < this.fields.length; i++){\n                this._lookup[this.fields[i].localName] = this.fields[i];\n            }\n        }\n        return this._lookup[localName];\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Provides functionality for messages defined with the proto3 syntax.\n */ const proto3 = makeProtoRuntime(\"proto3\", makeJsonFormatProto3(), makeBinaryFormatProto3(), Object.assign(Object.assign({}, makeUtilCommon()), {\n    newFieldList (fields) {\n        return new InternalFieldList(fields, normalizeFieldInfosProto3);\n    },\n    initFields (target) {\n        for (const member of target.getType().fields.byMember()){\n            if (member.opt) {\n                continue;\n            }\n            const name = member.localName, t = target;\n            if (member.repeated) {\n                t[name] = [];\n                continue;\n            }\n            switch(member.kind){\n                case \"oneof\":\n                    t[name] = {\n                        case: undefined\n                    };\n                    break;\n                case \"enum\":\n                    t[name] = 0;\n                    break;\n                case \"map\":\n                    t[name] = {};\n                    break;\n                case \"scalar\":\n                    t[name] = scalarDefaultValue(member.T, member.L); // eslint-disable-line @typescript-eslint/no-unsafe-assignment\n                    break;\n            }\n        }\n    }\n}));\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ function normalizeFieldInfosProto3(fieldInfos) {\n    var _a, _b, _c, _d;\n    const r = [];\n    let o;\n    for (const field of typeof fieldInfos == \"function\" ? fieldInfos() : fieldInfos){\n        const f = field;\n        f.localName = localFieldName(field.name, field.oneof !== undefined);\n        f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);\n        f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;\n        if (field.kind == \"scalar\") {\n            f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;\n        }\n        // From the proto3 language guide:\n        // > In proto3, repeated fields of scalar numeric types are packed by default.\n        // This information is incomplete - according to the conformance tests, BOOL\n        // and ENUM are packed by default as well. This means only STRING and BYTES\n        // are not packed by default, which makes sense because they are length-delimited.\n        f.packed = (_d = field.packed) !== null && _d !== void 0 ? _d : field.kind == \"enum\" || field.kind == \"scalar\" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;\n        // We do not surface options at this time\n        // f.options = field.options ?? emptyReadonlyObject;\n        if (field.oneof !== undefined) {\n            const ooname = typeof field.oneof == \"string\" ? field.oneof : field.oneof.name;\n            if (!o || o.name != ooname) {\n                o = new InternalOneofInfo(ooname);\n            }\n            f.oneof = o;\n            o.addField(f);\n        }\n        r.push(f);\n    }\n    return r;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()\n * ) to obtain a formatter capable of generating timestamps in this format.\n *\n *\n * @generated from message google.protobuf.Timestamp\n */ class Timestamp extends Message {\n    constructor(data){\n        super();\n        /**\n     * Represents seconds of UTC time since Unix epoch\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     * 9999-12-31T23:59:59Z inclusive.\n     *\n     * @generated from field: int64 seconds = 1;\n     */ this.seconds = protoInt64.zero;\n        /**\n     * Non-negative fractions of a second at nanosecond resolution. Negative\n     * second values with fractions must still have non-negative nanos values\n     * that count forward in time. Must be from 0 to 999,999,999\n     * inclusive.\n     *\n     * @generated from field: int32 nanos = 2;\n     */ this.nanos = 0;\n        proto3.util.initPartial(data, this);\n    }\n    fromJson(json, options) {\n        if (typeof json !== \"string\") {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: \".concat(proto3.json.debug(json)));\n        }\n        const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n        if (!matches) {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n        }\n        const ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\n        if (Number.isNaN(ms)) {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n        }\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n            throw new Error(\"cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n        }\n        this.seconds = protoInt64.parse(ms / 1000);\n        this.nanos = 0;\n        if (matches[7]) {\n            this.nanos = parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000;\n        }\n        return this;\n    }\n    toJson(options) {\n        const ms = Number(this.seconds) * 1000;\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n            throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n        }\n        if (this.nanos < 0) {\n            throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative\");\n        }\n        let z = \"Z\";\n        if (this.nanos > 0) {\n            const nanosStr = (this.nanos + 1000000000).toString().substring(1);\n            if (nanosStr.substring(3) === \"000000\") {\n                z = \".\" + nanosStr.substring(0, 3) + \"Z\";\n            } else if (nanosStr.substring(6) === \"000\") {\n                z = \".\" + nanosStr.substring(0, 6) + \"Z\";\n            } else {\n                z = \".\" + nanosStr + \"Z\";\n            }\n        }\n        return new Date(ms).toISOString().replace(\".000Z\", z);\n    }\n    toDate() {\n        return new Date(Number(this.seconds) * 1000 + Math.ceil(this.nanos / 1000000));\n    }\n    static now() {\n        return Timestamp.fromDate(new Date());\n    }\n    static fromDate(date) {\n        const ms = date.getTime();\n        return new Timestamp({\n            seconds: protoInt64.parse(Math.floor(ms / 1000)),\n            nanos: ms % 1000 * 1000000\n        });\n    }\n    static fromBinary(bytes, options) {\n        return new Timestamp().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Timestamp().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Timestamp().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Timestamp, a, b);\n    }\n}\nTimestamp.runtime = proto3;\nTimestamp.typeName = \"google.protobuf.Timestamp\";\nTimestamp.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"seconds\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"nanos\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        }\n    ]);\n// Copyright 2023 LiveKit, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @generated from enum livekit.AudioCodec\n */ var AudioCodec;\n(function(AudioCodec) {\n    /**\n   * @generated from enum value: DEFAULT_AC = 0;\n   */ AudioCodec[AudioCodec[\"DEFAULT_AC\"] = 0] = \"DEFAULT_AC\";\n    /**\n   * @generated from enum value: OPUS = 1;\n   */ AudioCodec[AudioCodec[\"OPUS\"] = 1] = \"OPUS\";\n    /**\n   * @generated from enum value: AAC = 2;\n   */ AudioCodec[AudioCodec[\"AAC\"] = 2] = \"AAC\";\n})(AudioCodec || (AudioCodec = {}));\n// Retrieve enum metadata with: proto3.getEnumType(AudioCodec)\nproto3.util.setEnumType(AudioCodec, \"livekit.AudioCodec\", [\n    {\n        no: 0,\n        name: \"DEFAULT_AC\"\n    },\n    {\n        no: 1,\n        name: \"OPUS\"\n    },\n    {\n        no: 2,\n        name: \"AAC\"\n    }\n]);\n/**\n * @generated from enum livekit.VideoCodec\n */ var VideoCodec;\n(function(VideoCodec) {\n    /**\n   * @generated from enum value: DEFAULT_VC = 0;\n   */ VideoCodec[VideoCodec[\"DEFAULT_VC\"] = 0] = \"DEFAULT_VC\";\n    /**\n   * @generated from enum value: H264_BASELINE = 1;\n   */ VideoCodec[VideoCodec[\"H264_BASELINE\"] = 1] = \"H264_BASELINE\";\n    /**\n   * @generated from enum value: H264_MAIN = 2;\n   */ VideoCodec[VideoCodec[\"H264_MAIN\"] = 2] = \"H264_MAIN\";\n    /**\n   * @generated from enum value: H264_HIGH = 3;\n   */ VideoCodec[VideoCodec[\"H264_HIGH\"] = 3] = \"H264_HIGH\";\n    /**\n   * @generated from enum value: VP8 = 4;\n   */ VideoCodec[VideoCodec[\"VP8\"] = 4] = \"VP8\";\n})(VideoCodec || (VideoCodec = {}));\n// Retrieve enum metadata with: proto3.getEnumType(VideoCodec)\nproto3.util.setEnumType(VideoCodec, \"livekit.VideoCodec\", [\n    {\n        no: 0,\n        name: \"DEFAULT_VC\"\n    },\n    {\n        no: 1,\n        name: \"H264_BASELINE\"\n    },\n    {\n        no: 2,\n        name: \"H264_MAIN\"\n    },\n    {\n        no: 3,\n        name: \"H264_HIGH\"\n    },\n    {\n        no: 4,\n        name: \"VP8\"\n    }\n]);\n/**\n * @generated from enum livekit.ImageCodec\n */ var ImageCodec;\n(function(ImageCodec) {\n    /**\n   * @generated from enum value: IC_DEFAULT = 0;\n   */ ImageCodec[ImageCodec[\"IC_DEFAULT\"] = 0] = \"IC_DEFAULT\";\n    /**\n   * @generated from enum value: IC_JPEG = 1;\n   */ ImageCodec[ImageCodec[\"IC_JPEG\"] = 1] = \"IC_JPEG\";\n})(ImageCodec || (ImageCodec = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ImageCodec)\nproto3.util.setEnumType(ImageCodec, \"livekit.ImageCodec\", [\n    {\n        no: 0,\n        name: \"IC_DEFAULT\"\n    },\n    {\n        no: 1,\n        name: \"IC_JPEG\"\n    }\n]);\n/**\n * @generated from enum livekit.TrackType\n */ var TrackType;\n(function(TrackType) {\n    /**\n   * @generated from enum value: AUDIO = 0;\n   */ TrackType[TrackType[\"AUDIO\"] = 0] = \"AUDIO\";\n    /**\n   * @generated from enum value: VIDEO = 1;\n   */ TrackType[TrackType[\"VIDEO\"] = 1] = \"VIDEO\";\n    /**\n   * @generated from enum value: DATA = 2;\n   */ TrackType[TrackType[\"DATA\"] = 2] = \"DATA\";\n})(TrackType || (TrackType = {}));\n// Retrieve enum metadata with: proto3.getEnumType(TrackType)\nproto3.util.setEnumType(TrackType, \"livekit.TrackType\", [\n    {\n        no: 0,\n        name: \"AUDIO\"\n    },\n    {\n        no: 1,\n        name: \"VIDEO\"\n    },\n    {\n        no: 2,\n        name: \"DATA\"\n    }\n]);\n/**\n * @generated from enum livekit.TrackSource\n */ var TrackSource;\n(function(TrackSource) {\n    /**\n   * @generated from enum value: UNKNOWN = 0;\n   */ TrackSource[TrackSource[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    /**\n   * @generated from enum value: CAMERA = 1;\n   */ TrackSource[TrackSource[\"CAMERA\"] = 1] = \"CAMERA\";\n    /**\n   * @generated from enum value: MICROPHONE = 2;\n   */ TrackSource[TrackSource[\"MICROPHONE\"] = 2] = \"MICROPHONE\";\n    /**\n   * @generated from enum value: SCREEN_SHARE = 3;\n   */ TrackSource[TrackSource[\"SCREEN_SHARE\"] = 3] = \"SCREEN_SHARE\";\n    /**\n   * @generated from enum value: SCREEN_SHARE_AUDIO = 4;\n   */ TrackSource[TrackSource[\"SCREEN_SHARE_AUDIO\"] = 4] = \"SCREEN_SHARE_AUDIO\";\n})(TrackSource || (TrackSource = {}));\n// Retrieve enum metadata with: proto3.getEnumType(TrackSource)\nproto3.util.setEnumType(TrackSource, \"livekit.TrackSource\", [\n    {\n        no: 0,\n        name: \"UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"CAMERA\"\n    },\n    {\n        no: 2,\n        name: \"MICROPHONE\"\n    },\n    {\n        no: 3,\n        name: \"SCREEN_SHARE\"\n    },\n    {\n        no: 4,\n        name: \"SCREEN_SHARE_AUDIO\"\n    }\n]);\n/**\n * @generated from enum livekit.VideoQuality\n */ var VideoQuality;\n(function(VideoQuality) {\n    /**\n   * @generated from enum value: LOW = 0;\n   */ VideoQuality[VideoQuality[\"LOW\"] = 0] = \"LOW\";\n    /**\n   * @generated from enum value: MEDIUM = 1;\n   */ VideoQuality[VideoQuality[\"MEDIUM\"] = 1] = \"MEDIUM\";\n    /**\n   * @generated from enum value: HIGH = 2;\n   */ VideoQuality[VideoQuality[\"HIGH\"] = 2] = \"HIGH\";\n    /**\n   * @generated from enum value: OFF = 3;\n   */ VideoQuality[VideoQuality[\"OFF\"] = 3] = \"OFF\";\n})(VideoQuality || (VideoQuality = {}));\n// Retrieve enum metadata with: proto3.getEnumType(VideoQuality)\nproto3.util.setEnumType(VideoQuality, \"livekit.VideoQuality\", [\n    {\n        no: 0,\n        name: \"LOW\"\n    },\n    {\n        no: 1,\n        name: \"MEDIUM\"\n    },\n    {\n        no: 2,\n        name: \"HIGH\"\n    },\n    {\n        no: 3,\n        name: \"OFF\"\n    }\n]);\n/**\n * @generated from enum livekit.ConnectionQuality\n */ var ConnectionQuality$1;\n(function(ConnectionQuality) {\n    /**\n   * @generated from enum value: POOR = 0;\n   */ ConnectionQuality[ConnectionQuality[\"POOR\"] = 0] = \"POOR\";\n    /**\n   * @generated from enum value: GOOD = 1;\n   */ ConnectionQuality[ConnectionQuality[\"GOOD\"] = 1] = \"GOOD\";\n    /**\n   * @generated from enum value: EXCELLENT = 2;\n   */ ConnectionQuality[ConnectionQuality[\"EXCELLENT\"] = 2] = \"EXCELLENT\";\n    /**\n   * @generated from enum value: LOST = 3;\n   */ ConnectionQuality[ConnectionQuality[\"LOST\"] = 3] = \"LOST\";\n})(ConnectionQuality$1 || (ConnectionQuality$1 = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ConnectionQuality)\nproto3.util.setEnumType(ConnectionQuality$1, \"livekit.ConnectionQuality\", [\n    {\n        no: 0,\n        name: \"POOR\"\n    },\n    {\n        no: 1,\n        name: \"GOOD\"\n    },\n    {\n        no: 2,\n        name: \"EXCELLENT\"\n    },\n    {\n        no: 3,\n        name: \"LOST\"\n    }\n]);\n/**\n * @generated from enum livekit.ClientConfigSetting\n */ var ClientConfigSetting;\n(function(ClientConfigSetting) {\n    /**\n   * @generated from enum value: UNSET = 0;\n   */ ClientConfigSetting[ClientConfigSetting[\"UNSET\"] = 0] = \"UNSET\";\n    /**\n   * @generated from enum value: DISABLED = 1;\n   */ ClientConfigSetting[ClientConfigSetting[\"DISABLED\"] = 1] = \"DISABLED\";\n    /**\n   * @generated from enum value: ENABLED = 2;\n   */ ClientConfigSetting[ClientConfigSetting[\"ENABLED\"] = 2] = \"ENABLED\";\n})(ClientConfigSetting || (ClientConfigSetting = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ClientConfigSetting)\nproto3.util.setEnumType(ClientConfigSetting, \"livekit.ClientConfigSetting\", [\n    {\n        no: 0,\n        name: \"UNSET\"\n    },\n    {\n        no: 1,\n        name: \"DISABLED\"\n    },\n    {\n        no: 2,\n        name: \"ENABLED\"\n    }\n]);\n/**\n * @generated from enum livekit.DisconnectReason\n */ var DisconnectReason;\n(function(DisconnectReason) {\n    /**\n   * @generated from enum value: UNKNOWN_REASON = 0;\n   */ DisconnectReason[DisconnectReason[\"UNKNOWN_REASON\"] = 0] = \"UNKNOWN_REASON\";\n    /**\n   * @generated from enum value: CLIENT_INITIATED = 1;\n   */ DisconnectReason[DisconnectReason[\"CLIENT_INITIATED\"] = 1] = \"CLIENT_INITIATED\";\n    /**\n   * @generated from enum value: DUPLICATE_IDENTITY = 2;\n   */ DisconnectReason[DisconnectReason[\"DUPLICATE_IDENTITY\"] = 2] = \"DUPLICATE_IDENTITY\";\n    /**\n   * @generated from enum value: SERVER_SHUTDOWN = 3;\n   */ DisconnectReason[DisconnectReason[\"SERVER_SHUTDOWN\"] = 3] = \"SERVER_SHUTDOWN\";\n    /**\n   * @generated from enum value: PARTICIPANT_REMOVED = 4;\n   */ DisconnectReason[DisconnectReason[\"PARTICIPANT_REMOVED\"] = 4] = \"PARTICIPANT_REMOVED\";\n    /**\n   * @generated from enum value: ROOM_DELETED = 5;\n   */ DisconnectReason[DisconnectReason[\"ROOM_DELETED\"] = 5] = \"ROOM_DELETED\";\n    /**\n   * @generated from enum value: STATE_MISMATCH = 6;\n   */ DisconnectReason[DisconnectReason[\"STATE_MISMATCH\"] = 6] = \"STATE_MISMATCH\";\n    /**\n   * @generated from enum value: JOIN_FAILURE = 7;\n   */ DisconnectReason[DisconnectReason[\"JOIN_FAILURE\"] = 7] = \"JOIN_FAILURE\";\n})(DisconnectReason || (DisconnectReason = {}));\n// Retrieve enum metadata with: proto3.getEnumType(DisconnectReason)\nproto3.util.setEnumType(DisconnectReason, \"livekit.DisconnectReason\", [\n    {\n        no: 0,\n        name: \"UNKNOWN_REASON\"\n    },\n    {\n        no: 1,\n        name: \"CLIENT_INITIATED\"\n    },\n    {\n        no: 2,\n        name: \"DUPLICATE_IDENTITY\"\n    },\n    {\n        no: 3,\n        name: \"SERVER_SHUTDOWN\"\n    },\n    {\n        no: 4,\n        name: \"PARTICIPANT_REMOVED\"\n    },\n    {\n        no: 5,\n        name: \"ROOM_DELETED\"\n    },\n    {\n        no: 6,\n        name: \"STATE_MISMATCH\"\n    },\n    {\n        no: 7,\n        name: \"JOIN_FAILURE\"\n    }\n]);\n/**\n * @generated from enum livekit.ReconnectReason\n */ var ReconnectReason;\n(function(ReconnectReason) {\n    /**\n   * @generated from enum value: RR_UNKNOWN = 0;\n   */ ReconnectReason[ReconnectReason[\"RR_UNKNOWN\"] = 0] = \"RR_UNKNOWN\";\n    /**\n   * @generated from enum value: RR_SIGNAL_DISCONNECTED = 1;\n   */ ReconnectReason[ReconnectReason[\"RR_SIGNAL_DISCONNECTED\"] = 1] = \"RR_SIGNAL_DISCONNECTED\";\n    /**\n   * @generated from enum value: RR_PUBLISHER_FAILED = 2;\n   */ ReconnectReason[ReconnectReason[\"RR_PUBLISHER_FAILED\"] = 2] = \"RR_PUBLISHER_FAILED\";\n    /**\n   * @generated from enum value: RR_SUBSCRIBER_FAILED = 3;\n   */ ReconnectReason[ReconnectReason[\"RR_SUBSCRIBER_FAILED\"] = 3] = \"RR_SUBSCRIBER_FAILED\";\n    /**\n   * @generated from enum value: RR_SWITCH_CANDIDATE = 4;\n   */ ReconnectReason[ReconnectReason[\"RR_SWITCH_CANDIDATE\"] = 4] = \"RR_SWITCH_CANDIDATE\";\n})(ReconnectReason || (ReconnectReason = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ReconnectReason)\nproto3.util.setEnumType(ReconnectReason, \"livekit.ReconnectReason\", [\n    {\n        no: 0,\n        name: \"RR_UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"RR_SIGNAL_DISCONNECTED\"\n    },\n    {\n        no: 2,\n        name: \"RR_PUBLISHER_FAILED\"\n    },\n    {\n        no: 3,\n        name: \"RR_SUBSCRIBER_FAILED\"\n    },\n    {\n        no: 4,\n        name: \"RR_SWITCH_CANDIDATE\"\n    }\n]);\n/**\n * @generated from enum livekit.SubscriptionError\n */ var SubscriptionError;\n(function(SubscriptionError) {\n    /**\n   * @generated from enum value: SE_UNKNOWN = 0;\n   */ SubscriptionError[SubscriptionError[\"SE_UNKNOWN\"] = 0] = \"SE_UNKNOWN\";\n    /**\n   * @generated from enum value: SE_CODEC_UNSUPPORTED = 1;\n   */ SubscriptionError[SubscriptionError[\"SE_CODEC_UNSUPPORTED\"] = 1] = \"SE_CODEC_UNSUPPORTED\";\n    /**\n   * @generated from enum value: SE_TRACK_NOTFOUND = 2;\n   */ SubscriptionError[SubscriptionError[\"SE_TRACK_NOTFOUND\"] = 2] = \"SE_TRACK_NOTFOUND\";\n})(SubscriptionError || (SubscriptionError = {}));\n// Retrieve enum metadata with: proto3.getEnumType(SubscriptionError)\nproto3.util.setEnumType(SubscriptionError, \"livekit.SubscriptionError\", [\n    {\n        no: 0,\n        name: \"SE_UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"SE_CODEC_UNSUPPORTED\"\n    },\n    {\n        no: 2,\n        name: \"SE_TRACK_NOTFOUND\"\n    }\n]);\n/**\n * @generated from message livekit.Room\n */ let Room$1 = class Room extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: string name = 2;\n     */ this.name = \"\";\n        /**\n     * @generated from field: uint32 empty_timeout = 3;\n     */ this.emptyTimeout = 0;\n        /**\n     * @generated from field: uint32 max_participants = 4;\n     */ this.maxParticipants = 0;\n        /**\n     * @generated from field: int64 creation_time = 5;\n     */ this.creationTime = protoInt64.zero;\n        /**\n     * @generated from field: string turn_password = 6;\n     */ this.turnPassword = \"\";\n        /**\n     * @generated from field: repeated livekit.Codec enabled_codecs = 7;\n     */ this.enabledCodecs = [];\n        /**\n     * @generated from field: string metadata = 8;\n     */ this.metadata = \"\";\n        /**\n     * @generated from field: uint32 num_participants = 9;\n     */ this.numParticipants = 0;\n        /**\n     * @generated from field: uint32 num_publishers = 11;\n     */ this.numPublishers = 0;\n        /**\n     * @generated from field: bool active_recording = 10;\n     */ this.activeRecording = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Room().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Room().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Room().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Room, a, b);\n    }\n};\nRoom$1.runtime = proto3;\nRoom$1.typeName = \"livekit.Room\";\nRoom$1.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"empty_timeout\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 4,\n            name: \"max_participants\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: \"creation_time\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 6,\n            name: \"turn_password\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 7,\n            name: \"enabled_codecs\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 8,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 9,\n            name: \"num_participants\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 11,\n            name: \"num_publishers\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 10,\n            name: \"active_recording\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.Codec\n */ class Codec extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string mime = 1;\n     */ this.mime = \"\";\n        /**\n     * @generated from field: string fmtp_line = 2;\n     */ this.fmtpLine = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Codec().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Codec().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Codec().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Codec, a, b);\n    }\n}\nCodec.runtime = proto3;\nCodec.typeName = \"livekit.Codec\";\nCodec.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"mime\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"fmtp_line\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.PlayoutDelay\n */ class PlayoutDelay extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: bool enabled = 1;\n     */ this.enabled = false;\n        /**\n     * @generated from field: uint32 min = 2;\n     */ this.min = 0;\n        /**\n     * @generated from field: uint32 max = 3;\n     */ this.max = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new PlayoutDelay().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new PlayoutDelay().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new PlayoutDelay().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(PlayoutDelay, a, b);\n    }\n}\nPlayoutDelay.runtime = proto3;\nPlayoutDelay.typeName = \"livekit.PlayoutDelay\";\nPlayoutDelay.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"enabled\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: \"min\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 3,\n            name: \"max\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantPermission\n */ class ParticipantPermission extends Message {\n    constructor(data){\n        super();\n        /**\n     * allow participant to subscribe to other tracks in the room\n     *\n     * @generated from field: bool can_subscribe = 1;\n     */ this.canSubscribe = false;\n        /**\n     * allow participant to publish new tracks to room\n     *\n     * @generated from field: bool can_publish = 2;\n     */ this.canPublish = false;\n        /**\n     * allow participant to publish data\n     *\n     * @generated from field: bool can_publish_data = 3;\n     */ this.canPublishData = false;\n        /**\n     * sources that are allowed to be published\n     *\n     * @generated from field: repeated livekit.TrackSource can_publish_sources = 9;\n     */ this.canPublishSources = [];\n        /**\n     * indicates that it's hidden to others\n     *\n     * @generated from field: bool hidden = 7;\n     */ this.hidden = false;\n        /**\n     * indicates it's a recorder instance\n     *\n     * @generated from field: bool recorder = 8;\n     */ this.recorder = false;\n        /**\n     * indicates that participant can update own metadata\n     *\n     * @generated from field: bool can_update_metadata = 10;\n     */ this.canUpdateMetadata = false;\n        /**\n     * indicates that participant is an agent\n     *\n     * @generated from field: bool agent = 11;\n     */ this.agent = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantPermission().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantPermission().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantPermission().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantPermission, a, b);\n    }\n}\nParticipantPermission.runtime = proto3;\nParticipantPermission.typeName = \"livekit.ParticipantPermission\";\nParticipantPermission.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"can_subscribe\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: \"can_publish\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 3,\n            name: \"can_publish_data\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 9,\n            name: \"can_publish_sources\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource),\n            repeated: true\n        },\n        {\n            no: 7,\n            name: \"hidden\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 8,\n            name: \"recorder\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 10,\n            name: \"can_update_metadata\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 11,\n            name: \"agent\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantInfo\n */ class ParticipantInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: string identity = 2;\n     */ this.identity = \"\";\n        /**\n     * @generated from field: livekit.ParticipantInfo.State state = 3;\n     */ this.state = ParticipantInfo_State.JOINING;\n        /**\n     * @generated from field: repeated livekit.TrackInfo tracks = 4;\n     */ this.tracks = [];\n        /**\n     * @generated from field: string metadata = 5;\n     */ this.metadata = \"\";\n        /**\n     * timestamp when participant joined room, in seconds\n     *\n     * @generated from field: int64 joined_at = 6;\n     */ this.joinedAt = protoInt64.zero;\n        /**\n     * @generated from field: string name = 9;\n     */ this.name = \"\";\n        /**\n     * @generated from field: uint32 version = 10;\n     */ this.version = 0;\n        /**\n     * @generated from field: string region = 12;\n     */ this.region = \"\";\n        /**\n     * indicates the participant has an active publisher connection\n     * and can publish to the server\n     *\n     * @generated from field: bool is_publisher = 13;\n     */ this.isPublisher = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantInfo, a, b);\n    }\n}\nParticipantInfo.runtime = proto3;\nParticipantInfo.typeName = \"livekit.ParticipantInfo\";\nParticipantInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"identity\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"state\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ParticipantInfo_State)\n        },\n        {\n            no: 4,\n            name: \"tracks\",\n            kind: \"message\",\n            T: TrackInfo,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 6,\n            name: \"joined_at\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 9,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 10,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 11,\n            name: \"permission\",\n            kind: \"message\",\n            T: ParticipantPermission\n        },\n        {\n            no: 12,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 13,\n            name: \"is_publisher\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from enum livekit.ParticipantInfo.State\n */ var ParticipantInfo_State;\n(function(ParticipantInfo_State) {\n    /**\n   * websocket' connected, but not offered yet\n   *\n   * @generated from enum value: JOINING = 0;\n   */ ParticipantInfo_State[ParticipantInfo_State[\"JOINING\"] = 0] = \"JOINING\";\n    /**\n   * server received client offer\n   *\n   * @generated from enum value: JOINED = 1;\n   */ ParticipantInfo_State[ParticipantInfo_State[\"JOINED\"] = 1] = \"JOINED\";\n    /**\n   * ICE connectivity established\n   *\n   * @generated from enum value: ACTIVE = 2;\n   */ ParticipantInfo_State[ParticipantInfo_State[\"ACTIVE\"] = 2] = \"ACTIVE\";\n    /**\n   * WS disconnected\n   *\n   * @generated from enum value: DISCONNECTED = 3;\n   */ ParticipantInfo_State[ParticipantInfo_State[\"DISCONNECTED\"] = 3] = \"DISCONNECTED\";\n})(ParticipantInfo_State || (ParticipantInfo_State = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ParticipantInfo_State)\nproto3.util.setEnumType(ParticipantInfo_State, \"livekit.ParticipantInfo.State\", [\n    {\n        no: 0,\n        name: \"JOINING\"\n    },\n    {\n        no: 1,\n        name: \"JOINED\"\n    },\n    {\n        no: 2,\n        name: \"ACTIVE\"\n    },\n    {\n        no: 3,\n        name: \"DISCONNECTED\"\n    }\n]);\n/**\n * @generated from message livekit.Encryption\n */ class Encryption extends Message {\n    constructor(data){\n        super();\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Encryption().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Encryption().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Encryption().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Encryption, a, b);\n    }\n}\nEncryption.runtime = proto3;\nEncryption.typeName = \"livekit.Encryption\";\nEncryption.fields = proto3.util.newFieldList(()=>[]);\n/**\n * @generated from enum livekit.Encryption.Type\n */ var Encryption_Type;\n(function(Encryption_Type) {\n    /**\n   * @generated from enum value: NONE = 0;\n   */ Encryption_Type[Encryption_Type[\"NONE\"] = 0] = \"NONE\";\n    /**\n   * @generated from enum value: GCM = 1;\n   */ Encryption_Type[Encryption_Type[\"GCM\"] = 1] = \"GCM\";\n    /**\n   * @generated from enum value: CUSTOM = 2;\n   */ Encryption_Type[Encryption_Type[\"CUSTOM\"] = 2] = \"CUSTOM\";\n})(Encryption_Type || (Encryption_Type = {}));\n// Retrieve enum metadata with: proto3.getEnumType(Encryption_Type)\nproto3.util.setEnumType(Encryption_Type, \"livekit.Encryption.Type\", [\n    {\n        no: 0,\n        name: \"NONE\"\n    },\n    {\n        no: 1,\n        name: \"GCM\"\n    },\n    {\n        no: 2,\n        name: \"CUSTOM\"\n    }\n]);\n/**\n * @generated from message livekit.SimulcastCodecInfo\n */ class SimulcastCodecInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string mime_type = 1;\n     */ this.mimeType = \"\";\n        /**\n     * @generated from field: string mid = 2;\n     */ this.mid = \"\";\n        /**\n     * @generated from field: string cid = 3;\n     */ this.cid = \"\";\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 4;\n     */ this.layers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SimulcastCodecInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SimulcastCodecInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SimulcastCodecInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SimulcastCodecInfo, a, b);\n    }\n}\nSimulcastCodecInfo.runtime = proto3;\nSimulcastCodecInfo.typeName = \"livekit.SimulcastCodecInfo\";\nSimulcastCodecInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"mime_type\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"mid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 4,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.TrackInfo\n */ class TrackInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: livekit.TrackType type = 2;\n     */ this.type = TrackType.AUDIO;\n        /**\n     * @generated from field: string name = 3;\n     */ this.name = \"\";\n        /**\n     * @generated from field: bool muted = 4;\n     */ this.muted = false;\n        /**\n     * original width of video (unset for audio)\n     * clients may receive a lower resolution version with simulcast\n     *\n     * @generated from field: uint32 width = 5;\n     */ this.width = 0;\n        /**\n     * original height of video (unset for audio)\n     *\n     * @generated from field: uint32 height = 6;\n     */ this.height = 0;\n        /**\n     * true if track is simulcasted\n     *\n     * @generated from field: bool simulcast = 7;\n     */ this.simulcast = false;\n        /**\n     * true if DTX (Discontinuous Transmission) is disabled for audio\n     *\n     * @generated from field: bool disable_dtx = 8;\n     */ this.disableDtx = false;\n        /**\n     * source of media\n     *\n     * @generated from field: livekit.TrackSource source = 9;\n     */ this.source = TrackSource.UNKNOWN;\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 10;\n     */ this.layers = [];\n        /**\n     * mime type of codec\n     *\n     * @generated from field: string mime_type = 11;\n     */ this.mimeType = \"\";\n        /**\n     * @generated from field: string mid = 12;\n     */ this.mid = \"\";\n        /**\n     * @generated from field: repeated livekit.SimulcastCodecInfo codecs = 13;\n     */ this.codecs = [];\n        /**\n     * @generated from field: bool stereo = 14;\n     */ this.stereo = false;\n        /**\n     * true if RED (Redundant Encoding) is disabled for audio\n     *\n     * @generated from field: bool disable_red = 15;\n     */ this.disableRed = false;\n        /**\n     * @generated from field: livekit.Encryption.Type encryption = 16;\n     */ this.encryption = Encryption_Type.NONE;\n        /**\n     * @generated from field: string stream = 17;\n     */ this.stream = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackInfo, a, b);\n    }\n}\nTrackInfo.runtime = proto3;\nTrackInfo.typeName = \"livekit.TrackInfo\";\nTrackInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackType)\n        },\n        {\n            no: 3,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 4,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 5,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 6,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 7,\n            name: \"simulcast\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 8,\n            name: \"disable_dtx\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 9,\n            name: \"source\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource)\n        },\n        {\n            no: 10,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 11,\n            name: \"mime_type\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 12,\n            name: \"mid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 13,\n            name: \"codecs\",\n            kind: \"message\",\n            T: SimulcastCodecInfo,\n            repeated: true\n        },\n        {\n            no: 14,\n            name: \"stereo\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 15,\n            name: \"disable_red\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 16,\n            name: \"encryption\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 17,\n            name: \"stream\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * provide information about available spatial layers\n *\n * @generated from message livekit.VideoLayer\n */ class VideoLayer extends Message {\n    constructor(data){\n        super();\n        /**\n     * for tracks with a single layer, this should be HIGH\n     *\n     * @generated from field: livekit.VideoQuality quality = 1;\n     */ this.quality = VideoQuality.LOW;\n        /**\n     * @generated from field: uint32 width = 2;\n     */ this.width = 0;\n        /**\n     * @generated from field: uint32 height = 3;\n     */ this.height = 0;\n        /**\n     * target bitrate in bit per second (bps), server will measure actual\n     *\n     * @generated from field: uint32 bitrate = 4;\n     */ this.bitrate = 0;\n        /**\n     * @generated from field: uint32 ssrc = 5;\n     */ this.ssrc = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new VideoLayer().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new VideoLayer().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new VideoLayer().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(VideoLayer, a, b);\n    }\n}\nVideoLayer.runtime = proto3;\nVideoLayer.typeName = \"livekit.VideoLayer\";\nVideoLayer.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality)\n        },\n        {\n            no: 2,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 3,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 4,\n            name: \"bitrate\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: \"ssrc\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        }\n    ]);\n/**\n * new DataPacket API\n *\n * @generated from message livekit.DataPacket\n */ class DataPacket extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.DataPacket.Kind kind = 1;\n     */ this.kind = DataPacket_Kind.RELIABLE;\n        /**\n     * @generated from oneof livekit.DataPacket.value\n     */ this.value = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DataPacket().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DataPacket().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DataPacket().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(DataPacket, a, b);\n    }\n}\nDataPacket.runtime = proto3;\nDataPacket.typeName = \"livekit.DataPacket\";\nDataPacket.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"kind\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DataPacket_Kind)\n        },\n        {\n            no: 2,\n            name: \"user\",\n            kind: \"message\",\n            T: UserPacket,\n            oneof: \"value\"\n        },\n        {\n            no: 3,\n            name: \"speaker\",\n            kind: \"message\",\n            T: ActiveSpeakerUpdate,\n            oneof: \"value\"\n        }\n    ]);\n/**\n * @generated from enum livekit.DataPacket.Kind\n */ var DataPacket_Kind;\n(function(DataPacket_Kind) {\n    /**\n   * @generated from enum value: RELIABLE = 0;\n   */ DataPacket_Kind[DataPacket_Kind[\"RELIABLE\"] = 0] = \"RELIABLE\";\n    /**\n   * @generated from enum value: LOSSY = 1;\n   */ DataPacket_Kind[DataPacket_Kind[\"LOSSY\"] = 1] = \"LOSSY\";\n})(DataPacket_Kind || (DataPacket_Kind = {}));\n// Retrieve enum metadata with: proto3.getEnumType(DataPacket_Kind)\nproto3.util.setEnumType(DataPacket_Kind, \"livekit.DataPacket.Kind\", [\n    {\n        no: 0,\n        name: \"RELIABLE\"\n    },\n    {\n        no: 1,\n        name: \"LOSSY\"\n    }\n]);\n/**\n * @generated from message livekit.ActiveSpeakerUpdate\n */ class ActiveSpeakerUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.SpeakerInfo speakers = 1;\n     */ this.speakers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ActiveSpeakerUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ActiveSpeakerUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ActiveSpeakerUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ActiveSpeakerUpdate, a, b);\n    }\n}\nActiveSpeakerUpdate.runtime = proto3;\nActiveSpeakerUpdate.typeName = \"livekit.ActiveSpeakerUpdate\";\nActiveSpeakerUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"speakers\",\n            kind: \"message\",\n            T: SpeakerInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SpeakerInfo\n */ class SpeakerInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * audio level, 0-1.0, 1 is loudest\n     *\n     * @generated from field: float level = 2;\n     */ this.level = 0;\n        /**\n     * true if speaker is currently active\n     *\n     * @generated from field: bool active = 3;\n     */ this.active = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SpeakerInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SpeakerInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SpeakerInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SpeakerInfo, a, b);\n    }\n}\nSpeakerInfo.runtime = proto3;\nSpeakerInfo.typeName = \"livekit.SpeakerInfo\";\nSpeakerInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"level\",\n            kind: \"scalar\",\n            T: 2 /* ScalarType.FLOAT */ \n        },\n        {\n            no: 3,\n            name: \"active\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.UserPacket\n */ class UserPacket extends Message {\n    constructor(data){\n        super();\n        /**\n     * participant ID of user that sent the message\n     *\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: string participant_identity = 5;\n     */ this.participantIdentity = \"\";\n        /**\n     * user defined payload\n     *\n     * @generated from field: bytes payload = 2;\n     */ this.payload = new Uint8Array(0);\n        /**\n     * the ID of the participants who will receive the message (sent to all by default)\n     *\n     * @generated from field: repeated string destination_sids = 3;\n     */ this.destinationSids = [];\n        /**\n     * identities of participants who will receive the message (sent to all by default)\n     *\n     * @generated from field: repeated string destination_identities = 6;\n     */ this.destinationIdentities = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UserPacket().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UserPacket().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UserPacket().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UserPacket, a, b);\n    }\n}\nUserPacket.runtime = proto3;\nUserPacket.typeName = \"livekit.UserPacket\";\nUserPacket.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"payload\",\n            kind: \"scalar\",\n            T: 12 /* ScalarType.BYTES */ \n        },\n        {\n            no: 3,\n            name: \"destination_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 6,\n            name: \"destination_identities\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"topic\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            opt: true\n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantTracks\n */ class ParticipantTracks extends Message {\n    constructor(data){\n        super();\n        /**\n     * participant ID of participant to whom the tracks belong\n     *\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: repeated string track_sids = 2;\n     */ this.trackSids = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantTracks().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantTracks().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantTracks().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantTracks, a, b);\n    }\n}\nParticipantTracks.runtime = proto3;\nParticipantTracks.typeName = \"livekit.ParticipantTracks\";\nParticipantTracks.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        }\n    ]);\n/**\n * details about the server\n *\n * @generated from message livekit.ServerInfo\n */ class ServerInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ServerInfo.Edition edition = 1;\n     */ this.edition = ServerInfo_Edition.Standard;\n        /**\n     * @generated from field: string version = 2;\n     */ this.version = \"\";\n        /**\n     * @generated from field: int32 protocol = 3;\n     */ this.protocol = 0;\n        /**\n     * @generated from field: string region = 4;\n     */ this.region = \"\";\n        /**\n     * @generated from field: string node_id = 5;\n     */ this.nodeId = \"\";\n        /**\n     * additional debugging information. sent only if server is in development mode\n     *\n     * @generated from field: string debug_info = 6;\n     */ this.debugInfo = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ServerInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ServerInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ServerInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ServerInfo, a, b);\n    }\n}\nServerInfo.runtime = proto3;\nServerInfo.typeName = \"livekit.ServerInfo\";\nServerInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"edition\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ServerInfo_Edition)\n        },\n        {\n            no: 2,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"protocol\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 4,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"node_id\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 6,\n            name: \"debug_info\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from enum livekit.ServerInfo.Edition\n */ var ServerInfo_Edition;\n(function(ServerInfo_Edition) {\n    /**\n   * @generated from enum value: Standard = 0;\n   */ ServerInfo_Edition[ServerInfo_Edition[\"Standard\"] = 0] = \"Standard\";\n    /**\n   * @generated from enum value: Cloud = 1;\n   */ ServerInfo_Edition[ServerInfo_Edition[\"Cloud\"] = 1] = \"Cloud\";\n})(ServerInfo_Edition || (ServerInfo_Edition = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ServerInfo_Edition)\nproto3.util.setEnumType(ServerInfo_Edition, \"livekit.ServerInfo.Edition\", [\n    {\n        no: 0,\n        name: \"Standard\"\n    },\n    {\n        no: 1,\n        name: \"Cloud\"\n    }\n]);\n/**\n * details about the client\n *\n * @generated from message livekit.ClientInfo\n */ class ClientInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ClientInfo.SDK sdk = 1;\n     */ this.sdk = ClientInfo_SDK.UNKNOWN;\n        /**\n     * @generated from field: string version = 2;\n     */ this.version = \"\";\n        /**\n     * @generated from field: int32 protocol = 3;\n     */ this.protocol = 0;\n        /**\n     * @generated from field: string os = 4;\n     */ this.os = \"\";\n        /**\n     * @generated from field: string os_version = 5;\n     */ this.osVersion = \"\";\n        /**\n     * @generated from field: string device_model = 6;\n     */ this.deviceModel = \"\";\n        /**\n     * @generated from field: string browser = 7;\n     */ this.browser = \"\";\n        /**\n     * @generated from field: string browser_version = 8;\n     */ this.browserVersion = \"\";\n        /**\n     * @generated from field: string address = 9;\n     */ this.address = \"\";\n        /**\n     * wifi, wired, cellular, vpn, empty if not known\n     *\n     * @generated from field: string network = 10;\n     */ this.network = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ClientInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ClientInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ClientInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ClientInfo, a, b);\n    }\n}\nClientInfo.runtime = proto3;\nClientInfo.typeName = \"livekit.ClientInfo\";\nClientInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sdk\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientInfo_SDK)\n        },\n        {\n            no: 2,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"protocol\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 4,\n            name: \"os\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"os_version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 6,\n            name: \"device_model\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 7,\n            name: \"browser\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 8,\n            name: \"browser_version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 9,\n            name: \"address\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 10,\n            name: \"network\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from enum livekit.ClientInfo.SDK\n */ var ClientInfo_SDK;\n(function(ClientInfo_SDK) {\n    /**\n   * @generated from enum value: UNKNOWN = 0;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    /**\n   * @generated from enum value: JS = 1;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"JS\"] = 1] = \"JS\";\n    /**\n   * @generated from enum value: SWIFT = 2;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"SWIFT\"] = 2] = \"SWIFT\";\n    /**\n   * @generated from enum value: ANDROID = 3;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"ANDROID\"] = 3] = \"ANDROID\";\n    /**\n   * @generated from enum value: FLUTTER = 4;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"FLUTTER\"] = 4] = \"FLUTTER\";\n    /**\n   * @generated from enum value: GO = 5;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"GO\"] = 5] = \"GO\";\n    /**\n   * @generated from enum value: UNITY = 6;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"UNITY\"] = 6] = \"UNITY\";\n    /**\n   * @generated from enum value: REACT_NATIVE = 7;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"REACT_NATIVE\"] = 7] = \"REACT_NATIVE\";\n    /**\n   * @generated from enum value: RUST = 8;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"RUST\"] = 8] = \"RUST\";\n    /**\n   * @generated from enum value: PYTHON = 9;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"PYTHON\"] = 9] = \"PYTHON\";\n    /**\n   * @generated from enum value: CPP = 10;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"CPP\"] = 10] = \"CPP\";\n})(ClientInfo_SDK || (ClientInfo_SDK = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ClientInfo_SDK)\nproto3.util.setEnumType(ClientInfo_SDK, \"livekit.ClientInfo.SDK\", [\n    {\n        no: 0,\n        name: \"UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"JS\"\n    },\n    {\n        no: 2,\n        name: \"SWIFT\"\n    },\n    {\n        no: 3,\n        name: \"ANDROID\"\n    },\n    {\n        no: 4,\n        name: \"FLUTTER\"\n    },\n    {\n        no: 5,\n        name: \"GO\"\n    },\n    {\n        no: 6,\n        name: \"UNITY\"\n    },\n    {\n        no: 7,\n        name: \"REACT_NATIVE\"\n    },\n    {\n        no: 8,\n        name: \"RUST\"\n    },\n    {\n        no: 9,\n        name: \"PYTHON\"\n    },\n    {\n        no: 10,\n        name: \"CPP\"\n    }\n]);\n/**\n * server provided client configuration\n *\n * @generated from message livekit.ClientConfiguration\n */ class ClientConfiguration extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ClientConfigSetting resume_connection = 3;\n     */ this.resumeConnection = ClientConfigSetting.UNSET;\n        /**\n     * @generated from field: livekit.ClientConfigSetting force_relay = 5;\n     */ this.forceRelay = ClientConfigSetting.UNSET;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ClientConfiguration().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ClientConfiguration().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ClientConfiguration().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ClientConfiguration, a, b);\n    }\n}\nClientConfiguration.runtime = proto3;\nClientConfiguration.typeName = \"livekit.ClientConfiguration\";\nClientConfiguration.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"video\",\n            kind: \"message\",\n            T: VideoConfiguration\n        },\n        {\n            no: 2,\n            name: \"screen\",\n            kind: \"message\",\n            T: VideoConfiguration\n        },\n        {\n            no: 3,\n            name: \"resume_connection\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        },\n        {\n            no: 4,\n            name: \"disabled_codecs\",\n            kind: \"message\",\n            T: DisabledCodecs\n        },\n        {\n            no: 5,\n            name: \"force_relay\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        }\n    ]);\n/**\n * @generated from message livekit.VideoConfiguration\n */ class VideoConfiguration extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ClientConfigSetting hardware_encoder = 1;\n     */ this.hardwareEncoder = ClientConfigSetting.UNSET;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new VideoConfiguration().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new VideoConfiguration().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new VideoConfiguration().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(VideoConfiguration, a, b);\n    }\n}\nVideoConfiguration.runtime = proto3;\nVideoConfiguration.typeName = \"livekit.VideoConfiguration\";\nVideoConfiguration.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"hardware_encoder\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        }\n    ]);\n/**\n * @generated from message livekit.DisabledCodecs\n */ class DisabledCodecs extends Message {\n    constructor(data){\n        super();\n        /**\n     * disabled for both publish and subscribe\n     *\n     * @generated from field: repeated livekit.Codec codecs = 1;\n     */ this.codecs = [];\n        /**\n     * only disable for publish\n     *\n     * @generated from field: repeated livekit.Codec publish = 2;\n     */ this.publish = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DisabledCodecs().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DisabledCodecs().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DisabledCodecs().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(DisabledCodecs, a, b);\n    }\n}\nDisabledCodecs.runtime = proto3;\nDisabledCodecs.typeName = \"livekit.DisabledCodecs\";\nDisabledCodecs.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"codecs\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"publish\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.RTPDrift\n */ class RTPDrift extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: double duration = 3;\n     */ this.duration = 0;\n        /**\n     * @generated from field: uint64 start_timestamp = 4;\n     */ this.startTimestamp = protoInt64.zero;\n        /**\n     * @generated from field: uint64 end_timestamp = 5;\n     */ this.endTimestamp = protoInt64.zero;\n        /**\n     * @generated from field: uint64 rtp_clock_ticks = 6;\n     */ this.rtpClockTicks = protoInt64.zero;\n        /**\n     * @generated from field: int64 drift_samples = 7;\n     */ this.driftSamples = protoInt64.zero;\n        /**\n     * @generated from field: double drift_ms = 8;\n     */ this.driftMs = 0;\n        /**\n     * @generated from field: double clock_rate = 9;\n     */ this.clockRate = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RTPDrift().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RTPDrift().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RTPDrift().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RTPDrift, a, b);\n    }\n}\nRTPDrift.runtime = proto3;\nRTPDrift.typeName = \"livekit.RTPDrift\";\nRTPDrift.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"start_time\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 2,\n            name: \"end_time\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 3,\n            name: \"duration\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 4,\n            name: \"start_timestamp\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 5,\n            name: \"end_timestamp\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 6,\n            name: \"rtp_clock_ticks\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 7,\n            name: \"drift_samples\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 8,\n            name: \"drift_ms\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 9,\n            name: \"clock_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        }\n    ]);\n/**\n * @generated from message livekit.RTPStats\n */ class RTPStats extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: double duration = 3;\n     */ this.duration = 0;\n        /**\n     * @generated from field: uint32 packets = 4;\n     */ this.packets = 0;\n        /**\n     * @generated from field: double packet_rate = 5;\n     */ this.packetRate = 0;\n        /**\n     * @generated from field: uint64 bytes = 6;\n     */ this.bytes = protoInt64.zero;\n        /**\n     * @generated from field: uint64 header_bytes = 39;\n     */ this.headerBytes = protoInt64.zero;\n        /**\n     * @generated from field: double bitrate = 7;\n     */ this.bitrate = 0;\n        /**\n     * @generated from field: uint32 packets_lost = 8;\n     */ this.packetsLost = 0;\n        /**\n     * @generated from field: double packet_loss_rate = 9;\n     */ this.packetLossRate = 0;\n        /**\n     * @generated from field: float packet_loss_percentage = 10;\n     */ this.packetLossPercentage = 0;\n        /**\n     * @generated from field: uint32 packets_duplicate = 11;\n     */ this.packetsDuplicate = 0;\n        /**\n     * @generated from field: double packet_duplicate_rate = 12;\n     */ this.packetDuplicateRate = 0;\n        /**\n     * @generated from field: uint64 bytes_duplicate = 13;\n     */ this.bytesDuplicate = protoInt64.zero;\n        /**\n     * @generated from field: uint64 header_bytes_duplicate = 40;\n     */ this.headerBytesDuplicate = protoInt64.zero;\n        /**\n     * @generated from field: double bitrate_duplicate = 14;\n     */ this.bitrateDuplicate = 0;\n        /**\n     * @generated from field: uint32 packets_padding = 15;\n     */ this.packetsPadding = 0;\n        /**\n     * @generated from field: double packet_padding_rate = 16;\n     */ this.packetPaddingRate = 0;\n        /**\n     * @generated from field: uint64 bytes_padding = 17;\n     */ this.bytesPadding = protoInt64.zero;\n        /**\n     * @generated from field: uint64 header_bytes_padding = 41;\n     */ this.headerBytesPadding = protoInt64.zero;\n        /**\n     * @generated from field: double bitrate_padding = 18;\n     */ this.bitratePadding = 0;\n        /**\n     * @generated from field: uint32 packets_out_of_order = 19;\n     */ this.packetsOutOfOrder = 0;\n        /**\n     * @generated from field: uint32 frames = 20;\n     */ this.frames = 0;\n        /**\n     * @generated from field: double frame_rate = 21;\n     */ this.frameRate = 0;\n        /**\n     * @generated from field: double jitter_current = 22;\n     */ this.jitterCurrent = 0;\n        /**\n     * @generated from field: double jitter_max = 23;\n     */ this.jitterMax = 0;\n        /**\n     * @generated from field: map<int32, uint32> gap_histogram = 24;\n     */ this.gapHistogram = {};\n        /**\n     * @generated from field: uint32 nacks = 25;\n     */ this.nacks = 0;\n        /**\n     * @generated from field: uint32 nack_acks = 37;\n     */ this.nackAcks = 0;\n        /**\n     * @generated from field: uint32 nack_misses = 26;\n     */ this.nackMisses = 0;\n        /**\n     * @generated from field: uint32 nack_repeated = 38;\n     */ this.nackRepeated = 0;\n        /**\n     * @generated from field: uint32 plis = 27;\n     */ this.plis = 0;\n        /**\n     * @generated from field: uint32 firs = 29;\n     */ this.firs = 0;\n        /**\n     * @generated from field: uint32 rtt_current = 31;\n     */ this.rttCurrent = 0;\n        /**\n     * @generated from field: uint32 rtt_max = 32;\n     */ this.rttMax = 0;\n        /**\n     * @generated from field: uint32 key_frames = 33;\n     */ this.keyFrames = 0;\n        /**\n     * @generated from field: uint32 layer_lock_plis = 35;\n     */ this.layerLockPlis = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RTPStats().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RTPStats().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RTPStats().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RTPStats, a, b);\n    }\n}\nRTPStats.runtime = proto3;\nRTPStats.typeName = \"livekit.RTPStats\";\nRTPStats.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"start_time\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 2,\n            name: \"end_time\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 3,\n            name: \"duration\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 4,\n            name: \"packets\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: \"packet_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 6,\n            name: \"bytes\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 39,\n            name: \"header_bytes\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 7,\n            name: \"bitrate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 8,\n            name: \"packets_lost\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 9,\n            name: \"packet_loss_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 10,\n            name: \"packet_loss_percentage\",\n            kind: \"scalar\",\n            T: 2 /* ScalarType.FLOAT */ \n        },\n        {\n            no: 11,\n            name: \"packets_duplicate\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 12,\n            name: \"packet_duplicate_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 13,\n            name: \"bytes_duplicate\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 40,\n            name: \"header_bytes_duplicate\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 14,\n            name: \"bitrate_duplicate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 15,\n            name: \"packets_padding\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 16,\n            name: \"packet_padding_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 17,\n            name: \"bytes_padding\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 41,\n            name: \"header_bytes_padding\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 18,\n            name: \"bitrate_padding\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 19,\n            name: \"packets_out_of_order\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 20,\n            name: \"frames\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 21,\n            name: \"frame_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 22,\n            name: \"jitter_current\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 23,\n            name: \"jitter_max\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 24,\n            name: \"gap_histogram\",\n            kind: \"map\",\n            K: 5 /* ScalarType.INT32 */ ,\n            V: {\n                kind: \"scalar\",\n                T: 13 /* ScalarType.UINT32 */ \n            }\n        },\n        {\n            no: 25,\n            name: \"nacks\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 37,\n            name: \"nack_acks\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 26,\n            name: \"nack_misses\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 38,\n            name: \"nack_repeated\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 27,\n            name: \"plis\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 28,\n            name: \"last_pli\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 29,\n            name: \"firs\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 30,\n            name: \"last_fir\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 31,\n            name: \"rtt_current\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 32,\n            name: \"rtt_max\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 33,\n            name: \"key_frames\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 34,\n            name: \"last_key_frame\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 35,\n            name: \"layer_lock_plis\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 36,\n            name: \"last_layer_lock_pli\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 44,\n            name: \"packet_drift\",\n            kind: \"message\",\n            T: RTPDrift\n        },\n        {\n            no: 45,\n            name: \"report_drift\",\n            kind: \"message\",\n            T: RTPDrift\n        }\n    ]);\n/**\n * @generated from message livekit.TimedVersion\n */ class TimedVersion extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: int64 unix_micro = 1;\n     */ this.unixMicro = protoInt64.zero;\n        /**\n     * @generated from field: int32 ticks = 2;\n     */ this.ticks = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TimedVersion().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TimedVersion().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TimedVersion().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TimedVersion, a, b);\n    }\n}\nTimedVersion.runtime = proto3;\nTimedVersion.typeName = \"livekit.TimedVersion\";\nTimedVersion.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"unix_micro\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"ticks\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        }\n    ]);\nconst maxRetryDelay = 7000;\nconst DEFAULT_RETRY_DELAYS_IN_MS = [\n    0,\n    300,\n    2 * 2 * 300,\n    3 * 3 * 300,\n    4 * 4 * 300,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay\n];\nclass DefaultReconnectPolicy {\n    constructor(retryDelays){\n        this._retryDelays = retryDelays !== undefined ? [\n            ...retryDelays\n        ] : DEFAULT_RETRY_DELAYS_IN_MS;\n    }\n    nextRetryDelayInMs(context) {\n        if (context.retryCount >= this._retryDelays.length) return null;\n        const retryDelay = this._retryDelays[context.retryCount];\n        if (context.retryCount <= 1) return retryDelay;\n        return retryDelay + Math.random() * 1000;\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nvar events = {\n    exports: {}\n};\nvar R = typeof Reflect === \"object\" ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === \"function\" ? R.apply : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === \"function\") {\n    ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n    };\n} else {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n        return Object.getOwnPropertyNames(target);\n    };\n}\nfunction ProcessEmitWarning(warning) {\n    if (console && console.warn) console.warn(warning);\n}\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n    return value !== value;\n};\nfunction EventEmitter() {\n    EventEmitter.init.call(this);\n}\nevents.exports = EventEmitter;\nevents.exports.once = once;\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\nfunction checkListener(listener) {\n    if (typeof listener !== \"function\") {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n    }\n}\nObject.defineProperty(EventEmitter, \"defaultMaxListeners\", {\n    enumerable: true,\n    get: function() {\n        return defaultMaxListeners;\n    },\n    set: function(arg) {\n        if (typeof arg !== \"number\" || arg < 0 || NumberIsNaN(arg)) {\n            throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + \".\");\n        }\n        defaultMaxListeners = arg;\n    }\n});\nEventEmitter.init = function() {\n    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n    }\n    this._maxListeners = this._maxListeners || undefined;\n};\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n    if (typeof n !== \"number\" || n < 0 || NumberIsNaN(n)) {\n        throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + \".\");\n    }\n    this._maxListeners = n;\n    return this;\n};\nfunction _getMaxListeners(that) {\n    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n    return that._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n    return _getMaxListeners(this);\n};\nEventEmitter.prototype.emit = function emit(type) {\n    var args = [];\n    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);\n    var doError = type === \"error\";\n    var events = this._events;\n    if (events !== undefined) doError = doError && events.error === undefined;\n    else if (!doError) return false;\n    // If there is no 'error' event listener then throw.\n    if (doError) {\n        var er;\n        if (args.length > 0) er = args[0];\n        if (er instanceof Error) {\n            // Note: The comments on the `throw` lines are intentional, they show\n            // up in Node's output if this results in an unhandled exception.\n            throw er; // Unhandled 'error' event\n        }\n        // At least give some kind of context to the user\n        var err = new Error(\"Unhandled error.\" + (er ? \" (\" + er.message + \")\" : \"\"));\n        err.context = er;\n        throw err; // Unhandled 'error' event\n    }\n    var handler = events[type];\n    if (handler === undefined) return false;\n    if (typeof handler === \"function\") {\n        ReflectApply(handler, this, args);\n    } else {\n        var len = handler.length;\n        var listeners = arrayClone(handler, len);\n        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);\n    }\n    return true;\n};\nfunction _addListener(target, type, listener, prepend) {\n    var m;\n    var events;\n    var existing;\n    checkListener(listener);\n    events = target._events;\n    if (events === undefined) {\n        events = target._events = Object.create(null);\n        target._eventsCount = 0;\n    } else {\n        // To avoid recursion in the case that type === \"newListener\"! Before\n        // adding it to the listeners, first emit \"newListener\".\n        if (events.newListener !== undefined) {\n            target.emit(\"newListener\", type, listener.listener ? listener.listener : listener);\n            // Re-assign `events` because a newListener handler could have caused the\n            // this._events to be assigned to a new object\n            events = target._events;\n        }\n        existing = events[type];\n    }\n    if (existing === undefined) {\n        // Optimize the case of one listener. Don't need the extra array object.\n        existing = events[type] = listener;\n        ++target._eventsCount;\n    } else {\n        if (typeof existing === \"function\") {\n            // Adding the second element, need to change to array.\n            existing = events[type] = prepend ? [\n                listener,\n                existing\n            ] : [\n                existing,\n                listener\n            ];\n        // If we've already got an array, just append.\n        } else if (prepend) {\n            existing.unshift(listener);\n        } else {\n            existing.push(listener);\n        }\n        // Check for listener leak\n        m = _getMaxListeners(target);\n        if (m > 0 && existing.length > m && !existing.warned) {\n            existing.warned = true;\n            // No error code for this since it is a Warning\n            // eslint-disable-next-line no-restricted-syntax\n            var w = new Error(\"Possible EventEmitter memory leak detected. \" + existing.length + \" \" + String(type) + \" listeners \" + \"added. Use emitter.setMaxListeners() to \" + \"increase limit\");\n            w.name = \"MaxListenersExceededWarning\";\n            w.emitter = target;\n            w.type = type;\n            w.count = existing.length;\n            ProcessEmitWarning(w);\n        }\n    }\n    return target;\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n    return _addListener(this, type, listener, false);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n    return _addListener(this, type, listener, true);\n};\nfunction onceWrapper() {\n    if (!this.fired) {\n        this.target.removeListener(this.type, this.wrapFn);\n        this.fired = true;\n        if (arguments.length === 0) return this.listener.call(this.target);\n        return this.listener.apply(this.target, arguments);\n    }\n}\nfunction _onceWrap(target, type, listener) {\n    var state = {\n        fired: false,\n        wrapFn: undefined,\n        target: target,\n        type: type,\n        listener: listener\n    };\n    var wrapped = onceWrapper.bind(state);\n    wrapped.listener = listener;\n    state.wrapFn = wrapped;\n    return wrapped;\n}\nEventEmitter.prototype.once = function once(type, listener) {\n    checkListener(listener);\n    this.on(type, _onceWrap(this, type, listener));\n    return this;\n};\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n    checkListener(listener);\n    this.prependListener(type, _onceWrap(this, type, listener));\n    return this;\n};\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n    var list, events, position, i, originalListener;\n    checkListener(listener);\n    events = this._events;\n    if (events === undefined) return this;\n    list = events[type];\n    if (list === undefined) return this;\n    if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0) this._events = Object.create(null);\n        else {\n            delete events[type];\n            if (events.removeListener) this.emit(\"removeListener\", type, list.listener || listener);\n        }\n    } else if (typeof list !== \"function\") {\n        position = -1;\n        for(i = list.length - 1; i >= 0; i--){\n            if (list[i] === listener || list[i].listener === listener) {\n                originalListener = list[i].listener;\n                position = i;\n                break;\n            }\n        }\n        if (position < 0) return this;\n        if (position === 0) list.shift();\n        else {\n            spliceOne(list, position);\n        }\n        if (list.length === 1) events[type] = list[0];\n        if (events.removeListener !== undefined) this.emit(\"removeListener\", type, originalListener || listener);\n    }\n    return this;\n};\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n    var listeners, events, i;\n    events = this._events;\n    if (events === undefined) return this;\n    // not listening for removeListener, no need to emit\n    if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n            this._events = Object.create(null);\n            this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n            if (--this._eventsCount === 0) this._events = Object.create(null);\n            else delete events[type];\n        }\n        return this;\n    }\n    // emit removeListener for all listeners on all events\n    if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for(i = 0; i < keys.length; ++i){\n            key = keys[i];\n            if (key === \"removeListener\") continue;\n            this.removeAllListeners(key);\n        }\n        this.removeAllListeners(\"removeListener\");\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n    }\n    listeners = events[type];\n    if (typeof listeners === \"function\") {\n        this.removeListener(type, listeners);\n    } else if (listeners !== undefined) {\n        // LIFO order\n        for(i = listeners.length - 1; i >= 0; i--){\n            this.removeListener(type, listeners[i]);\n        }\n    }\n    return this;\n};\nfunction _listeners(target, type, unwrap) {\n    var events = target._events;\n    if (events === undefined) return [];\n    var evlistener = events[type];\n    if (evlistener === undefined) return [];\n    if (typeof evlistener === \"function\") return unwrap ? [\n        evlistener.listener || evlistener\n    ] : [\n        evlistener\n    ];\n    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\nEventEmitter.prototype.listeners = function listeners(type) {\n    return _listeners(this, type, true);\n};\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n    return _listeners(this, type, false);\n};\nEventEmitter.listenerCount = function(emitter, type) {\n    if (typeof emitter.listenerCount === \"function\") {\n        return emitter.listenerCount(type);\n    } else {\n        return listenerCount.call(emitter, type);\n    }\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n    var events = this._events;\n    if (events !== undefined) {\n        var evlistener = events[type];\n        if (typeof evlistener === \"function\") {\n            return 1;\n        } else if (evlistener !== undefined) {\n            return evlistener.length;\n        }\n    }\n    return 0;\n}\nEventEmitter.prototype.eventNames = function eventNames() {\n    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\nfunction arrayClone(arr, n) {\n    var copy = new Array(n);\n    for(var i = 0; i < n; ++i)copy[i] = arr[i];\n    return copy;\n}\nfunction spliceOne(list, index) {\n    for(; index + 1 < list.length; index++)list[index] = list[index + 1];\n    list.pop();\n}\nfunction unwrapListeners(arr) {\n    var ret = new Array(arr.length);\n    for(var i = 0; i < ret.length; ++i){\n        ret[i] = arr[i].listener || arr[i];\n    }\n    return ret;\n}\nfunction once(emitter, name) {\n    return new Promise(function(resolve, reject) {\n        function errorListener(err) {\n            emitter.removeListener(name, resolver);\n            reject(err);\n        }\n        function resolver() {\n            if (typeof emitter.removeListener === \"function\") {\n                emitter.removeListener(\"error\", errorListener);\n            }\n            resolve([].slice.call(arguments));\n        }\n        eventTargetAgnosticAddListener(emitter, name, resolver, {\n            once: true\n        });\n        if (name !== \"error\") {\n            addErrorHandlerIfEventEmitter(emitter, errorListener, {\n                once: true\n            });\n        }\n    });\n}\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n    if (typeof emitter.on === \"function\") {\n        eventTargetAgnosticAddListener(emitter, \"error\", handler, flags);\n    }\n}\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n    if (typeof emitter.on === \"function\") {\n        if (flags.once) {\n            emitter.once(name, listener);\n        } else {\n            emitter.on(name, listener);\n        }\n    } else if (typeof emitter.addEventListener === \"function\") {\n        // EventTarget does not have `error` event semantics like Node\n        // EventEmitters, we do not listen for `error` events here.\n        emitter.addEventListener(name, function wrapListener(arg) {\n            // IE does not have builtin `{ once: true }` support so we\n            // have to do it manually.\n            if (flags.once) {\n                emitter.removeEventListener(name, wrapListener);\n            }\n            listener(arg);\n        });\n    } else {\n        throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n    }\n}\nvar eventsExports = events.exports;\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ let logDisabled_ = true;\nlet deprecationWarnings_ = true;\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */ function extractVersion(uastring, expr, pos) {\n    const match = uastring.match(expr);\n    return match && match.length >= pos && parseInt(match[pos], 10);\n}\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nfunction wrapPeerConnectionEvent(window1, eventNameToWrap, wrapper) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    const proto = window1.RTCPeerConnection.prototype;\n    const nativeAddEventListener = proto.addEventListener;\n    proto.addEventListener = function(nativeEventName, cb) {\n        if (nativeEventName !== eventNameToWrap) {\n            return nativeAddEventListener.apply(this, arguments);\n        }\n        const wrappedCallback = (e)=>{\n            const modifiedEvent = wrapper(e);\n            if (modifiedEvent) {\n                if (cb.handleEvent) {\n                    cb.handleEvent(modifiedEvent);\n                } else {\n                    cb(modifiedEvent);\n                }\n            }\n        };\n        this._eventMap = this._eventMap || {};\n        if (!this._eventMap[eventNameToWrap]) {\n            this._eventMap[eventNameToWrap] = new Map();\n        }\n        this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n        return nativeAddEventListener.apply(this, [\n            nativeEventName,\n            wrappedCallback\n        ]);\n    };\n    const nativeRemoveEventListener = proto.removeEventListener;\n    proto.removeEventListener = function(nativeEventName, cb) {\n        if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\n            return nativeRemoveEventListener.apply(this, arguments);\n        }\n        if (!this._eventMap[eventNameToWrap].has(cb)) {\n            return nativeRemoveEventListener.apply(this, arguments);\n        }\n        const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n        this._eventMap[eventNameToWrap].delete(cb);\n        if (this._eventMap[eventNameToWrap].size === 0) {\n            delete this._eventMap[eventNameToWrap];\n        }\n        if (Object.keys(this._eventMap).length === 0) {\n            delete this._eventMap;\n        }\n        return nativeRemoveEventListener.apply(this, [\n            nativeEventName,\n            unwrappedCb\n        ]);\n    };\n    Object.defineProperty(proto, \"on\" + eventNameToWrap, {\n        get () {\n            return this[\"_on\" + eventNameToWrap];\n        },\n        set (cb) {\n            if (this[\"_on\" + eventNameToWrap]) {\n                this.removeEventListener(eventNameToWrap, this[\"_on\" + eventNameToWrap]);\n                delete this[\"_on\" + eventNameToWrap];\n            }\n            if (cb) {\n                this.addEventListener(eventNameToWrap, this[\"_on\" + eventNameToWrap] = cb);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n}\nfunction disableLog(bool) {\n    if (typeof bool !== \"boolean\") {\n        return new Error(\"Argument type: \" + typeof bool + \". Please use a boolean.\");\n    }\n    logDisabled_ = bool;\n    return bool ? \"adapter.js logging disabled\" : \"adapter.js logging enabled\";\n}\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */ function disableWarnings(bool) {\n    if (typeof bool !== \"boolean\") {\n        return new Error(\"Argument type: \" + typeof bool + \". Please use a boolean.\");\n    }\n    deprecationWarnings_ = !bool;\n    return \"adapter.js deprecation warnings \" + (bool ? \"disabled\" : \"enabled\");\n}\nfunction log() {\n    if (false) {}\n}\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */ function deprecated(oldMethod, newMethod) {\n    if (!deprecationWarnings_) {\n        return;\n    }\n    console.warn(oldMethod + \" is deprecated, please use \" + newMethod + \" instead.\");\n}\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */ function detectBrowser(window1) {\n    // Returned result object.\n    const result = {\n        browser: null,\n        version: null\n    };\n    // Fail early if it's not a browser\n    if (typeof window1 === \"undefined\" || !window1.navigator || !window1.navigator.userAgent) {\n        result.browser = \"Not a browser.\";\n        return result;\n    }\n    const { navigator: navigator1 } = window1;\n    if (navigator1.mozGetUserMedia) {\n        // Firefox.\n        result.browser = \"firefox\";\n        result.version = extractVersion(navigator1.userAgent, /Firefox\\/(\\d+)\\./, 1);\n    } else if (navigator1.webkitGetUserMedia || window1.isSecureContext === false && window1.webkitRTCPeerConnection) {\n        // Chrome, Chromium, Webview, Opera.\n        // Version matches Chrome/WebRTC version.\n        // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n        // more complicated fallback to webkitRTCPeerConnection.\n        result.browser = \"chrome\";\n        result.version = extractVersion(navigator1.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n    } else if (window1.RTCPeerConnection && navigator1.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n        // Safari.\n        result.browser = \"safari\";\n        result.version = extractVersion(navigator1.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n        result.supportsUnifiedPlan = window1.RTCRtpTransceiver && \"currentDirection\" in window1.RTCRtpTransceiver.prototype;\n    } else {\n        // Default fallthrough: not supported.\n        result.browser = \"Not a supported browser.\";\n        return result;\n    }\n    return result;\n}\n/**\n * Checks if something is an object.\n *\n * @param {*} val The something you want to check.\n * @return true if val is an object, false otherwise.\n */ function isObject(val) {\n    return Object.prototype.toString.call(val) === \"[object Object]\";\n}\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash's `compact`.\n */ function compactObject(data) {\n    if (!isObject(data)) {\n        return data;\n    }\n    return Object.keys(data).reduce(function(accumulator, key) {\n        const isObj = isObject(data[key]);\n        const value = isObj ? compactObject(data[key]) : data[key];\n        const isEmptyObject = isObj && !Object.keys(value).length;\n        if (value === undefined || isEmptyObject) {\n            return accumulator;\n        }\n        return Object.assign(accumulator, {\n            [key]: value\n        });\n    }, {});\n}\n/* iterates the stats graph recursively. */ function walkStats(stats, base, resultSet) {\n    if (!base || resultSet.has(base.id)) {\n        return;\n    }\n    resultSet.set(base.id, base);\n    Object.keys(base).forEach((name)=>{\n        if (name.endsWith(\"Id\")) {\n            walkStats(stats, stats.get(base[name]), resultSet);\n        } else if (name.endsWith(\"Ids\")) {\n            base[name].forEach((id)=>{\n                walkStats(stats, stats.get(id), resultSet);\n            });\n        }\n    });\n}\n/* filter getStats for a sender/receiver track. */ function filterStats(result, track, outbound) {\n    const streamStatsType = outbound ? \"outbound-rtp\" : \"inbound-rtp\";\n    const filteredResult = new Map();\n    if (track === null) {\n        return filteredResult;\n    }\n    const trackStats = [];\n    result.forEach((value)=>{\n        if (value.type === \"track\" && value.trackIdentifier === track.id) {\n            trackStats.push(value);\n        }\n    });\n    trackStats.forEach((trackStat)=>{\n        result.forEach((stats)=>{\n            if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n                walkStats(result, stats, filteredResult);\n            }\n        });\n    });\n    return filteredResult;\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ const logging = log;\nfunction shimGetUserMedia$2(window1, browserDetails) {\n    const navigator1 = window1 && window1.navigator;\n    if (!navigator1.mediaDevices) {\n        return;\n    }\n    const constraintsToChrome_ = function(c) {\n        if (typeof c !== \"object\" || c.mandatory || c.optional) {\n            return c;\n        }\n        const cc = {};\n        Object.keys(c).forEach((key)=>{\n            if (key === \"require\" || key === \"advanced\" || key === \"mediaSource\") {\n                return;\n            }\n            const r = typeof c[key] === \"object\" ? c[key] : {\n                ideal: c[key]\n            };\n            if (r.exact !== undefined && typeof r.exact === \"number\") {\n                r.min = r.max = r.exact;\n            }\n            const oldname_ = function(prefix, name) {\n                if (prefix) {\n                    return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n                }\n                return name === \"deviceId\" ? \"sourceId\" : name;\n            };\n            if (r.ideal !== undefined) {\n                cc.optional = cc.optional || [];\n                let oc = {};\n                if (typeof r.ideal === \"number\") {\n                    oc[oldname_(\"min\", key)] = r.ideal;\n                    cc.optional.push(oc);\n                    oc = {};\n                    oc[oldname_(\"max\", key)] = r.ideal;\n                    cc.optional.push(oc);\n                } else {\n                    oc[oldname_(\"\", key)] = r.ideal;\n                    cc.optional.push(oc);\n                }\n            }\n            if (r.exact !== undefined && typeof r.exact !== \"number\") {\n                cc.mandatory = cc.mandatory || {};\n                cc.mandatory[oldname_(\"\", key)] = r.exact;\n            } else {\n                [\n                    \"min\",\n                    \"max\"\n                ].forEach((mix)=>{\n                    if (r[mix] !== undefined) {\n                        cc.mandatory = cc.mandatory || {};\n                        cc.mandatory[oldname_(mix, key)] = r[mix];\n                    }\n                });\n            }\n        });\n        if (c.advanced) {\n            cc.optional = (cc.optional || []).concat(c.advanced);\n        }\n        return cc;\n    };\n    const shimConstraints_ = function(constraints, func) {\n        if (browserDetails.version >= 61) {\n            return func(constraints);\n        }\n        constraints = JSON.parse(JSON.stringify(constraints));\n        if (constraints && typeof constraints.audio === \"object\") {\n            const remap = function(obj, a, b) {\n                if (a in obj && !(b in obj)) {\n                    obj[b] = obj[a];\n                    delete obj[a];\n                }\n            };\n            constraints = JSON.parse(JSON.stringify(constraints));\n            remap(constraints.audio, \"autoGainControl\", \"googAutoGainControl\");\n            remap(constraints.audio, \"noiseSuppression\", \"googNoiseSuppression\");\n            constraints.audio = constraintsToChrome_(constraints.audio);\n        }\n        if (constraints && typeof constraints.video === \"object\") {\n            // Shim facingMode for mobile & surface pro.\n            let face = constraints.video.facingMode;\n            face = face && (typeof face === \"object\" ? face : {\n                ideal: face\n            });\n            const getSupportedFacingModeLies = browserDetails.version < 66;\n            if (face && (face.exact === \"user\" || face.exact === \"environment\" || face.ideal === \"user\" || face.ideal === \"environment\") && !(navigator1.mediaDevices.getSupportedConstraints && navigator1.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\n                delete constraints.video.facingMode;\n                let matches;\n                if (face.exact === \"environment\" || face.ideal === \"environment\") {\n                    matches = [\n                        \"back\",\n                        \"rear\"\n                    ];\n                } else if (face.exact === \"user\" || face.ideal === \"user\") {\n                    matches = [\n                        \"front\"\n                    ];\n                }\n                if (matches) {\n                    // Look for matches in label, or use last cam for back (typical).\n                    return navigator1.mediaDevices.enumerateDevices().then((devices)=>{\n                        devices = devices.filter((d)=>d.kind === \"videoinput\");\n                        let dev = devices.find((d)=>matches.some((match)=>d.label.toLowerCase().includes(match)));\n                        if (!dev && devices.length && matches.includes(\"back\")) {\n                            dev = devices[devices.length - 1]; // more likely the back cam\n                        }\n                        if (dev) {\n                            constraints.video.deviceId = face.exact ? {\n                                exact: dev.deviceId\n                            } : {\n                                ideal: dev.deviceId\n                            };\n                        }\n                        constraints.video = constraintsToChrome_(constraints.video);\n                        logging(\"chrome: \" + JSON.stringify(constraints));\n                        return func(constraints);\n                    });\n                }\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n        }\n        logging(\"chrome: \" + JSON.stringify(constraints));\n        return func(constraints);\n    };\n    const shimError_ = function(e) {\n        if (browserDetails.version >= 64) {\n            return e;\n        }\n        return {\n            name: ({\n                PermissionDeniedError: \"NotAllowedError\",\n                PermissionDismissedError: \"NotAllowedError\",\n                InvalidStateError: \"NotAllowedError\",\n                DevicesNotFoundError: \"NotFoundError\",\n                ConstraintNotSatisfiedError: \"OverconstrainedError\",\n                TrackStartError: \"NotReadableError\",\n                MediaDeviceFailedDueToShutdown: \"NotAllowedError\",\n                MediaDeviceKillSwitchOn: \"NotAllowedError\",\n                TabCaptureError: \"AbortError\",\n                ScreenCaptureError: \"AbortError\",\n                DeviceCaptureError: \"AbortError\"\n            })[e.name] || e.name,\n            message: e.message,\n            constraint: e.constraint || e.constraintName,\n            toString () {\n                return this.name + (this.message && \": \") + this.message;\n            }\n        };\n    };\n    const getUserMedia_ = function(constraints, onSuccess, onError) {\n        shimConstraints_(constraints, (c)=>{\n            navigator1.webkitGetUserMedia(c, onSuccess, (e)=>{\n                if (onError) {\n                    onError(shimError_(e));\n                }\n            });\n        });\n    };\n    navigator1.getUserMedia = getUserMedia_.bind(navigator1);\n    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n    // function which returns a Promise, it does not accept spec-style\n    // constraints.\n    if (navigator1.mediaDevices.getUserMedia) {\n        const origGetUserMedia = navigator1.mediaDevices.getUserMedia.bind(navigator1.mediaDevices);\n        navigator1.mediaDevices.getUserMedia = function(cs) {\n            return shimConstraints_(cs, (c)=>origGetUserMedia(c).then((stream)=>{\n                    if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\n                        stream.getTracks().forEach((track)=>{\n                            track.stop();\n                        });\n                        throw new DOMException(\"\", \"NotFoundError\");\n                    }\n                    return stream;\n                }, (e)=>Promise.reject(shimError_(e))));\n        };\n    }\n}\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetDisplayMedia$1(window1, getSourceId) {\n    if (window1.navigator.mediaDevices && \"getDisplayMedia\" in window1.navigator.mediaDevices) {\n        return;\n    }\n    if (!window1.navigator.mediaDevices) {\n        return;\n    }\n    // getSourceId is a function that returns a promise resolving with\n    // the sourceId of the screen/window/tab to be shared.\n    if (typeof getSourceId !== \"function\") {\n        console.error(\"shimGetDisplayMedia: getSourceId argument is not \" + \"a function\");\n        return;\n    }\n    window1.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n        return getSourceId(constraints).then((sourceId)=>{\n            const widthSpecified = constraints.video && constraints.video.width;\n            const heightSpecified = constraints.video && constraints.video.height;\n            const frameRateSpecified = constraints.video && constraints.video.frameRate;\n            constraints.video = {\n                mandatory: {\n                    chromeMediaSource: \"desktop\",\n                    chromeMediaSourceId: sourceId,\n                    maxFrameRate: frameRateSpecified || 3\n                }\n            };\n            if (widthSpecified) {\n                constraints.video.mandatory.maxWidth = widthSpecified;\n            }\n            if (heightSpecified) {\n                constraints.video.mandatory.maxHeight = heightSpecified;\n            }\n            return window1.navigator.mediaDevices.getUserMedia(constraints);\n        });\n    };\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimMediaStream(window1) {\n    window1.MediaStream = window1.MediaStream || window1.webkitMediaStream;\n}\nfunction shimOnTrack$1(window1) {\n    if (typeof window1 === \"object\" && window1.RTCPeerConnection && !(\"ontrack\" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, \"ontrack\", {\n            get () {\n                return this._ontrack;\n            },\n            set (f) {\n                if (this._ontrack) {\n                    this.removeEventListener(\"track\", this._ontrack);\n                }\n                this.addEventListener(\"track\", this._ontrack = f);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n        window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n            if (!this._ontrackpoly) {\n                this._ontrackpoly = (e)=>{\n                    // onaddstream does not fire when a track is added to an existing\n                    // stream. But stream.onaddtrack is implemented so we use that.\n                    e.stream.addEventListener(\"addtrack\", (te)=>{\n                        let receiver;\n                        if (window1.RTCPeerConnection.prototype.getReceivers) {\n                            receiver = this.getReceivers().find((r)=>r.track && r.track.id === te.track.id);\n                        } else {\n                            receiver = {\n                                track: te.track\n                            };\n                        }\n                        const event = new Event(\"track\");\n                        event.track = te.track;\n                        event.receiver = receiver;\n                        event.transceiver = {\n                            receiver\n                        };\n                        event.streams = [\n                            e.stream\n                        ];\n                        this.dispatchEvent(event);\n                    });\n                    e.stream.getTracks().forEach((track)=>{\n                        let receiver;\n                        if (window1.RTCPeerConnection.prototype.getReceivers) {\n                            receiver = this.getReceivers().find((r)=>r.track && r.track.id === track.id);\n                        } else {\n                            receiver = {\n                                track\n                            };\n                        }\n                        const event = new Event(\"track\");\n                        event.track = track;\n                        event.receiver = receiver;\n                        event.transceiver = {\n                            receiver\n                        };\n                        event.streams = [\n                            e.stream\n                        ];\n                        this.dispatchEvent(event);\n                    });\n                };\n                this.addEventListener(\"addstream\", this._ontrackpoly);\n            }\n            return origSetRemoteDescription.apply(this, arguments);\n        };\n    } else {\n        // even if RTCRtpTransceiver is in window, it is only used and\n        // emitted in unified-plan. Unfortunately this means we need\n        // to unconditionally wrap the event.\n        wrapPeerConnectionEvent(window1, \"track\", (e)=>{\n            if (!e.transceiver) {\n                Object.defineProperty(e, \"transceiver\", {\n                    value: {\n                        receiver: e.receiver\n                    }\n                });\n            }\n            return e;\n        });\n    }\n}\nfunction shimGetSendersWithDtmf(window1) {\n    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n    if (typeof window1 === \"object\" && window1.RTCPeerConnection && !(\"getSenders\" in window1.RTCPeerConnection.prototype) && \"createDTMFSender\" in window1.RTCPeerConnection.prototype) {\n        const shimSenderWithDtmf = function(pc, track) {\n            return {\n                track,\n                get dtmf () {\n                    if (this._dtmf === undefined) {\n                        if (track.kind === \"audio\") {\n                            this._dtmf = pc.createDTMFSender(track);\n                        } else {\n                            this._dtmf = null;\n                        }\n                    }\n                    return this._dtmf;\n                },\n                _pc: pc\n            };\n        };\n        // augment addTrack when getSenders is not available.\n        if (!window1.RTCPeerConnection.prototype.getSenders) {\n            window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n                this._senders = this._senders || [];\n                return this._senders.slice(); // return a copy of the internal state.\n            };\n            const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n            window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n                let sender = origAddTrack.apply(this, arguments);\n                if (!sender) {\n                    sender = shimSenderWithDtmf(this, track);\n                    this._senders.push(sender);\n                }\n                return sender;\n            };\n            const origRemoveTrack = window1.RTCPeerConnection.prototype.removeTrack;\n            window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n                origRemoveTrack.apply(this, arguments);\n                const idx = this._senders.indexOf(sender);\n                if (idx !== -1) {\n                    this._senders.splice(idx, 1);\n                }\n            };\n        }\n        const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n        window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n            this._senders = this._senders || [];\n            origAddStream.apply(this, [\n                stream\n            ]);\n            stream.getTracks().forEach((track)=>{\n                this._senders.push(shimSenderWithDtmf(this, track));\n            });\n        };\n        const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n        window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n            this._senders = this._senders || [];\n            origRemoveStream.apply(this, [\n                stream\n            ]);\n            stream.getTracks().forEach((track)=>{\n                const sender = this._senders.find((s)=>s.track === track);\n                if (sender) {\n                    // remove sender\n                    this._senders.splice(this._senders.indexOf(sender), 1);\n                }\n            });\n        };\n    } else if (typeof window1 === \"object\" && window1.RTCPeerConnection && \"getSenders\" in window1.RTCPeerConnection.prototype && \"createDTMFSender\" in window1.RTCPeerConnection.prototype && window1.RTCRtpSender && !(\"dtmf\" in window1.RTCRtpSender.prototype)) {\n        const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n        window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n            const senders = origGetSenders.apply(this, []);\n            senders.forEach((sender)=>sender._pc = this);\n            return senders;\n        };\n        Object.defineProperty(window1.RTCRtpSender.prototype, \"dtmf\", {\n            get () {\n                if (this._dtmf === undefined) {\n                    if (this.track.kind === \"audio\") {\n                        this._dtmf = this._pc.createDTMFSender(this.track);\n                    } else {\n                        this._dtmf = null;\n                    }\n                }\n                return this._dtmf;\n            }\n        });\n    }\n}\nfunction shimGetStats(window1) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    const origGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        const [selector, onSucc, onErr] = arguments;\n        // If selector is a function then we are in the old style stats so just\n        // pass back the original getStats format to avoid breaking old users.\n        if (arguments.length > 0 && typeof selector === \"function\") {\n            return origGetStats.apply(this, arguments);\n        }\n        // When spec-style getStats is supported, return those when called with\n        // either no arguments or the selector argument is null.\n        if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== \"function\")) {\n            return origGetStats.apply(this, []);\n        }\n        const fixChromeStats_ = function(response) {\n            const standardReport = {};\n            const reports = response.result();\n            reports.forEach((report)=>{\n                const standardStats = {\n                    id: report.id,\n                    timestamp: report.timestamp,\n                    type: {\n                        localcandidate: \"local-candidate\",\n                        remotecandidate: \"remote-candidate\"\n                    }[report.type] || report.type\n                };\n                report.names().forEach((name)=>{\n                    standardStats[name] = report.stat(name);\n                });\n                standardReport[standardStats.id] = standardStats;\n            });\n            return standardReport;\n        };\n        // shim getStats with maplike support\n        const makeMapStats = function(stats) {\n            return new Map(Object.keys(stats).map((key)=>[\n                    key,\n                    stats[key]\n                ]));\n        };\n        if (arguments.length >= 2) {\n            const successCallbackWrapper_ = function(response) {\n                onSucc(makeMapStats(fixChromeStats_(response)));\n            };\n            return origGetStats.apply(this, [\n                successCallbackWrapper_,\n                selector\n            ]);\n        }\n        // promise-support\n        return new Promise((resolve, reject)=>{\n            origGetStats.apply(this, [\n                function(response) {\n                    resolve(makeMapStats(fixChromeStats_(response)));\n                },\n                reject\n            ]);\n        }).then(onSucc, onErr);\n    };\n}\nfunction shimSenderReceiverGetStats(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection && window1.RTCRtpSender && window1.RTCRtpReceiver)) {\n        return;\n    }\n    // shim sender stats.\n    if (!(\"getStats\" in window1.RTCRtpSender.prototype)) {\n        const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n        if (origGetSenders) {\n            window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n                const senders = origGetSenders.apply(this, []);\n                senders.forEach((sender)=>sender._pc = this);\n                return senders;\n            };\n        }\n        const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n        if (origAddTrack) {\n            window1.RTCPeerConnection.prototype.addTrack = function addTrack() {\n                const sender = origAddTrack.apply(this, arguments);\n                sender._pc = this;\n                return sender;\n            };\n        }\n        window1.RTCRtpSender.prototype.getStats = function getStats() {\n            const sender = this;\n            return this._pc.getStats().then((result)=>/* Note: this will include stats of all senders that\n       *   send a track with the same id as sender.track as\n       *   it is not possible to identify the RTCRtpSender.\n       */ filterStats(result, sender.track, true));\n        };\n    }\n    // shim receiver stats.\n    if (!(\"getStats\" in window1.RTCRtpReceiver.prototype)) {\n        const origGetReceivers = window1.RTCPeerConnection.prototype.getReceivers;\n        if (origGetReceivers) {\n            window1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n                const receivers = origGetReceivers.apply(this, []);\n                receivers.forEach((receiver)=>receiver._pc = this);\n                return receivers;\n            };\n        }\n        wrapPeerConnectionEvent(window1, \"track\", (e)=>{\n            e.receiver._pc = e.srcElement;\n            return e;\n        });\n        window1.RTCRtpReceiver.prototype.getStats = function getStats() {\n            const receiver = this;\n            return this._pc.getStats().then((result)=>filterStats(result, receiver.track, false));\n        };\n    }\n    if (!(\"getStats\" in window1.RTCRtpSender.prototype && \"getStats\" in window1.RTCRtpReceiver.prototype)) {\n        return;\n    }\n    // shim RTCPeerConnection.getStats(track).\n    const origGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        if (arguments.length > 0 && arguments[0] instanceof window1.MediaStreamTrack) {\n            const track = arguments[0];\n            let sender;\n            let receiver;\n            let err;\n            this.getSenders().forEach((s)=>{\n                if (s.track === track) {\n                    if (sender) {\n                        err = true;\n                    } else {\n                        sender = s;\n                    }\n                }\n            });\n            this.getReceivers().forEach((r)=>{\n                if (r.track === track) {\n                    if (receiver) {\n                        err = true;\n                    } else {\n                        receiver = r;\n                    }\n                }\n                return r.track === track;\n            });\n            if (err || sender && receiver) {\n                return Promise.reject(new DOMException(\"There are more than one sender or receiver for the track.\", \"InvalidAccessError\"));\n            } else if (sender) {\n                return sender.getStats();\n            } else if (receiver) {\n                return receiver.getStats();\n            }\n            return Promise.reject(new DOMException(\"There is no sender or receiver for the track.\", \"InvalidAccessError\"));\n        }\n        return origGetStats.apply(this, arguments);\n    };\n}\nfunction shimAddTrackRemoveTrackWithNative(window1) {\n    // shim addTrack/removeTrack with native variants in order to make\n    // the interactions with legacy getLocalStreams behave as in other browsers.\n    // Keeps a mapping stream.id => [stream, rtpsenders...]\n    window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        return Object.keys(this._shimmedLocalStreams).map((streamId)=>this._shimmedLocalStreams[streamId][0]);\n    };\n    const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n    window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        if (!stream) {\n            return origAddTrack.apply(this, arguments);\n        }\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        const sender = origAddTrack.apply(this, arguments);\n        if (!this._shimmedLocalStreams[stream.id]) {\n            this._shimmedLocalStreams[stream.id] = [\n                stream,\n                sender\n            ];\n        } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n            this._shimmedLocalStreams[stream.id].push(sender);\n        }\n        return sender;\n    };\n    const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n    window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        stream.getTracks().forEach((track)=>{\n            const alreadyExists = this.getSenders().find((s)=>s.track === track);\n            if (alreadyExists) {\n                throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n            }\n        });\n        const existingSenders = this.getSenders();\n        origAddStream.apply(this, arguments);\n        const newSenders = this.getSenders().filter((newSender)=>existingSenders.indexOf(newSender) === -1);\n        this._shimmedLocalStreams[stream.id] = [\n            stream\n        ].concat(newSenders);\n    };\n    const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        delete this._shimmedLocalStreams[stream.id];\n        return origRemoveStream.apply(this, arguments);\n    };\n    const origRemoveTrack = window1.RTCPeerConnection.prototype.removeTrack;\n    window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        if (sender) {\n            Object.keys(this._shimmedLocalStreams).forEach((streamId)=>{\n                const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n                if (idx !== -1) {\n                    this._shimmedLocalStreams[streamId].splice(idx, 1);\n                }\n                if (this._shimmedLocalStreams[streamId].length === 1) {\n                    delete this._shimmedLocalStreams[streamId];\n                }\n            });\n        }\n        return origRemoveTrack.apply(this, arguments);\n    };\n}\nfunction shimAddTrackRemoveTrack(window1, browserDetails) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // shim addTrack and removeTrack.\n    if (window1.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n        return shimAddTrackRemoveTrackWithNative(window1);\n    }\n    // also shim pc.getLocalStreams when addTrack is shimmed\n    // to return the original streams.\n    const origGetLocalStreams = window1.RTCPeerConnection.prototype.getLocalStreams;\n    window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n        const nativeStreams = origGetLocalStreams.apply(this);\n        this._reverseStreams = this._reverseStreams || {};\n        return nativeStreams.map((stream)=>this._reverseStreams[stream.id]);\n    };\n    const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n    window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        stream.getTracks().forEach((track)=>{\n            const alreadyExists = this.getSenders().find((s)=>s.track === track);\n            if (alreadyExists) {\n                throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n            }\n        });\n        // Add identity mapping for consistency with addTrack.\n        // Unless this is being used with a stream from addTrack.\n        if (!this._reverseStreams[stream.id]) {\n            const newStream = new window1.MediaStream(stream.getTracks());\n            this._streams[stream.id] = newStream;\n            this._reverseStreams[newStream.id] = stream;\n            stream = newStream;\n        }\n        origAddStream.apply(this, [\n            stream\n        ]);\n    };\n    const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        origRemoveStream.apply(this, [\n            this._streams[stream.id] || stream\n        ]);\n        delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n        delete this._streams[stream.id];\n    };\n    window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        if (this.signalingState === \"closed\") {\n            throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n        }\n        const streams = [].slice.call(arguments, 1);\n        if (streams.length !== 1 || !streams[0].getTracks().find((t)=>t === track)) {\n            // this is not fully correct but all we can manage without\n            // [[associated MediaStreams]] internal slot.\n            throw new DOMException(\"The adapter.js addTrack polyfill only supports a single \" + \" stream which is associated with the specified track.\", \"NotSupportedError\");\n        }\n        const alreadyExists = this.getSenders().find((s)=>s.track === track);\n        if (alreadyExists) {\n            throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n        }\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        const oldStream = this._streams[stream.id];\n        if (oldStream) {\n            // this is using odd Chrome behaviour, use with caution:\n            // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n            // Note: we rely on the high-level addTrack/dtmf shim to\n            // create the sender with a dtmf sender.\n            oldStream.addTrack(track);\n            // Trigger ONN async.\n            Promise.resolve().then(()=>{\n                this.dispatchEvent(new Event(\"negotiationneeded\"));\n            });\n        } else {\n            const newStream = new window1.MediaStream([\n                track\n            ]);\n            this._streams[stream.id] = newStream;\n            this._reverseStreams[newStream.id] = stream;\n            this.addStream(newStream);\n        }\n        return this.getSenders().find((s)=>s.track === track);\n    };\n    // replace the internal stream id with the external one and\n    // vice versa.\n    function replaceInternalStreamId(pc, description) {\n        let sdp = description.sdp;\n        Object.keys(pc._reverseStreams || []).forEach((internalId)=>{\n            const externalStream = pc._reverseStreams[internalId];\n            const internalStream = pc._streams[externalStream.id];\n            sdp = sdp.replace(new RegExp(internalStream.id, \"g\"), externalStream.id);\n        });\n        return new RTCSessionDescription({\n            type: description.type,\n            sdp\n        });\n    }\n    function replaceExternalStreamId(pc, description) {\n        let sdp = description.sdp;\n        Object.keys(pc._reverseStreams || []).forEach((internalId)=>{\n            const externalStream = pc._reverseStreams[internalId];\n            const internalStream = pc._streams[externalStream.id];\n            sdp = sdp.replace(new RegExp(externalStream.id, \"g\"), internalStream.id);\n        });\n        return new RTCSessionDescription({\n            type: description.type,\n            sdp\n        });\n    }\n    [\n        \"createOffer\",\n        \"createAnswer\"\n    ].forEach(function(method) {\n        const nativeMethod = window1.RTCPeerConnection.prototype[method];\n        const methodObj = {\n            [method] () {\n                const args = arguments;\n                const isLegacyCall = arguments.length && typeof arguments[0] === \"function\";\n                if (isLegacyCall) {\n                    return nativeMethod.apply(this, [\n                        (description)=>{\n                            const desc = replaceInternalStreamId(this, description);\n                            args[0].apply(null, [\n                                desc\n                            ]);\n                        },\n                        (err)=>{\n                            if (args[1]) {\n                                args[1].apply(null, err);\n                            }\n                        },\n                        arguments[2]\n                    ]);\n                }\n                return nativeMethod.apply(this, arguments).then((description)=>replaceInternalStreamId(this, description));\n            }\n        };\n        window1.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n    const origSetLocalDescription = window1.RTCPeerConnection.prototype.setLocalDescription;\n    window1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n        if (!arguments.length || !arguments[0].type) {\n            return origSetLocalDescription.apply(this, arguments);\n        }\n        arguments[0] = replaceExternalStreamId(this, arguments[0]);\n        return origSetLocalDescription.apply(this, arguments);\n    };\n    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n    const origLocalDescription = Object.getOwnPropertyDescriptor(window1.RTCPeerConnection.prototype, \"localDescription\");\n    Object.defineProperty(window1.RTCPeerConnection.prototype, \"localDescription\", {\n        get () {\n            const description = origLocalDescription.get.apply(this);\n            if (description.type === \"\") {\n                return description;\n            }\n            return replaceInternalStreamId(this, description);\n        }\n    });\n    window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        if (this.signalingState === \"closed\") {\n            throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n        }\n        // We can not yet check for sender instanceof RTCRtpSender\n        // since we shim RTPSender. So we check if sender._pc is set.\n        if (!sender._pc) {\n            throw new DOMException(\"Argument 1 of RTCPeerConnection.removeTrack \" + \"does not implement interface RTCRtpSender.\", \"TypeError\");\n        }\n        const isLocal = sender._pc === this;\n        if (!isLocal) {\n            throw new DOMException(\"Sender was not created by this connection.\", \"InvalidAccessError\");\n        }\n        // Search for the native stream the senders track belongs to.\n        this._streams = this._streams || {};\n        let stream;\n        Object.keys(this._streams).forEach((streamid)=>{\n            const hasTrack = this._streams[streamid].getTracks().find((track)=>sender.track === track);\n            if (hasTrack) {\n                stream = this._streams[streamid];\n            }\n        });\n        if (stream) {\n            if (stream.getTracks().length === 1) {\n                // if this is the last track of the stream, remove the stream. This\n                // takes care of any shimmed _senders.\n                this.removeStream(this._reverseStreams[stream.id]);\n            } else {\n                // relying on the same odd chrome behaviour as above.\n                stream.removeTrack(sender.track);\n            }\n            this.dispatchEvent(new Event(\"negotiationneeded\"));\n        }\n    };\n}\nfunction shimPeerConnection$1(window1, browserDetails) {\n    if (!window1.RTCPeerConnection && window1.webkitRTCPeerConnection) {\n        // very basic support for old versions.\n        window1.RTCPeerConnection = window1.webkitRTCPeerConnection;\n    }\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n    if (browserDetails.version < 53) {\n        [\n            \"setLocalDescription\",\n            \"setRemoteDescription\",\n            \"addIceCandidate\"\n        ].forEach(function(method) {\n            const nativeMethod = window1.RTCPeerConnection.prototype[method];\n            const methodObj = {\n                [method] () {\n                    arguments[0] = new (method === \"addIceCandidate\" ? window1.RTCIceCandidate : window1.RTCSessionDescription)(arguments[0]);\n                    return nativeMethod.apply(this, arguments);\n                }\n            };\n            window1.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n    }\n}\n// Attempt to fix ONN in plan-b mode.\nfunction fixNegotiationNeeded(window1, browserDetails) {\n    wrapPeerConnectionEvent(window1, \"negotiationneeded\", (e)=>{\n        const pc = e.target;\n        if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === \"plan-b\") {\n            if (pc.signalingState !== \"stable\") {\n                return;\n            }\n        }\n        return e;\n    });\n}\nvar chromeShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    fixNegotiationNeeded: fixNegotiationNeeded,\n    shimAddTrackRemoveTrack: shimAddTrackRemoveTrack,\n    shimAddTrackRemoveTrackWithNative: shimAddTrackRemoveTrackWithNative,\n    shimGetDisplayMedia: shimGetDisplayMedia$1,\n    shimGetSendersWithDtmf: shimGetSendersWithDtmf,\n    shimGetStats: shimGetStats,\n    shimGetUserMedia: shimGetUserMedia$2,\n    shimMediaStream: shimMediaStream,\n    shimOnTrack: shimOnTrack$1,\n    shimPeerConnection: shimPeerConnection$1,\n    shimSenderReceiverGetStats: shimSenderReceiverGetStats\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetUserMedia$1(window1, browserDetails) {\n    const navigator1 = window1 && window1.navigator;\n    const MediaStreamTrack1 = window1 && window1.MediaStreamTrack;\n    navigator1.getUserMedia = function(constraints, onSuccess, onError) {\n        // Replace Firefox 44+'s deprecation warning with unprefixed version.\n        deprecated(\"navigator.getUserMedia\", \"navigator.mediaDevices.getUserMedia\");\n        navigator1.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n    };\n    if (!(browserDetails.version > 55 && \"autoGainControl\" in navigator1.mediaDevices.getSupportedConstraints())) {\n        const remap = function(obj, a, b) {\n            if (a in obj && !(b in obj)) {\n                obj[b] = obj[a];\n                delete obj[a];\n            }\n        };\n        const nativeGetUserMedia = navigator1.mediaDevices.getUserMedia.bind(navigator1.mediaDevices);\n        navigator1.mediaDevices.getUserMedia = function(c) {\n            if (typeof c === \"object\" && typeof c.audio === \"object\") {\n                c = JSON.parse(JSON.stringify(c));\n                remap(c.audio, \"autoGainControl\", \"mozAutoGainControl\");\n                remap(c.audio, \"noiseSuppression\", \"mozNoiseSuppression\");\n            }\n            return nativeGetUserMedia(c);\n        };\n        if (MediaStreamTrack1 && MediaStreamTrack1.prototype.getSettings) {\n            const nativeGetSettings = MediaStreamTrack1.prototype.getSettings;\n            MediaStreamTrack1.prototype.getSettings = function() {\n                const obj = nativeGetSettings.apply(this, arguments);\n                remap(obj, \"mozAutoGainControl\", \"autoGainControl\");\n                remap(obj, \"mozNoiseSuppression\", \"noiseSuppression\");\n                return obj;\n            };\n        }\n        if (MediaStreamTrack1 && MediaStreamTrack1.prototype.applyConstraints) {\n            const nativeApplyConstraints = MediaStreamTrack1.prototype.applyConstraints;\n            MediaStreamTrack1.prototype.applyConstraints = function(c) {\n                if (this.kind === \"audio\" && typeof c === \"object\") {\n                    c = JSON.parse(JSON.stringify(c));\n                    remap(c, \"autoGainControl\", \"mozAutoGainControl\");\n                    remap(c, \"noiseSuppression\", \"mozNoiseSuppression\");\n                }\n                return nativeApplyConstraints.apply(this, [\n                    c\n                ]);\n            };\n        }\n    }\n}\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetDisplayMedia(window1, preferredMediaSource) {\n    if (window1.navigator.mediaDevices && \"getDisplayMedia\" in window1.navigator.mediaDevices) {\n        return;\n    }\n    if (!window1.navigator.mediaDevices) {\n        return;\n    }\n    window1.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n        if (!(constraints && constraints.video)) {\n            const err = new DOMException(\"getDisplayMedia without video \" + \"constraints is undefined\");\n            err.name = \"NotFoundError\";\n            // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n            err.code = 8;\n            return Promise.reject(err);\n        }\n        if (constraints.video === true) {\n            constraints.video = {\n                mediaSource: preferredMediaSource\n            };\n        } else {\n            constraints.video.mediaSource = preferredMediaSource;\n        }\n        return window1.navigator.mediaDevices.getUserMedia(constraints);\n    };\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimOnTrack(window1) {\n    if (typeof window1 === \"object\" && window1.RTCTrackEvent && \"receiver\" in window1.RTCTrackEvent.prototype && !(\"transceiver\" in window1.RTCTrackEvent.prototype)) {\n        Object.defineProperty(window1.RTCTrackEvent.prototype, \"transceiver\", {\n            get () {\n                return {\n                    receiver: this.receiver\n                };\n            }\n        });\n    }\n}\nfunction shimPeerConnection(window1, browserDetails) {\n    if (typeof window1 !== \"object\" || !(window1.RTCPeerConnection || window1.mozRTCPeerConnection)) {\n        return; // probably media.peerconnection.enabled=false in about:config\n    }\n    if (!window1.RTCPeerConnection && window1.mozRTCPeerConnection) {\n        // very basic support for old versions.\n        window1.RTCPeerConnection = window1.mozRTCPeerConnection;\n    }\n    if (browserDetails.version < 53) {\n        // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n        [\n            \"setLocalDescription\",\n            \"setRemoteDescription\",\n            \"addIceCandidate\"\n        ].forEach(function(method) {\n            const nativeMethod = window1.RTCPeerConnection.prototype[method];\n            const methodObj = {\n                [method] () {\n                    arguments[0] = new (method === \"addIceCandidate\" ? window1.RTCIceCandidate : window1.RTCSessionDescription)(arguments[0]);\n                    return nativeMethod.apply(this, arguments);\n                }\n            };\n            window1.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n    }\n    const modernStatsTypes = {\n        inboundrtp: \"inbound-rtp\",\n        outboundrtp: \"outbound-rtp\",\n        candidatepair: \"candidate-pair\",\n        localcandidate: \"local-candidate\",\n        remotecandidate: \"remote-candidate\"\n    };\n    const nativeGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        const [selector, onSucc, onErr] = arguments;\n        return nativeGetStats.apply(this, [\n            selector || null\n        ]).then((stats)=>{\n            if (browserDetails.version < 53 && !onSucc) {\n                // Shim only promise getStats with spec-hyphens in type names\n                // Leave callback version alone; misc old uses of forEach before Map\n                try {\n                    stats.forEach((stat)=>{\n                        stat.type = modernStatsTypes[stat.type] || stat.type;\n                    });\n                } catch (e) {\n                    if (e.name !== \"TypeError\") {\n                        throw e;\n                    }\n                    // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n                    stats.forEach((stat, i)=>{\n                        stats.set(i, Object.assign({}, stat, {\n                            type: modernStatsTypes[stat.type] || stat.type\n                        }));\n                    });\n                }\n            }\n            return stats;\n        }).then(onSucc, onErr);\n    };\n}\nfunction shimSenderGetStats(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection && window1.RTCRtpSender)) {\n        return;\n    }\n    if (window1.RTCRtpSender && \"getStats\" in window1.RTCRtpSender.prototype) {\n        return;\n    }\n    const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n        window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n            const senders = origGetSenders.apply(this, []);\n            senders.forEach((sender)=>sender._pc = this);\n            return senders;\n        };\n    }\n    const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n        window1.RTCPeerConnection.prototype.addTrack = function addTrack() {\n            const sender = origAddTrack.apply(this, arguments);\n            sender._pc = this;\n            return sender;\n        };\n    }\n    window1.RTCRtpSender.prototype.getStats = function getStats() {\n        return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());\n    };\n}\nfunction shimReceiverGetStats(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection && window1.RTCRtpSender)) {\n        return;\n    }\n    if (window1.RTCRtpSender && \"getStats\" in window1.RTCRtpReceiver.prototype) {\n        return;\n    }\n    const origGetReceivers = window1.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n        window1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n            const receivers = origGetReceivers.apply(this, []);\n            receivers.forEach((receiver)=>receiver._pc = this);\n            return receivers;\n        };\n    }\n    wrapPeerConnectionEvent(window1, \"track\", (e)=>{\n        e.receiver._pc = e.srcElement;\n        return e;\n    });\n    window1.RTCRtpReceiver.prototype.getStats = function getStats() {\n        return this._pc.getStats(this.track);\n    };\n}\nfunction shimRemoveStream(window1) {\n    if (!window1.RTCPeerConnection || \"removeStream\" in window1.RTCPeerConnection.prototype) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        deprecated(\"removeStream\", \"removeTrack\");\n        this.getSenders().forEach((sender)=>{\n            if (sender.track && stream.getTracks().includes(sender.track)) {\n                this.removeTrack(sender);\n            }\n        });\n    };\n}\nfunction shimRTCDataChannel(window1) {\n    // rename DataChannel to RTCDataChannel (native fix in FF60):\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n    if (window1.DataChannel && !window1.RTCDataChannel) {\n        window1.RTCDataChannel = window1.DataChannel;\n    }\n}\nfunction shimAddTransceiver(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origAddTransceiver = window1.RTCPeerConnection.prototype.addTransceiver;\n    if (origAddTransceiver) {\n        window1.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\n            this.setParametersPromises = [];\n            // WebIDL input coercion and validation\n            let sendEncodings = arguments[1] && arguments[1].sendEncodings;\n            if (sendEncodings === undefined) {\n                sendEncodings = [];\n            }\n            sendEncodings = [\n                ...sendEncodings\n            ];\n            const shouldPerformCheck = sendEncodings.length > 0;\n            if (shouldPerformCheck) {\n                // If sendEncodings params are provided, validate grammar\n                sendEncodings.forEach((encodingParam)=>{\n                    if (\"rid\" in encodingParam) {\n                        const ridRegex = /^[a-z0-9]{0,16}$/i;\n                        if (!ridRegex.test(encodingParam.rid)) {\n                            throw new TypeError(\"Invalid RID value provided.\");\n                        }\n                    }\n                    if (\"scaleResolutionDownBy\" in encodingParam) {\n                        if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\n                            throw new RangeError(\"scale_resolution_down_by must be >= 1.0\");\n                        }\n                    }\n                    if (\"maxFramerate\" in encodingParam) {\n                        if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n                            throw new RangeError(\"max_framerate must be >= 0.0\");\n                        }\n                    }\n                });\n            }\n            const transceiver = origAddTransceiver.apply(this, arguments);\n            if (shouldPerformCheck) {\n                // Check if the init options were applied. If not we do this in an\n                // asynchronous way and save the promise reference in a global object.\n                // This is an ugly hack, but at the same time is way more robust than\n                // checking the sender parameters before and after the createOffer\n                // Also note that after the createoffer we are not 100% sure that\n                // the params were asynchronously applied so we might miss the\n                // opportunity to recreate offer.\n                const { sender } = transceiver;\n                const params = sender.getParameters();\n                if (!(\"encodings\" in params) || // Avoid being fooled by patched getParameters() below.\n                params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {\n                    params.encodings = sendEncodings;\n                    sender.sendEncodings = sendEncodings;\n                    this.setParametersPromises.push(sender.setParameters(params).then(()=>{\n                        delete sender.sendEncodings;\n                    }).catch(()=>{\n                        delete sender.sendEncodings;\n                    }));\n                }\n            }\n            return transceiver;\n        };\n    }\n}\nfunction shimGetParameters(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCRtpSender)) {\n        return;\n    }\n    const origGetParameters = window1.RTCRtpSender.prototype.getParameters;\n    if (origGetParameters) {\n        window1.RTCRtpSender.prototype.getParameters = function getParameters() {\n            const params = origGetParameters.apply(this, arguments);\n            if (!(\"encodings\" in params)) {\n                params.encodings = [].concat(this.sendEncodings || [\n                    {}\n                ]);\n            }\n            return params;\n        };\n    }\n}\nfunction shimCreateOffer(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origCreateOffer = window1.RTCPeerConnection.prototype.createOffer;\n    window1.RTCPeerConnection.prototype.createOffer = function createOffer() {\n        if (this.setParametersPromises && this.setParametersPromises.length) {\n            return Promise.all(this.setParametersPromises).then(()=>{\n                return origCreateOffer.apply(this, arguments);\n            }).finally(()=>{\n                this.setParametersPromises = [];\n            });\n        }\n        return origCreateOffer.apply(this, arguments);\n    };\n}\nfunction shimCreateAnswer(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origCreateAnswer = window1.RTCPeerConnection.prototype.createAnswer;\n    window1.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n        if (this.setParametersPromises && this.setParametersPromises.length) {\n            return Promise.all(this.setParametersPromises).then(()=>{\n                return origCreateAnswer.apply(this, arguments);\n            }).finally(()=>{\n                this.setParametersPromises = [];\n            });\n        }\n        return origCreateAnswer.apply(this, arguments);\n    };\n}\nvar firefoxShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    shimAddTransceiver: shimAddTransceiver,\n    shimCreateAnswer: shimCreateAnswer,\n    shimCreateOffer: shimCreateOffer,\n    shimGetDisplayMedia: shimGetDisplayMedia,\n    shimGetParameters: shimGetParameters,\n    shimGetUserMedia: shimGetUserMedia$1,\n    shimOnTrack: shimOnTrack,\n    shimPeerConnection: shimPeerConnection,\n    shimRTCDataChannel: shimRTCDataChannel,\n    shimReceiverGetStats: shimReceiverGetStats,\n    shimRemoveStream: shimRemoveStream,\n    shimSenderGetStats: shimSenderGetStats\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ function shimLocalStreamsAPI(window1) {\n    if (typeof window1 !== \"object\" || !window1.RTCPeerConnection) {\n        return;\n    }\n    if (!(\"getLocalStreams\" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            return this._localStreams;\n        };\n    }\n    if (!(\"addStream\" in window1.RTCPeerConnection.prototype)) {\n        const _addTrack = window1.RTCPeerConnection.prototype.addTrack;\n        window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            if (!this._localStreams.includes(stream)) {\n                this._localStreams.push(stream);\n            }\n            // Try to emulate Chrome's behaviour of adding in audio-video order.\n            // Safari orders by track id.\n            stream.getAudioTracks().forEach((track)=>_addTrack.call(this, track, stream));\n            stream.getVideoTracks().forEach((track)=>_addTrack.call(this, track, stream));\n        };\n        window1.RTCPeerConnection.prototype.addTrack = function addTrack(track) {\n            for(var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                streams[_key - 1] = arguments[_key];\n            }\n            if (streams) {\n                streams.forEach((stream)=>{\n                    if (!this._localStreams) {\n                        this._localStreams = [\n                            stream\n                        ];\n                    } else if (!this._localStreams.includes(stream)) {\n                        this._localStreams.push(stream);\n                    }\n                });\n            }\n            return _addTrack.apply(this, arguments);\n        };\n    }\n    if (!(\"removeStream\" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            const index = this._localStreams.indexOf(stream);\n            if (index === -1) {\n                return;\n            }\n            this._localStreams.splice(index, 1);\n            const tracks = stream.getTracks();\n            this.getSenders().forEach((sender)=>{\n                if (tracks.includes(sender.track)) {\n                    this.removeTrack(sender);\n                }\n            });\n        };\n    }\n}\nfunction shimRemoteStreamsAPI(window1) {\n    if (typeof window1 !== \"object\" || !window1.RTCPeerConnection) {\n        return;\n    }\n    if (!(\"getRemoteStreams\" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {\n            return this._remoteStreams ? this._remoteStreams : [];\n        };\n    }\n    if (!(\"onaddstream\" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, \"onaddstream\", {\n            get () {\n                return this._onaddstream;\n            },\n            set (f) {\n                if (this._onaddstream) {\n                    this.removeEventListener(\"addstream\", this._onaddstream);\n                    this.removeEventListener(\"track\", this._onaddstreampoly);\n                }\n                this.addEventListener(\"addstream\", this._onaddstream = f);\n                this.addEventListener(\"track\", this._onaddstreampoly = (e)=>{\n                    e.streams.forEach((stream)=>{\n                        if (!this._remoteStreams) {\n                            this._remoteStreams = [];\n                        }\n                        if (this._remoteStreams.includes(stream)) {\n                            return;\n                        }\n                        this._remoteStreams.push(stream);\n                        const event = new Event(\"addstream\");\n                        event.stream = stream;\n                        this.dispatchEvent(event);\n                    });\n                });\n            }\n        });\n        const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n        window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n            const pc = this;\n            if (!this._onaddstreampoly) {\n                this.addEventListener(\"track\", this._onaddstreampoly = function(e) {\n                    e.streams.forEach((stream)=>{\n                        if (!pc._remoteStreams) {\n                            pc._remoteStreams = [];\n                        }\n                        if (pc._remoteStreams.indexOf(stream) >= 0) {\n                            return;\n                        }\n                        pc._remoteStreams.push(stream);\n                        const event = new Event(\"addstream\");\n                        event.stream = stream;\n                        pc.dispatchEvent(event);\n                    });\n                });\n            }\n            return origSetRemoteDescription.apply(pc, arguments);\n        };\n    }\n}\nfunction shimCallbacksAPI(window1) {\n    if (typeof window1 !== \"object\" || !window1.RTCPeerConnection) {\n        return;\n    }\n    const prototype = window1.RTCPeerConnection.prototype;\n    const origCreateOffer = prototype.createOffer;\n    const origCreateAnswer = prototype.createAnswer;\n    const setLocalDescription = prototype.setLocalDescription;\n    const setRemoteDescription = prototype.setRemoteDescription;\n    const addIceCandidate = prototype.addIceCandidate;\n    prototype.createOffer = function createOffer(successCallback, failureCallback) {\n        const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n        const promise = origCreateOffer.apply(this, [\n            options\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.createAnswer = function createAnswer(successCallback, failureCallback) {\n        const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n        const promise = origCreateAnswer.apply(this, [\n            options\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    let withCallback = function(description, successCallback, failureCallback) {\n        const promise = setLocalDescription.apply(this, [\n            description\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.setLocalDescription = withCallback;\n    withCallback = function(description, successCallback, failureCallback) {\n        const promise = setRemoteDescription.apply(this, [\n            description\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.setRemoteDescription = withCallback;\n    withCallback = function(candidate, successCallback, failureCallback) {\n        const promise = addIceCandidate.apply(this, [\n            candidate\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.addIceCandidate = withCallback;\n}\nfunction shimGetUserMedia(window1) {\n    const navigator1 = window1 && window1.navigator;\n    if (navigator1.mediaDevices && navigator1.mediaDevices.getUserMedia) {\n        // shim not needed in Safari 12.1\n        const mediaDevices = navigator1.mediaDevices;\n        const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n        navigator1.mediaDevices.getUserMedia = (constraints)=>{\n            return _getUserMedia(shimConstraints(constraints));\n        };\n    }\n    if (!navigator1.getUserMedia && navigator1.mediaDevices && navigator1.mediaDevices.getUserMedia) {\n        navigator1.getUserMedia = (function getUserMedia(constraints, cb, errcb) {\n            navigator1.mediaDevices.getUserMedia(constraints).then(cb, errcb);\n        }).bind(navigator1);\n    }\n}\nfunction shimConstraints(constraints) {\n    if (constraints && constraints.video !== undefined) {\n        return Object.assign({}, constraints, {\n            video: compactObject(constraints.video)\n        });\n    }\n    return constraints;\n}\nfunction shimRTCIceServerUrls(window1) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n    const OrigPeerConnection = window1.RTCPeerConnection;\n    window1.RTCPeerConnection = function RTCPeerConnection1(pcConfig, pcConstraints) {\n        if (pcConfig && pcConfig.iceServers) {\n            const newIceServers = [];\n            for(let i = 0; i < pcConfig.iceServers.length; i++){\n                let server = pcConfig.iceServers[i];\n                if (server.urls === undefined && server.url) {\n                    deprecated(\"RTCIceServer.url\", \"RTCIceServer.urls\");\n                    server = JSON.parse(JSON.stringify(server));\n                    server.urls = server.url;\n                    delete server.url;\n                    newIceServers.push(server);\n                } else {\n                    newIceServers.push(pcConfig.iceServers[i]);\n                }\n            }\n            pcConfig.iceServers = newIceServers;\n        }\n        return new OrigPeerConnection(pcConfig, pcConstraints);\n    };\n    window1.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n    // wrap static methods. Currently just generateCertificate.\n    if (\"generateCertificate\" in OrigPeerConnection) {\n        Object.defineProperty(window1.RTCPeerConnection, \"generateCertificate\", {\n            get () {\n                return OrigPeerConnection.generateCertificate;\n            }\n        });\n    }\n}\nfunction shimTrackEventTransceiver(window1) {\n    // Add event.transceiver member over deprecated event.receiver\n    if (typeof window1 === \"object\" && window1.RTCTrackEvent && \"receiver\" in window1.RTCTrackEvent.prototype && !(\"transceiver\" in window1.RTCTrackEvent.prototype)) {\n        Object.defineProperty(window1.RTCTrackEvent.prototype, \"transceiver\", {\n            get () {\n                return {\n                    receiver: this.receiver\n                };\n            }\n        });\n    }\n}\nfunction shimCreateOfferLegacy(window1) {\n    const origCreateOffer = window1.RTCPeerConnection.prototype.createOffer;\n    window1.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {\n        if (offerOptions) {\n            if (typeof offerOptions.offerToReceiveAudio !== \"undefined\") {\n                // support bit values\n                offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n            }\n            const audioTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === \"audio\");\n            if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n                if (audioTransceiver.direction === \"sendrecv\") {\n                    if (audioTransceiver.setDirection) {\n                        audioTransceiver.setDirection(\"sendonly\");\n                    } else {\n                        audioTransceiver.direction = \"sendonly\";\n                    }\n                } else if (audioTransceiver.direction === \"recvonly\") {\n                    if (audioTransceiver.setDirection) {\n                        audioTransceiver.setDirection(\"inactive\");\n                    } else {\n                        audioTransceiver.direction = \"inactive\";\n                    }\n                }\n            } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\n                this.addTransceiver(\"audio\", {\n                    direction: \"recvonly\"\n                });\n            }\n            if (typeof offerOptions.offerToReceiveVideo !== \"undefined\") {\n                // support bit values\n                offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n            }\n            const videoTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === \"video\");\n            if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n                if (videoTransceiver.direction === \"sendrecv\") {\n                    if (videoTransceiver.setDirection) {\n                        videoTransceiver.setDirection(\"sendonly\");\n                    } else {\n                        videoTransceiver.direction = \"sendonly\";\n                    }\n                } else if (videoTransceiver.direction === \"recvonly\") {\n                    if (videoTransceiver.setDirection) {\n                        videoTransceiver.setDirection(\"inactive\");\n                    } else {\n                        videoTransceiver.direction = \"inactive\";\n                    }\n                }\n            } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\n                this.addTransceiver(\"video\", {\n                    direction: \"recvonly\"\n                });\n            }\n        }\n        return origCreateOffer.apply(this, arguments);\n    };\n}\nfunction shimAudioContext(window1) {\n    if (typeof window1 !== \"object\" || window1.AudioContext) {\n        return;\n    }\n    window1.AudioContext = window1.webkitAudioContext;\n}\nvar safariShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    shimAudioContext: shimAudioContext,\n    shimCallbacksAPI: shimCallbacksAPI,\n    shimConstraints: shimConstraints,\n    shimCreateOfferLegacy: shimCreateOfferLegacy,\n    shimGetUserMedia: shimGetUserMedia,\n    shimLocalStreamsAPI: shimLocalStreamsAPI,\n    shimRTCIceServerUrls: shimRTCIceServerUrls,\n    shimRemoteStreamsAPI: shimRemoteStreamsAPI,\n    shimTrackEventTransceiver: shimTrackEventTransceiver\n});\nvar sdp$1 = {\n    exports: {}\n};\n/* eslint-env node */ (function(module) {\n    // SDP helpers.\n    const SDPUtils = {};\n    // Generate an alphanumeric identifier for cname or mids.\n    // TODO: use UUIDs instead? https://gist.github.com/jed/982883\n    SDPUtils.generateIdentifier = function() {\n        return Math.random().toString(36).substring(2, 12);\n    };\n    // The RTCP CNAME used by all peerconnections from the same JS.\n    SDPUtils.localCName = SDPUtils.generateIdentifier();\n    // Splits SDP into lines, dealing with both CRLF and LF.\n    SDPUtils.splitLines = function(blob) {\n        return blob.trim().split(\"\\n\").map((line)=>line.trim());\n    };\n    // Splits SDP into sessionpart and mediasections. Ensures CRLF.\n    SDPUtils.splitSections = function(blob) {\n        const parts = blob.split(\"\\nm=\");\n        return parts.map((part, index)=>(index > 0 ? \"m=\" + part : part).trim() + \"\\r\\n\");\n    };\n    // Returns the session description.\n    SDPUtils.getDescription = function(blob) {\n        const sections = SDPUtils.splitSections(blob);\n        return sections && sections[0];\n    };\n    // Returns the individual media sections.\n    SDPUtils.getMediaSections = function(blob) {\n        const sections = SDPUtils.splitSections(blob);\n        sections.shift();\n        return sections;\n    };\n    // Returns lines that start with a certain prefix.\n    SDPUtils.matchPrefix = function(blob, prefix) {\n        return SDPUtils.splitLines(blob).filter((line)=>line.indexOf(prefix) === 0);\n    };\n    // Parses an ICE candidate line. Sample input:\n    // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n    // rport 55996\"\n    // Input can be prefixed with a=.\n    SDPUtils.parseCandidate = function(line) {\n        let parts;\n        // Parse both variants.\n        if (line.indexOf(\"a=candidate:\") === 0) {\n            parts = line.substring(12).split(\" \");\n        } else {\n            parts = line.substring(10).split(\" \");\n        }\n        const candidate = {\n            foundation: parts[0],\n            component: {\n                1: \"rtp\",\n                2: \"rtcp\"\n            }[parts[1]] || parts[1],\n            protocol: parts[2].toLowerCase(),\n            priority: parseInt(parts[3], 10),\n            ip: parts[4],\n            address: parts[4],\n            // address is an alias for ip.\n            port: parseInt(parts[5], 10),\n            // skip parts[6] == 'typ'\n            type: parts[7]\n        };\n        for(let i = 8; i < parts.length; i += 2){\n            switch(parts[i]){\n                case \"raddr\":\n                    candidate.relatedAddress = parts[i + 1];\n                    break;\n                case \"rport\":\n                    candidate.relatedPort = parseInt(parts[i + 1], 10);\n                    break;\n                case \"tcptype\":\n                    candidate.tcpType = parts[i + 1];\n                    break;\n                case \"ufrag\":\n                    candidate.ufrag = parts[i + 1]; // for backward compatibility.\n                    candidate.usernameFragment = parts[i + 1];\n                    break;\n                default:\n                    // extension handling, in particular ufrag. Don't overwrite.\n                    if (candidate[parts[i]] === undefined) {\n                        candidate[parts[i]] = parts[i + 1];\n                    }\n                    break;\n            }\n        }\n        return candidate;\n    };\n    // Translates a candidate object into SDP candidate attribute.\n    // This does not include the a= prefix!\n    SDPUtils.writeCandidate = function(candidate) {\n        const sdp = [];\n        sdp.push(candidate.foundation);\n        const component = candidate.component;\n        if (component === \"rtp\") {\n            sdp.push(1);\n        } else if (component === \"rtcp\") {\n            sdp.push(2);\n        } else {\n            sdp.push(component);\n        }\n        sdp.push(candidate.protocol.toUpperCase());\n        sdp.push(candidate.priority);\n        sdp.push(candidate.address || candidate.ip);\n        sdp.push(candidate.port);\n        const type = candidate.type;\n        sdp.push(\"typ\");\n        sdp.push(type);\n        if (type !== \"host\" && candidate.relatedAddress && candidate.relatedPort) {\n            sdp.push(\"raddr\");\n            sdp.push(candidate.relatedAddress);\n            sdp.push(\"rport\");\n            sdp.push(candidate.relatedPort);\n        }\n        if (candidate.tcpType && candidate.protocol.toLowerCase() === \"tcp\") {\n            sdp.push(\"tcptype\");\n            sdp.push(candidate.tcpType);\n        }\n        if (candidate.usernameFragment || candidate.ufrag) {\n            sdp.push(\"ufrag\");\n            sdp.push(candidate.usernameFragment || candidate.ufrag);\n        }\n        return \"candidate:\" + sdp.join(\" \");\n    };\n    // Parses an ice-options line, returns an array of option tags.\n    // Sample input:\n    // a=ice-options:foo bar\n    SDPUtils.parseIceOptions = function(line) {\n        return line.substring(14).split(\" \");\n    };\n    // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n    // a=rtpmap:111 opus/48000/2\n    SDPUtils.parseRtpMap = function(line) {\n        let parts = line.substring(9).split(\" \");\n        const parsed = {\n            payloadType: parseInt(parts.shift(), 10) // was: id\n        };\n        parts = parts[0].split(\"/\");\n        parsed.name = parts[0];\n        parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n        parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n        // legacy alias, got renamed back to channels in ORTC.\n        parsed.numChannels = parsed.channels;\n        return parsed;\n    };\n    // Generates a rtpmap line from RTCRtpCodecCapability or\n    // RTCRtpCodecParameters.\n    SDPUtils.writeRtpMap = function(codec) {\n        let pt = codec.payloadType;\n        if (codec.preferredPayloadType !== undefined) {\n            pt = codec.preferredPayloadType;\n        }\n        const channels = codec.channels || codec.numChannels || 1;\n        return \"a=rtpmap:\" + pt + \" \" + codec.name + \"/\" + codec.clockRate + (channels !== 1 ? \"/\" + channels : \"\") + \"\\r\\n\";\n    };\n    // Parses a extmap line (headerextension from RFC 5285). Sample input:\n    // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n    // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\n    SDPUtils.parseExtmap = function(line) {\n        const parts = line.substring(9).split(\" \");\n        return {\n            id: parseInt(parts[0], 10),\n            direction: parts[0].indexOf(\"/\") > 0 ? parts[0].split(\"/\")[1] : \"sendrecv\",\n            uri: parts[1],\n            attributes: parts.slice(2).join(\" \")\n        };\n    };\n    // Generates an extmap line from RTCRtpHeaderExtensionParameters or\n    // RTCRtpHeaderExtension.\n    SDPUtils.writeExtmap = function(headerExtension) {\n        return \"a=extmap:\" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== \"sendrecv\" ? \"/\" + headerExtension.direction : \"\") + \" \" + headerExtension.uri + (headerExtension.attributes ? \" \" + headerExtension.attributes : \"\") + \"\\r\\n\";\n    };\n    // Parses a fmtp line, returns dictionary. Sample input:\n    // a=fmtp:96 vbr=on;cng=on\n    // Also deals with vbr=on; cng=on\n    SDPUtils.parseFmtp = function(line) {\n        const parsed = {};\n        let kv;\n        const parts = line.substring(line.indexOf(\" \") + 1).split(\";\");\n        for(let j = 0; j < parts.length; j++){\n            kv = parts[j].trim().split(\"=\");\n            parsed[kv[0].trim()] = kv[1];\n        }\n        return parsed;\n    };\n    // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\n    SDPUtils.writeFmtp = function(codec) {\n        let line = \"\";\n        let pt = codec.payloadType;\n        if (codec.preferredPayloadType !== undefined) {\n            pt = codec.preferredPayloadType;\n        }\n        if (codec.parameters && Object.keys(codec.parameters).length) {\n            const params = [];\n            Object.keys(codec.parameters).forEach((param)=>{\n                if (codec.parameters[param] !== undefined) {\n                    params.push(param + \"=\" + codec.parameters[param]);\n                } else {\n                    params.push(param);\n                }\n            });\n            line += \"a=fmtp:\" + pt + \" \" + params.join(\";\") + \"\\r\\n\";\n        }\n        return line;\n    };\n    // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n    // a=rtcp-fb:98 nack rpsi\n    SDPUtils.parseRtcpFb = function(line) {\n        const parts = line.substring(line.indexOf(\" \") + 1).split(\" \");\n        return {\n            type: parts.shift(),\n            parameter: parts.join(\" \")\n        };\n    };\n    // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\n    SDPUtils.writeRtcpFb = function(codec) {\n        let lines = \"\";\n        let pt = codec.payloadType;\n        if (codec.preferredPayloadType !== undefined) {\n            pt = codec.preferredPayloadType;\n        }\n        if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n            // FIXME: special handling for trr-int?\n            codec.rtcpFeedback.forEach((fb)=>{\n                lines += \"a=rtcp-fb:\" + pt + \" \" + fb.type + (fb.parameter && fb.parameter.length ? \" \" + fb.parameter : \"\") + \"\\r\\n\";\n            });\n        }\n        return lines;\n    };\n    // Parses a RFC 5576 ssrc media attribute. Sample input:\n    // a=ssrc:3735928559 cname:something\n    SDPUtils.parseSsrcMedia = function(line) {\n        const sp = line.indexOf(\" \");\n        const parts = {\n            ssrc: parseInt(line.substring(7, sp), 10)\n        };\n        const colon = line.indexOf(\":\", sp);\n        if (colon > -1) {\n            parts.attribute = line.substring(sp + 1, colon);\n            parts.value = line.substring(colon + 1);\n        } else {\n            parts.attribute = line.substring(sp + 1);\n        }\n        return parts;\n    };\n    // Parse a ssrc-group line (see RFC 5576). Sample input:\n    // a=ssrc-group:semantics 12 34\n    SDPUtils.parseSsrcGroup = function(line) {\n        const parts = line.substring(13).split(\" \");\n        return {\n            semantics: parts.shift(),\n            ssrcs: parts.map((ssrc)=>parseInt(ssrc, 10))\n        };\n    };\n    // Extracts the MID (RFC 5888) from a media section.\n    // Returns the MID or undefined if no mid line was found.\n    SDPUtils.getMid = function(mediaSection) {\n        const mid = SDPUtils.matchPrefix(mediaSection, \"a=mid:\")[0];\n        if (mid) {\n            return mid.substring(6);\n        }\n    };\n    // Parses a fingerprint line for DTLS-SRTP.\n    SDPUtils.parseFingerprint = function(line) {\n        const parts = line.substring(14).split(\" \");\n        return {\n            algorithm: parts[0].toLowerCase(),\n            // algorithm is case-sensitive in Edge.\n            value: parts[1].toUpperCase() // the definition is upper-case in RFC 4572.\n        };\n    };\n    // Extracts DTLS parameters from SDP media section or sessionpart.\n    // FIXME: for consistency with other functions this should only\n    //   get the fingerprint line as input. See also getIceParameters.\n    SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n        const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=fingerprint:\");\n        // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n        return {\n            role: \"auto\",\n            fingerprints: lines.map(SDPUtils.parseFingerprint)\n        };\n    };\n    // Serializes DTLS parameters to SDP.\n    SDPUtils.writeDtlsParameters = function(params, setupType) {\n        let sdp = \"a=setup:\" + setupType + \"\\r\\n\";\n        params.fingerprints.forEach((fp)=>{\n            sdp += \"a=fingerprint:\" + fp.algorithm + \" \" + fp.value + \"\\r\\n\";\n        });\n        return sdp;\n    };\n    // Parses a=crypto lines into\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\n    SDPUtils.parseCryptoLine = function(line) {\n        const parts = line.substring(9).split(\" \");\n        return {\n            tag: parseInt(parts[0], 10),\n            cryptoSuite: parts[1],\n            keyParams: parts[2],\n            sessionParams: parts.slice(3)\n        };\n    };\n    SDPUtils.writeCryptoLine = function(parameters) {\n        return \"a=crypto:\" + parameters.tag + \" \" + parameters.cryptoSuite + \" \" + (typeof parameters.keyParams === \"object\" ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? \" \" + parameters.sessionParams.join(\" \") : \"\") + \"\\r\\n\";\n    };\n    // Parses the crypto key parameters into\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\n    SDPUtils.parseCryptoKeyParams = function(keyParams) {\n        if (keyParams.indexOf(\"inline:\") !== 0) {\n            return null;\n        }\n        const parts = keyParams.substring(7).split(\"|\");\n        return {\n            keyMethod: \"inline\",\n            keySalt: parts[0],\n            lifeTime: parts[1],\n            mkiValue: parts[2] ? parts[2].split(\":\")[0] : undefined,\n            mkiLength: parts[2] ? parts[2].split(\":\")[1] : undefined\n        };\n    };\n    SDPUtils.writeCryptoKeyParams = function(keyParams) {\n        return keyParams.keyMethod + \":\" + keyParams.keySalt + (keyParams.lifeTime ? \"|\" + keyParams.lifeTime : \"\") + (keyParams.mkiValue && keyParams.mkiLength ? \"|\" + keyParams.mkiValue + \":\" + keyParams.mkiLength : \"\");\n    };\n    // Extracts all SDES parameters.\n    SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {\n        const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=crypto:\");\n        return lines.map(SDPUtils.parseCryptoLine);\n    };\n    // Parses ICE information from SDP media section or sessionpart.\n    // FIXME: for consistency with other functions this should only\n    //   get the ice-ufrag and ice-pwd lines as input.\n    SDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n        const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=ice-ufrag:\")[0];\n        const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=ice-pwd:\")[0];\n        if (!(ufrag && pwd)) {\n            return null;\n        }\n        return {\n            usernameFragment: ufrag.substring(12),\n            password: pwd.substring(10)\n        };\n    };\n    // Serializes ICE parameters to SDP.\n    SDPUtils.writeIceParameters = function(params) {\n        let sdp = \"a=ice-ufrag:\" + params.usernameFragment + \"\\r\\n\" + \"a=ice-pwd:\" + params.password + \"\\r\\n\";\n        if (params.iceLite) {\n            sdp += \"a=ice-lite\\r\\n\";\n        }\n        return sdp;\n    };\n    // Parses the SDP media section and returns RTCRtpParameters.\n    SDPUtils.parseRtpParameters = function(mediaSection) {\n        const description = {\n            codecs: [],\n            headerExtensions: [],\n            fecMechanisms: [],\n            rtcp: []\n        };\n        const lines = SDPUtils.splitLines(mediaSection);\n        const mline = lines[0].split(\" \");\n        description.profile = mline[2];\n        for(let i = 3; i < mline.length; i++){\n            // find all codecs from mline[3..]\n            const pt = mline[i];\n            const rtpmapline = SDPUtils.matchPrefix(mediaSection, \"a=rtpmap:\" + pt + \" \")[0];\n            if (rtpmapline) {\n                const codec = SDPUtils.parseRtpMap(rtpmapline);\n                const fmtps = SDPUtils.matchPrefix(mediaSection, \"a=fmtp:\" + pt + \" \");\n                // Only the first a=fmtp:<pt> is considered.\n                codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n                codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-fb:\" + pt + \" \").map(SDPUtils.parseRtcpFb);\n                description.codecs.push(codec);\n                // parse FEC mechanisms from rtpmap lines.\n                switch(codec.name.toUpperCase()){\n                    case \"RED\":\n                    case \"ULPFEC\":\n                        description.fecMechanisms.push(codec.name.toUpperCase());\n                        break;\n                }\n            }\n        }\n        SDPUtils.matchPrefix(mediaSection, \"a=extmap:\").forEach((line)=>{\n            description.headerExtensions.push(SDPUtils.parseExtmap(line));\n        });\n        const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-fb:* \").map(SDPUtils.parseRtcpFb);\n        description.codecs.forEach((codec)=>{\n            wildcardRtcpFb.forEach((fb)=>{\n                const duplicate = codec.rtcpFeedback.find((existingFeedback)=>{\n                    return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;\n                });\n                if (!duplicate) {\n                    codec.rtcpFeedback.push(fb);\n                }\n            });\n        });\n        // FIXME: parse rtcp.\n        return description;\n    };\n    // Generates parts of the SDP media section describing the capabilities /\n    // parameters.\n    SDPUtils.writeRtpDescription = function(kind, caps) {\n        let sdp = \"\";\n        // Build the mline.\n        sdp += \"m=\" + kind + \" \";\n        sdp += caps.codecs.length > 0 ? \"9\" : \"0\"; // reject if no codecs.\n        sdp += \" \" + (caps.profile || \"UDP/TLS/RTP/SAVPF\") + \" \";\n        sdp += caps.codecs.map((codec)=>{\n            if (codec.preferredPayloadType !== undefined) {\n                return codec.preferredPayloadType;\n            }\n            return codec.payloadType;\n        }).join(\" \") + \"\\r\\n\";\n        sdp += \"c=IN IP4 0.0.0.0\\r\\n\";\n        sdp += \"a=rtcp:9 IN IP4 0.0.0.0\\r\\n\";\n        // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n        caps.codecs.forEach((codec)=>{\n            sdp += SDPUtils.writeRtpMap(codec);\n            sdp += SDPUtils.writeFmtp(codec);\n            sdp += SDPUtils.writeRtcpFb(codec);\n        });\n        let maxptime = 0;\n        caps.codecs.forEach((codec)=>{\n            if (codec.maxptime > maxptime) {\n                maxptime = codec.maxptime;\n            }\n        });\n        if (maxptime > 0) {\n            sdp += \"a=maxptime:\" + maxptime + \"\\r\\n\";\n        }\n        if (caps.headerExtensions) {\n            caps.headerExtensions.forEach((extension)=>{\n                sdp += SDPUtils.writeExtmap(extension);\n            });\n        }\n        // FIXME: write fecMechanisms.\n        return sdp;\n    };\n    // Parses the SDP media section and returns an array of\n    // RTCRtpEncodingParameters.\n    SDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n        const encodingParameters = [];\n        const description = SDPUtils.parseRtpParameters(mediaSection);\n        const hasRed = description.fecMechanisms.indexOf(\"RED\") !== -1;\n        const hasUlpfec = description.fecMechanisms.indexOf(\"ULPFEC\") !== -1;\n        // filter a=ssrc:... cname:, ignore PlanB-msid\n        const ssrcs = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((parts)=>parts.attribute === \"cname\");\n        const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n        let secondarySsrc;\n        const flows = SDPUtils.matchPrefix(mediaSection, \"a=ssrc-group:FID\").map((line)=>{\n            const parts = line.substring(17).split(\" \");\n            return parts.map((part)=>parseInt(part, 10));\n        });\n        if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n            secondarySsrc = flows[0][1];\n        }\n        description.codecs.forEach((codec)=>{\n            if (codec.name.toUpperCase() === \"RTX\" && codec.parameters.apt) {\n                let encParam = {\n                    ssrc: primarySsrc,\n                    codecPayloadType: parseInt(codec.parameters.apt, 10)\n                };\n                if (primarySsrc && secondarySsrc) {\n                    encParam.rtx = {\n                        ssrc: secondarySsrc\n                    };\n                }\n                encodingParameters.push(encParam);\n                if (hasRed) {\n                    encParam = JSON.parse(JSON.stringify(encParam));\n                    encParam.fec = {\n                        ssrc: primarySsrc,\n                        mechanism: hasUlpfec ? \"red+ulpfec\" : \"red\"\n                    };\n                    encodingParameters.push(encParam);\n                }\n            }\n        });\n        if (encodingParameters.length === 0 && primarySsrc) {\n            encodingParameters.push({\n                ssrc: primarySsrc\n            });\n        }\n        // we support both b=AS and b=TIAS but interpret AS as TIAS.\n        let bandwidth = SDPUtils.matchPrefix(mediaSection, \"b=\");\n        if (bandwidth.length) {\n            if (bandwidth[0].indexOf(\"b=TIAS:\") === 0) {\n                bandwidth = parseInt(bandwidth[0].substring(7), 10);\n            } else if (bandwidth[0].indexOf(\"b=AS:\") === 0) {\n                // use formula from JSEP to convert b=AS to TIAS value.\n                bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\n            } else {\n                bandwidth = undefined;\n            }\n            encodingParameters.forEach((params)=>{\n                params.maxBitrate = bandwidth;\n            });\n        }\n        return encodingParameters;\n    };\n    // parses http://draft.ortc.org/#rtcrtcpparameters*\n    SDPUtils.parseRtcpParameters = function(mediaSection) {\n        const rtcpParameters = {};\n        // Gets the first SSRC. Note that with RTX there might be multiple\n        // SSRCs.\n        const remoteSsrc = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((obj)=>obj.attribute === \"cname\")[0];\n        if (remoteSsrc) {\n            rtcpParameters.cname = remoteSsrc.value;\n            rtcpParameters.ssrc = remoteSsrc.ssrc;\n        }\n        // Edge uses the compound attribute instead of reducedSize\n        // compound is !reducedSize\n        const rsize = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-rsize\");\n        rtcpParameters.reducedSize = rsize.length > 0;\n        rtcpParameters.compound = rsize.length === 0;\n        // parses the rtcp-mux attrbute.\n        // Note that Edge does not support unmuxed RTCP.\n        const mux = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-mux\");\n        rtcpParameters.mux = mux.length > 0;\n        return rtcpParameters;\n    };\n    SDPUtils.writeRtcpParameters = function(rtcpParameters) {\n        let sdp = \"\";\n        if (rtcpParameters.reducedSize) {\n            sdp += \"a=rtcp-rsize\\r\\n\";\n        }\n        if (rtcpParameters.mux) {\n            sdp += \"a=rtcp-mux\\r\\n\";\n        }\n        if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n            sdp += \"a=ssrc:\" + rtcpParameters.ssrc + \" cname:\" + rtcpParameters.cname + \"\\r\\n\";\n        }\n        return sdp;\n    };\n    // parses either a=msid: or a=ssrc:... msid lines and returns\n    // the id of the MediaStream and MediaStreamTrack.\n    SDPUtils.parseMsid = function(mediaSection) {\n        let parts;\n        const spec = SDPUtils.matchPrefix(mediaSection, \"a=msid:\");\n        if (spec.length === 1) {\n            parts = spec[0].substring(7).split(\" \");\n            return {\n                stream: parts[0],\n                track: parts[1]\n            };\n        }\n        const planB = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((msidParts)=>msidParts.attribute === \"msid\");\n        if (planB.length > 0) {\n            parts = planB[0].value.split(\" \");\n            return {\n                stream: parts[0],\n                track: parts[1]\n            };\n        }\n    };\n    // SCTP\n    // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n    // to draft-ietf-mmusic-sctp-sdp-05\n    SDPUtils.parseSctpDescription = function(mediaSection) {\n        const mline = SDPUtils.parseMLine(mediaSection);\n        const maxSizeLine = SDPUtils.matchPrefix(mediaSection, \"a=max-message-size:\");\n        let maxMessageSize;\n        if (maxSizeLine.length > 0) {\n            maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\n        }\n        if (isNaN(maxMessageSize)) {\n            maxMessageSize = 65536;\n        }\n        const sctpPort = SDPUtils.matchPrefix(mediaSection, \"a=sctp-port:\");\n        if (sctpPort.length > 0) {\n            return {\n                port: parseInt(sctpPort[0].substring(12), 10),\n                protocol: mline.fmt,\n                maxMessageSize\n            };\n        }\n        const sctpMapLines = SDPUtils.matchPrefix(mediaSection, \"a=sctpmap:\");\n        if (sctpMapLines.length > 0) {\n            const parts = sctpMapLines[0].substring(10).split(\" \");\n            return {\n                port: parseInt(parts[0], 10),\n                protocol: parts[1],\n                maxMessageSize\n            };\n        }\n    };\n    // SCTP\n    // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n    // support by now receiving in this format, unless we originally parsed\n    // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n    // protocol of DTLS/SCTP -- without UDP/ or TCP/)\n    SDPUtils.writeSctpDescription = function(media, sctp) {\n        let output = [];\n        if (media.protocol !== \"DTLS/SCTP\") {\n            output = [\n                \"m=\" + media.kind + \" 9 \" + media.protocol + \" \" + sctp.protocol + \"\\r\\n\",\n                \"c=IN IP4 0.0.0.0\\r\\n\",\n                \"a=sctp-port:\" + sctp.port + \"\\r\\n\"\n            ];\n        } else {\n            output = [\n                \"m=\" + media.kind + \" 9 \" + media.protocol + \" \" + sctp.port + \"\\r\\n\",\n                \"c=IN IP4 0.0.0.0\\r\\n\",\n                \"a=sctpmap:\" + sctp.port + \" \" + sctp.protocol + \" 65535\\r\\n\"\n            ];\n        }\n        if (sctp.maxMessageSize !== undefined) {\n            output.push(\"a=max-message-size:\" + sctp.maxMessageSize + \"\\r\\n\");\n        }\n        return output.join(\"\");\n    };\n    // Generate a session ID for SDP.\n    // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n    // recommends using a cryptographically random +ve 64-bit value\n    // but right now this should be acceptable and within the right range\n    SDPUtils.generateSessionId = function() {\n        return Math.random().toString().substr(2, 22);\n    };\n    // Write boiler plate for start of SDP\n    // sessId argument is optional - if not supplied it will\n    // be generated randomly\n    // sessVersion is optional and defaults to 2\n    // sessUser is optional and defaults to 'thisisadapterortc'\n    SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n        let sessionId;\n        const version = sessVer !== undefined ? sessVer : 2;\n        if (sessId) {\n            sessionId = sessId;\n        } else {\n            sessionId = SDPUtils.generateSessionId();\n        }\n        const user = sessUser || \"thisisadapterortc\";\n        // FIXME: sess-id should be an NTP timestamp.\n        return \"v=0\\r\\n\" + \"o=\" + user + \" \" + sessionId + \" \" + version + \" IN IP4 127.0.0.1\\r\\n\" + \"s=-\\r\\n\" + \"t=0 0\\r\\n\";\n    };\n    // Gets the direction from the mediaSection or the sessionpart.\n    SDPUtils.getDirection = function(mediaSection, sessionpart) {\n        // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n        const lines = SDPUtils.splitLines(mediaSection);\n        for(let i = 0; i < lines.length; i++){\n            switch(lines[i]){\n                case \"a=sendrecv\":\n                case \"a=sendonly\":\n                case \"a=recvonly\":\n                case \"a=inactive\":\n                    return lines[i].substring(2);\n            }\n        }\n        if (sessionpart) {\n            return SDPUtils.getDirection(sessionpart);\n        }\n        return \"sendrecv\";\n    };\n    SDPUtils.getKind = function(mediaSection) {\n        const lines = SDPUtils.splitLines(mediaSection);\n        const mline = lines[0].split(\" \");\n        return mline[0].substring(2);\n    };\n    SDPUtils.isRejected = function(mediaSection) {\n        return mediaSection.split(\" \", 2)[1] === \"0\";\n    };\n    SDPUtils.parseMLine = function(mediaSection) {\n        const lines = SDPUtils.splitLines(mediaSection);\n        const parts = lines[0].substring(2).split(\" \");\n        return {\n            kind: parts[0],\n            port: parseInt(parts[1], 10),\n            protocol: parts[2],\n            fmt: parts.slice(3).join(\" \")\n        };\n    };\n    SDPUtils.parseOLine = function(mediaSection) {\n        const line = SDPUtils.matchPrefix(mediaSection, \"o=\")[0];\n        const parts = line.substring(2).split(\" \");\n        return {\n            username: parts[0],\n            sessionId: parts[1],\n            sessionVersion: parseInt(parts[2], 10),\n            netType: parts[3],\n            addressType: parts[4],\n            address: parts[5]\n        };\n    };\n    // a very naive interpretation of a valid SDP.\n    SDPUtils.isValidSDP = function(blob) {\n        if (typeof blob !== \"string\" || blob.length === 0) {\n            return false;\n        }\n        const lines = SDPUtils.splitLines(blob);\n        for(let i = 0; i < lines.length; i++){\n            if (lines[i].length < 2 || lines[i].charAt(1) !== \"=\") {\n                return false;\n            }\n        // TODO: check the modifier a bit more.\n        }\n        return true;\n    };\n    // Expose public methods.\n    {\n        module.exports = SDPUtils;\n    }\n})(sdp$1);\nvar sdpExports = sdp$1.exports;\nvar SDPUtils = /*@__PURE__*/ getDefaultExportFromCjs(sdpExports);\nvar sdp = /*#__PURE__*/ _mergeNamespaces({\n    __proto__: null,\n    default: SDPUtils\n}, [\n    sdpExports\n]);\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimRTCIceCandidate(window1) {\n    // foundation is arbitrarily chosen as an indicator for full support for\n    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n    if (!window1.RTCIceCandidate || window1.RTCIceCandidate && \"foundation\" in window1.RTCIceCandidate.prototype) {\n        return;\n    }\n    const NativeRTCIceCandidate = window1.RTCIceCandidate;\n    window1.RTCIceCandidate = function RTCIceCandidate1(args) {\n        // Remove the a= which shouldn't be part of the candidate string.\n        if (typeof args === \"object\" && args.candidate && args.candidate.indexOf(\"a=\") === 0) {\n            args = JSON.parse(JSON.stringify(args));\n            args.candidate = args.candidate.substring(2);\n        }\n        if (args.candidate && args.candidate.length) {\n            // Augment the native candidate with the parsed fields.\n            const nativeCandidate = new NativeRTCIceCandidate(args);\n            const parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n            for(const key in parsedCandidate){\n                if (!(key in nativeCandidate)) {\n                    Object.defineProperty(nativeCandidate, key, {\n                        value: parsedCandidate[key]\n                    });\n                }\n            }\n            // Override serializer to not serialize the extra attributes.\n            nativeCandidate.toJSON = function toJSON() {\n                return {\n                    candidate: nativeCandidate.candidate,\n                    sdpMid: nativeCandidate.sdpMid,\n                    sdpMLineIndex: nativeCandidate.sdpMLineIndex,\n                    usernameFragment: nativeCandidate.usernameFragment\n                };\n            };\n            return nativeCandidate;\n        }\n        return new NativeRTCIceCandidate(args);\n    };\n    window1.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    wrapPeerConnectionEvent(window1, \"icecandidate\", (e)=>{\n        if (e.candidate) {\n            Object.defineProperty(e, \"candidate\", {\n                value: new window1.RTCIceCandidate(e.candidate),\n                writable: \"false\"\n            });\n        }\n        return e;\n    });\n}\nfunction shimRTCIceCandidateRelayProtocol(window1) {\n    if (!window1.RTCIceCandidate || window1.RTCIceCandidate && \"relayProtocol\" in window1.RTCIceCandidate.prototype) {\n        return;\n    }\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    wrapPeerConnectionEvent(window1, \"icecandidate\", (e)=>{\n        if (e.candidate) {\n            const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);\n            if (parsedCandidate.type === \"relay\") {\n                // This is a libwebrtc-specific mapping of local type preference\n                // to relayProtocol.\n                e.candidate.relayProtocol = ({\n                    0: \"tls\",\n                    1: \"tcp\",\n                    2: \"udp\"\n                })[parsedCandidate.priority >> 24];\n            }\n        }\n        return e;\n    });\n}\nfunction shimMaxMessageSize(window1, browserDetails) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    if (!(\"sctp\" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, \"sctp\", {\n            get () {\n                return typeof this._sctp === \"undefined\" ? null : this._sctp;\n            }\n        });\n    }\n    const sctpInDescription = function(description) {\n        if (!description || !description.sdp) {\n            return false;\n        }\n        const sections = SDPUtils.splitSections(description.sdp);\n        sections.shift();\n        return sections.some((mediaSection)=>{\n            const mLine = SDPUtils.parseMLine(mediaSection);\n            return mLine && mLine.kind === \"application\" && mLine.protocol.indexOf(\"SCTP\") !== -1;\n        });\n    };\n    const getRemoteFirefoxVersion = function(description) {\n        // TODO: Is there a better solution for detecting Firefox?\n        const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n        if (match === null || match.length < 2) {\n            return -1;\n        }\n        const version = parseInt(match[1], 10);\n        // Test for NaN (yes, this is ugly)\n        return version !== version ? -1 : version;\n    };\n    const getCanSendMaxMessageSize = function(remoteIsFirefox) {\n        // Every implementation we know can send at least 64 KiB.\n        // Note: Although Chrome is technically able to send up to 256 KiB, the\n        //       data does not reach the other peer reliably.\n        //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n        let canSendMaxMessageSize = 65536;\n        if (browserDetails.browser === \"firefox\") {\n            if (browserDetails.version < 57) {\n                if (remoteIsFirefox === -1) {\n                    // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n                    // fragmentation.\n                    canSendMaxMessageSize = 16384;\n                } else {\n                    // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n                    // messages. Thus, supporting ~2 GiB when sending.\n                    canSendMaxMessageSize = 2147483637;\n                }\n            } else if (browserDetails.version < 60) {\n                // Currently, all FF >= 57 will reset the remote maximum message size\n                // to the default value when a data channel is created at a later\n                // stage. :(\n                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n                canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\n            } else {\n                // FF >= 60 supports sending ~2 GiB\n                canSendMaxMessageSize = 2147483637;\n            }\n        }\n        return canSendMaxMessageSize;\n    };\n    const getMaxMessageSize = function(description, remoteIsFirefox) {\n        // Note: 65536 bytes is the default value from the SDP spec. Also,\n        //       every implementation we know supports receiving 65536 bytes.\n        let maxMessageSize = 65536;\n        // FF 57 has a slightly incorrect default remote max message size, so\n        // we need to adjust it here to avoid a failure when sending.\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n        if (browserDetails.browser === \"firefox\" && browserDetails.version === 57) {\n            maxMessageSize = 65535;\n        }\n        const match = SDPUtils.matchPrefix(description.sdp, \"a=max-message-size:\");\n        if (match.length > 0) {\n            maxMessageSize = parseInt(match[0].substring(19), 10);\n        } else if (browserDetails.browser === \"firefox\" && remoteIsFirefox !== -1) {\n            // If the maximum message size is not present in the remote SDP and\n            // both local and remote are Firefox, the remote peer can receive\n            // ~2 GiB.\n            maxMessageSize = 2147483637;\n        }\n        return maxMessageSize;\n    };\n    const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n    window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n        this._sctp = null;\n        // Chrome decided to not expose .sctp in plan-b mode.\n        // As usual, adapter.js has to do an 'ugly worakaround'\n        // to cover up the mess.\n        if (browserDetails.browser === \"chrome\" && browserDetails.version >= 76) {\n            const { sdpSemantics } = this.getConfiguration();\n            if (sdpSemantics === \"plan-b\") {\n                Object.defineProperty(this, \"sctp\", {\n                    get () {\n                        return typeof this._sctp === \"undefined\" ? null : this._sctp;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n            }\n        }\n        if (sctpInDescription(arguments[0])) {\n            // Check if the remote is FF.\n            const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n            // Get the maximum message size the local peer is capable of sending\n            const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n            // Get the maximum message size of the remote peer.\n            const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n            // Determine final maximum message size\n            let maxMessageSize;\n            if (canSendMMS === 0 && remoteMMS === 0) {\n                maxMessageSize = Number.POSITIVE_INFINITY;\n            } else if (canSendMMS === 0 || remoteMMS === 0) {\n                maxMessageSize = Math.max(canSendMMS, remoteMMS);\n            } else {\n                maxMessageSize = Math.min(canSendMMS, remoteMMS);\n            }\n            // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n            // attribute.\n            const sctp = {};\n            Object.defineProperty(sctp, \"maxMessageSize\", {\n                get () {\n                    return maxMessageSize;\n                }\n            });\n            this._sctp = sctp;\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n    };\n}\nfunction shimSendThrowTypeError(window1) {\n    if (!(window1.RTCPeerConnection && \"createDataChannel\" in window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    // Note: Although Firefox >= 57 has a native implementation, the maximum\n    //       message size can be reset for all data channels at a later stage.\n    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n    function wrapDcSend(dc, pc) {\n        const origDataChannelSend = dc.send;\n        dc.send = function send() {\n            const data = arguments[0];\n            const length = data.length || data.size || data.byteLength;\n            if (dc.readyState === \"open\" && pc.sctp && length > pc.sctp.maxMessageSize) {\n                throw new TypeError(\"Message too large (can send a maximum of \" + pc.sctp.maxMessageSize + \" bytes)\");\n            }\n            return origDataChannelSend.apply(dc, arguments);\n        };\n    }\n    const origCreateDataChannel = window1.RTCPeerConnection.prototype.createDataChannel;\n    window1.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {\n        const dataChannel = origCreateDataChannel.apply(this, arguments);\n        wrapDcSend(dataChannel, this);\n        return dataChannel;\n    };\n    wrapPeerConnectionEvent(window1, \"datachannel\", (e)=>{\n        wrapDcSend(e.channel, e.target);\n        return e;\n    });\n}\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */ function shimConnectionState(window1) {\n    if (!window1.RTCPeerConnection || \"connectionState\" in window1.RTCPeerConnection.prototype) {\n        return;\n    }\n    const proto = window1.RTCPeerConnection.prototype;\n    Object.defineProperty(proto, \"connectionState\", {\n        get () {\n            return ({\n                completed: \"connected\",\n                checking: \"connecting\"\n            })[this.iceConnectionState] || this.iceConnectionState;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(proto, \"onconnectionstatechange\", {\n        get () {\n            return this._onconnectionstatechange || null;\n        },\n        set (cb) {\n            if (this._onconnectionstatechange) {\n                this.removeEventListener(\"connectionstatechange\", this._onconnectionstatechange);\n                delete this._onconnectionstatechange;\n            }\n            if (cb) {\n                this.addEventListener(\"connectionstatechange\", this._onconnectionstatechange = cb);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    [\n        \"setLocalDescription\",\n        \"setRemoteDescription\"\n    ].forEach((method)=>{\n        const origMethod = proto[method];\n        proto[method] = function() {\n            if (!this._connectionstatechangepoly) {\n                this._connectionstatechangepoly = (e)=>{\n                    const pc = e.target;\n                    if (pc._lastConnectionState !== pc.connectionState) {\n                        pc._lastConnectionState = pc.connectionState;\n                        const newEvent = new Event(\"connectionstatechange\", e);\n                        pc.dispatchEvent(newEvent);\n                    }\n                    return e;\n                };\n                this.addEventListener(\"iceconnectionstatechange\", this._connectionstatechangepoly);\n            }\n            return origMethod.apply(this, arguments);\n        };\n    });\n}\nfunction removeExtmapAllowMixed(window1, browserDetails) {\n    /* remove a=extmap-allow-mixed for webrtc.org < M71 */ if (!window1.RTCPeerConnection) {\n        return;\n    }\n    if (browserDetails.browser === \"chrome\" && browserDetails.version >= 71) {\n        return;\n    }\n    if (browserDetails.browser === \"safari\" && browserDetails.version >= 605) {\n        return;\n    }\n    const nativeSRD = window1.RTCPeerConnection.prototype.setRemoteDescription;\n    window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {\n        if (desc && desc.sdp && desc.sdp.indexOf(\"\\na=extmap-allow-mixed\") !== -1) {\n            const sdp = desc.sdp.split(\"\\n\").filter((line)=>{\n                return line.trim() !== \"a=extmap-allow-mixed\";\n            }).join(\"\\n\");\n            // Safari enforces read-only-ness of RTCSessionDescription fields.\n            if (window1.RTCSessionDescription && desc instanceof window1.RTCSessionDescription) {\n                arguments[0] = new window1.RTCSessionDescription({\n                    type: desc.type,\n                    sdp\n                });\n            } else {\n                desc.sdp = sdp;\n            }\n        }\n        return nativeSRD.apply(this, arguments);\n    };\n}\nfunction shimAddIceCandidateNullOrEmpty(window1, browserDetails) {\n    // Support for addIceCandidate(null or undefined)\n    // as well as addIceCandidate({candidate: \"\", ...})\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n    // Note: must be called before other polyfills which change the signature.\n    if (!(window1.RTCPeerConnection && window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    const nativeAddIceCandidate = window1.RTCPeerConnection.prototype.addIceCandidate;\n    if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\n        if (!arguments[0]) {\n            if (arguments[1]) {\n                arguments[1].apply(null);\n            }\n            return Promise.resolve();\n        }\n        // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n        // in older versions.\n        // Native support for ignoring exists for Chrome M77+.\n        // Safari ignores as well, exact version unknown but works in the same\n        // version that also ignores addIceCandidate(null).\n        if ((browserDetails.browser === \"chrome\" && browserDetails.version < 78 || browserDetails.browser === \"firefox\" && browserDetails.version < 68 || browserDetails.browser === \"safari\") && arguments[0] && arguments[0].candidate === \"\") {\n            return Promise.resolve();\n        }\n        return nativeAddIceCandidate.apply(this, arguments);\n    };\n}\n// Note: Make sure to call this ahead of APIs that modify\n// setLocalDescription.length\nfunction shimParameterlessSetLocalDescription(window1, browserDetails) {\n    if (!(window1.RTCPeerConnection && window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    const nativeSetLocalDescription = window1.RTCPeerConnection.prototype.setLocalDescription;\n    if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n        let desc = arguments[0] || {};\n        if (typeof desc !== \"object\" || desc.type && desc.sdp) {\n            return nativeSetLocalDescription.apply(this, arguments);\n        }\n        // The remaining steps should technically happen when SLD comes off the\n        // RTCPeerConnection's operations chain (not ahead of going on it), but\n        // this is too difficult to shim. Instead, this shim only covers the\n        // common case where the operations chain is empty. This is imperfect, but\n        // should cover many cases. Rationale: Even if we can't reduce the glare\n        // window to zero on imperfect implementations, there's value in tapping\n        // into the perfect negotiation pattern that several browsers support.\n        desc = {\n            type: desc.type,\n            sdp: desc.sdp\n        };\n        if (!desc.type) {\n            switch(this.signalingState){\n                case \"stable\":\n                case \"have-local-offer\":\n                case \"have-remote-pranswer\":\n                    desc.type = \"offer\";\n                    break;\n                default:\n                    desc.type = \"answer\";\n                    break;\n            }\n        }\n        if (desc.sdp || desc.type !== \"offer\" && desc.type !== \"answer\") {\n            return nativeSetLocalDescription.apply(this, [\n                desc\n            ]);\n        }\n        const func = desc.type === \"offer\" ? this.createOffer : this.createAnswer;\n        return func.apply(this).then((d)=>nativeSetLocalDescription.apply(this, [\n                d\n            ]));\n    };\n}\nvar commonShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    removeExtmapAllowMixed: removeExtmapAllowMixed,\n    shimAddIceCandidateNullOrEmpty: shimAddIceCandidateNullOrEmpty,\n    shimConnectionState: shimConnectionState,\n    shimMaxMessageSize: shimMaxMessageSize,\n    shimParameterlessSetLocalDescription: shimParameterlessSetLocalDescription,\n    shimRTCIceCandidate: shimRTCIceCandidate,\n    shimRTCIceCandidateRelayProtocol: shimRTCIceCandidateRelayProtocol,\n    shimSendThrowTypeError: shimSendThrowTypeError\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ // Shimming starts here.\nfunction adapterFactory() {\n    let { window: window1 } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        shimChrome: true,\n        shimFirefox: true,\n        shimSafari: true\n    };\n    // Utils.\n    const logging = log;\n    const browserDetails = detectBrowser(window1);\n    const adapter = {\n        browserDetails,\n        commonShim,\n        extractVersion: extractVersion,\n        disableLog: disableLog,\n        disableWarnings: disableWarnings,\n        // Expose sdp as a convenience. For production apps include directly.\n        sdp\n    };\n    // Shim browser if found.\n    switch(browserDetails.browser){\n        case \"chrome\":\n            if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {\n                logging(\"Chrome shim is not included in this adapter release.\");\n                return adapter;\n            }\n            if (browserDetails.version === null) {\n                logging(\"Chrome shim can not determine version, not shimming.\");\n                return adapter;\n            }\n            logging(\"adapter.js shimming chrome.\");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = chromeShim;\n            // Must be called before shimPeerConnection.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimGetUserMedia$2(window1, browserDetails);\n            shimMediaStream(window1);\n            shimPeerConnection$1(window1, browserDetails);\n            shimOnTrack$1(window1);\n            shimAddTrackRemoveTrack(window1, browserDetails);\n            shimGetSendersWithDtmf(window1);\n            shimGetStats(window1);\n            shimSenderReceiverGetStats(window1);\n            fixNegotiationNeeded(window1, browserDetails);\n            shimRTCIceCandidate(window1);\n            shimRTCIceCandidateRelayProtocol(window1);\n            shimConnectionState(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            removeExtmapAllowMixed(window1, browserDetails);\n            break;\n        case \"firefox\":\n            if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {\n                logging(\"Firefox shim is not included in this adapter release.\");\n                return adapter;\n            }\n            logging(\"adapter.js shimming firefox.\");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = firefoxShim;\n            // Must be called before shimPeerConnection.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimGetUserMedia$1(window1, browserDetails);\n            shimPeerConnection(window1, browserDetails);\n            shimOnTrack(window1);\n            shimRemoveStream(window1);\n            shimSenderGetStats(window1);\n            shimReceiverGetStats(window1);\n            shimRTCDataChannel(window1);\n            shimAddTransceiver(window1);\n            shimGetParameters(window1);\n            shimCreateOffer(window1);\n            shimCreateAnswer(window1);\n            shimRTCIceCandidate(window1);\n            shimConnectionState(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            break;\n        case \"safari\":\n            if (!safariShim || !options.shimSafari) {\n                logging(\"Safari shim is not included in this adapter release.\");\n                return adapter;\n            }\n            logging(\"adapter.js shimming safari.\");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = safariShim;\n            // Must be called before shimCallbackAPI.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimRTCIceServerUrls(window1);\n            shimCreateOfferLegacy(window1);\n            shimCallbacksAPI(window1);\n            shimLocalStreamsAPI(window1);\n            shimRemoteStreamsAPI(window1);\n            shimTrackEventTransceiver(window1);\n            shimGetUserMedia(window1);\n            shimAudioContext(window1);\n            shimRTCIceCandidate(window1);\n            shimRTCIceCandidateRelayProtocol(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            removeExtmapAllowMixed(window1, browserDetails);\n            break;\n        default:\n            logging(\"Unsupported browser!\");\n            break;\n    }\n    return adapter;\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ adapterFactory({\n    window:  true ? undefined : 0\n});\nconst ENCRYPTION_ALGORITHM = \"AES-GCM\";\n// How many consecutive frames can fail decrypting before a particular key gets marked as invalid\nconst DECRYPTION_FAILURE_TOLERANCE = 10;\n// flag set to indicate that e2ee has been setup for sender/receiver;\nconst E2EE_FLAG = \"lk_e2ee\";\nconst SALT = \"LKFrameEncryptionKey\";\nconst KEY_PROVIDER_DEFAULTS = {\n    sharedKey: false,\n    ratchetSalt: SALT,\n    ratchetWindowSize: 8,\n    failureTolerance: DECRYPTION_FAILURE_TOLERANCE\n};\nvar KeyProviderEvent;\n(function(KeyProviderEvent) {\n    KeyProviderEvent[\"SetKey\"] = \"setKey\";\n    KeyProviderEvent[\"RatchetRequest\"] = \"ratchetRequest\";\n    KeyProviderEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyProviderEvent || (KeyProviderEvent = {}));\nvar KeyHandlerEvent;\n(function(KeyHandlerEvent) {\n    KeyHandlerEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyHandlerEvent || (KeyHandlerEvent = {}));\nvar EncryptionEvent;\n(function(EncryptionEvent) {\n    EncryptionEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n    EncryptionEvent[\"EncryptionError\"] = \"encryptionError\";\n})(EncryptionEvent || (EncryptionEvent = {}));\nvar CryptorEvent;\n(function(CryptorEvent) {\n    CryptorEvent[\"Error\"] = \"cryptorError\";\n})(CryptorEvent || (CryptorEvent = {}));\nfunction isE2EESupported() {\n    return isInsertableStreamSupported() || isScriptTransformSupported();\n}\nfunction isScriptTransformSupported() {\n    // @ts-ignore\n    return typeof window.RTCRtpScriptTransform !== \"undefined\";\n}\nfunction isInsertableStreamSupported() {\n    return typeof window.RTCRtpSender !== \"undefined\" && // @ts-ignore\n    typeof window.RTCRtpSender.prototype.createEncodedStreams !== \"undefined\";\n}\nfunction isVideoFrame(frame) {\n    return \"type\" in frame;\n}\nfunction importKey(keyBytes) {\n    let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        name: ENCRYPTION_ALGORITHM\n    };\n    let usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"encrypt\";\n    return __awaiter(this, void 0, void 0, function*() {\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\n        return crypto.subtle.importKey(\"raw\", keyBytes, algorithm, false, usage === \"derive\" ? [\n            \"deriveBits\",\n            \"deriveKey\"\n        ] : [\n            \"encrypt\",\n            \"decrypt\"\n        ]);\n    });\n}\nfunction createKeyMaterialFromString(password) {\n    return __awaiter(this, void 0, void 0, function*() {\n        let enc = new TextEncoder();\n        const keyMaterial = yield crypto.subtle.importKey(\"raw\", enc.encode(password), {\n            name: \"PBKDF2\"\n        }, false, [\n            \"deriveBits\",\n            \"deriveKey\"\n        ]);\n        return keyMaterial;\n    });\n}\nfunction createKeyMaterialFromBuffer(cryptoBuffer) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const keyMaterial = yield crypto.subtle.importKey(\"raw\", cryptoBuffer, \"HKDF\", false, [\n            \"deriveBits\",\n            \"deriveKey\"\n        ]);\n        return keyMaterial;\n    });\n}\nfunction getAlgoOptions(algorithmName, salt) {\n    const textEncoder = new TextEncoder();\n    const encodedSalt = textEncoder.encode(salt);\n    switch(algorithmName){\n        case \"HKDF\":\n            return {\n                name: \"HKDF\",\n                salt: encodedSalt,\n                hash: \"SHA-256\",\n                info: new ArrayBuffer(128)\n            };\n        case \"PBKDF2\":\n            {\n                return {\n                    name: \"PBKDF2\",\n                    salt: encodedSalt,\n                    hash: \"SHA-256\",\n                    iterations: 100000\n                };\n            }\n        default:\n            throw new Error(\"algorithm \".concat(algorithmName, \" is currently unsupported\"));\n    }\n}\n/**\n * Derives a set of keys from the master key.\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\n */ function deriveKeys(material, salt) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\n        // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\n        const encryptionKey = yield crypto.subtle.deriveKey(algorithmOptions, material, {\n            name: ENCRYPTION_ALGORITHM,\n            length: 128\n        }, false, [\n            \"encrypt\",\n            \"decrypt\"\n        ]);\n        return {\n            material,\n            encryptionKey\n        };\n    });\n}\nfunction createE2EEKey() {\n    return window.crypto.getRandomValues(new Uint8Array(32));\n}\n/**\n * Ratchets a key. See\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\n */ function ratchet(material, salt) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\n        return crypto.subtle.deriveBits(algorithmOptions, material, 256);\n    });\n}\nfunction needsRbspUnescaping(frameData) {\n    for(var i = 0; i < frameData.length - 3; i++){\n        if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;\n    }\n    return false;\n}\nfunction parseRbsp(stream) {\n    const dataOut = [];\n    var length = stream.length;\n    for(var i = 0; i < stream.length;){\n        // Be careful about over/underflow here. byte_length_ - 3 can underflow, and\n        // i + 3 can overflow, but byte_length_ - i can't, because i < byte_length_\n        // above, and that expression will produce the number of bytes left in\n        // the stream including the byte at i.\n        if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {\n            // Two rbsp bytes.\n            dataOut.push(stream[i++]);\n            dataOut.push(stream[i++]);\n            // Skip the emulation byte.\n            i++;\n        } else {\n            // Single rbsp byte.\n            dataOut.push(stream[i++]);\n        }\n    }\n    return new Uint8Array(dataOut);\n}\nconst kZerosInStartSequence = 2;\nconst kEmulationByte = 3;\nfunction writeRbsp(data_in) {\n    const dataOut = [];\n    var numConsecutiveZeros = 0;\n    for(var i = 0; i < data_in.length; ++i){\n        var byte = data_in[i];\n        if (byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {\n            // Need to escape.\n            dataOut.push(kEmulationByte);\n            numConsecutiveZeros = 0;\n        }\n        dataOut.push(byte);\n        if (byte == 0) {\n            ++numConsecutiveZeros;\n        } else {\n            numConsecutiveZeros = 0;\n        }\n    }\n    return new Uint8Array(dataOut);\n}\n/**\n * @experimental\n */ class BaseKeyProvider extends eventsExports.EventEmitter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        super();\n        /**\n     * callback being invoked after a ratchet request has been performed on a participant\n     * that surfaces the new key material.\n     * @param material\n     * @param keyIndex\n     */ this.onKeyRatcheted = (material, keyIndex)=>{\n            livekitLogger.debug(\"key ratcheted event received\", {\n                material,\n                keyIndex\n            });\n        };\n        this.keyInfoMap = new Map();\n        this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);\n        this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);\n    }\n    /**\n   * callback to invoke once a key has been set for a participant\n   * @param key\n   * @param participantIdentity\n   * @param keyIndex\n   */ onSetEncryptionKey(key, participantIdentity, keyIndex) {\n        const keyInfo = {\n            key,\n            participantIdentity,\n            keyIndex\n        };\n        this.keyInfoMap.set(\"\".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : \"shared\", \"-\").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);\n        this.emit(KeyProviderEvent.SetKey, keyInfo);\n    }\n    getKeys() {\n        return Array.from(this.keyInfoMap.values());\n    }\n    getOptions() {\n        return this.options;\n    }\n    ratchetKey(participantIdentity, keyIndex) {\n        this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);\n    }\n}\n/**\n * A basic KeyProvider implementation intended for a single shared\n * passphrase between all participants\n * @experimental\n */ class ExternalE2EEKeyProvider extends BaseKeyProvider {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const opts = Object.assign(Object.assign({}, options), {\n            sharedKey: true,\n            // for a shared key provider failing to decrypt for a specific participant\n            // should not mark the key as invalid, so we accept wrong keys forever\n            // and won't try to auto-ratchet\n            ratchetWindowSize: 0,\n            failureTolerance: -1\n        });\n        super(opts);\n    }\n    /**\n   * Accepts a passphrase that's used to create the crypto keys.\n   * When passing in a string, PBKDF2 is used.\n   * When passing in an Array buffer of cryptographically random numbers, HKDF is being used. (recommended)\n   * @param key\n   */ setKey(key) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const derivedKey = typeof key === \"string\" ? yield createKeyMaterialFromString(key) : yield createKeyMaterialFromBuffer(key);\n            this.onSetEncryptionKey(derivedKey);\n        });\n    }\n}\nclass LivekitError extends Error {\n    constructor(code, message){\n        super(message || \"an error has occured\");\n        this.code = code;\n    }\n}\nclass ConnectionError extends LivekitError {\n    constructor(message, reason, status){\n        super(1, message);\n        this.status = status;\n        this.reason = reason;\n    }\n}\nclass DeviceUnsupportedError extends LivekitError {\n    constructor(message){\n        super(21, message !== null && message !== void 0 ? message : \"device is unsupported\");\n    }\n}\nclass TrackInvalidError extends LivekitError {\n    constructor(message){\n        super(20, message !== null && message !== void 0 ? message : \"track is invalid\");\n    }\n}\nclass UnsupportedServer extends LivekitError {\n    constructor(message){\n        super(10, message !== null && message !== void 0 ? message : \"unsupported server\");\n    }\n}\nclass UnexpectedConnectionState extends LivekitError {\n    constructor(message){\n        super(12, message !== null && message !== void 0 ? message : \"unexpected connection state\");\n    }\n}\nclass NegotiationError extends LivekitError {\n    constructor(message){\n        super(13, message !== null && message !== void 0 ? message : \"unable to negotiate\");\n    }\n}\nclass PublishDataError extends LivekitError {\n    constructor(message){\n        super(13, message !== null && message !== void 0 ? message : \"unable to publish data\");\n    }\n}\nvar MediaDeviceFailure;\n(function(MediaDeviceFailure) {\n    // user rejected permissions\n    MediaDeviceFailure[\"PermissionDenied\"] = \"PermissionDenied\";\n    // device is not available\n    MediaDeviceFailure[\"NotFound\"] = \"NotFound\";\n    // device is in use. On Windows, only a single tab may get access to a device at a time.\n    MediaDeviceFailure[\"DeviceInUse\"] = \"DeviceInUse\";\n    MediaDeviceFailure[\"Other\"] = \"Other\";\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n(function(MediaDeviceFailure) {\n    function getFailure(error) {\n        if (error && \"name\" in error) {\n            if (error.name === \"NotFoundError\" || error.name === \"DevicesNotFoundError\") {\n                return MediaDeviceFailure.NotFound;\n            }\n            if (error.name === \"NotAllowedError\" || error.name === \"PermissionDeniedError\") {\n                return MediaDeviceFailure.PermissionDenied;\n            }\n            if (error.name === \"NotReadableError\" || error.name === \"TrackStartError\") {\n                return MediaDeviceFailure.DeviceInUse;\n            }\n            return MediaDeviceFailure.Other;\n        }\n    }\n    MediaDeviceFailure.getFailure = getFailure;\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n/**\n * Events are the primary way LiveKit notifies your application of changes.\n *\n * The following are events emitted by [[Room]], listen to room events like\n *\n * ```typescript\n * room.on(RoomEvent.TrackPublished, (track, publication, participant) => {})\n * ```\n */ var RoomEvent;\n(function(RoomEvent) {\n    /**\n   * When the connection to the server has been established\n   */ RoomEvent[\"Connected\"] = \"connected\";\n    /**\n   * When the connection to the server has been interrupted and it's attempting\n   * to reconnect.\n   */ RoomEvent[\"Reconnecting\"] = \"reconnecting\";\n    /**\n   * Fires when a reconnection has been successful.\n   */ RoomEvent[\"Reconnected\"] = \"reconnected\";\n    /**\n   * When disconnected from room. This fires when room.disconnect() is called or\n   * when an unrecoverable connection issue had occured\n   */ RoomEvent[\"Disconnected\"] = \"disconnected\";\n    /**\n   * Whenever the connection state of the room changes\n   *\n   * args: ([[ConnectionState]])\n   */ RoomEvent[\"ConnectionStateChanged\"] = \"connectionStateChanged\";\n    /**\n   * @deprecated StateChanged has been renamed to ConnectionStateChanged\n   */ RoomEvent[\"StateChanged\"] = \"connectionStateChanged\";\n    /**\n   * When input or output devices on the machine have changed.\n   */ RoomEvent[\"MediaDevicesChanged\"] = \"mediaDevicesChanged\";\n    /**\n   * When a [[RemoteParticipant]] joins *after* the local\n   * participant. It will not emit events for participants that are already\n   * in the room\n   *\n   * args: ([[RemoteParticipant]])\n   */ RoomEvent[\"ParticipantConnected\"] = \"participantConnected\";\n    /**\n   * When a [[RemoteParticipant]] leaves *after* the local\n   * participant has joined.\n   *\n   * args: ([[RemoteParticipant]])\n   */ RoomEvent[\"ParticipantDisconnected\"] = \"participantDisconnected\";\n    /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackPublished\"] = \"trackPublished\";\n    /**\n   * The [[LocalParticipant]] has subscribed to a new track. This event will **always**\n   * fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n    /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid, [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n    /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n    /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[Track]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n    /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */ RoomEvent[\"TrackMuted\"] = \"trackMuted\";\n    /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */ RoomEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n    /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */ RoomEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n    /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */ RoomEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n    /**\n   * When a local audio track is published the SDK checks whether there is complete silence\n   * on that track and emits the LocalAudioSilenceDetected event in that case.\n   * This allows for applications to show UI informing users that they might have to\n   * reset their audio hardware or check for proper device connectivity.\n   */ RoomEvent[\"LocalAudioSilenceDetected\"] = \"localAudioSilenceDetected\";\n    /**\n   * Active speakers changed. List of speakers are ordered by their audio level.\n   * loudest speakers first. This will include the LocalParticipant too.\n   *\n   * Speaker updates are sent only to the publishing participant and their subscribers.\n   *\n   * args: (Array<[[Participant]]>)\n   */ RoomEvent[\"ActiveSpeakersChanged\"] = \"activeSpeakersChanged\";\n    /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   *\n   * args: (prevMetadata: string, [[Participant]])\n   *\n   */ RoomEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n    /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */ RoomEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n    /**\n   * Room metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateRoomMetadata is called to change a room's state,\n   * *all*  participants in the room will fire this event.\n   *\n   * args: (string)\n   */ RoomEvent[\"RoomMetadataChanged\"] = \"roomMetadataChanged\";\n    /**\n   * Data received from another participant.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, participant: [[Participant]], kind: [[DataPacket_Kind]], topic?: string)\n   */ RoomEvent[\"DataReceived\"] = \"dataReceived\";\n    /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]], participant: [[Participant]])\n   */ RoomEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n    /**\n   * StreamState indicates if a subscribed (remote) track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n    /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.PermissionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n    /**\n   * One of subscribed tracks have changed its status for the current\n   * participant.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n    /**\n   * LiveKit will attempt to autoplay all audio tracks when you attach them to\n   * audio elements. However, if that fails, we'll notify you via AudioPlaybackStatusChanged.\n   * `Room.canPlaybackAudio` will indicate if audio playback is permitted.\n   */ RoomEvent[\"AudioPlaybackStatusChanged\"] = \"audioPlaybackChanged\";\n    /**\n   * LiveKit will attempt to autoplay all video tracks when you attach them to\n   * a video element. However, if that fails, we'll notify you via VideoPlaybackStatusChanged.\n   * Calling `room.startVideo()` in a user gesture event handler will resume the video playback.\n   */ RoomEvent[\"VideoPlaybackStatusChanged\"] = \"videoPlaybackChanged\";\n    /**\n   * When we have encountered an error while attempting to create a track.\n   * The errors take place in getUserMedia().\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\n   * [[LocalParticipant.lastCameraError]] and [[LocalParticipant.lastMicrophoneError]]\n   * will indicate if it had an error while creating the audio or video track respectively.\n   *\n   * args: (error: Error)\n   */ RoomEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n    /**\n   * A participant's permission has changed. Currently only fired on LocalParticipant.\n   * args: (prevPermissions: [[ParticipantPermission]], participant: [[Participant]])\n   */ RoomEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n    /**\n   * Signal connected, can publish tracks.\n   */ RoomEvent[\"SignalConnected\"] = \"signalConnected\";\n    /**\n   * Recording of a room has started/stopped. Room.isRecording will be updated too.\n   * args: (isRecording: boolean)\n   */ RoomEvent[\"RecordingStatusChanged\"] = \"recordingStatusChanged\";\n    RoomEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n    RoomEvent[\"EncryptionError\"] = \"encryptionError\";\n    /**\n   * Emits whenever the current buffer status of a data channel changes\n   * args: (isLow: boolean, kind: [[DataPacket_Kind]])\n   */ RoomEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n    /**\n   * Triggered by a call to room.switchActiveDevice\n   * args: (kind: MediaDeviceKind, deviceId: string)\n   */ RoomEvent[\"ActiveDeviceChanged\"] = \"activeDeviceChanged\";\n})(RoomEvent || (RoomEvent = {}));\nvar ParticipantEvent;\n(function(ParticipantEvent) {\n    /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackPublished\"] = \"trackPublished\";\n    /**\n   * Successfully subscribed to the [[RemoteParticipant]]'s track.\n   * This event will **always** fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n    /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid)\n   */ ParticipantEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n    /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n    /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n    /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */ ParticipantEvent[\"TrackMuted\"] = \"trackMuted\";\n    /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */ ParticipantEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n    /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]])\n   */ ParticipantEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n    /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]])\n   */ ParticipantEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n    /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   * To access the current metadata, see [[Participant.metadata]].\n   *\n   * args: (prevMetadata: string)\n   *\n   */ ParticipantEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n    /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */ ParticipantEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n    /**\n   * Data received from this participant as sender.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, kind: [[DataPacket_Kind]])\n   */ ParticipantEvent[\"DataReceived\"] = \"dataReceived\";\n    /**\n   * Has speaking status changed for the current participant\n   *\n   * args: (speaking: boolean)\n   */ ParticipantEvent[\"IsSpeakingChanged\"] = \"isSpeakingChanged\";\n    /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]])\n   */ ParticipantEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n    /**\n   * StreamState indicates if a subscribed track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]])\n   */ ParticipantEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n    /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]])\n   */ ParticipantEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n    /**\n   * One of the remote participants publications has changed its subscription status.\n   *\n   */ ParticipantEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n    // fired only on LocalParticipant\n    /** @internal */ ParticipantEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n    // fired only on LocalParticipant\n    /** @internal */ ParticipantEvent[\"AudioStreamAcquired\"] = \"audioStreamAcquired\";\n    /**\n   * A participant's permission has changed. Currently only fired on LocalParticipant.\n   * args: (prevPermissions: [[ParticipantPermission]])\n   */ ParticipantEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n    /** @internal */ ParticipantEvent[\"PCTrackAdded\"] = \"pcTrackAdded\";\n})(ParticipantEvent || (ParticipantEvent = {}));\n/** @internal */ var EngineEvent;\n(function(EngineEvent) {\n    EngineEvent[\"TransportsCreated\"] = \"transportsCreated\";\n    EngineEvent[\"Connected\"] = \"connected\";\n    EngineEvent[\"Disconnected\"] = \"disconnected\";\n    EngineEvent[\"Resuming\"] = \"resuming\";\n    EngineEvent[\"Resumed\"] = \"resumed\";\n    EngineEvent[\"Restarting\"] = \"restarting\";\n    EngineEvent[\"Restarted\"] = \"restarted\";\n    EngineEvent[\"SignalResumed\"] = \"signalResumed\";\n    EngineEvent[\"SignalRestarted\"] = \"signalRestarted\";\n    EngineEvent[\"Closing\"] = \"closing\";\n    EngineEvent[\"MediaTrackAdded\"] = \"mediaTrackAdded\";\n    EngineEvent[\"ActiveSpeakersUpdate\"] = \"activeSpeakersUpdate\";\n    EngineEvent[\"DataPacketReceived\"] = \"dataPacketReceived\";\n    EngineEvent[\"RTPVideoMapUpdate\"] = \"rtpVideoMapUpdate\";\n    EngineEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n    EngineEvent[\"ParticipantUpdate\"] = \"participantUpdate\";\n    EngineEvent[\"RoomUpdate\"] = \"roomUpdate\";\n    EngineEvent[\"SpeakersChanged\"] = \"speakersChanged\";\n    EngineEvent[\"StreamStateChanged\"] = \"streamStateChanged\";\n    EngineEvent[\"ConnectionQualityUpdate\"] = \"connectionQualityUpdate\";\n    EngineEvent[\"SubscriptionError\"] = \"subscriptionError\";\n    EngineEvent[\"SubscriptionPermissionUpdate\"] = \"subscriptionPermissionUpdate\";\n    EngineEvent[\"RemoteMute\"] = \"remoteMute\";\n    EngineEvent[\"SubscribedQualityUpdate\"] = \"subscribedQualityUpdate\";\n    EngineEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n})(EngineEvent || (EngineEvent = {}));\nvar TrackEvent;\n(function(TrackEvent) {\n    TrackEvent[\"Message\"] = \"message\";\n    TrackEvent[\"Muted\"] = \"muted\";\n    TrackEvent[\"Unmuted\"] = \"unmuted\";\n    /**\n   * Only fires on LocalTracks\n   */ TrackEvent[\"Restarted\"] = \"restarted\";\n    TrackEvent[\"Ended\"] = \"ended\";\n    TrackEvent[\"Subscribed\"] = \"subscribed\";\n    TrackEvent[\"Unsubscribed\"] = \"unsubscribed\";\n    /** @internal */ TrackEvent[\"UpdateSettings\"] = \"updateSettings\";\n    /** @internal */ TrackEvent[\"UpdateSubscription\"] = \"updateSubscription\";\n    /** @internal */ TrackEvent[\"AudioPlaybackStarted\"] = \"audioPlaybackStarted\";\n    /** @internal */ TrackEvent[\"AudioPlaybackFailed\"] = \"audioPlaybackFailed\";\n    /**\n   * @internal\n   * Only fires on LocalAudioTrack instances\n   */ TrackEvent[\"AudioSilenceDetected\"] = \"audioSilenceDetected\";\n    /** @internal */ TrackEvent[\"VisibilityChanged\"] = \"visibilityChanged\";\n    /** @internal */ TrackEvent[\"VideoDimensionsChanged\"] = \"videoDimensionsChanged\";\n    /** @internal */ TrackEvent[\"VideoPlaybackStarted\"] = \"videoPlaybackStarted\";\n    /** @internal */ TrackEvent[\"VideoPlaybackFailed\"] = \"videoPlaybackFailed\";\n    /** @internal */ TrackEvent[\"ElementAttached\"] = \"elementAttached\";\n    /** @internal */ TrackEvent[\"ElementDetached\"] = \"elementDetached\";\n    /**\n   * @internal\n   * Only fires on LocalTracks\n   */ TrackEvent[\"UpstreamPaused\"] = \"upstreamPaused\";\n    /**\n   * @internal\n   * Only fires on LocalTracks\n   */ TrackEvent[\"UpstreamResumed\"] = \"upstreamResumed\";\n    /**\n   * @internal\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionPermissionChanged\"] = \"subscriptionPermissionChanged\";\n    /**\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionStatusChanged\"] = \"subscriptionStatusChanged\";\n    /**\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionFailed\"] = \"subscriptionFailed\";\n})(TrackEvent || (TrackEvent = {}));\nfunction r(r, e, n) {\n    var i, t, o;\n    void 0 === e && (e = 50), void 0 === n && (n = {});\n    var a = null != (i = n.isImmediate) && i, u = null != (t = n.callback) && t, c = n.maxWait, v = Date.now(), l = [];\n    function f() {\n        if (void 0 !== c) {\n            var r = Date.now() - v;\n            if (r + e >= c) return c - r;\n        }\n        return e;\n    }\n    var d = function() {\n        var e = [].slice.call(arguments), n = this;\n        return new Promise(function(i, t) {\n            var c = a && void 0 === o;\n            if (void 0 !== o && clearTimeout(o), o = setTimeout(function() {\n                if (o = void 0, v = Date.now(), !a) {\n                    var i = r.apply(n, e);\n                    u && u(i), l.forEach(function(r) {\n                        return (0, r.resolve)(i);\n                    }), l = [];\n                }\n            }, f()), c) {\n                var d = r.apply(n, e);\n                return u && u(d), i(d);\n            }\n            l.push({\n                resolve: i,\n                reject: t\n            });\n        });\n    };\n    return d.cancel = function(r) {\n        void 0 !== o && clearTimeout(o), l.forEach(function(e) {\n            return (0, e.reject)(r);\n        }), l = [];\n    }, d;\n}\n// tiny, simplified version of https://github.com/lancedikson/bowser/blob/master/src/parser-browsers.js\n// reduced to only differentiate Chrome(ium) based browsers / Firefox / Safari\nconst commonVersionIdentifier = /version\\/(\\d+(\\.?_?\\d+)+)/i;\nlet browserDetails;\n/**\n * @internal\n */ function getBrowser(userAgent) {\n    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (typeof userAgent === \"undefined\" && typeof navigator === \"undefined\") {\n        return;\n    }\n    const ua = (userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent).toLowerCase();\n    if (browserDetails === undefined || force) {\n        const browser = browsersList.find((_ref)=>{\n            let { test } = _ref;\n            return test.test(ua);\n        });\n        browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);\n    }\n    return browserDetails;\n}\nconst browsersList = [\n    {\n        test: /firefox|iceweasel|fxios/i,\n        describe (ua) {\n            const browser = {\n                name: \"Firefox\",\n                version: getMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, ua),\n                os: ua.toLowerCase().includes(\"fxios\") ? \"iOS\" : undefined\n            };\n            return browser;\n        }\n    },\n    {\n        test: /chrom|crios|crmo/i,\n        describe (ua) {\n            const browser = {\n                name: \"Chrome\",\n                version: getMatch(/(?:chrome|chromium|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i, ua),\n                os: ua.toLowerCase().includes(\"crios\") ? \"iOS\" : undefined\n            };\n            return browser;\n        }\n    },\n    /* Safari */ {\n        test: /safari|applewebkit/i,\n        describe (ua) {\n            const browser = {\n                name: \"Safari\",\n                version: getMatch(commonVersionIdentifier, ua),\n                os: ua.includes(\"mobile/\") ? \"iOS\" : \"macOS\"\n            };\n            return browser;\n        }\n    }\n];\nfunction getMatch(exp, ua) {\n    let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const match = ua.match(exp);\n    return match && match.length >= id && match[id] || \"\";\n}\nvar version$1 = \"1.15.10\";\nconst version = version$1;\nconst protocolVersion = 11;\n/**\n * Timers that can be overridden with platform specific implementations\n * that ensure that they are fired. These should be used when it is critical\n * that the timer fires on time.\n */ class CriticalTimers {\n}\n// eslint-disable-next-line @typescript-eslint/no-implied-eval\nCriticalTimers.setTimeout = function() {\n    return setTimeout(...arguments);\n};\n// eslint-disable-next-line @typescript-eslint/no-implied-eval\nCriticalTimers.setInterval = function() {\n    return setInterval(...arguments);\n};\nCriticalTimers.clearTimeout = function() {\n    return clearTimeout(...arguments);\n};\nCriticalTimers.clearInterval = function() {\n    return clearInterval(...arguments);\n};\nclass VideoPreset {\n    constructor(width, height, maxBitrate, maxFramerate, priority){\n        this.width = width;\n        this.height = height;\n        this.encoding = {\n            maxBitrate,\n            maxFramerate,\n            priority\n        };\n    }\n    get resolution() {\n        return {\n            width: this.width,\n            height: this.height,\n            frameRate: this.encoding.maxFramerate,\n            aspectRatio: this.width / this.height\n        };\n    }\n}\nconst backupCodecs = [\n    \"vp8\",\n    \"h264\"\n];\nconst videoCodecs = [\n    \"vp8\",\n    \"h264\",\n    \"vp9\",\n    \"av1\"\n];\nfunction isBackupCodec(codec) {\n    return !!backupCodecs.find((backup)=>backup === codec);\n}\nvar AudioPresets;\n(function(AudioPresets) {\n    AudioPresets.telephone = {\n        maxBitrate: 12000\n    };\n    AudioPresets.speech = {\n        maxBitrate: 20000\n    };\n    AudioPresets.music = {\n        maxBitrate: 32000\n    };\n    AudioPresets.musicStereo = {\n        maxBitrate: 48000\n    };\n    AudioPresets.musicHighQuality = {\n        maxBitrate: 64000\n    };\n    AudioPresets.musicHighQualityStereo = {\n        maxBitrate: 96000\n    };\n})(AudioPresets || (AudioPresets = {}));\n/**\n * Sane presets for video resolution/encoding\n */ const VideoPresets = {\n    h90: new VideoPreset(160, 90, 90000, 20),\n    h180: new VideoPreset(320, 180, 160000, 20),\n    h216: new VideoPreset(384, 216, 180000, 20),\n    h360: new VideoPreset(640, 360, 450000, 20),\n    h540: new VideoPreset(960, 540, 800000, 25),\n    h720: new VideoPreset(1280, 720, 1700000, 30),\n    h1080: new VideoPreset(1920, 1080, 3000000, 30),\n    h1440: new VideoPreset(2560, 1440, 5000000, 30),\n    h2160: new VideoPreset(3840, 2160, 8000000, 30)\n};\n/**\n * Four by three presets\n */ const VideoPresets43 = {\n    h120: new VideoPreset(160, 120, 70000, 20),\n    h180: new VideoPreset(240, 180, 125000, 20),\n    h240: new VideoPreset(320, 240, 140000, 20),\n    h360: new VideoPreset(480, 360, 330000, 20),\n    h480: new VideoPreset(640, 480, 500000, 20),\n    h540: new VideoPreset(720, 540, 600000, 25),\n    h720: new VideoPreset(960, 720, 1300000, 30),\n    h1080: new VideoPreset(1440, 1080, 2300000, 30),\n    h1440: new VideoPreset(1920, 1440, 3800000, 30)\n};\nconst ScreenSharePresets = {\n    h360fps3: new VideoPreset(640, 360, 200000, 3, \"medium\"),\n    h360fps15: new VideoPreset(640, 360, 400000, 15, \"medium\"),\n    h720fps5: new VideoPreset(1280, 720, 800000, 5, \"medium\"),\n    h720fps15: new VideoPreset(1280, 720, 1500000, 15, \"medium\"),\n    h720fps30: new VideoPreset(1280, 720, 2000000, 30, \"medium\"),\n    h1080fps15: new VideoPreset(1920, 1080, 2500000, 15, \"medium\"),\n    h1080fps30: new VideoPreset(1920, 1080, 5000000, 30, \"medium\"),\n    // original resolution, without resizing\n    original: new VideoPreset(0, 0, 7000000, 30, \"medium\")\n};\n// Copyright 2023 LiveKit, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @generated from enum livekit.SignalTarget\n */ var SignalTarget;\n(function(SignalTarget) {\n    /**\n   * @generated from enum value: PUBLISHER = 0;\n   */ SignalTarget[SignalTarget[\"PUBLISHER\"] = 0] = \"PUBLISHER\";\n    /**\n   * @generated from enum value: SUBSCRIBER = 1;\n   */ SignalTarget[SignalTarget[\"SUBSCRIBER\"] = 1] = \"SUBSCRIBER\";\n})(SignalTarget || (SignalTarget = {}));\n// Retrieve enum metadata with: proto3.getEnumType(SignalTarget)\nproto3.util.setEnumType(SignalTarget, \"livekit.SignalTarget\", [\n    {\n        no: 0,\n        name: \"PUBLISHER\"\n    },\n    {\n        no: 1,\n        name: \"SUBSCRIBER\"\n    }\n]);\n/**\n * @generated from enum livekit.StreamState\n */ var StreamState;\n(function(StreamState) {\n    /**\n   * @generated from enum value: ACTIVE = 0;\n   */ StreamState[StreamState[\"ACTIVE\"] = 0] = \"ACTIVE\";\n    /**\n   * @generated from enum value: PAUSED = 1;\n   */ StreamState[StreamState[\"PAUSED\"] = 1] = \"PAUSED\";\n})(StreamState || (StreamState = {}));\n// Retrieve enum metadata with: proto3.getEnumType(StreamState)\nproto3.util.setEnumType(StreamState, \"livekit.StreamState\", [\n    {\n        no: 0,\n        name: \"ACTIVE\"\n    },\n    {\n        no: 1,\n        name: \"PAUSED\"\n    }\n]);\n/**\n * @generated from enum livekit.CandidateProtocol\n */ var CandidateProtocol;\n(function(CandidateProtocol) {\n    /**\n   * @generated from enum value: UDP = 0;\n   */ CandidateProtocol[CandidateProtocol[\"UDP\"] = 0] = \"UDP\";\n    /**\n   * @generated from enum value: TCP = 1;\n   */ CandidateProtocol[CandidateProtocol[\"TCP\"] = 1] = \"TCP\";\n    /**\n   * @generated from enum value: TLS = 2;\n   */ CandidateProtocol[CandidateProtocol[\"TLS\"] = 2] = \"TLS\";\n})(CandidateProtocol || (CandidateProtocol = {}));\n// Retrieve enum metadata with: proto3.getEnumType(CandidateProtocol)\nproto3.util.setEnumType(CandidateProtocol, \"livekit.CandidateProtocol\", [\n    {\n        no: 0,\n        name: \"UDP\"\n    },\n    {\n        no: 1,\n        name: \"TCP\"\n    },\n    {\n        no: 2,\n        name: \"TLS\"\n    }\n]);\n/**\n * @generated from message livekit.SignalRequest\n */ class SignalRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from oneof livekit.SignalRequest.message\n     */ this.message = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SignalRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SignalRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SignalRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SignalRequest, a, b);\n    }\n}\nSignalRequest.runtime = proto3;\nSignalRequest.typeName = \"livekit.SignalRequest\";\nSignalRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 2,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 3,\n            name: \"trickle\",\n            kind: \"message\",\n            T: TrickleRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 4,\n            name: \"add_track\",\n            kind: \"message\",\n            T: AddTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 5,\n            name: \"mute\",\n            kind: \"message\",\n            T: MuteTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 6,\n            name: \"subscription\",\n            kind: \"message\",\n            T: UpdateSubscription,\n            oneof: \"message\"\n        },\n        {\n            no: 7,\n            name: \"track_setting\",\n            kind: \"message\",\n            T: UpdateTrackSettings,\n            oneof: \"message\"\n        },\n        {\n            no: 8,\n            name: \"leave\",\n            kind: \"message\",\n            T: LeaveRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 10,\n            name: \"update_layers\",\n            kind: \"message\",\n            T: UpdateVideoLayers,\n            oneof: \"message\"\n        },\n        {\n            no: 11,\n            name: \"subscription_permission\",\n            kind: \"message\",\n            T: SubscriptionPermission,\n            oneof: \"message\"\n        },\n        {\n            no: 12,\n            name: \"sync_state\",\n            kind: \"message\",\n            T: SyncState,\n            oneof: \"message\"\n        },\n        {\n            no: 13,\n            name: \"simulate\",\n            kind: \"message\",\n            T: SimulateScenario,\n            oneof: \"message\"\n        },\n        {\n            no: 14,\n            name: \"ping\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ ,\n            oneof: \"message\"\n        },\n        {\n            no: 15,\n            name: \"update_metadata\",\n            kind: \"message\",\n            T: UpdateParticipantMetadata,\n            oneof: \"message\"\n        },\n        {\n            no: 16,\n            name: \"ping_req\",\n            kind: \"message\",\n            T: Ping,\n            oneof: \"message\"\n        }\n    ]);\n/**\n * @generated from message livekit.SignalResponse\n */ class SignalResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from oneof livekit.SignalResponse.message\n     */ this.message = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SignalResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SignalResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SignalResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SignalResponse, a, b);\n    }\n}\nSignalResponse.runtime = proto3;\nSignalResponse.typeName = \"livekit.SignalResponse\";\nSignalResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"join\",\n            kind: \"message\",\n            T: JoinResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 2,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 3,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 4,\n            name: \"trickle\",\n            kind: \"message\",\n            T: TrickleRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 5,\n            name: \"update\",\n            kind: \"message\",\n            T: ParticipantUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 6,\n            name: \"track_published\",\n            kind: \"message\",\n            T: TrackPublishedResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 8,\n            name: \"leave\",\n            kind: \"message\",\n            T: LeaveRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 9,\n            name: \"mute\",\n            kind: \"message\",\n            T: MuteTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 10,\n            name: \"speakers_changed\",\n            kind: \"message\",\n            T: SpeakersChanged,\n            oneof: \"message\"\n        },\n        {\n            no: 11,\n            name: \"room_update\",\n            kind: \"message\",\n            T: RoomUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 12,\n            name: \"connection_quality\",\n            kind: \"message\",\n            T: ConnectionQualityUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 13,\n            name: \"stream_state_update\",\n            kind: \"message\",\n            T: StreamStateUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 14,\n            name: \"subscribed_quality_update\",\n            kind: \"message\",\n            T: SubscribedQualityUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 15,\n            name: \"subscription_permission_update\",\n            kind: \"message\",\n            T: SubscriptionPermissionUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 16,\n            name: \"refresh_token\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            oneof: \"message\"\n        },\n        {\n            no: 17,\n            name: \"track_unpublished\",\n            kind: \"message\",\n            T: TrackUnpublishedResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 18,\n            name: \"pong\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ ,\n            oneof: \"message\"\n        },\n        {\n            no: 19,\n            name: \"reconnect\",\n            kind: \"message\",\n            T: ReconnectResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 20,\n            name: \"pong_resp\",\n            kind: \"message\",\n            T: Pong,\n            oneof: \"message\"\n        },\n        {\n            no: 21,\n            name: \"subscription_response\",\n            kind: \"message\",\n            T: SubscriptionResponse,\n            oneof: \"message\"\n        }\n    ]);\n/**\n * @generated from message livekit.SimulcastCodec\n */ class SimulcastCodec extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string codec = 1;\n     */ this.codec = \"\";\n        /**\n     * @generated from field: string cid = 2;\n     */ this.cid = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SimulcastCodec().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SimulcastCodec().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SimulcastCodec().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SimulcastCodec, a, b);\n    }\n}\nSimulcastCodec.runtime = proto3;\nSimulcastCodec.typeName = \"livekit.SimulcastCodec\";\nSimulcastCodec.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"codec\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.AddTrackRequest\n */ class AddTrackRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * client ID of track, to match it when RTC track is received\n     *\n     * @generated from field: string cid = 1;\n     */ this.cid = \"\";\n        /**\n     * @generated from field: string name = 2;\n     */ this.name = \"\";\n        /**\n     * @generated from field: livekit.TrackType type = 3;\n     */ this.type = TrackType.AUDIO;\n        /**\n     * to be deprecated in favor of layers\n     *\n     * @generated from field: uint32 width = 4;\n     */ this.width = 0;\n        /**\n     * @generated from field: uint32 height = 5;\n     */ this.height = 0;\n        /**\n     * true to add track and initialize to muted\n     *\n     * @generated from field: bool muted = 6;\n     */ this.muted = false;\n        /**\n     * true if DTX (Discontinuous Transmission) is disabled for audio\n     *\n     * @generated from field: bool disable_dtx = 7;\n     */ this.disableDtx = false;\n        /**\n     * @generated from field: livekit.TrackSource source = 8;\n     */ this.source = TrackSource.UNKNOWN;\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 9;\n     */ this.layers = [];\n        /**\n     * @generated from field: repeated livekit.SimulcastCodec simulcast_codecs = 10;\n     */ this.simulcastCodecs = [];\n        /**\n     * server ID of track, publish new codec to exist track\n     *\n     * @generated from field: string sid = 11;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: bool stereo = 12;\n     */ this.stereo = false;\n        /**\n     * true if RED (Redundant Encoding) is disabled for audio\n     *\n     * @generated from field: bool disable_red = 13;\n     */ this.disableRed = false;\n        /**\n     * @generated from field: livekit.Encryption.Type encryption = 14;\n     */ this.encryption = Encryption_Type.NONE;\n        /**\n     * which stream the track belongs to, used to group tracks together.\n     * if not specified, server will infer it from track source to bundle camera/microphone, screenshare/audio together\n     *\n     * @generated from field: string stream = 15;\n     */ this.stream = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new AddTrackRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new AddTrackRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new AddTrackRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(AddTrackRequest, a, b);\n    }\n}\nAddTrackRequest.runtime = proto3;\nAddTrackRequest.typeName = \"livekit.AddTrackRequest\";\nAddTrackRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackType)\n        },\n        {\n            no: 4,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 6,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 7,\n            name: \"disable_dtx\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 8,\n            name: \"source\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource)\n        },\n        {\n            no: 9,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 10,\n            name: \"simulcast_codecs\",\n            kind: \"message\",\n            T: SimulcastCodec,\n            repeated: true\n        },\n        {\n            no: 11,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 12,\n            name: \"stereo\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 13,\n            name: \"disable_red\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 14,\n            name: \"encryption\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 15,\n            name: \"stream\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.TrickleRequest\n */ class TrickleRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string candidateInit = 1;\n     */ this.candidateInit = \"\";\n        /**\n     * @generated from field: livekit.SignalTarget target = 2;\n     */ this.target = SignalTarget.PUBLISHER;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrickleRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrickleRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrickleRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrickleRequest, a, b);\n    }\n}\nTrickleRequest.runtime = proto3;\nTrickleRequest.typeName = \"livekit.TrickleRequest\";\nTrickleRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"candidateInit\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"target\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SignalTarget)\n        }\n    ]);\n/**\n * @generated from message livekit.MuteTrackRequest\n */ class MuteTrackRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: bool muted = 2;\n     */ this.muted = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new MuteTrackRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new MuteTrackRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new MuteTrackRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(MuteTrackRequest, a, b);\n    }\n}\nMuteTrackRequest.runtime = proto3;\nMuteTrackRequest.typeName = \"livekit.MuteTrackRequest\";\nMuteTrackRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.JoinResponse\n */ class JoinResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ParticipantInfo other_participants = 3;\n     */ this.otherParticipants = [];\n        /**\n     * deprecated. use server_info.version instead.\n     *\n     * @generated from field: string server_version = 4;\n     */ this.serverVersion = \"\";\n        /**\n     * @generated from field: repeated livekit.ICEServer ice_servers = 5;\n     */ this.iceServers = [];\n        /**\n     * use subscriber as the primary PeerConnection\n     *\n     * @generated from field: bool subscriber_primary = 6;\n     */ this.subscriberPrimary = false;\n        /**\n     * when the current server isn't available, return alternate url to retry connection\n     * when this is set, the other fields will be largely empty\n     *\n     * @generated from field: string alternative_url = 7;\n     */ this.alternativeUrl = \"\";\n        /**\n     * deprecated. use server_info.region instead.\n     *\n     * @generated from field: string server_region = 9;\n     */ this.serverRegion = \"\";\n        /**\n     * @generated from field: int32 ping_timeout = 10;\n     */ this.pingTimeout = 0;\n        /**\n     * @generated from field: int32 ping_interval = 11;\n     */ this.pingInterval = 0;\n        /**\n     * Server-Injected-Frame byte trailer, used to identify unencrypted frames when e2ee is enabled\n     *\n     * @generated from field: bytes sif_trailer = 13;\n     */ this.sifTrailer = new Uint8Array(0);\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new JoinResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new JoinResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new JoinResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(JoinResponse, a, b);\n    }\n}\nJoinResponse.runtime = proto3;\nJoinResponse.typeName = \"livekit.JoinResponse\";\nJoinResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"room\",\n            kind: \"message\",\n            T: Room$1\n        },\n        {\n            no: 2,\n            name: \"participant\",\n            kind: \"message\",\n            T: ParticipantInfo\n        },\n        {\n            no: 3,\n            name: \"other_participants\",\n            kind: \"message\",\n            T: ParticipantInfo,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"server_version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"ice_servers\",\n            kind: \"message\",\n            T: ICEServer,\n            repeated: true\n        },\n        {\n            no: 6,\n            name: \"subscriber_primary\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 7,\n            name: \"alternative_url\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 8,\n            name: \"client_configuration\",\n            kind: \"message\",\n            T: ClientConfiguration\n        },\n        {\n            no: 9,\n            name: \"server_region\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 10,\n            name: \"ping_timeout\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 11,\n            name: \"ping_interval\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 12,\n            name: \"server_info\",\n            kind: \"message\",\n            T: ServerInfo\n        },\n        {\n            no: 13,\n            name: \"sif_trailer\",\n            kind: \"scalar\",\n            T: 12 /* ScalarType.BYTES */ \n        }\n    ]);\n/**\n * @generated from message livekit.ReconnectResponse\n */ class ReconnectResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ICEServer ice_servers = 1;\n     */ this.iceServers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ReconnectResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ReconnectResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ReconnectResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ReconnectResponse, a, b);\n    }\n}\nReconnectResponse.runtime = proto3;\nReconnectResponse.typeName = \"livekit.ReconnectResponse\";\nReconnectResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"ice_servers\",\n            kind: \"message\",\n            T: ICEServer,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"client_configuration\",\n            kind: \"message\",\n            T: ClientConfiguration\n        }\n    ]);\n/**\n * @generated from message livekit.TrackPublishedResponse\n */ class TrackPublishedResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string cid = 1;\n     */ this.cid = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackPublishedResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackPublishedResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackPublishedResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackPublishedResponse, a, b);\n    }\n}\nTrackPublishedResponse.runtime = proto3;\nTrackPublishedResponse.typeName = \"livekit.TrackPublishedResponse\";\nTrackPublishedResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"track\",\n            kind: \"message\",\n            T: TrackInfo\n        }\n    ]);\n/**\n * @generated from message livekit.TrackUnpublishedResponse\n */ class TrackUnpublishedResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackUnpublishedResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackUnpublishedResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackUnpublishedResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackUnpublishedResponse, a, b);\n    }\n}\nTrackUnpublishedResponse.runtime = proto3;\nTrackUnpublishedResponse.typeName = \"livekit.TrackUnpublishedResponse\";\nTrackUnpublishedResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.SessionDescription\n */ class SessionDescription extends Message {\n    constructor(data){\n        super();\n        /**\n     * \"answer\" | \"offer\" | \"pranswer\" | \"rollback\"\n     *\n     * @generated from field: string type = 1;\n     */ this.type = \"\";\n        /**\n     * @generated from field: string sdp = 2;\n     */ this.sdp = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SessionDescription().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SessionDescription().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SessionDescription().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SessionDescription, a, b);\n    }\n}\nSessionDescription.runtime = proto3;\nSessionDescription.typeName = \"livekit.SessionDescription\";\nSessionDescription.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"type\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"sdp\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantUpdate\n */ class ParticipantUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ParticipantInfo participants = 1;\n     */ this.participants = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantUpdate, a, b);\n    }\n}\nParticipantUpdate.runtime = proto3;\nParticipantUpdate.typeName = \"livekit.ParticipantUpdate\";\nParticipantUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participants\",\n            kind: \"message\",\n            T: ParticipantInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.UpdateSubscription\n */ class UpdateSubscription extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated string track_sids = 1;\n     */ this.trackSids = [];\n        /**\n     * @generated from field: bool subscribe = 2;\n     */ this.subscribe = false;\n        /**\n     * @generated from field: repeated livekit.ParticipantTracks participant_tracks = 3;\n     */ this.participantTracks = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateSubscription().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateSubscription().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateSubscription().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateSubscription, a, b);\n    }\n}\nUpdateSubscription.runtime = proto3;\nUpdateSubscription.typeName = \"livekit.UpdateSubscription\";\nUpdateSubscription.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"subscribe\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 3,\n            name: \"participant_tracks\",\n            kind: \"message\",\n            T: ParticipantTracks,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.UpdateTrackSettings\n */ class UpdateTrackSettings extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated string track_sids = 1;\n     */ this.trackSids = [];\n        /**\n     * when true, the track is placed in a paused state, with no new data returned\n     *\n     * @generated from field: bool disabled = 3;\n     */ this.disabled = false;\n        /**\n     * deprecated in favor of width & height\n     *\n     * @generated from field: livekit.VideoQuality quality = 4;\n     */ this.quality = VideoQuality.LOW;\n        /**\n     * for video, width to receive\n     *\n     * @generated from field: uint32 width = 5;\n     */ this.width = 0;\n        /**\n     * for video, height to receive\n     *\n     * @generated from field: uint32 height = 6;\n     */ this.height = 0;\n        /**\n     * @generated from field: uint32 fps = 7;\n     */ this.fps = 0;\n        /**\n     * subscription priority. 1 being the highest (0 is unset)\n     * when unset, server sill assign priority based on the order of subscription\n     * server will use priority in the following ways:\n     * 1. when subscribed tracks exceed per-participant subscription limit, server will\n     *    pause the lowest priority tracks\n     * 2. when the network is congested, server will assign available bandwidth to\n     *    higher priority tracks first. lowest priority tracks can be paused\n     *\n     * @generated from field: uint32 priority = 8;\n     */ this.priority = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateTrackSettings().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateTrackSettings().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateTrackSettings().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateTrackSettings, a, b);\n    }\n}\nUpdateTrackSettings.runtime = proto3;\nUpdateTrackSettings.typeName = \"livekit.UpdateTrackSettings\";\nUpdateTrackSettings.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 3,\n            name: \"disabled\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 4,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality)\n        },\n        {\n            no: 5,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 6,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 7,\n            name: \"fps\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 8,\n            name: \"priority\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        }\n    ]);\n/**\n * @generated from message livekit.LeaveRequest\n */ class LeaveRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * sent when server initiates the disconnect due to server-restart\n     * indicates clients should attempt full-reconnect sequence\n     *\n     * @generated from field: bool can_reconnect = 1;\n     */ this.canReconnect = false;\n        /**\n     * @generated from field: livekit.DisconnectReason reason = 2;\n     */ this.reason = DisconnectReason.UNKNOWN_REASON;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new LeaveRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new LeaveRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new LeaveRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(LeaveRequest, a, b);\n    }\n}\nLeaveRequest.runtime = proto3;\nLeaveRequest.typeName = \"livekit.LeaveRequest\";\nLeaveRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"can_reconnect\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: \"reason\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DisconnectReason)\n        }\n    ]);\n/**\n * message to indicate published video track dimensions are changing\n *\n * @generated from message livekit.UpdateVideoLayers\n */ class UpdateVideoLayers extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 2;\n     */ this.layers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateVideoLayers().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateVideoLayers().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateVideoLayers().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateVideoLayers, a, b);\n    }\n}\nUpdateVideoLayers.runtime = proto3;\nUpdateVideoLayers.typeName = \"livekit.UpdateVideoLayers\";\nUpdateVideoLayers.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.UpdateParticipantMetadata\n */ class UpdateParticipantMetadata extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string metadata = 1;\n     */ this.metadata = \"\";\n        /**\n     * @generated from field: string name = 2;\n     */ this.name = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateParticipantMetadata().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateParticipantMetadata().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateParticipantMetadata().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateParticipantMetadata, a, b);\n    }\n}\nUpdateParticipantMetadata.runtime = proto3;\nUpdateParticipantMetadata.typeName = \"livekit.UpdateParticipantMetadata\";\nUpdateParticipantMetadata.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.ICEServer\n */ class ICEServer extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated string urls = 1;\n     */ this.urls = [];\n        /**\n     * @generated from field: string username = 2;\n     */ this.username = \"\";\n        /**\n     * @generated from field: string credential = 3;\n     */ this.credential = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ICEServer().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ICEServer().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ICEServer().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ICEServer, a, b);\n    }\n}\nICEServer.runtime = proto3;\nICEServer.typeName = \"livekit.ICEServer\";\nICEServer.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"urls\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"username\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"credential\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.SpeakersChanged\n */ class SpeakersChanged extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.SpeakerInfo speakers = 1;\n     */ this.speakers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SpeakersChanged().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SpeakersChanged().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SpeakersChanged().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SpeakersChanged, a, b);\n    }\n}\nSpeakersChanged.runtime = proto3;\nSpeakersChanged.typeName = \"livekit.SpeakersChanged\";\nSpeakersChanged.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"speakers\",\n            kind: \"message\",\n            T: SpeakerInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.RoomUpdate\n */ class RoomUpdate extends Message {\n    constructor(data){\n        super();\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RoomUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RoomUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RoomUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RoomUpdate, a, b);\n    }\n}\nRoomUpdate.runtime = proto3;\nRoomUpdate.typeName = \"livekit.RoomUpdate\";\nRoomUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"room\",\n            kind: \"message\",\n            T: Room$1\n        }\n    ]);\n/**\n * @generated from message livekit.ConnectionQualityInfo\n */ class ConnectionQualityInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: livekit.ConnectionQuality quality = 2;\n     */ this.quality = ConnectionQuality$1.POOR;\n        /**\n     * @generated from field: float score = 3;\n     */ this.score = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ConnectionQualityInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ConnectionQualityInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ConnectionQualityInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ConnectionQualityInfo, a, b);\n    }\n}\nConnectionQualityInfo.runtime = proto3;\nConnectionQualityInfo.typeName = \"livekit.ConnectionQualityInfo\";\nConnectionQualityInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ConnectionQuality$1)\n        },\n        {\n            no: 3,\n            name: \"score\",\n            kind: \"scalar\",\n            T: 2 /* ScalarType.FLOAT */ \n        }\n    ]);\n/**\n * @generated from message livekit.ConnectionQualityUpdate\n */ class ConnectionQualityUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ConnectionQualityInfo updates = 1;\n     */ this.updates = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ConnectionQualityUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ConnectionQualityUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ConnectionQualityUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ConnectionQualityUpdate, a, b);\n    }\n}\nConnectionQualityUpdate.runtime = proto3;\nConnectionQualityUpdate.typeName = \"livekit.ConnectionQualityUpdate\";\nConnectionQualityUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"updates\",\n            kind: \"message\",\n            T: ConnectionQualityInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.StreamStateInfo\n */ class StreamStateInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: string track_sid = 2;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: livekit.StreamState state = 3;\n     */ this.state = StreamState.ACTIVE;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new StreamStateInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new StreamStateInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new StreamStateInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(StreamStateInfo, a, b);\n    }\n}\nStreamStateInfo.runtime = proto3;\nStreamStateInfo.typeName = \"livekit.StreamStateInfo\";\nStreamStateInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"state\",\n            kind: \"enum\",\n            T: proto3.getEnumType(StreamState)\n        }\n    ]);\n/**\n * @generated from message livekit.StreamStateUpdate\n */ class StreamStateUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.StreamStateInfo stream_states = 1;\n     */ this.streamStates = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new StreamStateUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new StreamStateUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new StreamStateUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(StreamStateUpdate, a, b);\n    }\n}\nStreamStateUpdate.runtime = proto3;\nStreamStateUpdate.typeName = \"livekit.StreamStateUpdate\";\nStreamStateUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"stream_states\",\n            kind: \"message\",\n            T: StreamStateInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SubscribedQuality\n */ class SubscribedQuality extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.VideoQuality quality = 1;\n     */ this.quality = VideoQuality.LOW;\n        /**\n     * @generated from field: bool enabled = 2;\n     */ this.enabled = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscribedQuality().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscribedQuality().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscribedQuality().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscribedQuality, a, b);\n    }\n}\nSubscribedQuality.runtime = proto3;\nSubscribedQuality.typeName = \"livekit.SubscribedQuality\";\nSubscribedQuality.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality)\n        },\n        {\n            no: 2,\n            name: \"enabled\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.SubscribedCodec\n */ class SubscribedCodec extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string codec = 1;\n     */ this.codec = \"\";\n        /**\n     * @generated from field: repeated livekit.SubscribedQuality qualities = 2;\n     */ this.qualities = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscribedCodec().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscribedCodec().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscribedCodec().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscribedCodec, a, b);\n    }\n}\nSubscribedCodec.runtime = proto3;\nSubscribedCodec.typeName = \"livekit.SubscribedCodec\";\nSubscribedCodec.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"codec\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"qualities\",\n            kind: \"message\",\n            T: SubscribedQuality,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SubscribedQualityUpdate\n */ class SubscribedQualityUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: repeated livekit.SubscribedQuality subscribed_qualities = 2;\n     */ this.subscribedQualities = [];\n        /**\n     * @generated from field: repeated livekit.SubscribedCodec subscribed_codecs = 3;\n     */ this.subscribedCodecs = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscribedQualityUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscribedQualityUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscribedQualityUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscribedQualityUpdate, a, b);\n    }\n}\nSubscribedQualityUpdate.runtime = proto3;\nSubscribedQualityUpdate.typeName = \"livekit.SubscribedQualityUpdate\";\nSubscribedQualityUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"subscribed_qualities\",\n            kind: \"message\",\n            T: SubscribedQuality,\n            repeated: true\n        },\n        {\n            no: 3,\n            name: \"subscribed_codecs\",\n            kind: \"message\",\n            T: SubscribedCodec,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.TrackPermission\n */ class TrackPermission extends Message {\n    constructor(data){\n        super();\n        /**\n     * permission could be granted either by participant sid or identity\n     *\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: bool all_tracks = 2;\n     */ this.allTracks = false;\n        /**\n     * @generated from field: repeated string track_sids = 3;\n     */ this.trackSids = [];\n        /**\n     * @generated from field: string participant_identity = 4;\n     */ this.participantIdentity = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackPermission().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackPermission().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackPermission().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackPermission, a, b);\n    }\n}\nTrackPermission.runtime = proto3;\nTrackPermission.typeName = \"livekit.TrackPermission\";\nTrackPermission.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"all_tracks\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 3,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.SubscriptionPermission\n */ class SubscriptionPermission extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: bool all_participants = 1;\n     */ this.allParticipants = false;\n        /**\n     * @generated from field: repeated livekit.TrackPermission track_permissions = 2;\n     */ this.trackPermissions = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscriptionPermission().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscriptionPermission().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscriptionPermission().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscriptionPermission, a, b);\n    }\n}\nSubscriptionPermission.runtime = proto3;\nSubscriptionPermission.typeName = \"livekit.SubscriptionPermission\";\nSubscriptionPermission.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"all_participants\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: \"track_permissions\",\n            kind: \"message\",\n            T: TrackPermission,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SubscriptionPermissionUpdate\n */ class SubscriptionPermissionUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: string track_sid = 2;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: bool allowed = 3;\n     */ this.allowed = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscriptionPermissionUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscriptionPermissionUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscriptionPermissionUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscriptionPermissionUpdate, a, b);\n    }\n}\nSubscriptionPermissionUpdate.runtime = proto3;\nSubscriptionPermissionUpdate.typeName = \"livekit.SubscriptionPermissionUpdate\";\nSubscriptionPermissionUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"allowed\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.SyncState\n */ class SyncState extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.TrackPublishedResponse publish_tracks = 3;\n     */ this.publishTracks = [];\n        /**\n     * @generated from field: repeated livekit.DataChannelInfo data_channels = 4;\n     */ this.dataChannels = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SyncState().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SyncState().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SyncState().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SyncState, a, b);\n    }\n}\nSyncState.runtime = proto3;\nSyncState.typeName = \"livekit.SyncState\";\nSyncState.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription\n        },\n        {\n            no: 2,\n            name: \"subscription\",\n            kind: \"message\",\n            T: UpdateSubscription\n        },\n        {\n            no: 3,\n            name: \"publish_tracks\",\n            kind: \"message\",\n            T: TrackPublishedResponse,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"data_channels\",\n            kind: \"message\",\n            T: DataChannelInfo,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription\n        }\n    ]);\n/**\n * @generated from message livekit.DataChannelInfo\n */ class DataChannelInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string label = 1;\n     */ this.label = \"\";\n        /**\n     * @generated from field: uint32 id = 2;\n     */ this.id = 0;\n        /**\n     * @generated from field: livekit.SignalTarget target = 3;\n     */ this.target = SignalTarget.PUBLISHER;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DataChannelInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DataChannelInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DataChannelInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(DataChannelInfo, a, b);\n    }\n}\nDataChannelInfo.runtime = proto3;\nDataChannelInfo.typeName = \"livekit.DataChannelInfo\";\nDataChannelInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"label\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 3,\n            name: \"target\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SignalTarget)\n        }\n    ]);\n/**\n * @generated from message livekit.SimulateScenario\n */ class SimulateScenario extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from oneof livekit.SimulateScenario.scenario\n     */ this.scenario = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SimulateScenario().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SimulateScenario().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SimulateScenario().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SimulateScenario, a, b);\n    }\n}\nSimulateScenario.runtime = proto3;\nSimulateScenario.typeName = \"livekit.SimulateScenario\";\nSimulateScenario.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"speaker_update\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 2,\n            name: \"node_failure\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 3,\n            name: \"migration\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 4,\n            name: \"server_leave\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 5,\n            name: \"switch_candidate_protocol\",\n            kind: \"enum\",\n            T: proto3.getEnumType(CandidateProtocol),\n            oneof: \"scenario\"\n        },\n        {\n            no: 6,\n            name: \"subscriber_bandwidth\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 7,\n            name: \"disconnect_signal_on_resume\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 8,\n            name: \"disconnect_signal_on_resume_no_messages\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        }\n    ]);\n/**\n * @generated from message livekit.Ping\n */ class Ping extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: int64 timestamp = 1;\n     */ this.timestamp = protoInt64.zero;\n        /**\n     * rtt in milliseconds calculated by client\n     *\n     * @generated from field: int64 rtt = 2;\n     */ this.rtt = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Ping().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Ping().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Ping().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Ping, a, b);\n    }\n}\nPing.runtime = proto3;\nPing.typeName = \"livekit.Ping\";\nPing.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"rtt\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        }\n    ]);\n/**\n * @generated from message livekit.Pong\n */ class Pong extends Message {\n    constructor(data){\n        super();\n        /**\n     * timestamp field of last received ping request\n     *\n     * @generated from field: int64 last_ping_timestamp = 1;\n     */ this.lastPingTimestamp = protoInt64.zero;\n        /**\n     * @generated from field: int64 timestamp = 2;\n     */ this.timestamp = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Pong().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Pong().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Pong().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Pong, a, b);\n    }\n}\nPong.runtime = proto3;\nPong.typeName = \"livekit.Pong\";\nPong.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"last_ping_timestamp\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        }\n    ]);\n/**\n * @generated from message livekit.RegionSettings\n */ class RegionSettings extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.RegionInfo regions = 1;\n     */ this.regions = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RegionSettings().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RegionSettings().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RegionSettings().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RegionSettings, a, b);\n    }\n}\nRegionSettings.runtime = proto3;\nRegionSettings.typeName = \"livekit.RegionSettings\";\nRegionSettings.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"regions\",\n            kind: \"message\",\n            T: RegionInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.RegionInfo\n */ class RegionInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string region = 1;\n     */ this.region = \"\";\n        /**\n     * @generated from field: string url = 2;\n     */ this.url = \"\";\n        /**\n     * @generated from field: int64 distance = 3;\n     */ this.distance = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RegionInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RegionInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RegionInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RegionInfo, a, b);\n    }\n}\nRegionInfo.runtime = proto3;\nRegionInfo.typeName = \"livekit.RegionInfo\";\nRegionInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"url\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"distance\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        }\n    ]);\n/**\n * @generated from message livekit.SubscriptionResponse\n */ class SubscriptionResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: livekit.SubscriptionError err = 2;\n     */ this.err = SubscriptionError.SE_UNKNOWN;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscriptionResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscriptionResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscriptionResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscriptionResponse, a, b);\n    }\n}\nSubscriptionResponse.runtime = proto3;\nSubscriptionResponse.typeName = \"livekit.SubscriptionResponse\";\nSubscriptionResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"err\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SubscriptionError)\n        }\n    ]);\nfunction cloneDeep(value) {\n    if (typeof value === \"undefined\") {\n        return;\n    }\n    if (typeof structuredClone === \"function\") {\n        return structuredClone(value);\n    } else {\n        return JSON.parse(JSON.stringify(value));\n    }\n}\nconst BACKGROUND_REACTION_DELAY = 5000;\n// keep old audio elements when detached, we would re-use them since on iOS\n// Safari tracks which audio elements have been \"blessed\" by the user.\nconst recycledElements = [];\nclass Track extends eventsExports.EventEmitter {\n    constructor(mediaTrack, kind){\n        let loggerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _a;\n        super();\n        this.attachedElements = [];\n        this.isMuted = false;\n        /**\n     * indicates current state of stream, it'll indicate `paused` if the track\n     * has been paused by congestion controller\n     */ this.streamState = Track.StreamState.Active;\n        this.isInBackground = false;\n        this._currentBitrate = 0;\n        this.log = livekitLogger;\n        this.appVisibilityChangedListener = ()=>{\n            if (this.backgroundTimeout) {\n                clearTimeout(this.backgroundTimeout);\n            }\n            // delay app visibility update if it goes to hidden\n            // update immediately if it comes back to focus\n            if (document.visibilityState === \"hidden\") {\n                this.backgroundTimeout = setTimeout(()=>this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);\n            } else {\n                this.handleAppVisibilityChanged();\n            }\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Track);\n        this.loggerContextCb = loggerOptions.loggerContextCb;\n        this.setMaxListeners(100);\n        this.kind = kind;\n        this._mediaStreamTrack = mediaTrack;\n        this._mediaStreamID = mediaTrack.id;\n        this.source = Track.Source.Unknown;\n    }\n    get logContext() {\n        var _a;\n        return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n    }\n    /** current receive bits per second */ get currentBitrate() {\n        return this._currentBitrate;\n    }\n    get mediaStreamTrack() {\n        return this._mediaStreamTrack;\n    }\n    /**\n   * @internal\n   * used for keep mediaStream's first id, since it's id might change\n   * if we disable/enable a track\n   */ get mediaStreamID() {\n        return this._mediaStreamID;\n    }\n    attach(element) {\n        let elementType = \"audio\";\n        if (this.kind === Track.Kind.Video) {\n            elementType = \"video\";\n        }\n        if (this.attachedElements.length === 0 && Track.Kind.Video) {\n            this.addAppVisibilityListener();\n        }\n        if (!element) {\n            if (elementType === \"audio\") {\n                recycledElements.forEach((e)=>{\n                    if (e.parentElement === null && !element) {\n                        element = e;\n                    }\n                });\n                if (element) {\n                    // remove it from pool\n                    recycledElements.splice(recycledElements.indexOf(element), 1);\n                }\n            }\n            if (!element) {\n                element = document.createElement(elementType);\n            }\n        }\n        if (!this.attachedElements.includes(element)) {\n            this.attachedElements.push(element);\n        }\n        // even if we believe it's already attached to the element, it's possible\n        // the element's srcObject was set to something else out of band.\n        // we'll want to re-attach it in that case\n        attachToElement(this.mediaStreamTrack, element);\n        // handle auto playback failures\n        const allMediaStreamTracks = element.srcObject.getTracks();\n        const hasAudio = allMediaStreamTracks.some((tr)=>tr.kind === \"audio\");\n        // manually play media to detect auto playback status\n        element.play().then(()=>{\n            this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);\n        }).catch((e)=>{\n            if (e.name === \"NotAllowedError\") {\n                this.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e);\n            } else if (e.name === \"AbortError\") {\n                // commonly triggered by another `play` request, only log for debugging purposes\n                livekitLogger.debug(\"\".concat(hasAudio ? \"audio\" : \"video\", \" playback aborted, likely due to new play request\"));\n            } else {\n                livekitLogger.warn(\"could not playback \".concat(hasAudio ? \"audio\" : \"video\"), e);\n            }\n            // If audio playback isn't allowed make sure we still play back the video\n            if (hasAudio && element && allMediaStreamTracks.some((tr)=>tr.kind === \"video\") && e.name === \"NotAllowedError\") {\n                element.muted = true;\n                element.play().catch(()=>{\n                // catch for Safari, exceeded options at this point to automatically play the media element\n                });\n            }\n        });\n        this.emit(TrackEvent.ElementAttached, element);\n        return element;\n    }\n    detach(element) {\n        try {\n            // detach from a single element\n            if (element) {\n                detachTrack(this.mediaStreamTrack, element);\n                const idx = this.attachedElements.indexOf(element);\n                if (idx >= 0) {\n                    this.attachedElements.splice(idx, 1);\n                    this.recycleElement(element);\n                    this.emit(TrackEvent.ElementDetached, element);\n                }\n                return element;\n            }\n            const detached = [];\n            this.attachedElements.forEach((elm)=>{\n                detachTrack(this.mediaStreamTrack, elm);\n                detached.push(elm);\n                this.recycleElement(elm);\n                this.emit(TrackEvent.ElementDetached, elm);\n            });\n            // remove all tracks\n            this.attachedElements = [];\n            return detached;\n        } finally{\n            if (this.attachedElements.length === 0) {\n                this.removeAppVisibilityListener();\n            }\n        }\n    }\n    stop() {\n        this.stopMonitor();\n        this._mediaStreamTrack.stop();\n    }\n    enable() {\n        this._mediaStreamTrack.enabled = true;\n    }\n    disable() {\n        this._mediaStreamTrack.enabled = false;\n    }\n    /* @internal */ stopMonitor() {\n        if (this.monitorInterval) {\n            clearInterval(this.monitorInterval);\n        }\n    }\n    /** @internal */ updateLoggerOptions(loggerOptions) {\n        if (loggerOptions.loggerName) {\n            this.log = getLogger(loggerOptions.loggerName);\n        }\n        if (loggerOptions.loggerContextCb) {\n            this.loggerContextCb = loggerOptions.loggerContextCb;\n        }\n    }\n    recycleElement(element) {\n        if (element instanceof HTMLAudioElement) {\n            // we only need to re-use a single element\n            let shouldCache = true;\n            element.pause();\n            recycledElements.forEach((e)=>{\n                if (!e.parentElement) {\n                    shouldCache = false;\n                }\n            });\n            if (shouldCache) {\n                recycledElements.push(element);\n            }\n        }\n    }\n    handleAppVisibilityChanged() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.isInBackground = document.visibilityState === \"hidden\";\n        });\n    }\n    addAppVisibilityListener() {\n        if (isWeb()) {\n            this.isInBackground = document.visibilityState === \"hidden\";\n            document.addEventListener(\"visibilitychange\", this.appVisibilityChangedListener);\n        } else {\n            this.isInBackground = false;\n        }\n    }\n    removeAppVisibilityListener() {\n        if (isWeb()) {\n            document.removeEventListener(\"visibilitychange\", this.appVisibilityChangedListener);\n        }\n    }\n}\nfunction attachToElement(track, element) {\n    let mediaStream;\n    if (element.srcObject instanceof MediaStream) {\n        mediaStream = element.srcObject;\n    } else {\n        mediaStream = new MediaStream();\n    }\n    // check if track matches existing track\n    let existingTracks;\n    if (track.kind === \"audio\") {\n        existingTracks = mediaStream.getAudioTracks();\n    } else {\n        existingTracks = mediaStream.getVideoTracks();\n    }\n    if (!existingTracks.includes(track)) {\n        existingTracks.forEach((et)=>{\n            mediaStream.removeTrack(et);\n        });\n        mediaStream.addTrack(track);\n    }\n    if (!isSafari() || !(element instanceof HTMLVideoElement)) {\n        // when in low power mode (applies to both macOS and iOS), Safari will show a play/pause overlay\n        // when a video starts that has the `autoplay` attribute is set.\n        // we work around this by _not_ setting the autoplay attribute on safari and instead call `setTimeout(() => el.play(),0)` further down\n        element.autoplay = true;\n    }\n    // In case there are no audio tracks present on the mediastream, we set the element as muted to ensure autoplay works\n    element.muted = mediaStream.getAudioTracks().length === 0;\n    if (element instanceof HTMLVideoElement) {\n        element.playsInline = true;\n    }\n    // avoid flicker\n    if (element.srcObject !== mediaStream) {\n        element.srcObject = mediaStream;\n        if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {\n            // Firefox also has a timing issue where video doesn't actually get attached unless\n            // performed out-of-band\n            // Safari 15 has a bug where in certain layouts, video element renders\n            // black until the page is resized or other changes take place.\n            // Resetting the src triggers it to render.\n            // https://developer.apple.com/forums/thread/690523\n            setTimeout(()=>{\n                element.srcObject = mediaStream;\n                // Safari 15 sometimes fails to start a video\n                // when the window is backgrounded before the first frame is drawn\n                // manually calling play here seems to fix that\n                element.play().catch(()=>{\n                /** do nothing */ });\n            }, 0);\n        }\n    }\n}\n/** @internal */ function detachTrack(track, element) {\n    if (element.srcObject instanceof MediaStream) {\n        const mediaStream = element.srcObject;\n        mediaStream.removeTrack(track);\n        if (mediaStream.getTracks().length > 0) {\n            element.srcObject = mediaStream;\n        } else {\n            element.srcObject = null;\n        }\n    }\n}\n(function(Track) {\n    let Kind;\n    (function(Kind) {\n        Kind[\"Audio\"] = \"audio\";\n        Kind[\"Video\"] = \"video\";\n        Kind[\"Unknown\"] = \"unknown\";\n    })(Kind = Track.Kind || (Track.Kind = {}));\n    let Source;\n    (function(Source) {\n        Source[\"Camera\"] = \"camera\";\n        Source[\"Microphone\"] = \"microphone\";\n        Source[\"ScreenShare\"] = \"screen_share\";\n        Source[\"ScreenShareAudio\"] = \"screen_share_audio\";\n        Source[\"Unknown\"] = \"unknown\";\n    })(Source = Track.Source || (Track.Source = {}));\n    let StreamState$1;\n    (function(StreamState) {\n        StreamState[\"Active\"] = \"active\";\n        StreamState[\"Paused\"] = \"paused\";\n        StreamState[\"Unknown\"] = \"unknown\";\n    })(StreamState$1 = Track.StreamState || (Track.StreamState = {}));\n    /** @internal */ function kindToProto(k) {\n        switch(k){\n            case Kind.Audio:\n                return TrackType.AUDIO;\n            case Kind.Video:\n                return TrackType.VIDEO;\n            default:\n                // FIXME this was UNRECOGNIZED before\n                return TrackType.DATA;\n        }\n    }\n    Track.kindToProto = kindToProto;\n    /** @internal */ function kindFromProto(t) {\n        switch(t){\n            case TrackType.AUDIO:\n                return Kind.Audio;\n            case TrackType.VIDEO:\n                return Kind.Video;\n            default:\n                return Kind.Unknown;\n        }\n    }\n    Track.kindFromProto = kindFromProto;\n    /** @internal */ function sourceToProto(s) {\n        switch(s){\n            case Source.Camera:\n                return TrackSource.CAMERA;\n            case Source.Microphone:\n                return TrackSource.MICROPHONE;\n            case Source.ScreenShare:\n                return TrackSource.SCREEN_SHARE;\n            case Source.ScreenShareAudio:\n                return TrackSource.SCREEN_SHARE_AUDIO;\n            default:\n                return TrackSource.UNKNOWN;\n        }\n    }\n    Track.sourceToProto = sourceToProto;\n    /** @internal */ function sourceFromProto(s) {\n        switch(s){\n            case TrackSource.CAMERA:\n                return Source.Camera;\n            case TrackSource.MICROPHONE:\n                return Source.Microphone;\n            case TrackSource.SCREEN_SHARE:\n                return Source.ScreenShare;\n            case TrackSource.SCREEN_SHARE_AUDIO:\n                return Source.ScreenShareAudio;\n            default:\n                return Source.Unknown;\n        }\n    }\n    Track.sourceFromProto = sourceFromProto;\n    /** @internal */ function streamStateFromProto(s) {\n        switch(s){\n            case StreamState.ACTIVE:\n                return StreamState$1.Active;\n            case StreamState.PAUSED:\n                return StreamState$1.Paused;\n            default:\n                return StreamState$1.Unknown;\n        }\n    }\n    Track.streamStateFromProto = streamStateFromProto;\n})(Track || (Track = {}));\nfunction mergeDefaultOptions(options, audioDefaults, videoDefaults) {\n    var _a;\n    const opts = (_a = cloneDeep(options)) !== null && _a !== void 0 ? _a : {};\n    if (opts.audio === true) opts.audio = {};\n    if (opts.video === true) opts.video = {};\n    // use defaults\n    if (opts.audio) {\n        mergeObjectWithoutOverwriting(opts.audio, audioDefaults);\n    }\n    if (opts.video) {\n        mergeObjectWithoutOverwriting(opts.video, videoDefaults);\n    }\n    return opts;\n}\nfunction mergeObjectWithoutOverwriting(mainObject, objectToMerge) {\n    Object.keys(objectToMerge).forEach((key)=>{\n        if (mainObject[key] === undefined) mainObject[key] = objectToMerge[key];\n    });\n    return mainObject;\n}\nfunction constraintsForOptions(options) {\n    const constraints = {};\n    if (options.video) {\n        // default video options\n        if (typeof options.video === \"object\") {\n            const videoOptions = {};\n            const target = videoOptions;\n            const source = options.video;\n            Object.keys(source).forEach((key)=>{\n                switch(key){\n                    case \"resolution\":\n                        // flatten VideoResolution fields\n                        mergeObjectWithoutOverwriting(target, source.resolution);\n                        break;\n                    default:\n                        target[key] = source[key];\n                }\n            });\n            constraints.video = videoOptions;\n        } else {\n            constraints.video = options.video;\n        }\n    } else {\n        constraints.video = false;\n    }\n    if (options.audio) {\n        if (typeof options.audio === \"object\") {\n            constraints.audio = options.audio;\n        } else {\n            constraints.audio = true;\n        }\n    } else {\n        constraints.audio = false;\n    }\n    return constraints;\n}\n/**\n * This function detects silence on a given [[Track]] instance.\n * Returns true if the track seems to be entirely silent.\n */ function detectSilence(track) {\n    let timeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n    return __awaiter(this, void 0, void 0, function*() {\n        const ctx = getNewAudioContext();\n        if (ctx) {\n            const analyser = ctx.createAnalyser();\n            analyser.fftSize = 2048;\n            const bufferLength = analyser.frequencyBinCount;\n            const dataArray = new Uint8Array(bufferLength);\n            const source = ctx.createMediaStreamSource(new MediaStream([\n                track.mediaStreamTrack\n            ]));\n            source.connect(analyser);\n            yield sleep(timeOffset);\n            analyser.getByteTimeDomainData(dataArray);\n            const someNoise = dataArray.some((sample)=>sample !== 128 && sample !== 0);\n            ctx.close();\n            return !someNoise;\n        }\n        return false;\n    });\n}\n/**\n * @internal\n */ function getNewAudioContext() {\n    const AudioContext1 = // @ts-ignore\n     false && (0);\n    if (AudioContext1) {\n        return new AudioContext1({\n            latencyHint: \"interactive\"\n        });\n    }\n}\n/**\n * @internal\n */ function sourceToKind(source) {\n    if (source === Track.Source.Microphone) {\n        return \"audioinput\";\n    } else if (source === Track.Source.Camera) {\n        return \"videoinput\";\n    } else {\n        return undefined;\n    }\n}\n/**\n * @internal\n */ function screenCaptureToDisplayMediaStreamOptions(options) {\n    var _a, _b;\n    let videoConstraints = (_a = options.video) !== null && _a !== void 0 ? _a : true;\n    // treat 0 as uncapped\n    if (options.resolution && options.resolution.width > 0 && options.resolution.height > 0) {\n        videoConstraints = typeof videoConstraints === \"boolean\" ? {} : videoConstraints;\n        if (isSafari()) {\n            videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n                width: {\n                    max: options.resolution.width\n                },\n                height: {\n                    max: options.resolution.height\n                },\n                frameRate: options.resolution.frameRate\n            });\n        } else {\n            videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n                width: {\n                    ideal: options.resolution.width\n                },\n                height: {\n                    ideal: options.resolution.height\n                },\n                frameRate: options.resolution.frameRate\n            });\n        }\n    }\n    return {\n        audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,\n        video: videoConstraints,\n        // @ts-expect-error support for experimental display media features\n        controller: options.controller,\n        selfBrowserSurface: options.selfBrowserSurface,\n        surfaceSwitching: options.surfaceSwitching,\n        systemAudio: options.systemAudio\n    };\n}\nfunction mimeTypeToVideoCodecString(mimeType) {\n    const codec = mimeType.split(\"/\")[1].toLowerCase();\n    if (!videoCodecs.includes(codec)) {\n        throw Error(\"Video codec not supported: \".concat(codec));\n    }\n    return codec;\n}\nfunction getTrackPublicationInfo(tracks) {\n    const infos = [];\n    tracks.forEach((track)=>{\n        if (track.track !== undefined) {\n            infos.push(new TrackPublishedResponse({\n                cid: track.track.mediaStreamID,\n                track: track.trackInfo\n            }));\n        }\n    });\n    return infos;\n}\nfunction getLogContextFromTrack(track) {\n    if (track instanceof Track) {\n        return {\n            trackSid: track.sid,\n            trackSource: track.source,\n            trackMuted: track.isMuted,\n            trackEnabled: track.mediaStreamTrack.enabled,\n            trackKind: track.kind\n        };\n    } else {\n        return {\n            trackSid: track.trackSid,\n            trackName: track.trackName,\n            track: track.track ? getLogContextFromTrack(track.track) : undefined,\n            trackEnabled: track.isEnabled,\n            trackEncrypted: track.isEncrypted,\n            trackMimeType: track.mimeType\n        };\n    }\n}\nconst separator = \"|\";\nconst ddExtensionURI = \"https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension\";\nfunction unpackStreamId(packed) {\n    const parts = packed.split(separator);\n    if (parts.length > 1) {\n        return [\n            parts[0],\n            packed.substr(parts[0].length + 1)\n        ];\n    }\n    return [\n        packed,\n        \"\"\n    ];\n}\nfunction sleep(duration) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return new Promise((resolve)=>CriticalTimers.setTimeout(resolve, duration));\n    });\n}\n/** @internal */ function supportsTransceiver() {\n    return \"addTransceiver\" in RTCPeerConnection.prototype;\n}\n/** @internal */ function supportsAddTrack() {\n    return \"addTrack\" in RTCPeerConnection.prototype;\n}\nfunction supportsAdaptiveStream() {\n    return typeof ResizeObserver !== undefined && typeof IntersectionObserver !== undefined;\n}\nfunction supportsDynacast() {\n    return supportsTransceiver();\n}\nfunction supportsAV1() {\n    if (!(\"getCapabilities\" in RTCRtpSender)) {\n        return false;\n    }\n    if (isSafari()) {\n        // Safari 17 on iPhone14 reports AV1 capability, but does not actually support it\n        return false;\n    }\n    const capabilities = RTCRtpSender.getCapabilities(\"video\");\n    let hasAV1 = false;\n    if (capabilities) {\n        for (const codec of capabilities.codecs){\n            if (codec.mimeType === \"video/AV1\") {\n                hasAV1 = true;\n                break;\n            }\n        }\n    }\n    return hasAV1;\n}\nfunction supportsVP9() {\n    if (!(\"getCapabilities\" in RTCRtpSender)) {\n        return false;\n    }\n    if (isFireFox()) {\n        // technically speaking FireFox supports VP9, but SVC publishing is broken\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1633876\n        return false;\n    }\n    if (isSafari()) {\n        const browser = getBrowser();\n        if ((browser === null || browser === void 0 ? void 0 : browser.version) && compareVersions(browser.version, \"16\") < 0) {\n            // Safari 16 and below does not support VP9\n            return false;\n        }\n    }\n    const capabilities = RTCRtpSender.getCapabilities(\"video\");\n    let hasVP9 = false;\n    if (capabilities) {\n        for (const codec of capabilities.codecs){\n            if (codec.mimeType === \"video/VP9\") {\n                hasVP9 = true;\n                break;\n            }\n        }\n    }\n    return hasVP9;\n}\nfunction isSVCCodec(codec) {\n    return codec === \"av1\" || codec === \"vp9\";\n}\nfunction supportsSetSinkId(elm) {\n    if (!document) {\n        return false;\n    }\n    if (!elm) {\n        elm = document.createElement(\"audio\");\n    }\n    return \"setSinkId\" in elm;\n}\nconst setCodecPreferencesVersions = {\n    Chrome: \"100\",\n    Safari: \"15\",\n    Firefox: \"100\"\n};\nfunction supportsSetCodecPreferences(transceiver) {\n    if (!isWeb()) {\n        return false;\n    }\n    if (!(\"setCodecPreferences\" in transceiver)) {\n        return false;\n    }\n    const browser = getBrowser();\n    if (!(browser === null || browser === void 0 ? void 0 : browser.name) || !browser.version) {\n        // version is required\n        return false;\n    }\n    const v = setCodecPreferencesVersions[browser.name];\n    if (v) {\n        return compareVersions(browser.version, v) >= 0;\n    }\n    return false;\n}\nfunction isBrowserSupported() {\n    return supportsTransceiver() || supportsAddTrack();\n}\nfunction isFireFox() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === \"Firefox\";\n}\nfunction isChromiumBased() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === \"Chrome\";\n}\nfunction isSafari() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === \"Safari\";\n}\nfunction isSafari17() {\n    const b = getBrowser();\n    return (b === null || b === void 0 ? void 0 : b.name) === \"Safari\" && b.version.startsWith(\"17.\");\n}\nfunction isMobile() {\n    if (!isWeb()) return false;\n    return /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent);\n}\nfunction isWeb() {\n    return typeof document !== \"undefined\";\n}\nfunction isReactNative() {\n    // navigator.product is deprecated on browsers, but will be set appropriately for react-native.\n    return navigator.product == \"ReactNative\";\n}\nfunction isCloud(serverUrl) {\n    return serverUrl.hostname.endsWith(\".livekit.cloud\") || serverUrl.hostname.endsWith(\".livekit.run\");\n}\nfunction getLKReactNativeInfo() {\n    // global defined only for ReactNative.\n    // @ts-ignore\n    if (global && global.LiveKitReactNativeGlobal) {\n        // @ts-ignore\n        return global.LiveKitReactNativeGlobal;\n    }\n    return undefined;\n}\nfunction getReactNativeOs() {\n    if (!isReactNative()) {\n        return undefined;\n    }\n    let info = getLKReactNativeInfo();\n    if (info) {\n        return info.platform;\n    }\n    return undefined;\n}\nfunction getDevicePixelRatio() {\n    if (isWeb()) {\n        return window.devicePixelRatio;\n    }\n    if (isReactNative()) {\n        let info = getLKReactNativeInfo();\n        if (info) {\n            return info.devicePixelRatio;\n        }\n    }\n    return 1;\n}\nfunction compareVersions(v1, v2) {\n    const parts1 = v1.split(\".\");\n    const parts2 = v2.split(\".\");\n    const k = Math.min(parts1.length, parts2.length);\n    for(let i = 0; i < k; ++i){\n        const p1 = parseInt(parts1[i], 10);\n        const p2 = parseInt(parts2[i], 10);\n        if (p1 > p2) return 1;\n        if (p1 < p2) return -1;\n        if (i === k - 1 && p1 === p2) return 0;\n    }\n    if (v1 === \"\" && v2 !== \"\") {\n        return -1;\n    } else if (v2 === \"\") {\n        return 1;\n    }\n    return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;\n}\nfunction roDispatchCallback(entries) {\n    for (const entry of entries){\n        entry.target.handleResize(entry);\n    }\n}\nfunction ioDispatchCallback(entries) {\n    for (const entry of entries){\n        entry.target.handleVisibilityChanged(entry);\n    }\n}\nlet resizeObserver = null;\nconst getResizeObserver = ()=>{\n    if (!resizeObserver) resizeObserver = new ResizeObserver(roDispatchCallback);\n    return resizeObserver;\n};\nlet intersectionObserver = null;\nconst getIntersectionObserver = ()=>{\n    if (!intersectionObserver) {\n        intersectionObserver = new IntersectionObserver(ioDispatchCallback, {\n            root: null,\n            rootMargin: \"0px\"\n        });\n    }\n    return intersectionObserver;\n};\nfunction getClientInfo() {\n    var _a;\n    const info = new ClientInfo({\n        sdk: ClientInfo_SDK.JS,\n        protocol: protocolVersion,\n        version\n    });\n    if (isReactNative()) {\n        info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : \"\";\n    }\n    return info;\n}\nlet emptyVideoStreamTrack;\nfunction getEmptyVideoStreamTrack() {\n    if (!emptyVideoStreamTrack) {\n        emptyVideoStreamTrack = createDummyVideoStreamTrack();\n    }\n    return emptyVideoStreamTrack.clone();\n}\nfunction createDummyVideoStreamTrack() {\n    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\n    let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    let enabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let paintContent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const canvas = document.createElement(\"canvas\");\n    // the canvas size is set to 16 by default, because electron apps seem to fail with smaller values\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext(\"2d\");\n    ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);\n    if (paintContent && ctx) {\n        ctx.beginPath();\n        ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);\n        ctx.closePath();\n        ctx.fillStyle = \"grey\";\n        ctx.fill();\n    }\n    // @ts-ignore\n    const dummyStream = canvas.captureStream();\n    const [dummyTrack] = dummyStream.getTracks();\n    if (!dummyTrack) {\n        throw Error(\"Could not get empty media stream video track\");\n    }\n    dummyTrack.enabled = enabled;\n    return dummyTrack;\n}\nlet emptyAudioStreamTrack;\nfunction getEmptyAudioStreamTrack() {\n    if (!emptyAudioStreamTrack) {\n        // implementation adapted from https://blog.mozilla.org/webrtc/warm-up-with-replacetrack/\n        const ctx = new AudioContext();\n        const oscillator = ctx.createOscillator();\n        const gain = ctx.createGain();\n        gain.gain.setValueAtTime(0, 0);\n        const dst = ctx.createMediaStreamDestination();\n        oscillator.connect(gain);\n        gain.connect(dst);\n        oscillator.start();\n        [emptyAudioStreamTrack] = dst.stream.getAudioTracks();\n        if (!emptyAudioStreamTrack) {\n            throw Error(\"Could not get empty media stream audio track\");\n        }\n        emptyAudioStreamTrack.enabled = false;\n    }\n    return emptyAudioStreamTrack.clone();\n}\nclass Future {\n    constructor(futureBase, onFinally){\n        this.onFinally = onFinally;\n        this.promise = new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                this.resolve = resolve;\n                this.reject = reject;\n                if (futureBase) {\n                    yield futureBase(resolve, reject);\n                }\n            })).finally(()=>{\n            var _a;\n            return (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);\n        });\n    }\n}\n/**\n * Creates and returns an analyser web audio node that is attached to the provided track.\n * Additionally returns a convenience method `calculateVolume` to perform instant volume readings on that track.\n * Call the returned `cleanup` function to close the audioContext that has been created for the instance of this helper\n */ function createAudioAnalyser(track, options) {\n    const opts = Object.assign({\n        cloneTrack: false,\n        fftSize: 2048,\n        smoothingTimeConstant: 0.8,\n        minDecibels: -100,\n        maxDecibels: -80\n    }, options);\n    const audioContext = getNewAudioContext();\n    if (!audioContext) {\n        throw new Error(\"Audio Context not supported on this browser\");\n    }\n    const streamTrack = opts.cloneTrack ? track.mediaStreamTrack.clone() : track.mediaStreamTrack;\n    const mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([\n        streamTrack\n    ]));\n    const analyser = audioContext.createAnalyser();\n    analyser.minDecibels = opts.minDecibels;\n    analyser.maxDecibels = opts.maxDecibels;\n    analyser.fftSize = opts.fftSize;\n    analyser.smoothingTimeConstant = opts.smoothingTimeConstant;\n    mediaStreamSource.connect(analyser);\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n    /**\n   * Calculates the current volume of the track in the range from 0 to 1\n   */ const calculateVolume = ()=>{\n        analyser.getByteFrequencyData(dataArray);\n        let sum = 0;\n        for (const amplitude of dataArray){\n            sum += Math.pow(amplitude / 255, 2);\n        }\n        const volume = Math.sqrt(sum / dataArray.length);\n        return volume;\n    };\n    const cleanup = ()=>__awaiter(this, void 0, void 0, function*() {\n            yield audioContext.close();\n            if (opts.cloneTrack) {\n                streamTrack.stop();\n            }\n        });\n    return {\n        calculateVolume,\n        analyser,\n        cleanup\n    };\n}\nclass Mutex {\n    constructor(){\n        this._locking = Promise.resolve();\n        this._locks = 0;\n    }\n    isLocked() {\n        return this._locks > 0;\n    }\n    lock() {\n        this._locks += 1;\n        let unlockNext;\n        const willLock = new Promise((resolve)=>unlockNext = ()=>{\n                this._locks -= 1;\n                resolve();\n            });\n        const willUnlock = this._locking.then(()=>unlockNext);\n        this._locking = this._locking.then(()=>willLock);\n        return willUnlock;\n    }\n}\nfunction isVideoCodec(maybeCodec) {\n    return videoCodecs.includes(maybeCodec);\n}\nfunction unwrapConstraint(constraint) {\n    if (typeof constraint === \"string\") {\n        return constraint;\n    }\n    if (Array.isArray(constraint)) {\n        return constraint[0];\n    }\n    if (constraint.exact) {\n        if (Array.isArray(constraint.exact)) {\n            return constraint.exact[0];\n        }\n        return constraint.exact;\n    }\n    if (constraint.ideal) {\n        if (Array.isArray(constraint.ideal)) {\n            return constraint.ideal[0];\n        }\n        return constraint.ideal;\n    }\n    throw Error(\"could not unwrap constraint\");\n}\nfunction toWebsocketUrl(url) {\n    if (url.startsWith(\"http\")) {\n        return url.replace(/^(http)/, \"ws\");\n    }\n    return url;\n}\nfunction toHttpUrl(url) {\n    if (url.startsWith(\"ws\")) {\n        return url.replace(/^(ws)/, \"http\");\n    }\n    return url;\n}\nconst defaultId = \"default\";\nclass DeviceManager {\n    static getInstance() {\n        if (this.instance === undefined) {\n            this.instance = new DeviceManager();\n        }\n        return this.instance;\n    }\n    getDevices(kind) {\n        let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (((_a = DeviceManager.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0) {\n                livekitLogger.debug(\"awaiting getUserMedia promise\");\n                try {\n                    if (kind) {\n                        yield DeviceManager.userMediaPromiseMap.get(kind);\n                    } else {\n                        yield Promise.all(DeviceManager.userMediaPromiseMap.values());\n                    }\n                } catch (e) {\n                    livekitLogger.warn(\"error waiting for media permissons\");\n                }\n            }\n            let devices = yield navigator.mediaDevices.enumerateDevices();\n            if (requestPermissions && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363\n            !(isSafari() && this.hasDeviceInUse(kind))) {\n                const isDummyDeviceOrEmpty = devices.length === 0 || devices.some((device)=>{\n                    const noLabel = device.label === \"\";\n                    const isRelevant = kind ? device.kind === kind : true;\n                    return noLabel && isRelevant;\n                });\n                if (isDummyDeviceOrEmpty) {\n                    const permissionsToAcquire = {\n                        video: kind !== \"audioinput\" && kind !== \"audiooutput\",\n                        audio: kind !== \"videoinput\"\n                    };\n                    const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);\n                    devices = yield navigator.mediaDevices.enumerateDevices();\n                    stream.getTracks().forEach((track)=>{\n                        track.stop();\n                    });\n                }\n            }\n            if (kind) {\n                devices = devices.filter((device)=>device.kind === kind);\n            }\n            return devices;\n        });\n    }\n    normalizeDeviceId(kind, deviceId, groupId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (deviceId !== defaultId) {\n                return deviceId;\n            }\n            // resolve actual device id if it's 'default': Chrome returns it when no\n            // device has been chosen\n            const devices = yield this.getDevices(kind);\n            const device = devices.find((d)=>d.groupId === groupId && d.deviceId !== defaultId);\n            return device === null || device === void 0 ? void 0 : device.deviceId;\n        });\n    }\n    hasDeviceInUse(kind) {\n        return kind ? DeviceManager.userMediaPromiseMap.has(kind) : DeviceManager.userMediaPromiseMap.size > 0;\n    }\n}\nDeviceManager.mediaDeviceKinds = [\n    \"audioinput\",\n    \"audiooutput\",\n    \"videoinput\"\n];\nDeviceManager.userMediaPromiseMap = new Map();\nconst defaultDimensionsTimeout = 1000;\nclass LocalTrack extends Track {\n    get constraints() {\n        return this._constraints;\n    }\n    /**\n   *\n   * @param mediaTrack\n   * @param kind\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, kind, constraints){\n        let userProvidedTrack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n        super(mediaTrack, kind, loggerOptions);\n        this._isUpstreamPaused = false;\n        this.handleTrackMuteEvent = ()=>this.debouncedTrackMuteHandler().catch(()=>this.log.debug(\"track mute bounce got cancelled by an unmute event\", this.logContext));\n        this.debouncedTrackMuteHandler = r(()=>__awaiter(this, void 0, void 0, function*() {\n                yield this.pauseUpstream();\n            }), 5000);\n        this.handleTrackUnmuteEvent = ()=>__awaiter(this, void 0, void 0, function*() {\n                this.debouncedTrackMuteHandler.cancel(\"unmute\");\n                yield this.resumeUpstream();\n            });\n        this.handleEnded = ()=>{\n            if (this.isInBackground) {\n                this.reacquireTrack = true;\n            }\n            this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent);\n            this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n            this.emit(TrackEvent.Ended, this);\n        };\n        this.reacquireTrack = false;\n        this.providedByUser = userProvidedTrack;\n        this.muteLock = new Mutex();\n        this.pauseUpstreamLock = new Mutex();\n        this.processorLock = new Mutex();\n        this.setMediaStreamTrack(mediaTrack, true);\n        // added to satisfy TS compiler, constraints are synced with MediaStreamTrack\n        this._constraints = mediaTrack.getConstraints();\n        if (constraints) {\n            this._constraints = constraints;\n        }\n    }\n    get id() {\n        return this._mediaStreamTrack.id;\n    }\n    get dimensions() {\n        if (this.kind !== Track.Kind.Video) {\n            return undefined;\n        }\n        const { width, height } = this._mediaStreamTrack.getSettings();\n        if (width && height) {\n            return {\n                width,\n                height\n            };\n        }\n        return undefined;\n    }\n    get isUpstreamPaused() {\n        return this._isUpstreamPaused;\n    }\n    get isUserProvided() {\n        return this.providedByUser;\n    }\n    get mediaStreamTrack() {\n        var _a, _b;\n        return (_b = (_a = this.processor) === null || _a === void 0 ? void 0 : _a.processedTrack) !== null && _b !== void 0 ? _b : this._mediaStreamTrack;\n    }\n    setMediaStreamTrack(newTrack, force) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (newTrack === this._mediaStreamTrack && !force) {\n                return;\n            }\n            if (this._mediaStreamTrack) {\n                // detach\n                this.attachedElements.forEach((el)=>{\n                    detachTrack(this._mediaStreamTrack, el);\n                });\n                this.debouncedTrackMuteHandler.cancel(\"new-track\");\n                this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n                this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent);\n                this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n            }\n            this.mediaStream = new MediaStream([\n                newTrack\n            ]);\n            if (newTrack) {\n                newTrack.addEventListener(\"ended\", this.handleEnded);\n                // when underlying track emits mute, it indicates that the device is unable\n                // to produce media. In this case we'll need to signal with remote that\n                // the track is \"muted\"\n                // note this is different from LocalTrack.mute because we do not want to\n                // touch MediaStreamTrack.enabled\n                newTrack.addEventListener(\"mute\", this.handleTrackMuteEvent);\n                newTrack.addEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n                this._constraints = newTrack.getConstraints();\n            }\n            let processedTrack;\n            if (this.processor && newTrack && this.processorElement) {\n                this.log.debug(\"restarting processor\", this.logContext);\n                if (this.kind === \"unknown\") {\n                    throw TypeError(\"cannot set processor on track of unknown kind\");\n                }\n                attachToElement(newTrack, this.processorElement);\n                // ensure the processorElement itself stays muted\n                this.processorElement.muted = true;\n                yield this.processor.restart({\n                    track: newTrack,\n                    kind: this.kind,\n                    element: this.processorElement\n                });\n                processedTrack = this.processor.processedTrack;\n            }\n            if (this.sender) {\n                yield this.sender.replaceTrack(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack);\n            }\n            // if `newTrack` is different from the existing track, stop the\n            // older track just before replacing it\n            if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {\n                this._mediaStreamTrack.stop();\n            }\n            this._mediaStreamTrack = newTrack;\n            if (newTrack) {\n                // sync muted state with the enabled state of the newly provided track\n                this._mediaStreamTrack.enabled = !this.isMuted;\n                // when a valid track is replace, we'd want to start producing\n                yield this.resumeUpstream();\n                this.attachedElements.forEach((el)=>{\n                    attachToElement(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack, el);\n                });\n            }\n        });\n    }\n    waitForDimensions() {\n        let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultDimensionsTimeout;\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.kind === Track.Kind.Audio) {\n                throw new Error(\"cannot get dimensions for audio tracks\");\n            }\n            if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) === \"iOS\") {\n                // browsers report wrong initial resolution on iOS.\n                // when slightly delaying the call to .getSettings(), the correct resolution is being reported\n                yield sleep(10);\n            }\n            const started = Date.now();\n            while(Date.now() - started < timeout){\n                const dims = this.dimensions;\n                if (dims) {\n                    return dims;\n                }\n                yield sleep(50);\n            }\n            throw new TrackInvalidError(\"unable to get track dimensions after timeout\");\n        });\n    }\n    /**\n   * @returns DeviceID of the device that is currently being used for this track\n   */ getDeviceId() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // screen share doesn't have a usable device id\n            if (this.source === Track.Source.ScreenShare) {\n                return;\n            }\n            const { deviceId, groupId } = this._mediaStreamTrack.getSettings();\n            const kind = this.kind === Track.Kind.Audio ? \"audioinput\" : \"videoinput\";\n            return DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId);\n        });\n    }\n    mute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.setTrackMuted(true);\n            return this;\n        });\n    }\n    unmute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.setTrackMuted(false);\n            return this;\n        });\n    }\n    replaceTrack(track) {\n        let userProvidedTrack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.sender) {\n                throw new TrackInvalidError(\"unable to replace an unpublished track\");\n            }\n            this.log.debug(\"replace MediaStreamTrack\", this.logContext);\n            yield this.setMediaStreamTrack(track);\n            // this must be synced *after* setting mediaStreamTrack above, since it relies\n            // on the previous state in order to cleanup\n            this.providedByUser = userProvidedTrack;\n            if (this.processor) {\n                yield this.stopProcessor();\n            }\n            return this;\n        });\n    }\n    restart(constraints) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!constraints) {\n                constraints = this._constraints;\n            }\n            this.log.debug(\"restarting track with constraints\", Object.assign(Object.assign({}, this.logContext), {\n                constraints\n            }));\n            const streamConstraints = {\n                audio: false,\n                video: false\n            };\n            if (this.kind === Track.Kind.Video) {\n                streamConstraints.video = constraints;\n            } else {\n                streamConstraints.audio = constraints;\n            }\n            // these steps are duplicated from setMediaStreamTrack because we must stop\n            // the previous tracks before new tracks can be acquired\n            this.attachedElements.forEach((el)=>{\n                detachTrack(this.mediaStreamTrack, el);\n            });\n            this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n            // on Safari, the old audio track must be stopped before attempting to acquire\n            // the new track, otherwise the new track will stop with\n            // 'A MediaStreamTrack ended due to a capture failure`\n            this._mediaStreamTrack.stop();\n            // create new track and attach\n            const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);\n            const newTrack = mediaStream.getTracks()[0];\n            newTrack.addEventListener(\"ended\", this.handleEnded);\n            this.log.debug(\"re-acquired MediaStreamTrack\", this.logContext);\n            yield this.setMediaStreamTrack(newTrack);\n            this._constraints = constraints;\n            this.emit(TrackEvent.Restarted, this);\n            return this;\n        });\n    }\n    setTrackMuted(muted) {\n        this.log.debug(\"setting \".concat(this.kind, \" track \").concat(muted ? \"muted\" : \"unmuted\"), this.logContext);\n        if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {\n            return;\n        }\n        this.isMuted = muted;\n        this._mediaStreamTrack.enabled = !muted;\n        this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n    }\n    get needsReAcquisition() {\n        return this._mediaStreamTrack.readyState !== \"live\" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!isMobile()) return;\n            this.log.debug(\"visibility changed, is in Background: \".concat(this.isInBackground), this.logContext);\n            if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {\n                this.log.debug(\"track needs to be reacquired, restarting \".concat(this.source), this.logContext);\n                yield this.restart();\n                this.reacquireTrack = false;\n            }\n        });\n    }\n    stop() {\n        var _a;\n        super.stop();\n        this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n        this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent);\n        this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n        (_a = this.processor) === null || _a === void 0 ? void 0 : _a.destroy();\n        this.processor = undefined;\n    }\n    /**\n   * pauses publishing to the server without disabling the local MediaStreamTrack\n   * this is used to display a user's own video locally while pausing publishing to\n   * the server.\n   * this API is unsupported on Safari < 12 due to a bug\n   **/ pauseUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.pauseUpstreamLock.lock();\n            try {\n                if (this._isUpstreamPaused === true) {\n                    return;\n                }\n                if (!this.sender) {\n                    this.log.warn(\"unable to pause upstream for an unpublished track\", this.logContext);\n                    return;\n                }\n                this._isUpstreamPaused = true;\n                this.emit(TrackEvent.UpstreamPaused, this);\n                const browser = getBrowser();\n                if ((browser === null || browser === void 0 ? void 0 : browser.name) === \"Safari\" && compareVersions(browser.version, \"12.0\") < 0) {\n                    // https://bugs.webkit.org/show_bug.cgi?id=184911\n                    throw new DeviceUnsupportedError(\"pauseUpstream is not supported on Safari < 12.\");\n                }\n                yield this.sender.replaceTrack(null);\n            } finally{\n                unlock();\n            }\n        });\n    }\n    resumeUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.pauseUpstreamLock.lock();\n            try {\n                if (this._isUpstreamPaused === false) {\n                    return;\n                }\n                if (!this.sender) {\n                    this.log.warn(\"unable to resume upstream for an unpublished track\", this.logContext);\n                    return;\n                }\n                this._isUpstreamPaused = false;\n                this.emit(TrackEvent.UpstreamResumed, this);\n                // this operation is noop if mediastreamtrack is already being sent\n                yield this.sender.replaceTrack(this._mediaStreamTrack);\n            } finally{\n                unlock();\n            }\n        });\n    }\n    /**\n   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */ getRTCStatsReport() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return;\n            }\n            const statsReport = yield this.sender.getStats();\n            return statsReport;\n        });\n    }\n    /**\n   * Sets a processor on this track.\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   *\n   * @param processor\n   * @param showProcessedStreamLocally\n   * @returns\n   */ setProcessor(processor) {\n        let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.processorLock.lock();\n            try {\n                this.log.debug(\"setting up processor\", this.logContext);\n                if (this.processor) {\n                    yield this.stopProcessor();\n                }\n                if (this.kind === \"unknown\") {\n                    throw TypeError(\"cannot set processor on track of unknown kind\");\n                }\n                this.processorElement = (_a = this.processorElement) !== null && _a !== void 0 ? _a : document.createElement(this.kind);\n                attachToElement(this._mediaStreamTrack, this.processorElement);\n                this.processorElement.muted = true;\n                this.processorElement.play().catch((error)=>this.log.error(\"failed to play processor element\", Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    })));\n                const processorOptions = {\n                    kind: this.kind,\n                    track: this._mediaStreamTrack,\n                    element: this.processorElement\n                };\n                yield processor.init(processorOptions);\n                this.processor = processor;\n                if (this.processor.processedTrack) {\n                    for (const el of this.attachedElements){\n                        if (el !== this.processorElement && showProcessedStreamLocally) {\n                            detachTrack(this._mediaStreamTrack, el);\n                            attachToElement(this.processor.processedTrack, el);\n                        }\n                    }\n                    yield (_b = this.sender) === null || _b === void 0 ? void 0 : _b.replaceTrack(this.processor.processedTrack);\n                }\n            } finally{\n                unlock();\n            }\n        });\n    }\n    getProcessor() {\n        return this.processor;\n    }\n    /**\n   * Stops the track processor\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   * @returns\n   */ stopProcessor() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.processor) return;\n            this.log.debug(\"stopping processor\", this.logContext);\n            (_a = this.processor.processedTrack) === null || _a === void 0 ? void 0 : _a.stop();\n            yield this.processor.destroy();\n            this.processor = undefined;\n            (_b = this.processorElement) === null || _b === void 0 ? void 0 : _b.remove();\n            this.processorElement = undefined;\n            yield this.restart();\n        });\n    }\n}\n/**\n * @experimental\n */ class E2EEManager extends eventsExports.EventEmitter {\n    constructor(options){\n        super();\n        this.onWorkerMessage = (ev)=>{\n            var _a, _b;\n            const { kind, data } = ev.data;\n            switch(kind){\n                case \"error\":\n                    livekitLogger.error(data.error.message);\n                    this.emit(EncryptionEvent.EncryptionError, data.error);\n                    break;\n                case \"initAck\":\n                    if (data.enabled) {\n                        this.keyProvider.getKeys().forEach((keyInfo)=>{\n                            this.postKey(keyInfo);\n                        });\n                    }\n                    break;\n                case \"enable\":\n                    if (this.encryptionEnabled !== data.enabled && data.participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n                        this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, this.room.localParticipant);\n                        this.encryptionEnabled = data.enabled;\n                    } else if (data.participantIdentity) {\n                        const participant = (_b = this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);\n                        if (!participant) {\n                            throw TypeError(\"couldn't set encryption status, participant not found\".concat(data.participantIdentity));\n                        }\n                        this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, participant);\n                    }\n                    if (this.encryptionEnabled) {\n                        this.keyProvider.getKeys().forEach((keyInfo)=>{\n                            this.postKey(keyInfo);\n                        });\n                    }\n                    break;\n                case \"ratchetKey\":\n                    this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, data.material, data.keyIndex);\n                    break;\n            }\n        };\n        this.onWorkerError = (ev)=>{\n            livekitLogger.error(\"e2ee worker encountered an error:\", {\n                error: ev.error\n            });\n            this.emit(EncryptionEvent.EncryptionError, ev.error);\n        };\n        this.keyProvider = options.keyProvider;\n        this.worker = options.worker;\n        this.encryptionEnabled = false;\n    }\n    /**\n   * @internal\n   */ setup(room) {\n        if (!isE2EESupported()) {\n            throw new DeviceUnsupportedError(\"tried to setup end-to-end encryption on an unsupported browser\");\n        }\n        livekitLogger.info(\"setting up e2ee\");\n        if (room !== this.room) {\n            this.room = room;\n            this.setupEventListeners(room, this.keyProvider);\n            // this.worker = new Worker('');\n            const msg = {\n                kind: \"init\",\n                data: {\n                    keyProviderOptions: this.keyProvider.getOptions()\n                }\n            };\n            if (this.worker) {\n                livekitLogger.info(\"initializing worker\", {\n                    worker: this.worker\n                });\n                this.worker.onmessage = this.onWorkerMessage;\n                this.worker.onerror = this.onWorkerError;\n                this.worker.postMessage(msg);\n            }\n        }\n    }\n    /**\n   * @internal\n   */ setParticipantCryptorEnabled(enabled, participantIdentity) {\n        livekitLogger.debug(\"set e2ee to \".concat(enabled, \" for participant \").concat(participantIdentity));\n        this.postEnable(enabled, participantIdentity);\n    }\n    /**\n   * @internal\n   */ setSifTrailer(trailer) {\n        if (!trailer || trailer.length === 0) {\n            livekitLogger.warn(\"ignoring server sent trailer as it's empty\");\n        } else {\n            this.postSifTrailer(trailer);\n        }\n    }\n    setupEngine(engine) {\n        engine.on(EngineEvent.RTPVideoMapUpdate, (rtpMap)=>{\n            this.postRTPMap(rtpMap);\n        });\n    }\n    setupEventListeners(room, keyProvider) {\n        room.on(RoomEvent.TrackPublished, (pub, participant)=>this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity));\n        room.on(RoomEvent.ConnectionStateChanged, (state)=>{\n            if (state === ConnectionState.Connected) {\n                room.participants.forEach((participant)=>{\n                    participant.tracks.forEach((pub)=>{\n                        this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);\n                    });\n                });\n            }\n        }).on(RoomEvent.TrackUnsubscribed, (track, _, participant)=>{\n            var _a;\n            const msg = {\n                kind: \"removeTransform\",\n                data: {\n                    participantIdentity: participant.identity,\n                    trackId: track.mediaStreamID\n                }\n            };\n            (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(msg);\n        }).on(RoomEvent.TrackSubscribed, (track, pub, participant)=>{\n            this.setupE2EEReceiver(track, participant.identity, pub.trackInfo);\n        }).on(RoomEvent.SignalConnected, ()=>{\n            if (!this.room) {\n                throw new TypeError(\"expected room to be present on signal connect\");\n            }\n            this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);\n            keyProvider.getKeys().forEach((keyInfo)=>{\n                this.postKey(keyInfo);\n            });\n        });\n        room.localParticipant.on(ParticipantEvent.LocalTrackPublished, (publication)=>__awaiter(this, void 0, void 0, function*() {\n                this.setupE2EESender(publication.track, publication.track.sender);\n            }));\n        keyProvider.on(KeyProviderEvent.SetKey, (keyInfo)=>this.postKey(keyInfo)).on(KeyProviderEvent.RatchetRequest, (participantId, keyIndex)=>this.postRatchetRequest(participantId, keyIndex));\n    }\n    postRatchetRequest(participantIdentity, keyIndex) {\n        if (!this.worker) {\n            throw Error(\"could not ratchet key, worker is missing\");\n        }\n        const msg = {\n            kind: \"ratchetRequest\",\n            data: {\n                participantIdentity: participantIdentity,\n                keyIndex\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postKey(_ref) {\n        let { key, participantIdentity, keyIndex } = _ref;\n        var _a;\n        if (!this.worker) {\n            throw Error(\"could not set key, worker is missing\");\n        }\n        const msg = {\n            kind: \"setKey\",\n            data: {\n                participantIdentity: participantIdentity,\n                isPublisher: participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity),\n                key,\n                keyIndex\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postEnable(enabled, participantIdentity) {\n        if (this.worker) {\n            const enableMsg = {\n                kind: \"enable\",\n                data: {\n                    enabled,\n                    participantIdentity\n                }\n            };\n            this.worker.postMessage(enableMsg);\n        } else {\n            throw new ReferenceError(\"failed to enable e2ee, worker is not ready\");\n        }\n    }\n    postRTPMap(map) {\n        var _a;\n        if (!this.worker) {\n            throw TypeError(\"could not post rtp map, worker is missing\");\n        }\n        if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n            throw TypeError(\"could not post rtp map, local participant identity is missing\");\n        }\n        const msg = {\n            kind: \"setRTPMap\",\n            data: {\n                map,\n                participantIdentity: this.room.localParticipant.identity\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postSifTrailer(trailer) {\n        if (!this.worker) {\n            throw Error(\"could not post SIF trailer, worker is missing\");\n        }\n        const msg = {\n            kind: \"setSifTrailer\",\n            data: {\n                trailer\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    setupE2EEReceiver(track, remoteId, trackInfo) {\n        if (!track.receiver) {\n            return;\n        }\n        if (!(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) || trackInfo.mimeType === \"\") {\n            throw new TypeError(\"MimeType missing from trackInfo, cannot set up E2EE cryptor\");\n        }\n        this.handleReceiver(track.receiver, track.mediaStreamID, remoteId, track.kind === \"video\" ? mimeTypeToVideoCodecString(trackInfo.mimeType) : undefined);\n    }\n    setupE2EESender(track, sender) {\n        if (!(track instanceof LocalTrack) || !sender) {\n            if (!sender) livekitLogger.warn(\"early return because sender is not ready\");\n            return;\n        }\n        this.handleSender(sender, track.mediaStreamID, undefined);\n    }\n    /**\n   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject\n   * a frame decoder.\n   *\n   */ handleReceiver(receiver, trackId, participantIdentity, codec) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.worker) {\n                return;\n            }\n            if (isScriptTransformSupported()) {\n                const options = {\n                    kind: \"decode\",\n                    participantIdentity,\n                    trackId,\n                    codec\n                };\n                // @ts-ignore\n                receiver.transform = new RTCRtpScriptTransform(this.worker, options);\n            } else {\n                if (E2EE_FLAG in receiver && codec) {\n                    // only update codec\n                    const msg = {\n                        kind: \"updateCodec\",\n                        data: {\n                            trackId,\n                            codec,\n                            participantIdentity: participantIdentity\n                        }\n                    };\n                    this.worker.postMessage(msg);\n                    return;\n                }\n                // @ts-ignore\n                let writable = receiver.writableStream;\n                // @ts-ignore\n                let readable = receiver.readableStream;\n                if (!writable || !readable) {\n                    // @ts-ignore\n                    const receiverStreams = receiver.createEncodedStreams();\n                    // @ts-ignore\n                    receiver.writableStream = receiverStreams.writable;\n                    writable = receiverStreams.writable;\n                    // @ts-ignore\n                    receiver.readableStream = receiverStreams.readable;\n                    readable = receiverStreams.readable;\n                }\n                const msg = {\n                    kind: \"decode\",\n                    data: {\n                        readableStream: readable,\n                        writableStream: writable,\n                        trackId: trackId,\n                        codec,\n                        participantIdentity: participantIdentity\n                    }\n                };\n                this.worker.postMessage(msg, [\n                    readable,\n                    writable\n                ]);\n            }\n            // @ts-ignore\n            receiver[E2EE_FLAG] = true;\n        });\n    }\n    /**\n   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject\n   * a frame encoder.\n   *\n   */ handleSender(sender, trackId, codec) {\n        var _a;\n        if (E2EE_FLAG in sender || !this.worker) {\n            return;\n        }\n        if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity) || this.room.localParticipant.identity === \"\") {\n            throw TypeError(\"local identity needs to be known in order to set up encrypted sender\");\n        }\n        if (isScriptTransformSupported()) {\n            livekitLogger.info(\"initialize script transform\");\n            const options = {\n                kind: \"encode\",\n                participantIdentity: this.room.localParticipant.identity,\n                trackId,\n                codec\n            };\n            // @ts-ignore\n            sender.transform = new RTCRtpScriptTransform(this.worker, options);\n        } else {\n            livekitLogger.info(\"initialize encoded streams\");\n            // @ts-ignore\n            const senderStreams = sender.createEncodedStreams();\n            const msg = {\n                kind: \"encode\",\n                data: {\n                    readableStream: senderStreams.readable,\n                    writableStream: senderStreams.writable,\n                    codec,\n                    trackId,\n                    participantIdentity: this.room.localParticipant.identity\n                }\n            };\n            this.worker.postMessage(msg, [\n                senderStreams.readable,\n                senderStreams.writable\n            ]);\n        }\n        // @ts-ignore\n        sender[E2EE_FLAG] = true;\n    }\n}\nvar QueueTaskStatus;\n(function(QueueTaskStatus) {\n    QueueTaskStatus[QueueTaskStatus[\"WAITING\"] = 0] = \"WAITING\";\n    QueueTaskStatus[QueueTaskStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n    QueueTaskStatus[QueueTaskStatus[\"COMPLETED\"] = 2] = \"COMPLETED\";\n})(QueueTaskStatus || (QueueTaskStatus = {}));\nclass AsyncQueue {\n    constructor(){\n        this.pendingTasks = new Map();\n        this.taskMutex = new Mutex();\n        this.nextTaskIndex = 0;\n    }\n    run(task) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const taskInfo = {\n                id: this.nextTaskIndex++,\n                enqueuedAt: Date.now(),\n                status: QueueTaskStatus.WAITING\n            };\n            this.pendingTasks.set(taskInfo.id, taskInfo);\n            const unlock = yield this.taskMutex.lock();\n            try {\n                taskInfo.executedAt = Date.now();\n                taskInfo.status = QueueTaskStatus.RUNNING;\n                return yield task();\n            } finally{\n                taskInfo.status = QueueTaskStatus.COMPLETED;\n                this.pendingTasks.delete(taskInfo.id);\n                unlock();\n            }\n        });\n    }\n    flush() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.run(()=>__awaiter(this, void 0, void 0, function*() {}));\n        });\n    }\n    snapshot() {\n        return Array.from(this.pendingTasks.values());\n    }\n}\nconst passThroughQueueSignals = [\n    \"syncState\",\n    \"trickle\",\n    \"offer\",\n    \"answer\",\n    \"simulate\",\n    \"leave\"\n];\nfunction canPassThroughQueue(req) {\n    const canPass = passThroughQueueSignals.indexOf(req.case) >= 0;\n    livekitLogger.trace(\"request allowed to bypass queue:\", {\n        canPass,\n        req\n    });\n    return canPass;\n}\nvar SignalConnectionState;\n(function(SignalConnectionState) {\n    SignalConnectionState[SignalConnectionState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"CONNECTED\"] = 1] = \"CONNECTED\";\n    SignalConnectionState[SignalConnectionState[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"DISCONNECTING\"] = 3] = \"DISCONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"DISCONNECTED\"] = 4] = \"DISCONNECTED\";\n})(SignalConnectionState || (SignalConnectionState = {}));\n/** @internal */ class SignalClient {\n    get currentState() {\n        return this.state;\n    }\n    get isDisconnected() {\n        return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;\n    }\n    get isEstablishingConnection() {\n        return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;\n    }\n    constructor(){\n        let useJSON = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _a;\n        /** signal rtt in milliseconds */ this.rtt = 0;\n        this.state = SignalConnectionState.DISCONNECTED;\n        this.log = livekitLogger;\n        /** @internal */ this.resetCallbacks = ()=>{\n            this.onAnswer = undefined;\n            this.onLeave = undefined;\n            this.onLocalTrackPublished = undefined;\n            this.onLocalTrackUnpublished = undefined;\n            this.onNegotiateRequested = undefined;\n            this.onOffer = undefined;\n            this.onRemoteMuteChanged = undefined;\n            this.onSubscribedQualityUpdate = undefined;\n            this.onTokenRefresh = undefined;\n            this.onTrickle = undefined;\n            this.onClose = undefined;\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Signal);\n        this.loggerContextCb = loggerOptions.loggerContextCb;\n        this.useJSON = useJSON;\n        this.requestQueue = new AsyncQueue();\n        this.queuedRequests = [];\n        this.closingLock = new Mutex();\n        this.connectionLock = new Mutex();\n        this.state = SignalConnectionState.DISCONNECTED;\n    }\n    get logContext() {\n        var _a, _b;\n        return (_b = (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : {};\n    }\n    join(url, token, opts, abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // during a full reconnect, we'd want to start the sequence even if currently\n            // connected\n            this.state = SignalConnectionState.CONNECTING;\n            this.options = opts;\n            const res = yield this.connect(url, token, opts, abortSignal);\n            return res;\n        });\n    }\n    reconnect(url, token, sid, reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.options) {\n                this.log.warn(\"attempted to reconnect without signal options being set, ignoring\", this.logContext);\n                return;\n            }\n            this.state = SignalConnectionState.RECONNECTING;\n            // clear ping interval and restart it once reconnected\n            this.clearPingInterval();\n            const res = yield this.connect(url, token, Object.assign(Object.assign({}, this.options), {\n                reconnect: true,\n                sid,\n                reconnectReason: reason\n            }));\n            return res;\n        });\n    }\n    connect(url, token, opts, abortSignal) {\n        this.connectOptions = opts;\n        url = toWebsocketUrl(url);\n        // strip trailing slash\n        url = url.replace(/\\/$/, \"\");\n        url += \"/rtc\";\n        const clientInfo = getClientInfo();\n        const params = createConnectionParams(token, clientInfo, opts);\n        return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                const unlock = yield this.connectionLock.lock();\n                try {\n                    const abortHandler = ()=>__awaiter(this, void 0, void 0, function*() {\n                            this.close();\n                            clearTimeout(wsTimeout);\n                            reject(new ConnectionError(\"room connection has been cancelled (signal)\"));\n                        });\n                    const wsTimeout = setTimeout(()=>{\n                        this.close();\n                        reject(new ConnectionError(\"room connection has timed out (signal)\"));\n                    }, opts.websocketTimeout);\n                    if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\n                        abortHandler();\n                    }\n                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener(\"abort\", abortHandler);\n                    this.log.debug(\"connecting to \".concat(url + params), this.logContext);\n                    if (this.ws) {\n                        yield this.close();\n                    }\n                    this.ws = new WebSocket(url + params);\n                    this.ws.binaryType = \"arraybuffer\";\n                    this.ws.onopen = ()=>{\n                        clearTimeout(wsTimeout);\n                    };\n                    this.ws.onerror = (ev)=>__awaiter(this, void 0, void 0, function*() {\n                            if (this.state !== SignalConnectionState.CONNECTED) {\n                                clearTimeout(wsTimeout);\n                                try {\n                                    const resp = yield fetch(\"http\".concat(url.substring(2), \"/validate\").concat(params));\n                                    if (resp.status.toFixed(0).startsWith(\"4\")) {\n                                        const msg = yield resp.text();\n                                        reject(new ConnectionError(msg, 0 /* ConnectionErrorReason.NotAllowed */ , resp.status));\n                                    } else {\n                                        reject(new ConnectionError(\"Internal error\", 2 /* ConnectionErrorReason.InternalError */ , resp.status));\n                                    }\n                                } catch (e) {\n                                    reject(new ConnectionError(\"server was not reachable\", 1 /* ConnectionErrorReason.ServerUnreachable */ ));\n                                }\n                                return;\n                            }\n                            // other errors, handle\n                            this.handleWSError(ev);\n                        });\n                    this.ws.onmessage = (ev)=>__awaiter(this, void 0, void 0, function*() {\n                            var _a, _b, _c, _d;\n                            // not considered connected until JoinResponse is received\n                            let resp;\n                            if (typeof ev.data === \"string\") {\n                                const json = JSON.parse(ev.data);\n                                resp = SignalResponse.fromJson(json);\n                            } else if (ev.data instanceof ArrayBuffer) {\n                                resp = SignalResponse.fromBinary(new Uint8Array(ev.data));\n                            } else {\n                                this.log.error(\"could not decode websocket message: \".concat(typeof ev.data), this.logContext);\n                                return;\n                            }\n                            if (this.state !== SignalConnectionState.CONNECTED) {\n                                let shouldProcessMessage = false;\n                                // handle join message only\n                                if (((_a = resp.message) === null || _a === void 0 ? void 0 : _a.case) === \"join\") {\n                                    this.state = SignalConnectionState.CONNECTED;\n                                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener(\"abort\", abortHandler);\n                                    this.pingTimeoutDuration = resp.message.value.pingTimeout;\n                                    this.pingIntervalDuration = resp.message.value.pingInterval;\n                                    if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {\n                                        this.log.debug(\"ping config\", Object.assign(Object.assign({}, this.logContext), {\n                                            timeout: this.pingTimeoutDuration,\n                                            interval: this.pingIntervalDuration\n                                        }));\n                                        this.startPingInterval();\n                                    }\n                                    resolve(resp.message.value);\n                                } else if (this.state === SignalConnectionState.RECONNECTING && resp.message.case !== \"leave\") {\n                                    // in reconnecting, any message received means signal reconnected\n                                    this.state = SignalConnectionState.CONNECTED;\n                                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener(\"abort\", abortHandler);\n                                    this.startPingInterval();\n                                    if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b.case) === \"reconnect\") {\n                                        resolve((_c = resp.message) === null || _c === void 0 ? void 0 : _c.value);\n                                    } else {\n                                        resolve();\n                                        shouldProcessMessage = true;\n                                    }\n                                } else if (this.isEstablishingConnection && resp.message.case === \"leave\") {\n                                    reject(new ConnectionError(\"Received leave request while trying to (re)connect\", 4 /* ConnectionErrorReason.LeaveRequest */ ));\n                                } else if (!opts.reconnect) {\n                                    // non-reconnect case, should receive join response first\n                                    reject(new ConnectionError(\"did not receive join response, got \".concat((_d = resp.message) === null || _d === void 0 ? void 0 : _d.case, \" instead\")));\n                                }\n                                if (!shouldProcessMessage) {\n                                    return;\n                                }\n                            }\n                            if (this.signalLatency) {\n                                yield sleep(this.signalLatency);\n                            }\n                            this.handleSignalResponse(resp);\n                        });\n                    this.ws.onclose = (ev)=>{\n                        if (this.isEstablishingConnection) {\n                            reject(new ConnectionError(\"Websocket got closed during a (re)connection attempt\"));\n                        }\n                        this.log.warn(\"websocket closed\", Object.assign(Object.assign({}, this.logContext), {\n                            reason: ev.reason,\n                            state: this.state\n                        }));\n                        this.handleOnClose(ev.reason);\n                    };\n                } finally{\n                    unlock();\n                }\n            }));\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.closingLock.lock();\n            try {\n                this.state = SignalConnectionState.DISCONNECTING;\n                if (this.ws) {\n                    this.ws.onmessage = null;\n                    this.ws.onopen = null;\n                    this.ws.onclose = null;\n                    // calling `ws.close()` only starts the closing handshake (CLOSING state), prefer to wait until state is actually CLOSED\n                    const closePromise = new Promise((resolve)=>{\n                        if (this.ws) {\n                            this.ws.onclose = ()=>{\n                                resolve();\n                            };\n                        } else {\n                            resolve();\n                        }\n                    });\n                    if (this.ws.readyState < this.ws.CLOSING) {\n                        this.ws.close();\n                        // 250ms grace period for ws to close gracefully\n                        yield Promise.race([\n                            closePromise,\n                            sleep(250)\n                        ]);\n                    }\n                    this.ws = undefined;\n                }\n            } finally{\n                this.state = SignalConnectionState.DISCONNECTED;\n                this.clearPingInterval();\n                unlock();\n            }\n        });\n    }\n    // initial offer after joining\n    sendOffer(offer) {\n        this.log.debug(\"sending offer\", Object.assign(Object.assign({}, this.logContext), {\n            offerSdp: offer.sdp\n        }));\n        this.sendRequest({\n            case: \"offer\",\n            value: toProtoSessionDescription(offer)\n        });\n    }\n    // answer a server-initiated offer\n    sendAnswer(answer) {\n        this.log.debug(\"sending answer\", Object.assign(Object.assign({}, this.logContext), {\n            answerSdp: answer.sdp\n        }));\n        return this.sendRequest({\n            case: \"answer\",\n            value: toProtoSessionDescription(answer)\n        });\n    }\n    sendIceCandidate(candidate, target) {\n        this.log.trace(\"sending ice candidate\", Object.assign(Object.assign({}, this.logContext), {\n            candidate\n        }));\n        return this.sendRequest({\n            case: \"trickle\",\n            value: new TrickleRequest({\n                candidateInit: JSON.stringify(candidate),\n                target\n            })\n        });\n    }\n    sendMuteTrack(trackSid, muted) {\n        return this.sendRequest({\n            case: \"mute\",\n            value: new MuteTrackRequest({\n                sid: trackSid,\n                muted\n            })\n        });\n    }\n    sendAddTrack(req) {\n        return this.sendRequest({\n            case: \"addTrack\",\n            value: req\n        });\n    }\n    sendUpdateLocalMetadata(metadata, name) {\n        return this.sendRequest({\n            case: \"updateMetadata\",\n            value: new UpdateParticipantMetadata({\n                metadata,\n                name\n            })\n        });\n    }\n    sendUpdateTrackSettings(settings) {\n        this.sendRequest({\n            case: \"trackSetting\",\n            value: settings\n        });\n    }\n    sendUpdateSubscription(sub) {\n        return this.sendRequest({\n            case: \"subscription\",\n            value: sub\n        });\n    }\n    sendSyncState(sync) {\n        return this.sendRequest({\n            case: \"syncState\",\n            value: sync\n        });\n    }\n    sendUpdateVideoLayers(trackSid, layers) {\n        return this.sendRequest({\n            case: \"updateLayers\",\n            value: new UpdateVideoLayers({\n                trackSid,\n                layers\n            })\n        });\n    }\n    sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {\n        return this.sendRequest({\n            case: \"subscriptionPermission\",\n            value: new SubscriptionPermission({\n                allParticipants,\n                trackPermissions\n            })\n        });\n    }\n    sendSimulateScenario(scenario) {\n        return this.sendRequest({\n            case: \"simulate\",\n            value: scenario\n        });\n    }\n    sendPing() {\n        /** send both of ping and pingReq for compatibility to old and new server */ return Promise.all([\n            this.sendRequest({\n                case: \"ping\",\n                value: protoInt64.parse(Date.now())\n            }),\n            this.sendRequest({\n                case: \"pingReq\",\n                value: new Ping({\n                    timestamp: protoInt64.parse(Date.now()),\n                    rtt: protoInt64.parse(this.rtt)\n                })\n            })\n        ]);\n    }\n    sendLeave() {\n        return this.sendRequest({\n            case: \"leave\",\n            value: new LeaveRequest({\n                canReconnect: false,\n                reason: DisconnectReason.CLIENT_INITIATED\n            })\n        });\n    }\n    sendRequest(message) {\n        let fromQueue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        return __awaiter(this, void 0, void 0, function*() {\n            // capture all requests while reconnecting and put them in a queue\n            // unless the request originates from the queue, then don't enqueue again\n            const canQueue = !fromQueue && !canPassThroughQueue(message);\n            if (canQueue && this.state === SignalConnectionState.RECONNECTING) {\n                this.queuedRequests.push(()=>__awaiter(this, void 0, void 0, function*() {\n                        yield this.sendRequest(message, true);\n                    }));\n                return;\n            }\n            // make sure previously queued requests are being sent first\n            if (!fromQueue) {\n                yield this.requestQueue.flush();\n            }\n            if (this.signalLatency) {\n                yield sleep(this.signalLatency);\n            }\n            if (!this.ws || this.ws.readyState !== this.ws.OPEN) {\n                this.log.error(\"cannot send signal request before connected, type: \".concat(message === null || message === void 0 ? void 0 : message.case), this.logContext);\n                return;\n            }\n            const req = new SignalRequest({\n                message\n            });\n            try {\n                if (this.useJSON) {\n                    this.ws.send(req.toJsonString());\n                } else {\n                    this.ws.send(req.toBinary());\n                }\n            } catch (e) {\n                this.log.error(\"error sending signal message\", Object.assign(Object.assign({}, this.logContext), {\n                    error: e\n                }));\n            }\n        });\n    }\n    handleSignalResponse(res) {\n        var _a, _b;\n        const msg = res.message;\n        if (msg == undefined) {\n            this.log.debug(\"received unsupported message\", this.logContext);\n            return;\n        }\n        let pingHandled = false;\n        if (msg.case === \"answer\") {\n            const sd = fromProtoSessionDescription(msg.value);\n            if (this.onAnswer) {\n                this.onAnswer(sd);\n            }\n        } else if (msg.case === \"offer\") {\n            const sd = fromProtoSessionDescription(msg.value);\n            if (this.onOffer) {\n                this.onOffer(sd);\n            }\n        } else if (msg.case === \"trickle\") {\n            const candidate = JSON.parse(msg.value.candidateInit);\n            if (this.onTrickle) {\n                this.onTrickle(candidate, msg.value.target);\n            }\n        } else if (msg.case === \"update\") {\n            if (this.onParticipantUpdate) {\n                this.onParticipantUpdate((_a = msg.value.participants) !== null && _a !== void 0 ? _a : []);\n            }\n        } else if (msg.case === \"trackPublished\") {\n            if (this.onLocalTrackPublished) {\n                this.onLocalTrackPublished(msg.value);\n            }\n        } else if (msg.case === \"speakersChanged\") {\n            if (this.onSpeakersChanged) {\n                this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);\n            }\n        } else if (msg.case === \"leave\") {\n            if (this.onLeave) {\n                this.onLeave(msg.value);\n            }\n        } else if (msg.case === \"mute\") {\n            if (this.onRemoteMuteChanged) {\n                this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);\n            }\n        } else if (msg.case === \"roomUpdate\") {\n            if (this.onRoomUpdate && msg.value.room) {\n                this.onRoomUpdate(msg.value.room);\n            }\n        } else if (msg.case === \"connectionQuality\") {\n            if (this.onConnectionQuality) {\n                this.onConnectionQuality(msg.value);\n            }\n        } else if (msg.case === \"streamStateUpdate\") {\n            if (this.onStreamStateUpdate) {\n                this.onStreamStateUpdate(msg.value);\n            }\n        } else if (msg.case === \"subscribedQualityUpdate\") {\n            if (this.onSubscribedQualityUpdate) {\n                this.onSubscribedQualityUpdate(msg.value);\n            }\n        } else if (msg.case === \"subscriptionPermissionUpdate\") {\n            if (this.onSubscriptionPermissionUpdate) {\n                this.onSubscriptionPermissionUpdate(msg.value);\n            }\n        } else if (msg.case === \"refreshToken\") {\n            if (this.onTokenRefresh) {\n                this.onTokenRefresh(msg.value);\n            }\n        } else if (msg.case === \"trackUnpublished\") {\n            if (this.onLocalTrackUnpublished) {\n                this.onLocalTrackUnpublished(msg.value);\n            }\n        } else if (msg.case === \"subscriptionResponse\") {\n            if (this.onSubscriptionError) {\n                this.onSubscriptionError(msg.value);\n            }\n        } else if (msg.case === \"pong\") ;\n        else if (msg.case === \"pongResp\") {\n            this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());\n            this.resetPingTimeout();\n            pingHandled = true;\n        } else {\n            this.log.debug(\"unsupported message\", Object.assign(Object.assign({}, this.logContext), {\n                msgCase: msg.case\n            }));\n        }\n        if (!pingHandled) {\n            this.resetPingTimeout();\n        }\n    }\n    setReconnected() {\n        while(this.queuedRequests.length > 0){\n            const req = this.queuedRequests.shift();\n            if (req) {\n                this.requestQueue.run(req);\n            }\n        }\n    }\n    handleOnClose(reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state === SignalConnectionState.DISCONNECTED) return;\n            const onCloseCallback = this.onClose;\n            yield this.close();\n            this.log.debug(\"websocket connection closed: \".concat(reason), Object.assign(Object.assign({}, this.logContext), {\n                reason\n            }));\n            if (onCloseCallback) {\n                onCloseCallback(reason);\n            }\n        });\n    }\n    handleWSError(ev) {\n        this.log.error(\"websocket error\", Object.assign(Object.assign({}, this.logContext), {\n            error: ev\n        }));\n    }\n    /**\n   * Resets the ping timeout and starts a new timeout.\n   * Call this after receiving a pong message\n   */ resetPingTimeout() {\n        this.clearPingTimeout();\n        if (!this.pingTimeoutDuration) {\n            this.log.warn(\"ping timeout duration not set\", this.logContext);\n            return;\n        }\n        this.pingTimeout = CriticalTimers.setTimeout(()=>{\n            this.log.warn(\"ping timeout triggered. last pong received at: \".concat(new Date(Date.now() - this.pingTimeoutDuration * 1000).toUTCString()), this.logContext);\n            this.handleOnClose(\"ping timeout\");\n        }, this.pingTimeoutDuration * 1000);\n    }\n    /**\n   * Clears ping timeout (does not start a new timeout)\n   */ clearPingTimeout() {\n        if (this.pingTimeout) {\n            CriticalTimers.clearTimeout(this.pingTimeout);\n        }\n    }\n    startPingInterval() {\n        this.clearPingInterval();\n        this.resetPingTimeout();\n        if (!this.pingIntervalDuration) {\n            this.log.warn(\"ping interval duration not set\", this.logContext);\n            return;\n        }\n        this.log.debug(\"start ping interval\", this.logContext);\n        this.pingInterval = CriticalTimers.setInterval(()=>{\n            this.sendPing();\n        }, this.pingIntervalDuration * 1000);\n    }\n    clearPingInterval() {\n        this.log.debug(\"clearing ping interval\", this.logContext);\n        this.clearPingTimeout();\n        if (this.pingInterval) {\n            CriticalTimers.clearInterval(this.pingInterval);\n        }\n    }\n}\nfunction fromProtoSessionDescription(sd) {\n    const rsd = {\n        type: \"offer\",\n        sdp: sd.sdp\n    };\n    switch(sd.type){\n        case \"answer\":\n        case \"offer\":\n        case \"pranswer\":\n        case \"rollback\":\n            rsd.type = sd.type;\n            break;\n    }\n    return rsd;\n}\nfunction toProtoSessionDescription(rsd) {\n    const sd = new SessionDescription({\n        sdp: rsd.sdp,\n        type: rsd.type\n    });\n    return sd;\n}\nfunction createConnectionParams(token, info, opts) {\n    var _a;\n    const params = new URLSearchParams();\n    params.set(\"access_token\", token);\n    // opts\n    if (opts.reconnect) {\n        params.set(\"reconnect\", \"1\");\n        if (opts.sid) {\n            params.set(\"sid\", opts.sid);\n        }\n    }\n    params.set(\"auto_subscribe\", opts.autoSubscribe ? \"1\" : \"0\");\n    // ClientInfo\n    params.set(\"sdk\", isReactNative() ? \"reactnative\" : \"js\");\n    params.set(\"version\", info.version);\n    params.set(\"protocol\", info.protocol.toString());\n    if (info.deviceModel) {\n        params.set(\"device_model\", info.deviceModel);\n    }\n    if (info.os) {\n        params.set(\"os\", info.os);\n    }\n    if (info.osVersion) {\n        params.set(\"os_version\", info.osVersion);\n    }\n    if (info.browser) {\n        params.set(\"browser\", info.browser);\n    }\n    if (info.browserVersion) {\n        params.set(\"browser_version\", info.browserVersion);\n    }\n    if (opts.publishOnly !== undefined) {\n        params.set(\"publish\", opts.publishOnly);\n    }\n    if (opts.adaptiveStream) {\n        params.set(\"adaptive_stream\", \"1\");\n    }\n    if (opts.reconnectReason) {\n        params.set(\"reconnect_reason\", opts.reconnectReason.toString());\n    }\n    // @ts-ignore\n    if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {\n        // @ts-ignore\n        params.set(\"network\", navigator.connection.type);\n    }\n    return \"?\".concat(params.toString());\n}\nvar parser$1 = {};\nvar grammar$2 = {\n    exports: {}\n};\nvar grammar$1 = grammar$2.exports = {\n    v: [\n        {\n            name: \"version\",\n            reg: /^(\\d*)$/\n        }\n    ],\n    o: [\n        {\n            // o=- 20518 0 IN IP4 203.0.113.1\n            // NB: sessionId will be a String in most cases because it is huge\n            name: \"origin\",\n            reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n            names: [\n                \"username\",\n                \"sessionId\",\n                \"sessionVersion\",\n                \"netType\",\n                \"ipVer\",\n                \"address\"\n            ],\n            format: \"%s %s %d %s IP%d %s\"\n        }\n    ],\n    // default parsing of these only (though some of these feel outdated)\n    s: [\n        {\n            name: \"name\"\n        }\n    ],\n    i: [\n        {\n            name: \"description\"\n        }\n    ],\n    u: [\n        {\n            name: \"uri\"\n        }\n    ],\n    e: [\n        {\n            name: \"email\"\n        }\n    ],\n    p: [\n        {\n            name: \"phone\"\n        }\n    ],\n    z: [\n        {\n            name: \"timezones\"\n        }\n    ],\n    // TODO: this one can actually be parsed properly...\n    r: [\n        {\n            name: \"repeats\"\n        }\n    ],\n    // TODO: this one can also be parsed properly\n    // k: [{}], // outdated thing ignored\n    t: [\n        {\n            // t=0 0\n            name: \"timing\",\n            reg: /^(\\d*) (\\d*)/,\n            names: [\n                \"start\",\n                \"stop\"\n            ],\n            format: \"%d %d\"\n        }\n    ],\n    c: [\n        {\n            // c=IN IP4 10.47.197.26\n            name: \"connection\",\n            reg: /^IN IP(\\d) (\\S*)/,\n            names: [\n                \"version\",\n                \"ip\"\n            ],\n            format: \"IN IP%d %s\"\n        }\n    ],\n    b: [\n        {\n            // b=AS:4000\n            push: \"bandwidth\",\n            reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n            names: [\n                \"type\",\n                \"limit\"\n            ],\n            format: \"%s:%s\"\n        }\n    ],\n    m: [\n        {\n            // m=video 51744 RTP/AVP 126 97 98 34 31\n            // NB: special - pushes to session\n            // TODO: rtp/fmtp should be filtered by the payloads found here?\n            reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n            names: [\n                \"type\",\n                \"port\",\n                \"protocol\",\n                \"payloads\"\n            ],\n            format: \"%s %d %s %s\"\n        }\n    ],\n    a: [\n        {\n            // a=rtpmap:110 opus/48000/2\n            push: \"rtp\",\n            reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n            names: [\n                \"payload\",\n                \"codec\",\n                \"rate\",\n                \"encoding\"\n            ],\n            format: function(o) {\n                return o.encoding ? \"rtpmap:%d %s/%s/%s\" : o.rate ? \"rtpmap:%d %s/%s\" : \"rtpmap:%d %s\";\n            }\n        },\n        {\n            // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n            // a=fmtp:111 minptime=10; useinbandfec=1\n            push: \"fmtp\",\n            reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n            names: [\n                \"payload\",\n                \"config\"\n            ],\n            format: \"fmtp:%d %s\"\n        },\n        {\n            // a=control:streamid=0\n            name: \"control\",\n            reg: /^control:(.*)/,\n            format: \"control:%s\"\n        },\n        {\n            // a=rtcp:65179 IN IP4 193.84.77.194\n            name: \"rtcp\",\n            reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n            names: [\n                \"port\",\n                \"netType\",\n                \"ipVer\",\n                \"address\"\n            ],\n            format: function(o) {\n                return o.address != null ? \"rtcp:%d %s IP%d %s\" : \"rtcp:%d\";\n            }\n        },\n        {\n            // a=rtcp-fb:98 trr-int 100\n            push: \"rtcpFbTrrInt\",\n            reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n            names: [\n                \"payload\",\n                \"value\"\n            ],\n            format: \"rtcp-fb:%s trr-int %d\"\n        },\n        {\n            // a=rtcp-fb:98 nack rpsi\n            push: \"rtcpFb\",\n            reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n            names: [\n                \"payload\",\n                \"type\",\n                \"subtype\"\n            ],\n            format: function(o) {\n                return o.subtype != null ? \"rtcp-fb:%s %s %s\" : \"rtcp-fb:%s %s\";\n            }\n        },\n        {\n            // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n            // a=extmap:1/recvonly URI-gps-string\n            // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n            push: \"ext\",\n            reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n            names: [\n                \"value\",\n                \"direction\",\n                \"encrypt-uri\",\n                \"uri\",\n                \"config\"\n            ],\n            format: function(o) {\n                return \"extmap:%d\" + (o.direction ? \"/%s\" : \"%v\") + (o[\"encrypt-uri\"] ? \" %s\" : \"%v\") + \" %s\" + (o.config ? \" %s\" : \"\");\n            }\n        },\n        {\n            // a=extmap-allow-mixed\n            name: \"extmapAllowMixed\",\n            reg: /^(extmap-allow-mixed)/\n        },\n        {\n            // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n            push: \"crypto\",\n            reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n            names: [\n                \"id\",\n                \"suite\",\n                \"config\",\n                \"sessionConfig\"\n            ],\n            format: function(o) {\n                return o.sessionConfig != null ? \"crypto:%d %s %s %s\" : \"crypto:%d %s %s\";\n            }\n        },\n        {\n            // a=setup:actpass\n            name: \"setup\",\n            reg: /^setup:(\\w*)/,\n            format: \"setup:%s\"\n        },\n        {\n            // a=connection:new\n            name: \"connectionType\",\n            reg: /^connection:(new|existing)/,\n            format: \"connection:%s\"\n        },\n        {\n            // a=mid:1\n            name: \"mid\",\n            reg: /^mid:([^\\s]*)/,\n            format: \"mid:%s\"\n        },\n        {\n            // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n            name: \"msid\",\n            reg: /^msid:(.*)/,\n            format: \"msid:%s\"\n        },\n        {\n            // a=ptime:20\n            name: \"ptime\",\n            reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n            format: \"ptime:%d\"\n        },\n        {\n            // a=maxptime:60\n            name: \"maxptime\",\n            reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n            format: \"maxptime:%d\"\n        },\n        {\n            // a=sendrecv\n            name: \"direction\",\n            reg: /^(sendrecv|recvonly|sendonly|inactive)/\n        },\n        {\n            // a=ice-lite\n            name: \"icelite\",\n            reg: /^(ice-lite)/\n        },\n        {\n            // a=ice-ufrag:F7gI\n            name: \"iceUfrag\",\n            reg: /^ice-ufrag:(\\S*)/,\n            format: \"ice-ufrag:%s\"\n        },\n        {\n            // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n            name: \"icePwd\",\n            reg: /^ice-pwd:(\\S*)/,\n            format: \"ice-pwd:%s\"\n        },\n        {\n            // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n            name: \"fingerprint\",\n            reg: /^fingerprint:(\\S*) (\\S*)/,\n            names: [\n                \"type\",\n                \"hash\"\n            ],\n            format: \"fingerprint:%s %s\"\n        },\n        {\n            // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n            // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n            // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n            // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n            // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n            push: \"candidates\",\n            reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n            names: [\n                \"foundation\",\n                \"component\",\n                \"transport\",\n                \"priority\",\n                \"ip\",\n                \"port\",\n                \"type\",\n                \"raddr\",\n                \"rport\",\n                \"tcptype\",\n                \"generation\",\n                \"network-id\",\n                \"network-cost\"\n            ],\n            format: function(o) {\n                var str = \"candidate:%s %d %s %d %s %d typ %s\";\n                str += o.raddr != null ? \" raddr %s rport %d\" : \"%v%v\";\n                // NB: candidate has three optional chunks, so %void middles one if it's missing\n                str += o.tcptype != null ? \" tcptype %s\" : \"%v\";\n                if (o.generation != null) {\n                    str += \" generation %d\";\n                }\n                str += o[\"network-id\"] != null ? \" network-id %d\" : \"%v\";\n                str += o[\"network-cost\"] != null ? \" network-cost %d\" : \"%v\";\n                return str;\n            }\n        },\n        {\n            // a=end-of-candidates (keep after the candidates line for readability)\n            name: \"endOfCandidates\",\n            reg: /^(end-of-candidates)/\n        },\n        {\n            // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n            name: \"remoteCandidates\",\n            reg: /^remote-candidates:(.*)/,\n            format: \"remote-candidates:%s\"\n        },\n        {\n            // a=ice-options:google-ice\n            name: \"iceOptions\",\n            reg: /^ice-options:(\\S*)/,\n            format: \"ice-options:%s\"\n        },\n        {\n            // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n            push: \"ssrcs\",\n            reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n            names: [\n                \"id\",\n                \"attribute\",\n                \"value\"\n            ],\n            format: function(o) {\n                var str = \"ssrc:%d\";\n                if (o.attribute != null) {\n                    str += \" %s\";\n                    if (o.value != null) {\n                        str += \":%s\";\n                    }\n                }\n                return str;\n            }\n        },\n        {\n            // a=ssrc-group:FEC 1 2\n            // a=ssrc-group:FEC-FR 3004364195 1080772241\n            push: \"ssrcGroups\",\n            // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n            reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n            names: [\n                \"semantics\",\n                \"ssrcs\"\n            ],\n            format: \"ssrc-group:%s %s\"\n        },\n        {\n            // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n            name: \"msidSemantic\",\n            reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n            names: [\n                \"semantic\",\n                \"token\"\n            ],\n            format: \"msid-semantic: %s %s\" // space after ':' is not accidental\n        },\n        {\n            // a=group:BUNDLE audio video\n            push: \"groups\",\n            reg: /^group:(\\w*) (.*)/,\n            names: [\n                \"type\",\n                \"mids\"\n            ],\n            format: \"group:%s %s\"\n        },\n        {\n            // a=rtcp-mux\n            name: \"rtcpMux\",\n            reg: /^(rtcp-mux)/\n        },\n        {\n            // a=rtcp-rsize\n            name: \"rtcpRsize\",\n            reg: /^(rtcp-rsize)/\n        },\n        {\n            // a=sctpmap:5000 webrtc-datachannel 1024\n            name: \"sctpmap\",\n            reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n            names: [\n                \"sctpmapNumber\",\n                \"app\",\n                \"maxMessageSize\"\n            ],\n            format: function(o) {\n                return o.maxMessageSize != null ? \"sctpmap:%s %s %s\" : \"sctpmap:%s %s\";\n            }\n        },\n        {\n            // a=x-google-flag:conference\n            name: \"xGoogleFlag\",\n            reg: /^x-google-flag:([^\\s]*)/,\n            format: \"x-google-flag:%s\"\n        },\n        {\n            // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n            push: \"rids\",\n            reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n            names: [\n                \"id\",\n                \"direction\",\n                \"params\"\n            ],\n            format: function(o) {\n                return o.params ? \"rid:%s %s %s\" : \"rid:%s %s\";\n            }\n        },\n        {\n            // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n            // a=imageattr:* send [x=800,y=640] recv *\n            // a=imageattr:100 recv [x=320,y=240]\n            push: \"imageattrs\",\n            reg: new RegExp(// a=imageattr:97\n            \"^imageattr:(\\\\d+|\\\\*)\" + // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n            \"[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)\" + // recv [x=330,y=250]\n            \"(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?\"),\n            names: [\n                \"pt\",\n                \"dir1\",\n                \"attrs1\",\n                \"dir2\",\n                \"attrs2\"\n            ],\n            format: function(o) {\n                return \"imageattr:%s %s %s\" + (o.dir2 ? \" %s %s\" : \"\");\n            }\n        },\n        {\n            // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n            // a=simulcast:recv 1;4,5 send 6;7\n            name: \"simulcast\",\n            reg: new RegExp(// a=simulcast:\n            \"^simulcast:\" + // send 1,2,3;~4,~5\n            \"(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)\" + // space + recv 6;~7,~8\n            \"(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?\" + // end\n            \"$\"),\n            names: [\n                \"dir1\",\n                \"list1\",\n                \"dir2\",\n                \"list2\"\n            ],\n            format: function(o) {\n                return \"simulcast:%s %s\" + (o.dir2 ? \" %s %s\" : \"\");\n            }\n        },\n        {\n            // old simulcast draft 03 (implemented by Firefox)\n            //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n            // a=simulcast: recv pt=97;98 send pt=97\n            // a=simulcast: send rid=5;6;7 paused=6,7\n            name: \"simulcast_03\",\n            reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n            names: [\n                \"value\"\n            ],\n            format: \"simulcast: %s\"\n        },\n        {\n            // a=framerate:25\n            // a=framerate:29.97\n            name: \"framerate\",\n            reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n            format: \"framerate:%s\"\n        },\n        {\n            // RFC4570\n            // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n            name: \"sourceFilter\",\n            reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n            names: [\n                \"filterMode\",\n                \"netType\",\n                \"addressTypes\",\n                \"destAddress\",\n                \"srcList\"\n            ],\n            format: \"source-filter: %s %s %s %s %s\"\n        },\n        {\n            // a=bundle-only\n            name: \"bundleOnly\",\n            reg: /^(bundle-only)/\n        },\n        {\n            // a=label:1\n            name: \"label\",\n            reg: /^label:(.+)/,\n            format: \"label:%s\"\n        },\n        {\n            // RFC version 26 for SCTP over DTLS\n            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n            name: \"sctpPort\",\n            reg: /^sctp-port:(\\d+)$/,\n            format: \"sctp-port:%s\"\n        },\n        {\n            // RFC version 26 for SCTP over DTLS\n            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n            name: \"maxMessageSize\",\n            reg: /^max-message-size:(\\d+)$/,\n            format: \"max-message-size:%s\"\n        },\n        {\n            // RFC7273\n            // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n            push: \"tsRefClocks\",\n            reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n            names: [\n                \"clksrc\",\n                \"clksrcExt\"\n            ],\n            format: function(o) {\n                return \"ts-refclk:%s\" + (o.clksrcExt != null ? \"=%s\" : \"\");\n            }\n        },\n        {\n            // RFC7273\n            // a=mediaclk:direct=963214424\n            name: \"mediaClk\",\n            reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n            names: [\n                \"id\",\n                \"mediaClockName\",\n                \"mediaClockValue\",\n                \"rateNumerator\",\n                \"rateDenominator\"\n            ],\n            format: function(o) {\n                var str = \"mediaclk:\";\n                str += o.id != null ? \"id=%s %s\" : \"%v%s\";\n                str += o.mediaClockValue != null ? \"=%s\" : \"\";\n                str += o.rateNumerator != null ? \" rate=%s\" : \"\";\n                str += o.rateDenominator != null ? \"/%s\" : \"\";\n                return str;\n            }\n        },\n        {\n            // a=keywds:keywords\n            name: \"keywords\",\n            reg: /^keywds:(.+)$/,\n            format: \"keywds:%s\"\n        },\n        {\n            // a=content:main\n            name: \"content\",\n            reg: /^content:(.+)/,\n            format: \"content:%s\"\n        },\n        // BFCP https://tools.ietf.org/html/rfc4583\n        {\n            // a=floorctrl:c-s\n            name: \"bfcpFloorCtrl\",\n            reg: /^floorctrl:(c-only|s-only|c-s)/,\n            format: \"floorctrl:%s\"\n        },\n        {\n            // a=confid:1\n            name: \"bfcpConfId\",\n            reg: /^confid:(\\d+)/,\n            format: \"confid:%s\"\n        },\n        {\n            // a=userid:1\n            name: \"bfcpUserId\",\n            reg: /^userid:(\\d+)/,\n            format: \"userid:%s\"\n        },\n        {\n            // a=floorid:1\n            name: \"bfcpFloorId\",\n            reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n            names: [\n                \"id\",\n                \"mStream\"\n            ],\n            format: \"floorid:%s mstrm:%s\"\n        },\n        {\n            // any a= that we don't understand is kept verbatim on media.invalid\n            push: \"invalid\",\n            names: [\n                \"value\"\n            ]\n        }\n    ]\n};\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar$1).forEach(function(key) {\n    var objs = grammar$1[key];\n    objs.forEach(function(obj) {\n        if (!obj.reg) {\n            obj.reg = /(.*)/;\n        }\n        if (!obj.format) {\n            obj.format = \"%s\";\n        }\n    });\n});\nvar grammarExports = grammar$2.exports;\n(function(exports) {\n    var toIntIfInt = function(v) {\n        return String(Number(v)) === v ? Number(v) : v;\n    };\n    var attachProperties = function(match, location, names, rawName) {\n        if (rawName && !names) {\n            location[rawName] = toIntIfInt(match[1]);\n        } else {\n            for(var i = 0; i < names.length; i += 1){\n                if (match[i + 1] != null) {\n                    location[names[i]] = toIntIfInt(match[i + 1]);\n                }\n            }\n        }\n    };\n    var parseReg = function(obj, location, content) {\n        var needsBlank = obj.name && obj.names;\n        if (obj.push && !location[obj.push]) {\n            location[obj.push] = [];\n        } else if (needsBlank && !location[obj.name]) {\n            location[obj.name] = {};\n        }\n        var keyLocation = obj.push ? {} : // blank object that will be pushed\n        needsBlank ? location[obj.name] : location; // otherwise, named location or root\n        attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n        if (obj.push) {\n            location[obj.push].push(keyLocation);\n        }\n    };\n    var grammar = grammarExports;\n    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n    exports.parse = function(sdp) {\n        var session = {}, media = [], location = session; // points at where properties go under (one of the above)\n        // parse lines we understand\n        sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function(l) {\n            var type = l[0];\n            var content = l.slice(2);\n            if (type === \"m\") {\n                media.push({\n                    rtp: [],\n                    fmtp: []\n                });\n                location = media[media.length - 1]; // point at latest media line\n            }\n            for(var j = 0; j < (grammar[type] || []).length; j += 1){\n                var obj = grammar[type][j];\n                if (obj.reg.test(content)) {\n                    return parseReg(obj, location, content);\n                }\n            }\n        });\n        session.media = media; // link it up\n        return session;\n    };\n    var paramReducer = function(acc, expr) {\n        var s = expr.split(/=(.+)/, 2);\n        if (s.length === 2) {\n            acc[s[0]] = toIntIfInt(s[1]);\n        } else if (s.length === 1 && expr.length > 1) {\n            acc[s[0]] = undefined;\n        }\n        return acc;\n    };\n    exports.parseParams = function(str) {\n        return str.split(/;\\s?/).reduce(paramReducer, {});\n    };\n    // For backward compatibility - alias will be removed in 3.0.0\n    exports.parseFmtpConfig = exports.parseParams;\n    exports.parsePayloads = function(str) {\n        return str.toString().split(\" \").map(Number);\n    };\n    exports.parseRemoteCandidates = function(str) {\n        var candidates = [];\n        var parts = str.split(\" \").map(toIntIfInt);\n        for(var i = 0; i < parts.length; i += 3){\n            candidates.push({\n                component: parts[i],\n                ip: parts[i + 1],\n                port: parts[i + 2]\n            });\n        }\n        return candidates;\n    };\n    exports.parseImageAttributes = function(str) {\n        return str.split(\" \").map(function(item) {\n            return item.substring(1, item.length - 1).split(\",\").reduce(paramReducer, {});\n        });\n    };\n    exports.parseSimulcastStreamList = function(str) {\n        return str.split(\";\").map(function(stream) {\n            return stream.split(\",\").map(function(format) {\n                var scid, paused = false;\n                if (format[0] !== \"~\") {\n                    scid = toIntIfInt(format);\n                } else {\n                    scid = toIntIfInt(format.substring(1, format.length));\n                    paused = true;\n                }\n                return {\n                    scid: scid,\n                    paused: paused\n                };\n            });\n        });\n    };\n})(parser$1);\nvar grammar = grammarExports;\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function(formatStr) {\n    var i = 1;\n    var args = arguments;\n    var len = args.length;\n    return formatStr.replace(formatRegExp, function(x) {\n        if (i >= len) {\n            return x; // missing argument\n        }\n        var arg = args[i];\n        i += 1;\n        switch(x){\n            case \"%%\":\n                return \"%\";\n            case \"%s\":\n                return String(arg);\n            case \"%d\":\n                return Number(arg);\n            case \"%v\":\n                return \"\";\n        }\n    });\n// NB: we discard excess arguments - they are typically undefined from makeLine\n};\nvar makeLine = function(type, obj, location) {\n    var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;\n    var args = [\n        type + \"=\" + str\n    ];\n    if (obj.names) {\n        for(var i = 0; i < obj.names.length; i += 1){\n            var n = obj.names[i];\n            if (obj.name) {\n                args.push(location[obj.name][n]);\n            } else {\n                // for mLine and push attributes\n                args.push(location[obj.names[i]]);\n            }\n        }\n    } else {\n        args.push(location[obj.name]);\n    }\n    return format.apply(null, args);\n};\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n    \"v\",\n    \"o\",\n    \"s\",\n    \"i\",\n    \"u\",\n    \"e\",\n    \"p\",\n    \"c\",\n    \"b\",\n    \"t\",\n    \"r\",\n    \"z\",\n    \"a\"\n];\nvar defaultInnerOrder = [\n    \"i\",\n    \"c\",\n    \"b\",\n    \"a\"\n];\nvar writer$1 = function(session, opts) {\n    opts = opts || {};\n    // ensure certain properties exist\n    if (session.version == null) {\n        session.version = 0; // 'v=0' must be there (only defined version atm)\n    }\n    if (session.name == null) {\n        session.name = \" \"; // 's= ' must be there if no meaningful name set\n    }\n    session.media.forEach(function(mLine) {\n        if (mLine.payloads == null) {\n            mLine.payloads = \"\";\n        }\n    });\n    var outerOrder = opts.outerOrder || defaultOuterOrder;\n    var innerOrder = opts.innerOrder || defaultInnerOrder;\n    var sdp = [];\n    // loop through outerOrder for matching properties on session\n    outerOrder.forEach(function(type) {\n        grammar[type].forEach(function(obj) {\n            if (obj.name in session && session[obj.name] != null) {\n                sdp.push(makeLine(type, obj, session));\n            } else if (obj.push in session && session[obj.push] != null) {\n                session[obj.push].forEach(function(el) {\n                    sdp.push(makeLine(type, obj, el));\n                });\n            }\n        });\n    });\n    // then for each media line, follow the innerOrder\n    session.media.forEach(function(mLine) {\n        sdp.push(makeLine(\"m\", grammar.m[0], mLine));\n        innerOrder.forEach(function(type) {\n            grammar[type].forEach(function(obj) {\n                if (obj.name in mLine && mLine[obj.name] != null) {\n                    sdp.push(makeLine(type, obj, mLine));\n                } else if (obj.push in mLine && mLine[obj.push] != null) {\n                    mLine[obj.push].forEach(function(el) {\n                        sdp.push(makeLine(type, obj, el));\n                    });\n                }\n            });\n        });\n    });\n    return sdp.join(\"\\r\\n\") + \"\\r\\n\";\n};\nvar parser = parser$1;\nvar writer = writer$1;\nvar write = writer;\nvar parse = parser.parse;\nparser.parseParams;\nparser.parseFmtpConfig; // Alias of parseParams().\nparser.parsePayloads;\nparser.parseRemoteCandidates;\nparser.parseImageAttributes;\nparser.parseSimulcastStreamList;\n/* The svc codec (av1/vp9) would use a very low bitrate at the begining and\nincrease slowly by the bandwidth estimator until it reach the target bitrate. The\nprocess commonly cost more than 10 seconds cause subscriber will get blur video at\nthe first few seconds. So we use a 70% of target bitrate here as the start bitrate to\neliminate this issue.\n*/ const startBitrateForSVC = 0.7;\nconst PCEvents = {\n    NegotiationStarted: \"negotiationStarted\",\n    NegotiationComplete: \"negotiationComplete\",\n    RTPVideoPayloadTypes: \"rtpVideoPayloadTypes\"\n};\n/** @internal */ class PCTransport extends eventsExports.EventEmitter {\n    get pc() {\n        if (!this._pc) {\n            this._pc = this.createPC();\n        }\n        return this._pc;\n    }\n    constructor(config){\n        let mediaConstraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let loggerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _a;\n        super();\n        this.log = livekitLogger;\n        this.pendingCandidates = [];\n        this.restartingIce = false;\n        this.renegotiate = false;\n        this.trackBitrates = [];\n        this.remoteStereoMids = [];\n        this.remoteNackMids = [];\n        // debounced negotiate interface\n        this.negotiate = r((onError)=>__awaiter(this, void 0, void 0, function*() {\n                this.emit(PCEvents.NegotiationStarted);\n                try {\n                    yield this.createAndSendOffer();\n                } catch (e) {\n                    if (onError) {\n                        onError(e);\n                    } else {\n                        throw e;\n                    }\n                }\n            }), 100);\n        this.close = ()=>{\n            if (!this._pc) {\n                return;\n            }\n            this._pc.close();\n            this._pc.onconnectionstatechange = null;\n            this._pc.oniceconnectionstatechange = null;\n            this._pc.onicegatheringstatechange = null;\n            this._pc.ondatachannel = null;\n            this._pc.onnegotiationneeded = null;\n            this._pc.onsignalingstatechange = null;\n            this._pc.onicecandidate = null;\n            this._pc.ondatachannel = null;\n            this._pc.ontrack = null;\n            this._pc.onconnectionstatechange = null;\n            this._pc.oniceconnectionstatechange = null;\n            this._pc = null;\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCTransport);\n        this.loggerOptions = loggerOptions;\n        this.config = config;\n        this.mediaConstraints = mediaConstraints;\n        this._pc = this.createPC();\n    }\n    createPC() {\n        const pc = isChromiumBased() ? // @ts-expect-error chrome allows additional media constraints to be passed into the RTCPeerConnection constructor\n        new RTCPeerConnection(this.config, this.mediaConstraints) : new RTCPeerConnection(this.config);\n        pc.onicecandidate = (ev)=>{\n            var _a;\n            if (!ev.candidate) return;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, ev.candidate);\n        };\n        pc.onicecandidateerror = (ev)=>{\n            var _a;\n            (_a = this.onIceCandidateError) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        pc.oniceconnectionstatechange = ()=>{\n            var _a;\n            (_a = this.onIceConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.iceConnectionState);\n        };\n        pc.onsignalingstatechange = ()=>{\n            var _a;\n            (_a = this.onSignalingStatechange) === null || _a === void 0 ? void 0 : _a.call(this, pc.signalingState);\n        };\n        pc.onconnectionstatechange = ()=>{\n            var _a;\n            (_a = this.onConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.connectionState);\n        };\n        pc.ondatachannel = (ev)=>{\n            var _a;\n            (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        pc.ontrack = (ev)=>{\n            var _a;\n            (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        return pc;\n    }\n    get logContext() {\n        var _a, _b;\n        return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n    }\n    get isICEConnected() {\n        return this._pc !== null && (this.pc.iceConnectionState === \"connected\" || this.pc.iceConnectionState === \"completed\");\n    }\n    addIceCandidate(candidate) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.pc.remoteDescription && !this.restartingIce) {\n                return this.pc.addIceCandidate(candidate);\n            }\n            this.pendingCandidates.push(candidate);\n        });\n    }\n    setRemoteDescription(sd) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            let mungedSDP = undefined;\n            if (sd.type === \"offer\") {\n                let { stereoMids, nackMids } = extractStereoAndNackAudioFromOffer(sd);\n                this.remoteStereoMids = stereoMids;\n                this.remoteNackMids = nackMids;\n            } else if (sd.type === \"answer\") {\n                const sdpParsed = parse((_a = sd.sdp) !== null && _a !== void 0 ? _a : \"\");\n                sdpParsed.media.forEach((media)=>{\n                    if (media.type === \"audio\") {\n                        // mung sdp for opus bitrate settings\n                        this.trackBitrates.some((trackbr)=>{\n                            if (!trackbr.transceiver || media.mid != trackbr.transceiver.mid) {\n                                return false;\n                            }\n                            let codecPayload = 0;\n                            media.rtp.some((rtp)=>{\n                                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                                    codecPayload = rtp.payload;\n                                    return true;\n                                }\n                                return false;\n                            });\n                            if (codecPayload === 0) {\n                                return true;\n                            }\n                            let fmtpFound = false;\n                            for (const fmtp of media.fmtp){\n                                if (fmtp.payload === codecPayload) {\n                                    fmtp.config = fmtp.config.split(\";\").filter((attr)=>!attr.includes(\"maxaveragebitrate\")).join(\";\");\n                                    if (trackbr.maxbr > 0) {\n                                        fmtp.config += \";maxaveragebitrate=\".concat(trackbr.maxbr * 1000);\n                                    }\n                                    fmtpFound = true;\n                                    break;\n                                }\n                            }\n                            if (!fmtpFound) {\n                                if (trackbr.maxbr > 0) {\n                                    media.fmtp.push({\n                                        payload: codecPayload,\n                                        config: \"maxaveragebitrate=\".concat(trackbr.maxbr * 1000)\n                                    });\n                                }\n                            }\n                            return true;\n                        });\n                    }\n                });\n                mungedSDP = write(sdpParsed);\n            }\n            yield this.setMungedSDP(sd, mungedSDP, true);\n            this.pendingCandidates.forEach((candidate)=>{\n                this.pc.addIceCandidate(candidate);\n            });\n            this.pendingCandidates = [];\n            this.restartingIce = false;\n            if (this.renegotiate) {\n                this.renegotiate = false;\n                yield this.createAndSendOffer();\n            } else if (sd.type === \"answer\") {\n                this.emit(PCEvents.NegotiationComplete);\n                if (sd.sdp) {\n                    const sdpParsed = parse(sd.sdp);\n                    sdpParsed.media.forEach((media)=>{\n                        if (media.type === \"video\") {\n                            this.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);\n                        }\n                    });\n                }\n            }\n        });\n    }\n    createAndSendOffer(options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.onOffer === undefined) {\n                return;\n            }\n            if (options === null || options === void 0 ? void 0 : options.iceRestart) {\n                this.log.debug(\"restarting ICE\", this.logContext);\n                this.restartingIce = true;\n            }\n            if (this._pc && this._pc.signalingState === \"have-local-offer\") {\n                // we're waiting for the peer to accept our offer, so we'll just wait\n                // the only exception to this is when ICE restart is needed\n                const currentSD = this._pc.remoteDescription;\n                if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {\n                    // TODO: handle when ICE restart is needed but we don't have a remote description\n                    // the best thing to do is to recreate the peerconnection\n                    yield this._pc.setRemoteDescription(currentSD);\n                } else {\n                    this.renegotiate = true;\n                    return;\n                }\n            } else if (!this._pc || this._pc.signalingState === \"closed\") {\n                this.log.warn(\"could not createOffer with closed peer connection\", this.logContext);\n                return;\n            }\n            // actually negotiate\n            this.log.debug(\"starting to negotiate\", this.logContext);\n            const offer = yield this.pc.createOffer(options);\n            const sdpParsed = parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : \"\");\n            sdpParsed.media.forEach((media)=>{\n                if (media.type === \"audio\") {\n                    ensureAudioNackAndStereo(media, [], []);\n                } else if (media.type === \"video\") {\n                    ensureVideoDDExtensionForSVC(media);\n                    // mung sdp for codec bitrate setting that can't apply by sendEncoding\n                    this.trackBitrates.some((trackbr)=>{\n                        if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {\n                            return false;\n                        }\n                        let codecPayload = 0;\n                        media.rtp.some((rtp)=>{\n                            if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                                codecPayload = rtp.payload;\n                                return true;\n                            }\n                            return false;\n                        });\n                        if (codecPayload === 0) {\n                            return true;\n                        }\n                        let fmtpFound = false;\n                        for (const fmtp of media.fmtp){\n                            if (fmtp.payload === codecPayload) {\n                                if (!fmtp.config.includes(\"x-google-start-bitrate\")) {\n                                    fmtp.config += \";x-google-start-bitrate=\".concat(Math.round(trackbr.maxbr * startBitrateForSVC));\n                                }\n                                if (!fmtp.config.includes(\"x-google-max-bitrate\")) {\n                                    fmtp.config += \";x-google-max-bitrate=\".concat(trackbr.maxbr);\n                                }\n                                fmtpFound = true;\n                                break;\n                            }\n                        }\n                        if (!fmtpFound) {\n                            media.fmtp.push({\n                                payload: codecPayload,\n                                config: \"x-google-start-bitrate=\".concat(Math.round(trackbr.maxbr * startBitrateForSVC), \";x-google-max-bitrate=\").concat(trackbr.maxbr)\n                            });\n                        }\n                        return true;\n                    });\n                }\n            });\n            yield this.setMungedSDP(offer, write(sdpParsed));\n            this.onOffer(offer);\n        });\n    }\n    createAndSetAnswer() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const answer = yield this.pc.createAnswer();\n            const sdpParsed = parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : \"\");\n            sdpParsed.media.forEach((media)=>{\n                if (media.type === \"audio\") {\n                    ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);\n                }\n            });\n            yield this.setMungedSDP(answer, write(sdpParsed));\n            return answer;\n        });\n    }\n    createDataChannel(label, dataChannelDict) {\n        return this.pc.createDataChannel(label, dataChannelDict);\n    }\n    addTransceiver(mediaStreamTrack, transceiverInit) {\n        return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);\n    }\n    addTrack(track) {\n        if (!this._pc) {\n            throw new UnexpectedConnectionState(\"PC closed, cannot add track\");\n        }\n        return this._pc.addTrack(track);\n    }\n    setTrackCodecBitrate(info) {\n        this.trackBitrates.push(info);\n    }\n    setConfiguration(rtcConfig) {\n        var _a;\n        if (!this._pc) {\n            throw new UnexpectedConnectionState(\"PC closed, cannot configure\");\n        }\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.setConfiguration(rtcConfig);\n    }\n    canRemoveTrack() {\n        var _a;\n        return !!((_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack);\n    }\n    removeTrack(sender) {\n        var _a;\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack(sender);\n    }\n    getConnectionState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.connectionState) !== null && _b !== void 0 ? _b : \"closed\";\n    }\n    getICEConnectionState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState) !== null && _b !== void 0 ? _b : \"closed\";\n    }\n    getSignallingState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.signalingState) !== null && _b !== void 0 ? _b : \"closed\";\n    }\n    getTransceivers() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : [];\n    }\n    getSenders() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getSenders()) !== null && _b !== void 0 ? _b : [];\n    }\n    getLocalDescription() {\n        var _a;\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.localDescription;\n    }\n    getRemoteDescription() {\n        var _a;\n        return (_a = this.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription;\n    }\n    getStats() {\n        return this.pc.getStats();\n    }\n    getConnectedAddress() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this._pc) {\n                return;\n            }\n            let selectedCandidatePairId = \"\";\n            const candidatePairs = new Map();\n            // id -> candidate ip\n            const candidates = new Map();\n            const stats = yield this._pc.getStats();\n            stats.forEach((v)=>{\n                switch(v.type){\n                    case \"transport\":\n                        selectedCandidatePairId = v.selectedCandidatePairId;\n                        break;\n                    case \"candidate-pair\":\n                        if (selectedCandidatePairId === \"\" && v.selected) {\n                            selectedCandidatePairId = v.id;\n                        }\n                        candidatePairs.set(v.id, v);\n                        break;\n                    case \"remote-candidate\":\n                        candidates.set(v.id, \"\".concat(v.address, \":\").concat(v.port));\n                        break;\n                }\n            });\n            if (selectedCandidatePairId === \"\") {\n                return undefined;\n            }\n            const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;\n            if (selectedID === undefined) {\n                return undefined;\n            }\n            return candidates.get(selectedID);\n        });\n    }\n    setMungedSDP(sd, munged, remote) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (munged) {\n                const originalSdp = sd.sdp;\n                sd.sdp = munged;\n                try {\n                    this.log.debug(\"setting munged \".concat(remote ? \"remote\" : \"local\", \" description\"), this.logContext);\n                    if (remote) {\n                        yield this.pc.setRemoteDescription(sd);\n                    } else {\n                        yield this.pc.setLocalDescription(sd);\n                    }\n                    return;\n                } catch (e) {\n                    this.log.warn(\"not able to set \".concat(sd.type, \", falling back to unmodified sdp\"), Object.assign(Object.assign({}, this.logContext), {\n                        error: e,\n                        sdp: munged\n                    }));\n                    sd.sdp = originalSdp;\n                }\n            }\n            try {\n                if (remote) {\n                    yield this.pc.setRemoteDescription(sd);\n                } else {\n                    yield this.pc.setLocalDescription(sd);\n                }\n            } catch (e) {\n                // this error cannot always be caught.\n                // If the local description has a setCodecPreferences error, this error will be uncaught\n                let msg = \"unknown error\";\n                if (e instanceof Error) {\n                    msg = e.message;\n                } else if (typeof e === \"string\") {\n                    msg = e;\n                }\n                const fields = {\n                    error: msg,\n                    sdp: sd.sdp\n                };\n                if (!remote && this.pc.remoteDescription) {\n                    fields.remoteSdp = this.pc.remoteDescription;\n                }\n                this.log.error(\"unable to set \".concat(sd.type), Object.assign(Object.assign({}, this.logContext), {\n                    fields\n                }));\n                throw new NegotiationError(msg);\n            }\n        });\n    }\n}\nfunction ensureAudioNackAndStereo(media, stereoMids, nackMids) {\n    // found opus codec to add nack fb\n    let opusPayload = 0;\n    media.rtp.some((rtp)=>{\n        if (rtp.codec === \"opus\") {\n            opusPayload = rtp.payload;\n            return true;\n        }\n        return false;\n    });\n    // add nack rtcpfb if not exist\n    if (opusPayload > 0) {\n        if (!media.rtcpFb) {\n            media.rtcpFb = [];\n        }\n        if (nackMids.includes(media.mid) && !media.rtcpFb.some((fb)=>fb.payload === opusPayload && fb.type === \"nack\")) {\n            media.rtcpFb.push({\n                payload: opusPayload,\n                type: \"nack\"\n            });\n        }\n        if (stereoMids.includes(media.mid)) {\n            media.fmtp.some((fmtp)=>{\n                if (fmtp.payload === opusPayload) {\n                    if (!fmtp.config.includes(\"stereo=1\")) {\n                        fmtp.config += \";stereo=1\";\n                    }\n                    return true;\n                }\n                return false;\n            });\n        }\n    }\n}\nfunction ensureVideoDDExtensionForSVC(media) {\n    var _a, _b, _c, _d;\n    const codec = (_b = (_a = media.rtp[0]) === null || _a === void 0 ? void 0 : _a.codec) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n    if (!isSVCCodec(codec)) {\n        return;\n    }\n    let maxID = 0;\n    const ddFound = (_c = media.ext) === null || _c === void 0 ? void 0 : _c.some((ext)=>{\n        if (ext.uri === ddExtensionURI) {\n            return true;\n        }\n        if (ext.value > maxID) {\n            maxID = ext.value;\n        }\n        return false;\n    });\n    if (!ddFound) {\n        (_d = media.ext) === null || _d === void 0 ? void 0 : _d.push({\n            value: maxID + 1,\n            uri: ddExtensionURI\n        });\n    }\n}\nfunction extractStereoAndNackAudioFromOffer(offer) {\n    var _a;\n    const stereoMids = [];\n    const nackMids = [];\n    const sdpParsed = parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : \"\");\n    let opusPayload = 0;\n    sdpParsed.media.forEach((media)=>{\n        var _a;\n        if (media.type === \"audio\") {\n            media.rtp.some((rtp)=>{\n                if (rtp.codec === \"opus\") {\n                    opusPayload = rtp.payload;\n                    return true;\n                }\n                return false;\n            });\n            if ((_a = media.rtcpFb) === null || _a === void 0 ? void 0 : _a.some((fb)=>fb.payload === opusPayload && fb.type === \"nack\")) {\n                nackMids.push(media.mid);\n            }\n            media.fmtp.some((fmtp)=>{\n                if (fmtp.payload === opusPayload) {\n                    if (fmtp.config.includes(\"sprop-stereo=1\")) {\n                        stereoMids.push(media.mid);\n                    }\n                    return true;\n                }\n                return false;\n            });\n        }\n    });\n    return {\n        stereoMids,\n        nackMids\n    };\n}\nconst defaultVideoCodec = \"vp8\";\nconst publishDefaults = {\n    /**\n   * @deprecated\n   */ audioBitrate: AudioPresets.music.maxBitrate,\n    audioPreset: AudioPresets.music,\n    dtx: true,\n    red: true,\n    forceStereo: false,\n    simulcast: true,\n    screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,\n    stopMicTrackOnMute: false,\n    videoCodec: defaultVideoCodec,\n    backupCodec: true\n};\nconst audioDefaults = {\n    autoGainControl: true,\n    echoCancellation: true,\n    noiseSuppression: true\n};\nconst videoDefaults = {\n    resolution: VideoPresets.h720.resolution\n};\nconst roomOptionDefaults = {\n    adaptiveStream: false,\n    dynacast: false,\n    stopLocalTrackOnUnpublish: true,\n    reconnectPolicy: new DefaultReconnectPolicy(),\n    disconnectOnPageLeave: true,\n    expWebAudioMix: false\n};\nconst roomConnectOptionDefaults = {\n    autoSubscribe: true,\n    maxRetries: 1,\n    peerConnectionTimeout: 15000,\n    websocketTimeout: 15000\n};\nvar PCTransportState;\n(function(PCTransportState) {\n    PCTransportState[PCTransportState[\"NEW\"] = 0] = \"NEW\";\n    PCTransportState[PCTransportState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    PCTransportState[PCTransportState[\"CONNECTED\"] = 2] = \"CONNECTED\";\n    PCTransportState[PCTransportState[\"FAILED\"] = 3] = \"FAILED\";\n    PCTransportState[PCTransportState[\"CLOSING\"] = 4] = \"CLOSING\";\n    PCTransportState[PCTransportState[\"CLOSED\"] = 5] = \"CLOSED\";\n})(PCTransportState || (PCTransportState = {}));\nclass PCTransportManager {\n    get needsPublisher() {\n        return this.isPublisherConnectionRequired;\n    }\n    get needsSubscriber() {\n        return this.isSubscriberConnectionRequired;\n    }\n    get currentState() {\n        return this.state;\n    }\n    constructor(rtcConfig, subscriberPrimary, loggerOptions){\n        var _a;\n        this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n        this.log = livekitLogger;\n        this.updateState = ()=>{\n            var _a;\n            const previousState = this.state;\n            const connectionStates = this.requiredTransports.map((tr)=>tr.getConnectionState());\n            if (connectionStates.every((st)=>st === \"connected\")) {\n                this.state = PCTransportState.CONNECTED;\n            } else if (connectionStates.some((st)=>st === \"failed\")) {\n                this.state = PCTransportState.FAILED;\n            } else if (connectionStates.some((st)=>st === \"connecting\")) {\n                this.state = PCTransportState.CONNECTING;\n            } else if (connectionStates.every((st)=>st === \"closed\")) {\n                this.state = PCTransportState.CLOSED;\n            } else if (connectionStates.some((st)=>st === \"closed\")) {\n                this.state = PCTransportState.CLOSING;\n            } else if (connectionStates.every((st)=>st === \"new\")) {\n                this.state = PCTransportState.NEW;\n            }\n            if (previousState !== this.state) {\n                this.log.debug(\"pc state change: from \".concat(PCTransportState[previousState], \" to \").concat(PCTransportState[this.state]), this.logContext);\n                (_a = this.onStateChange) === null || _a === void 0 ? void 0 : _a.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState());\n            }\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCManager);\n        this.loggerOptions = loggerOptions;\n        this.isPublisherConnectionRequired = !subscriberPrimary;\n        this.isSubscriberConnectionRequired = subscriberPrimary;\n        const googConstraints = {\n            optional: [\n                {\n                    googDscp: true\n                }\n            ]\n        };\n        this.publisher = new PCTransport(rtcConfig, googConstraints, loggerOptions);\n        this.subscriber = new PCTransport(rtcConfig, loggerOptions);\n        this.publisher.onConnectionStateChange = this.updateState;\n        this.subscriber.onConnectionStateChange = this.updateState;\n        this.publisher.onIceConnectionStateChange = this.updateState;\n        this.subscriber.onIceConnectionStateChange = this.updateState;\n        this.publisher.onSignalingStatechange = this.updateState;\n        this.subscriber.onSignalingStatechange = this.updateState;\n        this.publisher.onIceCandidate = (candidate)=>{\n            var _a;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.PUBLISHER);\n        };\n        this.subscriber.onIceCandidate = (candidate)=>{\n            var _a;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.SUBSCRIBER);\n        };\n        // in subscriber primary mode, server side opens sub data channels.\n        this.subscriber.onDataChannel = (ev)=>{\n            var _a;\n            (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        this.subscriber.onTrack = (ev)=>{\n            var _a;\n            (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        this.publisher.onOffer = (offer)=>{\n            var _a;\n            (_a = this.onPublisherOffer) === null || _a === void 0 ? void 0 : _a.call(this, offer);\n        };\n        this.state = PCTransportState.NEW;\n        this.connectionLock = new Mutex();\n    }\n    get logContext() {\n        var _a, _b;\n        return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n    }\n    requirePublisher() {\n        let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        this.isPublisherConnectionRequired = require;\n        this.updateState();\n    }\n    requireSubscriber() {\n        let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        this.isSubscriberConnectionRequired = require;\n        this.updateState();\n    }\n    createAndSendPublisherOffer(options) {\n        return this.publisher.createAndSendOffer(options);\n    }\n    setPublisherAnswer(sd) {\n        return this.publisher.setRemoteDescription(sd);\n    }\n    removeTrack(sender) {\n        return this.publisher.removeTrack(sender);\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.publisher && this.publisher.getSignallingState() !== \"closed\") {\n                const publisher = this.publisher;\n                for (const sender of publisher.getSenders()){\n                    try {\n                        // TODO: react-native-webrtc doesn't have removeTrack yet.\n                        if (publisher.canRemoveTrack()) {\n                            publisher.removeTrack(sender);\n                        }\n                    } catch (e) {\n                        this.log.warn(\"could not removeTrack\", Object.assign(Object.assign({}, this.logContext), {\n                            error: e\n                        }));\n                    }\n                }\n            }\n            yield Promise.all([\n                this.publisher.close(),\n                this.subscriber.close()\n            ]);\n            this.updateState();\n        });\n    }\n    triggerIceRestart() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.subscriber.restartingIce = true;\n            // only restart publisher if it's needed\n            if (this.needsPublisher) {\n                yield this.createAndSendPublisherOffer({\n                    iceRestart: true\n                });\n            }\n        });\n    }\n    addIceCandidate(candidate, target) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (target === SignalTarget.PUBLISHER) {\n                yield this.publisher.addIceCandidate(candidate);\n            } else {\n                yield this.subscriber.addIceCandidate(candidate);\n            }\n        });\n    }\n    createSubscriberAnswerFromOffer(sd) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug(\"received server offer\", Object.assign(Object.assign({}, this.logContext), {\n                RTCSdpType: sd.type,\n                sdp: sd.sdp,\n                signalingState: this.subscriber.getSignallingState().toString()\n            }));\n            yield this.subscriber.setRemoteDescription(sd);\n            // answer the offer\n            const answer = yield this.subscriber.createAndSetAnswer();\n            return answer;\n        });\n    }\n    updateConfiguration(config, iceRestart) {\n        this.publisher.setConfiguration(config);\n        this.subscriber.setConfiguration(config);\n        if (iceRestart) {\n            this.triggerIceRestart();\n        }\n    }\n    ensurePCTransportConnection(abortController, timeout) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.connectionLock.lock();\n            try {\n                if (this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== \"connected\" && this.publisher.getConnectionState() !== \"connecting\") {\n                    this.log.debug(\"negotiation required, start negotiating\", this.logContext);\n                    this.publisher.negotiate();\n                }\n                yield Promise.all((_a = this.requiredTransports) === null || _a === void 0 ? void 0 : _a.map((transport)=>this.ensureTransportConnected(transport, abortController, timeout)));\n            } finally{\n                unlock();\n            }\n        });\n    }\n    negotiate(abortController) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    const negotiationTimeout = setTimeout(()=>{\n                        reject(\"negotiation timed out\");\n                    }, this.peerConnectionTimeout);\n                    const abortHandler = ()=>{\n                        clearTimeout(negotiationTimeout);\n                        reject(\"negotiation aborted\");\n                    };\n                    abortController.signal.addEventListener(\"abort\", abortHandler);\n                    this.publisher.once(PCEvents.NegotiationStarted, ()=>{\n                        if (abortController.signal.aborted) {\n                            return;\n                        }\n                        this.publisher.once(PCEvents.NegotiationComplete, ()=>{\n                            clearTimeout(negotiationTimeout);\n                            resolve();\n                        });\n                    });\n                    yield this.publisher.negotiate((e)=>{\n                        clearTimeout(negotiationTimeout);\n                        reject(e);\n                    });\n                }));\n        });\n    }\n    addPublisherTransceiver(track, transceiverInit) {\n        return this.publisher.addTransceiver(track, transceiverInit);\n    }\n    addPublisherTrack(track) {\n        return this.publisher.addTrack(track);\n    }\n    createPublisherDataChannel(label, dataChannelDict) {\n        return this.publisher.createDataChannel(label, dataChannelDict);\n    }\n    /**\n   * Returns the first required transport's address if no explicit target is specified\n   */ getConnectedAddress(target) {\n        if (target === SignalTarget.PUBLISHER) {\n            return this.publisher.getConnectedAddress();\n        } else if (target === SignalTarget.SUBSCRIBER) {\n            return this.publisher.getConnectedAddress();\n        }\n        return this.requiredTransports[0].getConnectedAddress();\n    }\n    get requiredTransports() {\n        const transports = [];\n        if (this.isPublisherConnectionRequired) {\n            transports.push(this.publisher);\n        }\n        if (this.isSubscriberConnectionRequired) {\n            transports.push(this.subscriber);\n        }\n        return transports;\n    }\n    ensureTransportConnected(pcTransport, abortController) {\n        let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.peerConnectionTimeout;\n        return __awaiter(this, void 0, void 0, function*() {\n            const connectionState = pcTransport.getConnectionState();\n            if (connectionState === \"connected\") {\n                return;\n            }\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    const abortHandler = ()=>{\n                        this.log.warn(\"abort transport connection\", this.logContext);\n                        CriticalTimers.clearTimeout(connectTimeout);\n                        reject(new ConnectionError(\"room connection has been cancelled\", 3 /* ConnectionErrorReason.Cancelled */ ));\n                    };\n                    if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n                        abortHandler();\n                    }\n                    abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener(\"abort\", abortHandler);\n                    const connectTimeout = CriticalTimers.setTimeout(()=>{\n                        abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener(\"abort\", abortHandler);\n                        reject(new ConnectionError(\"could not establish pc connection\"));\n                    }, timeout);\n                    while(this.state !== PCTransportState.CONNECTED){\n                        yield sleep(50); // FIXME we shouldn't rely on `sleep` in the connection paths, as it invokes `setTimeout` which can be drastically throttled by browser implementations\n                        if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n                            reject(new ConnectionError(\"room connection has been cancelled\", 3 /* ConnectionErrorReason.Cancelled */ ));\n                            return;\n                        }\n                    }\n                    CriticalTimers.clearTimeout(connectTimeout);\n                    abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener(\"abort\", abortHandler);\n                    resolve();\n                }));\n        });\n    }\n}\nconst lossyDataChannel = \"_lossy\";\nconst reliableDataChannel = \"_reliable\";\nconst minReconnectWait = 2 * 1000;\nconst leaveReconnect = \"leave-reconnect\";\nvar PCState;\n(function(PCState) {\n    PCState[PCState[\"New\"] = 0] = \"New\";\n    PCState[PCState[\"Connected\"] = 1] = \"Connected\";\n    PCState[PCState[\"Disconnected\"] = 2] = \"Disconnected\";\n    PCState[PCState[\"Reconnecting\"] = 3] = \"Reconnecting\";\n    PCState[PCState[\"Closed\"] = 4] = \"Closed\";\n})(PCState || (PCState = {}));\n/** @internal */ class RTCEngine extends eventsExports.EventEmitter {\n    get isClosed() {\n        return this._isClosed;\n    }\n    constructor(options){\n        var _a;\n        super();\n        this.options = options;\n        this.rtcConfig = {};\n        this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n        this.fullReconnectOnNext = false;\n        this.subscriberPrimary = false;\n        this.pcState = PCState.New;\n        this._isClosed = true;\n        this.pendingTrackResolvers = {};\n        this.reconnectAttempts = 0;\n        this.reconnectStart = 0;\n        this.attemptingReconnect = false;\n        /** keeps track of how often an initial join connection has been tried */ this.joinAttempts = 0;\n        /** specifies how often an initial join connection is allowed to retry */ this.maxJoinAttempts = 1;\n        this.shouldFailNext = false;\n        this.log = livekitLogger;\n        this.handleDataChannel = (_ref)=>{\n            let { channel } = _ref;\n            return __awaiter(this, void 0, void 0, function*() {\n                if (!channel) {\n                    return;\n                }\n                if (channel.label === reliableDataChannel) {\n                    this.reliableDCSub = channel;\n                } else if (channel.label === lossyDataChannel) {\n                    this.lossyDCSub = channel;\n                } else {\n                    return;\n                }\n                this.log.debug(\"on data channel \".concat(channel.id, \", \").concat(channel.label), this.logContext);\n                channel.onmessage = this.handleDataMessage;\n            });\n        };\n        this.handleDataMessage = (message)=>__awaiter(this, void 0, void 0, function*() {\n                var _b, _c;\n                // make sure to respect incoming data message order by processing message events one after the other\n                const unlock = yield this.dataProcessLock.lock();\n                try {\n                    // decode\n                    let buffer;\n                    if (message.data instanceof ArrayBuffer) {\n                        buffer = message.data;\n                    } else if (message.data instanceof Blob) {\n                        buffer = yield message.data.arrayBuffer();\n                    } else {\n                        this.log.error(\"unsupported data type\", Object.assign(Object.assign({}, this.logContext), {\n                            data: message.data\n                        }));\n                        return;\n                    }\n                    const dp = DataPacket.fromBinary(new Uint8Array(buffer));\n                    if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.case) === \"speaker\") {\n                        // dispatch speaker updates\n                        this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);\n                    } else if (((_c = dp.value) === null || _c === void 0 ? void 0 : _c.case) === \"user\") {\n                        this.emit(EngineEvent.DataPacketReceived, dp.value.value, dp.kind);\n                    }\n                } finally{\n                    unlock();\n                }\n            });\n        this.handleDataError = (event)=>{\n            const channel = event.currentTarget;\n            const channelKind = channel.maxRetransmits === 0 ? \"lossy\" : \"reliable\";\n            if (event instanceof ErrorEvent && event.error) {\n                const { error } = event.error;\n                this.log.error(\"DataChannel error on \".concat(channelKind, \": \").concat(event.message), Object.assign(Object.assign({}, this.logContext), {\n                    error\n                }));\n            } else {\n                this.log.error(\"Unknown DataChannel error on \".concat(channelKind), Object.assign(Object.assign({}, this.logContext), {\n                    event\n                }));\n            }\n        };\n        this.handleBufferedAmountLow = (event)=>{\n            const channel = event.currentTarget;\n            const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;\n            this.updateAndEmitDCBufferStatus(channelKind);\n        };\n        // websocket reconnect behavior. if websocket is interrupted, and the PeerConnection\n        // continues to work, we can reconnect to websocket to continue the session\n        // after a number of retries, we'll close and give up permanently\n        this.handleDisconnect = (connection, disconnectReason)=>{\n            if (this._isClosed) {\n                return;\n            }\n            this.log.warn(\"\".concat(connection, \" disconnected\"), this.logContext);\n            if (this.reconnectAttempts === 0) {\n                // only reset start time on the first try\n                this.reconnectStart = Date.now();\n            }\n            const disconnect = (duration)=>{\n                this.log.warn(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(duration, \"ms. giving up\"), this.logContext);\n                this.emit(EngineEvent.Disconnected);\n                this.close();\n            };\n            const duration = Date.now() - this.reconnectStart;\n            let delay = this.getNextRetryDelay({\n                elapsedMs: duration,\n                retryCount: this.reconnectAttempts\n            });\n            if (delay === null) {\n                disconnect(duration);\n                return;\n            }\n            if (connection === leaveReconnect) {\n                delay = 0;\n            }\n            this.log.debug(\"reconnecting in \".concat(delay, \"ms\"), this.logContext);\n            this.clearReconnectTimeout();\n            if (this.token && this.regionUrlProvider) {\n                // token may have been refreshed, we do not want to recreate the regionUrlProvider\n                // since the current engine may have inherited a regional url\n                this.regionUrlProvider.updateToken(this.token);\n            }\n            this.reconnectTimeout = CriticalTimers.setTimeout(()=>this.attemptReconnect(disconnectReason), delay);\n        };\n        this.waitForRestarted = ()=>{\n            return new Promise((resolve, reject)=>{\n                if (this.pcState === PCState.Connected) {\n                    resolve();\n                }\n                const onRestarted = ()=>{\n                    this.off(EngineEvent.Disconnected, onDisconnected);\n                    resolve();\n                };\n                const onDisconnected = ()=>{\n                    this.off(EngineEvent.Restarted, onRestarted);\n                    reject();\n                };\n                this.once(EngineEvent.Restarted, onRestarted);\n                this.once(EngineEvent.Disconnected, onDisconnected);\n            });\n        };\n        this.updateAndEmitDCBufferStatus = (kind)=>{\n            const status = this.isBufferStatusLow(kind);\n            if (typeof status !== \"undefined\" && status !== this.dcBufferStatus.get(kind)) {\n                this.dcBufferStatus.set(kind, status);\n                this.emit(EngineEvent.DCBufferStatusChanged, status, kind);\n            }\n        };\n        this.isBufferStatusLow = (kind)=>{\n            const dc = this.dataChannelForKind(kind);\n            if (dc) {\n                return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;\n            }\n        };\n        this.handleBrowserOnLine = ()=>{\n            // in case the engine is currently reconnecting, attempt a reconnect immediately after the browser state has changed to 'onLine'\n            if (this.client.currentState === SignalConnectionState.RECONNECTING) {\n                this.clearReconnectTimeout();\n                this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);\n            }\n        };\n        this.log = getLogger((_a = options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Engine);\n        this.loggerOptions = {\n            loggerName: options.loggerName,\n            loggerContextCb: ()=>this.logContext\n        };\n        this.client = new SignalClient(undefined, this.loggerOptions);\n        this.client.signalLatency = this.options.expSignalLatency;\n        this.reconnectPolicy = this.options.reconnectPolicy;\n        this.registerOnLineListener();\n        this.closingLock = new Mutex();\n        this.dataProcessLock = new Mutex();\n        this.dcBufferStatus = new Map([\n            [\n                DataPacket_Kind.LOSSY,\n                true\n            ],\n            [\n                DataPacket_Kind.RELIABLE,\n                true\n            ]\n        ]);\n        this.client.onParticipantUpdate = (updates)=>this.emit(EngineEvent.ParticipantUpdate, updates);\n        this.client.onConnectionQuality = (update)=>this.emit(EngineEvent.ConnectionQualityUpdate, update);\n        this.client.onRoomUpdate = (update)=>this.emit(EngineEvent.RoomUpdate, update);\n        this.client.onSubscriptionError = (resp)=>this.emit(EngineEvent.SubscriptionError, resp);\n        this.client.onSubscriptionPermissionUpdate = (update)=>this.emit(EngineEvent.SubscriptionPermissionUpdate, update);\n        this.client.onSpeakersChanged = (update)=>this.emit(EngineEvent.SpeakersChanged, update);\n        this.client.onStreamStateUpdate = (update)=>this.emit(EngineEvent.StreamStateChanged, update);\n    }\n    /** @internal */ get logContext() {\n        var _a, _b, _c, _d, _e, _f;\n        return {\n            room: (_b = (_a = this.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.room) === null || _b === void 0 ? void 0 : _b.name,\n            roomSid: (_d = (_c = this.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.room) === null || _d === void 0 ? void 0 : _d.sid,\n            identity: (_f = (_e = this.latestJoinResponse) === null || _e === void 0 ? void 0 : _e.participant) === null || _f === void 0 ? void 0 : _f.identity\n        };\n    }\n    join(url, token, opts, abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.url = url;\n            this.token = token;\n            this.signalOpts = opts;\n            this.maxJoinAttempts = opts.maxRetries;\n            try {\n                this.joinAttempts += 1;\n                this.setupSignalClientCallbacks();\n                const joinResponse = yield this.client.join(url, token, opts, abortSignal);\n                this._isClosed = false;\n                this.latestJoinResponse = joinResponse;\n                this.subscriberPrimary = joinResponse.subscriberPrimary;\n                if (!this.pcManager) {\n                    yield this.configure(joinResponse);\n                }\n                // create offer\n                if (!this.subscriberPrimary) {\n                    this.negotiate();\n                }\n                this.clientConfiguration = joinResponse.clientConfiguration;\n                return joinResponse;\n            } catch (e) {\n                if (e instanceof ConnectionError) {\n                    if (e.reason === 1 /* ConnectionErrorReason.ServerUnreachable */ ) {\n                        this.log.warn(\"Couldn't connect to server, attempt \".concat(this.joinAttempts, \" of \").concat(this.maxJoinAttempts), this.logContext);\n                        if (this.joinAttempts < this.maxJoinAttempts) {\n                            return this.join(url, token, opts, abortSignal);\n                        }\n                    }\n                }\n                throw e;\n            }\n        });\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.closingLock.lock();\n            if (this.isClosed) {\n                unlock();\n                return;\n            }\n            try {\n                this._isClosed = true;\n                this.emit(EngineEvent.Closing);\n                this.removeAllListeners();\n                this.deregisterOnLineListener();\n                this.clearPendingReconnect();\n                yield this.cleanupPeerConnections();\n                yield this.cleanupClient();\n            } finally{\n                unlock();\n            }\n        });\n    }\n    cleanupPeerConnections() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.close();\n            this.pcManager = undefined;\n            const dcCleanup = (dc)=>{\n                if (!dc) return;\n                dc.close();\n                dc.onbufferedamountlow = null;\n                dc.onclose = null;\n                dc.onclosing = null;\n                dc.onerror = null;\n                dc.onmessage = null;\n                dc.onopen = null;\n            };\n            dcCleanup(this.lossyDC);\n            dcCleanup(this.lossyDCSub);\n            dcCleanup(this.reliableDC);\n            dcCleanup(this.reliableDCSub);\n            this.lossyDC = undefined;\n            this.lossyDCSub = undefined;\n            this.reliableDC = undefined;\n            this.reliableDCSub = undefined;\n        });\n    }\n    cleanupClient() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.client.close();\n            this.client.resetCallbacks();\n        });\n    }\n    addTrack(req) {\n        if (this.pendingTrackResolvers[req.cid]) {\n            throw new TrackInvalidError(\"a track with the same ID has already been published\");\n        }\n        return new Promise((resolve, reject)=>{\n            const publicationTimeout = setTimeout(()=>{\n                delete this.pendingTrackResolvers[req.cid];\n                reject(new ConnectionError(\"publication of local track timed out, no response from server\"));\n            }, 10000);\n            this.pendingTrackResolvers[req.cid] = {\n                resolve: (info)=>{\n                    clearTimeout(publicationTimeout);\n                    resolve(info);\n                },\n                reject: ()=>{\n                    clearTimeout(publicationTimeout);\n                    reject(new Error(\"Cancelled publication by calling unpublish\"));\n                }\n            };\n            this.client.sendAddTrack(req);\n        });\n    }\n    /**\n   * Removes sender from PeerConnection, returning true if it was removed successfully\n   * and a negotiation is necessary\n   * @param sender\n   * @returns\n   */ removeTrack(sender) {\n        if (sender.track && this.pendingTrackResolvers[sender.track.id]) {\n            const { reject } = this.pendingTrackResolvers[sender.track.id];\n            if (reject) {\n                reject();\n            }\n            delete this.pendingTrackResolvers[sender.track.id];\n        }\n        try {\n            this.pcManager.removeTrack(sender);\n            return true;\n        } catch (e) {\n            this.log.warn(\"failed to remove track\", Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n        }\n        return false;\n    }\n    updateMuteStatus(trackSid, muted) {\n        this.client.sendMuteTrack(trackSid, muted);\n    }\n    get dataSubscriberReadyState() {\n        var _a;\n        return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;\n    }\n    getConnectedServerAddress() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getConnectedAddress();\n        });\n    }\n    /* @internal */ setRegionUrlProvider(provider) {\n        this.regionUrlProvider = provider;\n    }\n    configure(joinResponse) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            // already configured\n            if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW) {\n                return;\n            }\n            this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;\n            const rtcConfig = this.makeRTCConfiguration(joinResponse);\n            this.pcManager = new PCTransportManager(rtcConfig, joinResponse.subscriberPrimary, this.loggerOptions);\n            this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber);\n            this.pcManager.onIceCandidate = (candidate, target)=>{\n                this.client.sendIceCandidate(candidate, target);\n            };\n            this.pcManager.onPublisherOffer = (offer)=>{\n                this.client.sendOffer(offer);\n            };\n            this.pcManager.onDataChannel = this.handleDataChannel;\n            this.pcManager.onStateChange = (connectionState, publisherState, subscriberState)=>__awaiter(this, void 0, void 0, function*() {\n                    this.log.debug(\"primary PC state changed \".concat(connectionState), this.logContext);\n                    if (connectionState === PCTransportState.CONNECTED) {\n                        const shouldEmit = this.pcState === PCState.New;\n                        this.pcState = PCState.Connected;\n                        if (shouldEmit) {\n                            this.emit(EngineEvent.Connected, joinResponse);\n                        }\n                    } else if (connectionState === PCTransportState.FAILED) {\n                        // on Safari, PeerConnection will switch to 'disconnected' during renegotiation\n                        if (this.pcState === PCState.Connected) {\n                            this.pcState = PCState.Disconnected;\n                            this.handleDisconnect(\"peerconnection failed\", subscriberState === \"failed\" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);\n                        }\n                    }\n                });\n            this.pcManager.onTrack = (ev)=>{\n                this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);\n            };\n            this.createDataChannels();\n        });\n    }\n    setupSignalClientCallbacks() {\n        // configure signaling client\n        this.client.onAnswer = (sd)=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.pcManager) {\n                    return;\n                }\n                this.log.debug(\"received server answer\", Object.assign(Object.assign({}, this.logContext), {\n                    RTCSdpType: sd.type\n                }));\n                yield this.pcManager.setPublisherAnswer(sd);\n            });\n        // add candidate on trickle\n        this.client.onTrickle = (candidate, target)=>{\n            if (!this.pcManager) {\n                return;\n            }\n            this.log.trace(\"got ICE candidate from peer\", Object.assign(Object.assign({}, this.logContext), {\n                candidate,\n                target\n            }));\n            this.pcManager.addIceCandidate(candidate, target);\n        };\n        // when server creates an offer for the client\n        this.client.onOffer = (sd)=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.pcManager) {\n                    return;\n                }\n                const answer = yield this.pcManager.createSubscriberAnswerFromOffer(sd);\n                this.client.sendAnswer(answer);\n            });\n        this.client.onLocalTrackPublished = (res)=>{\n            var _a;\n            this.log.debug(\"received trackPublishedResponse\", Object.assign(Object.assign({}, this.logContext), {\n                cid: res.cid,\n                track: (_a = res.track) === null || _a === void 0 ? void 0 : _a.sid\n            }));\n            if (!this.pendingTrackResolvers[res.cid]) {\n                this.log.error(\"missing track resolver for \".concat(res.cid), Object.assign(Object.assign({}, this.logContext), {\n                    cid: res.cid\n                }));\n                return;\n            }\n            const { resolve } = this.pendingTrackResolvers[res.cid];\n            delete this.pendingTrackResolvers[res.cid];\n            resolve(res.track);\n        };\n        this.client.onLocalTrackUnpublished = (response)=>{\n            this.emit(EngineEvent.LocalTrackUnpublished, response);\n        };\n        this.client.onTokenRefresh = (token)=>{\n            this.token = token;\n        };\n        this.client.onRemoteMuteChanged = (trackSid, muted)=>{\n            this.emit(EngineEvent.RemoteMute, trackSid, muted);\n        };\n        this.client.onSubscribedQualityUpdate = (update)=>{\n            this.emit(EngineEvent.SubscribedQualityUpdate, update);\n        };\n        this.client.onClose = ()=>{\n            this.handleDisconnect(\"signal\", ReconnectReason.RR_SIGNAL_DISCONNECTED);\n        };\n        this.client.onLeave = (leave)=>{\n            if (leave === null || leave === void 0 ? void 0 : leave.canReconnect) {\n                this.fullReconnectOnNext = true;\n                // reconnect immediately instead of waiting for next attempt\n                this.handleDisconnect(leaveReconnect);\n            } else {\n                this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);\n                this.close();\n            }\n            this.log.debug(\"client leave request\", Object.assign(Object.assign({}, this.logContext), {\n                reason: leave === null || leave === void 0 ? void 0 : leave.reason\n            }));\n        };\n    }\n    makeRTCConfiguration(serverResponse) {\n        var _a;\n        const rtcConfig = Object.assign({}, this.rtcConfig);\n        if ((_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.e2eeEnabled) {\n            this.log.debug(\"E2EE - setting up transports with insertable streams\", this.logContext);\n            //  this makes sure that no data is sent before the transforms are ready\n            // @ts-ignore\n            rtcConfig.encodedInsertableStreams = true;\n        }\n        // update ICE servers before creating PeerConnection\n        if (serverResponse.iceServers && !rtcConfig.iceServers) {\n            const rtcIceServers = [];\n            serverResponse.iceServers.forEach((iceServer)=>{\n                const rtcIceServer = {\n                    urls: iceServer.urls\n                };\n                if (iceServer.username) rtcIceServer.username = iceServer.username;\n                if (iceServer.credential) {\n                    rtcIceServer.credential = iceServer.credential;\n                }\n                rtcIceServers.push(rtcIceServer);\n            });\n            rtcConfig.iceServers = rtcIceServers;\n        }\n        if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {\n            rtcConfig.iceTransportPolicy = \"relay\";\n        }\n        // @ts-ignore\n        rtcConfig.sdpSemantics = \"unified-plan\";\n        // @ts-ignore\n        rtcConfig.continualGatheringPolicy = \"gather_continually\";\n        return rtcConfig;\n    }\n    createDataChannels() {\n        if (!this.pcManager) {\n            return;\n        }\n        // clear old data channel callbacks if recreate\n        if (this.lossyDC) {\n            this.lossyDC.onmessage = null;\n            this.lossyDC.onerror = null;\n        }\n        if (this.reliableDC) {\n            this.reliableDC.onmessage = null;\n            this.reliableDC.onerror = null;\n        }\n        // create data channels\n        this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {\n            // will drop older packets that arrive\n            ordered: true,\n            maxRetransmits: 0\n        });\n        this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {\n            ordered: true\n        });\n        // also handle messages over the pub channel, for backwards compatibility\n        this.lossyDC.onmessage = this.handleDataMessage;\n        this.reliableDC.onmessage = this.handleDataMessage;\n        // handle datachannel errors\n        this.lossyDC.onerror = this.handleDataError;\n        this.reliableDC.onerror = this.handleDataError;\n        // set up dc buffer threshold, set to 64kB (otherwise 0 by default)\n        this.lossyDC.bufferedAmountLowThreshold = 65535;\n        this.reliableDC.bufferedAmountLowThreshold = 65535;\n        // handle buffer amount low events\n        this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;\n        this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;\n    }\n    setPreferredCodec(transceiver, kind, videoCodec) {\n        if (!(\"getCapabilities\" in RTCRtpSender)) {\n            return;\n        }\n        const cap = RTCRtpSender.getCapabilities(kind);\n        if (!cap) return;\n        this.log.debug(\"get sender capabilities\", Object.assign(Object.assign({}, this.logContext), {\n            cap\n        }));\n        const matched = [];\n        const partialMatched = [];\n        const unmatched = [];\n        cap.codecs.forEach((c)=>{\n            const codec = c.mimeType.toLowerCase();\n            if (codec === \"audio/opus\") {\n                matched.push(c);\n                return;\n            }\n            const matchesVideoCodec = codec === \"video/\".concat(videoCodec);\n            if (!matchesVideoCodec) {\n                unmatched.push(c);\n                return;\n            }\n            // for h264 codecs that have sdpFmtpLine available, use only if the\n            // profile-level-id is 42e01f for cross-browser compatibility\n            if (videoCodec === \"h264\") {\n                if (c.sdpFmtpLine && c.sdpFmtpLine.includes(\"profile-level-id=42e01f\")) {\n                    matched.push(c);\n                } else {\n                    partialMatched.push(c);\n                }\n                return;\n            }\n            matched.push(c);\n        });\n        if (supportsSetCodecPreferences(transceiver)) {\n            transceiver.setCodecPreferences(matched.concat(partialMatched, unmatched));\n        }\n    }\n    createSender(track, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (supportsTransceiver()) {\n                const sender = yield this.createTransceiverRTCRtpSender(track, opts, encodings);\n                return sender;\n            }\n            if (supportsAddTrack()) {\n                this.log.warn(\"using add-track fallback\", this.logContext);\n                const sender = yield this.createRTCRtpSender(track.mediaStreamTrack);\n                return sender;\n            }\n            throw new UnexpectedConnectionState(\"Required webRTC APIs not supported on this device\");\n        });\n    }\n    createSimulcastSender(track, simulcastTrack, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // store RTCRtpSender\n            if (supportsTransceiver()) {\n                return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);\n            }\n            if (supportsAddTrack()) {\n                this.log.debug(\"using add-track fallback\", this.logContext);\n                return this.createRTCRtpSender(track.mediaStreamTrack);\n            }\n            throw new UnexpectedConnectionState(\"Cannot stream on this device\");\n        });\n    }\n    createTransceiverRTCRtpSender(track, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher is closed\");\n            }\n            const streams = [];\n            if (track.mediaStream) {\n                streams.push(track.mediaStream);\n            }\n            const transceiverInit = {\n                direction: \"sendonly\",\n                streams\n            };\n            if (encodings) {\n                transceiverInit.sendEncodings = encodings;\n            }\n            // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n            const transceiver = yield this.pcManager.addPublisherTransceiver(track.mediaStreamTrack, transceiverInit);\n            if (track.kind === Track.Kind.Video && opts.videoCodec) {\n                this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);\n                track.codec = opts.videoCodec;\n            }\n            return transceiver.sender;\n        });\n    }\n    createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher is closed\");\n            }\n            const transceiverInit = {\n                direction: \"sendonly\"\n            };\n            if (encodings) {\n                transceiverInit.sendEncodings = encodings;\n            }\n            // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n            const transceiver = yield this.pcManager.addPublisherTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);\n            if (!opts.videoCodec) {\n                return;\n            }\n            this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);\n            track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);\n            return transceiver.sender;\n        });\n    }\n    createRTCRtpSender(track) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher is closed\");\n            }\n            return this.pcManager.addPublisherTrack(track);\n        });\n    }\n    attemptReconnect(reason) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._isClosed) {\n                return;\n            }\n            // guard for attempting reconnection multiple times while one attempt is still not finished\n            if (this.attemptingReconnect) {\n                livekitLogger.warn(\"already attempting reconnect, returning early\", this.logContext);\n                return;\n            }\n            if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep\n            // those connections cannot be resumed\n            ((_c = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !== null && _c !== void 0 ? _c : PCTransportState.NEW) === PCTransportState.NEW) {\n                this.fullReconnectOnNext = true;\n            }\n            try {\n                this.attemptingReconnect = true;\n                if (this.fullReconnectOnNext) {\n                    yield this.restartConnection();\n                } else {\n                    yield this.resumeConnection(reason);\n                }\n                this.clearPendingReconnect();\n                this.fullReconnectOnNext = false;\n            } catch (e) {\n                this.reconnectAttempts += 1;\n                let recoverable = true;\n                if (e instanceof UnexpectedConnectionState) {\n                    this.log.debug(\"received unrecoverable error\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    // unrecoverable\n                    recoverable = false;\n                } else if (!(e instanceof SignalReconnectError)) {\n                    // cannot resume\n                    this.fullReconnectOnNext = true;\n                }\n                if (recoverable) {\n                    this.handleDisconnect(\"reconnect\", ReconnectReason.RR_UNKNOWN);\n                } else {\n                    this.log.info(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(Date.now() - this.reconnectStart, \"ms. giving up\"), this.logContext);\n                    this.emit(EngineEvent.Disconnected);\n                    yield this.close();\n                }\n            } finally{\n                this.attemptingReconnect = false;\n            }\n        });\n    }\n    getNextRetryDelay(context) {\n        try {\n            return this.reconnectPolicy.nextRetryDelayInMs(context);\n        } catch (e) {\n            this.log.warn(\"encountered error in reconnect policy\", Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n        }\n        // error in user code with provided reconnect policy, stop reconnecting\n        return null;\n    }\n    restartConnection(regionUrl) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                if (!this.url || !this.token) {\n                    // permanent failure, don't attempt reconnection\n                    throw new UnexpectedConnectionState(\"could not reconnect, url or token not saved\");\n                }\n                this.log.info(\"reconnecting, attempt: \".concat(this.reconnectAttempts), this.logContext);\n                this.emit(EngineEvent.Restarting);\n                if (!this.client.isDisconnected) {\n                    yield this.client.sendLeave();\n                }\n                yield this.cleanupPeerConnections();\n                yield this.cleanupClient();\n                let joinResponse;\n                try {\n                    if (!this.signalOpts) {\n                        this.log.warn(\"attempted connection restart, without signal options present\", this.logContext);\n                        throw new SignalReconnectError();\n                    }\n                    // in case a regionUrl is passed, the region URL takes precedence\n                    joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);\n                } catch (e) {\n                    if (e instanceof ConnectionError && e.reason === 0 /* ConnectionErrorReason.NotAllowed */ ) {\n                        throw new UnexpectedConnectionState(\"could not reconnect, token might be expired\");\n                    }\n                    throw new SignalReconnectError();\n                }\n                if (this.shouldFailNext) {\n                    this.shouldFailNext = false;\n                    throw new Error(\"simulated failure\");\n                }\n                this.client.setReconnected();\n                this.emit(EngineEvent.SignalRestarted, joinResponse);\n                yield this.waitForPCReconnected();\n                // re-check signal connection state before setting engine as resumed\n                if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n                    throw new SignalReconnectError(\"Signal connection got severed during reconnect\");\n                }\n                (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.resetAttempts();\n                // reconnect success\n                this.emit(EngineEvent.Restarted);\n            } catch (error) {\n                const nextRegionUrl = yield (_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getNextBestRegionUrl();\n                if (nextRegionUrl) {\n                    yield this.restartConnection(nextRegionUrl);\n                    return;\n                } else {\n                    // no more regions to try (or we're not on cloud)\n                    (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();\n                    throw error;\n                }\n            }\n        });\n    }\n    resumeConnection(reason) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.url || !this.token) {\n                // permanent failure, don't attempt reconnection\n                throw new UnexpectedConnectionState(\"could not reconnect, url or token not saved\");\n            }\n            // trigger publisher reconnect\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher and subscriber connections unset\");\n            }\n            this.log.info(\"resuming signal connection, attempt \".concat(this.reconnectAttempts), this.logContext);\n            this.emit(EngineEvent.Resuming);\n            try {\n                this.setupSignalClientCallbacks();\n                const res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);\n                if (res) {\n                    const rtcConfig = this.makeRTCConfiguration(res);\n                    this.pcManager.updateConfiguration(rtcConfig);\n                }\n            } catch (error) {\n                let message = \"\";\n                if (error instanceof Error) {\n                    message = error.message;\n                    this.log.error(error.message, Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    }));\n                }\n                if (error instanceof ConnectionError && error.reason === 0 /* ConnectionErrorReason.NotAllowed */ ) {\n                    throw new UnexpectedConnectionState(\"could not reconnect, token might be expired\");\n                }\n                if (error instanceof ConnectionError && error.reason === 4 /* ConnectionErrorReason.LeaveRequest */ ) {\n                    throw error;\n                }\n                throw new SignalReconnectError(message);\n            }\n            this.emit(EngineEvent.SignalResumed);\n            if (this.shouldFailNext) {\n                this.shouldFailNext = false;\n                throw new Error(\"simulated failure\");\n            }\n            yield this.pcManager.triggerIceRestart();\n            yield this.waitForPCReconnected();\n            // re-check signal connection state before setting engine as resumed\n            if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n                throw new SignalReconnectError(\"Signal connection got severed during reconnect\");\n            }\n            this.client.setReconnected();\n            // recreate publish datachannel if it's id is null\n            // (for safari https://bugs.webkit.org/show_bug.cgi?id=184688)\n            if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === \"open\" && this.reliableDC.id === null) {\n                this.createDataChannels();\n            }\n            // resume success\n            this.emit(EngineEvent.Resumed);\n        });\n    }\n    waitForPCInitialConnection(timeout, abortController) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"PC manager is closed\");\n            }\n            yield this.pcManager.ensurePCTransportConnection(abortController, timeout);\n        });\n    }\n    waitForPCReconnected() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.pcState = PCState.Reconnecting;\n            this.log.debug(\"waiting for peer connection to reconnect\", this.logContext);\n            try {\n                yield sleep(minReconnectWait); // FIXME setTimeout again not ideal for a connection critical path\n                if (!this.pcManager) {\n                    throw new UnexpectedConnectionState(\"PC manager is closed\");\n                }\n                yield this.pcManager.ensurePCTransportConnection(undefined, this.peerConnectionTimeout);\n                this.pcState = PCState.Connected;\n            } catch (e) {\n                // TODO do we need a `failed` state here for the PC?\n                this.pcState = PCState.Disconnected;\n                throw new ConnectionError(\"could not establish PC connection, \".concat(e.message));\n            }\n        });\n    }\n    /* @internal */ sendDataPacket(packet, kind) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const msg = packet.toBinary();\n            // make sure we do have a data connection\n            yield this.ensurePublisherConnected(kind);\n            const dc = this.dataChannelForKind(kind);\n            if (dc) {\n                dc.send(msg);\n            }\n            this.updateAndEmitDCBufferStatus(kind);\n        });\n    }\n    /**\n   * @internal\n   */ ensureDataTransportConnected(kind) {\n        let subscriber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.subscriberPrimary;\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"PC manager is closed\");\n            }\n            const transport = subscriber ? this.pcManager.subscriber : this.pcManager.publisher;\n            const transportName = subscriber ? \"Subscriber\" : \"Publisher\";\n            if (!transport) {\n                throw new ConnectionError(\"\".concat(transportName, \" connection not set\"));\n            }\n            if (!subscriber && !this.pcManager.publisher.isICEConnected && this.pcManager.publisher.getICEConnectionState() !== \"checking\") {\n                // start negotiation\n                this.negotiate();\n            }\n            const targetChannel = this.dataChannelForKind(kind, subscriber);\n            if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === \"open\") {\n                return;\n            }\n            // wait until ICE connected\n            const endTime = new Date().getTime() + this.peerConnectionTimeout;\n            while(new Date().getTime() < endTime){\n                if (transport.isICEConnected && ((_a = this.dataChannelForKind(kind, subscriber)) === null || _a === void 0 ? void 0 : _a.readyState) === \"open\") {\n                    return;\n                }\n                yield sleep(50);\n            }\n            throw new ConnectionError(\"could not establish \".concat(transportName, \" connection, state: \").concat(transport.getICEConnectionState()));\n        });\n    }\n    ensurePublisherConnected(kind) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.ensureDataTransportConnected(kind, false);\n        });\n    }\n    /* @internal */ verifyTransport() {\n        if (!this.pcManager) {\n            return false;\n        }\n        // primary connection\n        if (this.pcManager.currentState !== PCTransportState.CONNECTED) {\n            return false;\n        }\n        // ensure signal is connected\n        if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {\n            return false;\n        }\n        return true;\n    }\n    /** @internal */ negotiate() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // observe signal state\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    if (!this.pcManager) {\n                        reject(new NegotiationError(\"PC manager is closed\"));\n                        return;\n                    }\n                    this.pcManager.requirePublisher();\n                    const abortController = new AbortController();\n                    const handleClosed = ()=>{\n                        abortController.abort();\n                        this.log.debug(\"engine disconnected while negotiation was ongoing\", this.logContext);\n                        resolve();\n                        return;\n                    };\n                    if (this.isClosed) {\n                        reject(\"cannot negotiate on closed engine\");\n                    }\n                    this.on(EngineEvent.Closing, handleClosed);\n                    this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (rtpTypes)=>{\n                        const rtpMap = new Map();\n                        rtpTypes.forEach((rtp)=>{\n                            const codec = rtp.codec.toLowerCase();\n                            if (isVideoCodec(codec)) {\n                                rtpMap.set(rtp.payload, codec);\n                            }\n                        });\n                        this.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);\n                    });\n                    try {\n                        yield this.pcManager.negotiate(abortController);\n                        resolve();\n                    } catch (e) {\n                        if (e instanceof NegotiationError) {\n                            this.fullReconnectOnNext = true;\n                        }\n                        this.handleDisconnect(\"negotiation\", ReconnectReason.RR_UNKNOWN);\n                        reject(e);\n                    } finally{\n                        this.off(EngineEvent.Closing, handleClosed);\n                    }\n                }));\n        });\n    }\n    dataChannelForKind(kind, sub) {\n        if (!sub) {\n            if (kind === DataPacket_Kind.LOSSY) {\n                return this.lossyDC;\n            }\n            if (kind === DataPacket_Kind.RELIABLE) {\n                return this.reliableDC;\n            }\n        } else {\n            if (kind === DataPacket_Kind.LOSSY) {\n                return this.lossyDCSub;\n            }\n            if (kind === DataPacket_Kind.RELIABLE) {\n                return this.reliableDCSub;\n            }\n        }\n    }\n    /** @internal */ sendSyncState(remoteTracks, localTracks) {\n        var _a, _b;\n        if (!this.pcManager) {\n            this.log.warn(\"sync state cannot be sent without peer connection setup\", this.logContext);\n            return;\n        }\n        const previousAnswer = this.pcManager.subscriber.getLocalDescription();\n        const previousOffer = this.pcManager.subscriber.getRemoteDescription();\n        /* 1. autosubscribe on, so subscribed tracks = all tracks - unsub tracks,\n          in this case, we send unsub tracks, so server add all tracks to this\n          subscribe pc and unsub special tracks from it.\n       2. autosubscribe off, we send subscribed tracks.\n    */ const autoSubscribe = (_b = (_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.autoSubscribe) !== null && _b !== void 0 ? _b : true;\n        const trackSids = new Array();\n        remoteTracks.forEach((track)=>{\n            if (track.isDesired !== autoSubscribe) {\n                trackSids.push(track.trackSid);\n            }\n        });\n        this.client.sendSyncState(new SyncState({\n            answer: previousAnswer ? toProtoSessionDescription({\n                sdp: previousAnswer.sdp,\n                type: previousAnswer.type\n            }) : undefined,\n            offer: previousOffer ? toProtoSessionDescription({\n                sdp: previousOffer.sdp,\n                type: previousOffer.type\n            }) : undefined,\n            subscription: new UpdateSubscription({\n                trackSids,\n                subscribe: !autoSubscribe,\n                participantTracks: []\n            }),\n            publishTracks: getTrackPublicationInfo(localTracks),\n            dataChannels: this.dataChannelsInfo()\n        }));\n    }\n    /* @internal */ failNext() {\n        // debugging method to fail the next reconnect/resume attempt\n        this.shouldFailNext = true;\n    }\n    dataChannelsInfo() {\n        const infos = [];\n        const getInfo = (dc, target)=>{\n            if ((dc === null || dc === void 0 ? void 0 : dc.id) !== undefined && dc.id !== null) {\n                infos.push(new DataChannelInfo({\n                    label: dc.label,\n                    id: dc.id,\n                    target\n                }));\n            }\n        };\n        getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);\n        return infos;\n    }\n    clearReconnectTimeout() {\n        if (this.reconnectTimeout) {\n            CriticalTimers.clearTimeout(this.reconnectTimeout);\n        }\n    }\n    clearPendingReconnect() {\n        this.clearReconnectTimeout();\n        this.reconnectAttempts = 0;\n    }\n    registerOnLineListener() {\n        if (isWeb()) {\n            window.addEventListener(\"online\", this.handleBrowserOnLine);\n        }\n    }\n    deregisterOnLineListener() {\n        if (isWeb()) {\n            window.removeEventListener(\"online\", this.handleBrowserOnLine);\n        }\n    }\n}\nclass SignalReconnectError extends Error {\n}\nclass RegionUrlProvider {\n    constructor(url, token){\n        this.lastUpdateAt = 0;\n        this.settingsCacheTime = 3000;\n        this.attemptedRegions = [];\n        this.serverUrl = new URL(url);\n        this.token = token;\n    }\n    updateToken(token) {\n        this.token = token;\n    }\n    isCloud() {\n        return isCloud(this.serverUrl);\n    }\n    getServerUrl() {\n        return this.serverUrl;\n    }\n    getNextBestRegionUrl(abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.isCloud()) {\n                throw Error(\"region availability is only supported for LiveKit Cloud domains\");\n            }\n            if (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) {\n                this.regionSettings = yield this.fetchRegionSettings(abortSignal);\n            }\n            const regionsLeft = this.regionSettings.regions.filter((region)=>!this.attemptedRegions.find((attempted)=>attempted.url === region.url));\n            if (regionsLeft.length > 0) {\n                const nextRegion = regionsLeft[0];\n                this.attemptedRegions.push(nextRegion);\n                livekitLogger.debug(\"next region: \".concat(nextRegion.region));\n                return nextRegion.url;\n            } else {\n                return null;\n            }\n        });\n    }\n    resetAttempts() {\n        this.attemptedRegions = [];\n    }\n    /* @internal */ fetchRegionSettings(signal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const regionSettingsResponse = yield fetch(\"\".concat(getCloudConfigUrl(this.serverUrl), \"/regions\"), {\n                headers: {\n                    authorization: \"Bearer \".concat(this.token)\n                },\n                signal\n            });\n            if (regionSettingsResponse.ok) {\n                const regionSettings = yield regionSettingsResponse.json();\n                this.lastUpdateAt = Date.now();\n                return regionSettings;\n            } else {\n                throw new ConnectionError(\"Could not fetch region settings: \".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? 0 /* ConnectionErrorReason.NotAllowed */  : undefined, regionSettingsResponse.status);\n            }\n        });\n    }\n}\nfunction getCloudConfigUrl(serverUrl) {\n    return \"\".concat(serverUrl.protocol.replace(\"ws\", \"http\"), \"//\").concat(serverUrl.host, \"/settings\");\n}\nconst monitorFrequency = 2000;\nfunction computeBitrate(currentStats, prevStats) {\n    if (!prevStats) {\n        return 0;\n    }\n    let bytesNow;\n    let bytesPrev;\n    if (\"bytesReceived\" in currentStats) {\n        bytesNow = currentStats.bytesReceived;\n        bytesPrev = prevStats.bytesReceived;\n    } else if (\"bytesSent\" in currentStats) {\n        bytesNow = currentStats.bytesSent;\n        bytesPrev = prevStats.bytesSent;\n    }\n    if (bytesNow === undefined || bytesPrev === undefined || currentStats.timestamp === undefined || prevStats.timestamp === undefined) {\n        return 0;\n    }\n    return (bytesNow - bytesPrev) * 8 * 1000 / (currentStats.timestamp - prevStats.timestamp);\n}\nclass LocalAudioTrack extends LocalTrack {\n    /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, constraints){\n        let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        let audioContext = arguments.length > 3 ? arguments[3] : undefined;\n        let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n        super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack, loggerOptions);\n        /** @internal */ this.stopOnMute = false;\n        this.monitorSender = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.sender) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                let stats;\n                try {\n                    stats = yield this.getSenderStats();\n                } catch (e) {\n                    this.log.error(\"could not get audio sender stats\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    return;\n                }\n                if (stats && this.prevStats) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.audioContext = audioContext;\n        this.checkForSilence();\n    }\n    setDeviceId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._constraints.deviceId === deviceId) {\n                return true;\n            }\n            this._constraints.deviceId = deviceId;\n            if (!this.isMuted) {\n                yield this.restartTrack();\n            }\n            return this.isMuted || unwrapConstraint(deviceId) === this.mediaStreamTrack.getSettings().deviceId;\n        });\n    }\n    mute() {\n        const _super = Object.create(null, {\n            mute: {\n                get: ()=>super.mute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                // disabled special handling as it will cause BT headsets to switch communication modes\n                if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {\n                    this.log.debug(\"stopping mic track\", this.logContext);\n                    // also stop the track, so that microphone indicator is turned off\n                    this._mediaStreamTrack.stop();\n                }\n                yield _super.mute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    unmute() {\n        const _super = Object.create(null, {\n            unmute: {\n                get: ()=>super.unmute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                const deviceHasChanged = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);\n                if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === \"ended\" || deviceHasChanged) && !this.isUserProvided) {\n                    this.log.debug(\"reacquiring mic track\", this.logContext);\n                    yield this.restartTrack();\n                }\n                yield _super.unmute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    restartTrack(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let constraints;\n            if (options) {\n                const streamConstraints = constraintsForOptions({\n                    audio: options\n                });\n                if (typeof streamConstraints.audio !== \"boolean\") {\n                    constraints = streamConstraints.audio;\n                }\n            }\n            yield this.restart(constraints);\n        });\n    }\n    restart(constraints) {\n        const _super = Object.create(null, {\n            restart: {\n                get: ()=>super.restart\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const track = yield _super.restart.call(this, constraints);\n            this.checkForSilence();\n            return track;\n        });\n    }\n    /* @internal */ startMonitor() {\n        if (!isWeb()) {\n            return;\n        }\n        if (this.monitorInterval) {\n            return;\n        }\n        this.monitorInterval = setInterval(()=>{\n            this.monitorSender();\n        }, monitorFrequency);\n    }\n    setProcessor(processor) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.processorLock.lock();\n            try {\n                if (!this.audioContext) {\n                    throw Error(\"Audio context needs to be set on LocalAudioTrack in order to enable processors\");\n                }\n                if (this.processor) {\n                    yield this.stopProcessor();\n                }\n                if (this.kind === \"unknown\") {\n                    throw TypeError(\"cannot set processor on track of unknown kind\");\n                }\n                const processorOptions = {\n                    kind: this.kind,\n                    track: this._mediaStreamTrack,\n                    audioContext: this.audioContext\n                };\n                this.log.debug(\"setting up audio processor \".concat(processor.name), this.logContext);\n                yield processor.init(processorOptions);\n                this.processor = processor;\n                if (this.processor.processedTrack) {\n                    yield (_a = this.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(this.processor.processedTrack);\n                }\n            } finally{\n                unlock();\n            }\n        });\n    }\n    /**\n   * @internal\n   * @experimental\n   */ setAudioContext(audioContext) {\n        this.audioContext = audioContext;\n    }\n    getSenderStats() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return undefined;\n            }\n            const stats = yield this.sender.getStats();\n            let audioStats;\n            stats.forEach((v)=>{\n                if (v.type === \"outbound-rtp\") {\n                    audioStats = {\n                        type: \"audio\",\n                        streamId: v.id,\n                        packetsSent: v.packetsSent,\n                        packetsLost: v.packetsLost,\n                        bytesSent: v.bytesSent,\n                        timestamp: v.timestamp,\n                        roundTripTime: v.roundTripTime,\n                        jitter: v.jitter\n                    };\n                }\n            });\n            return audioStats;\n        });\n    }\n    checkForSilence() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const trackIsSilent = yield detectSilence(this);\n            if (trackIsSilent) {\n                if (!this.isMuted) {\n                    this.log.warn(\"silence detected on local audio track\", this.logContext);\n                }\n                this.emit(TrackEvent.AudioSilenceDetected);\n            }\n            return trackIsSilent;\n        });\n    }\n}\n/** @internal */ function mediaTrackToLocalTrack(mediaStreamTrack, constraints, loggerOptions) {\n    switch(mediaStreamTrack.kind){\n        case \"audio\":\n            return new LocalAudioTrack(mediaStreamTrack, constraints, false, undefined, loggerOptions);\n        case \"video\":\n            return new LocalVideoTrack(mediaStreamTrack, constraints, false, loggerOptions);\n        default:\n            throw new TrackInvalidError(\"unsupported track type: \".concat(mediaStreamTrack.kind));\n    }\n}\n/* @internal */ const presets169 = Object.values(VideoPresets);\n/* @internal */ const presets43 = Object.values(VideoPresets43);\n/* @internal */ const presetsScreenShare = Object.values(ScreenSharePresets);\n/* @internal */ const defaultSimulcastPresets169 = [\n    VideoPresets.h180,\n    VideoPresets.h360\n];\n/* @internal */ const defaultSimulcastPresets43 = [\n    VideoPresets43.h180,\n    VideoPresets43.h360\n];\n/* @internal */ const computeDefaultScreenShareSimulcastPresets = (fromPreset)=>{\n    const layers = [\n        {\n            scaleResolutionDownBy: 2,\n            fps: fromPreset.encoding.maxFramerate\n        }\n    ];\n    return layers.map((t)=>{\n        var _a, _b;\n        return new VideoPreset(Math.floor(fromPreset.width / t.scaleResolutionDownBy), Math.floor(fromPreset.height / t.scaleResolutionDownBy), Math.max(150000, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / ((_b = t.fps) !== null && _b !== void 0 ? _b : 30))))), t.fps, fromPreset.encoding.priority);\n    });\n};\n// /**\n//  *\n//  * @internal\n//  * @experimental\n//  */\n// const computeDefaultMultiCodecSimulcastEncodings = (width: number, height: number) => {\n//   // use vp8 as a default\n//   const vp8 = determineAppropriateEncoding(false, width, height);\n//   const vp9 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.9 };\n//   const h264 = { ...vp8, maxBitrate: vp8.maxBitrate * 1.1 };\n//   const av1 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.7 };\n//   return {\n//     vp8,\n//     vp9,\n//     h264,\n//     av1,\n//   };\n// };\nconst videoRids = [\n    \"q\",\n    \"h\",\n    \"f\"\n];\n/* @internal */ function computeVideoEncodings(isScreenShare, width, height, options) {\n    var _a, _b;\n    let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;\n    if (isScreenShare) {\n        videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;\n    }\n    const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;\n    const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;\n    const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;\n    if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {\n        // when we aren't simulcasting or svc, will need to return a single encoding without\n        // capping bandwidth. we always require a encoding for dynacast\n        return [\n            {}\n        ];\n    }\n    if (!videoEncoding) {\n        // find the right encoding based on width/height\n        videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);\n        livekitLogger.debug(\"using video encoding\", videoEncoding);\n    }\n    const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate, videoEncoding.priority);\n    if (scalabilityMode && isSVCCodec(videoCodec)) {\n        livekitLogger.debug(\"using svc with scalabilityMode \".concat(scalabilityMode));\n        const sm = new ScalabilityMode(scalabilityMode);\n        const encodings = [];\n        if (sm.spatial > 3) {\n            throw new Error(\"unsupported scalabilityMode: \".concat(scalabilityMode));\n        }\n        for(let i = 0; i < sm.spatial; i += 1){\n            encodings.push({\n                rid: videoRids[2 - i],\n                maxBitrate: videoEncoding.maxBitrate / Math.pow(3, i),\n                /* @ts-ignore */ maxFramerate: original.encoding.maxFramerate\n            });\n        }\n        /* @ts-ignore */ encodings[0].scalabilityMode = scalabilityMode;\n        livekitLogger.debug(\"encodings\", encodings);\n        return encodings;\n    }\n    if (!useSimulcast) {\n        return [\n            videoEncoding\n        ];\n    }\n    let presets = [];\n    if (isScreenShare) {\n        presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);\n    } else {\n        presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);\n    }\n    let midPreset;\n    if (presets.length > 0) {\n        const lowPreset = presets[0];\n        if (presets.length > 1) {\n            [, midPreset] = presets;\n        }\n        // NOTE:\n        //   1. Ordering of these encodings is important. Chrome seems\n        //      to use the index into encodings to decide which layer\n        //      to disable when CPU constrained.\n        //      So encodings should be ordered in increasing spatial\n        //      resolution order.\n        //   2. ion-sfu translates rids into layers. So, all encodings\n        //      should have the base layer `q` and then more added\n        //      based on other conditions.\n        const size = Math.max(width, height);\n        if (size >= 960 && midPreset) {\n            return encodingsFromPresets(width, height, [\n                lowPreset,\n                midPreset,\n                original\n            ]);\n        }\n        if (size >= 480) {\n            return encodingsFromPresets(width, height, [\n                lowPreset,\n                original\n            ]);\n        }\n    }\n    return encodingsFromPresets(width, height, [\n        original\n    ]);\n}\nfunction computeTrackBackupEncodings(track, videoCodec, opts) {\n    var _a, _b, _c, _d;\n    // backupCodec should not be true anymore, default codec is set in LocalParticipant.publish\n    if (!opts.backupCodec || opts.backupCodec === true || opts.backupCodec.codec === opts.videoCodec) {\n        // backup codec publishing is disabled\n        return;\n    }\n    if (videoCodec !== opts.backupCodec.codec) {\n        livekitLogger.warn(\"requested a different codec than specified as backup\", {\n            serverRequested: videoCodec,\n            backup: opts.backupCodec.codec\n        });\n    }\n    opts.videoCodec = videoCodec;\n    // use backup encoding setting as videoEncoding for backup codec publishing\n    opts.videoEncoding = opts.backupCodec.encoding;\n    const settings = track.mediaStreamTrack.getSettings();\n    const width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;\n    const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;\n    const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);\n    return encodings;\n}\n/* @internal */ function determineAppropriateEncoding(isScreenShare, width, height, codec) {\n    const presets = presetsForResolution(isScreenShare, width, height);\n    let { encoding } = presets[0];\n    // handle portrait by swapping dimensions\n    const size = Math.max(width, height);\n    for(let i = 0; i < presets.length; i += 1){\n        const preset = presets[i];\n        encoding = preset.encoding;\n        if (preset.width >= size) {\n            break;\n        }\n    }\n    // presets are based on the assumption of vp8 as a codec\n    // for other codecs we adjust the maxBitrate if no specific videoEncoding has been provided\n    // users should override these with ones that are optimized for their use case\n    // NOTE: SVC codec bitrates are inclusive of all scalability layers. while\n    // bitrate for non-SVC codecs does not include other simulcast layers.\n    if (codec) {\n        switch(codec){\n            case \"av1\":\n                encoding = Object.assign({}, encoding);\n                encoding.maxBitrate = encoding.maxBitrate * 0.7;\n                break;\n            case \"vp9\":\n                encoding = Object.assign({}, encoding);\n                encoding.maxBitrate = encoding.maxBitrate * 0.85;\n                break;\n        }\n    }\n    return encoding;\n}\n/* @internal */ function presetsForResolution(isScreenShare, width, height) {\n    if (isScreenShare) {\n        return presetsScreenShare;\n    }\n    const aspect = width > height ? width / height : height / width;\n    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n        return presets169;\n    }\n    return presets43;\n}\n/* @internal */ function defaultSimulcastLayers(isScreenShare, original) {\n    if (isScreenShare) {\n        return computeDefaultScreenShareSimulcastPresets(original);\n    }\n    const { width, height } = original;\n    const aspect = width > height ? width / height : height / width;\n    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n        return defaultSimulcastPresets169;\n    }\n    return defaultSimulcastPresets43;\n}\n// presets should be ordered by low, medium, high\nfunction encodingsFromPresets(width, height, presets) {\n    const encodings = [];\n    presets.forEach((preset, idx)=>{\n        if (idx >= videoRids.length) {\n            return;\n        }\n        const size = Math.min(width, height);\n        const rid = videoRids[idx];\n        const encoding = {\n            rid,\n            scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),\n            maxBitrate: preset.encoding.maxBitrate\n        };\n        if (preset.encoding.maxFramerate) {\n            encoding.maxFramerate = preset.encoding.maxFramerate;\n        }\n        const canSetPriority = isFireFox() || idx === 0;\n        if (preset.encoding.priority && canSetPriority) {\n            encoding.priority = preset.encoding.priority;\n            encoding.networkPriority = preset.encoding.priority;\n        }\n        encodings.push(encoding);\n    });\n    // RN ios simulcast requires all same framerates.\n    if (isReactNative() && getReactNativeOs() === \"ios\") {\n        let topFramerate = undefined;\n        encodings.forEach((encoding)=>{\n            if (!topFramerate) {\n                topFramerate = encoding.maxFramerate;\n            } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {\n                topFramerate = encoding.maxFramerate;\n            }\n        });\n        let notifyOnce = true;\n        encodings.forEach((encoding)=>{\n            var _a;\n            if (encoding.maxFramerate != topFramerate) {\n                if (notifyOnce) {\n                    notifyOnce = false;\n                    livekitLogger.info(\"Simulcast on iOS React-Native requires all encodings to share the same framerate.\");\n                }\n                livekitLogger.info('Setting framerate of encoding \"'.concat((_a = encoding.rid) !== null && _a !== void 0 ? _a : \"\", '\" to ').concat(topFramerate));\n                encoding.maxFramerate = topFramerate;\n            }\n        });\n    }\n    return encodings;\n}\n/** @internal */ function sortPresets(presets) {\n    if (!presets) return;\n    return presets.sort((a, b)=>{\n        const { encoding: aEnc } = a;\n        const { encoding: bEnc } = b;\n        if (aEnc.maxBitrate > bEnc.maxBitrate) {\n            return 1;\n        }\n        if (aEnc.maxBitrate < bEnc.maxBitrate) return -1;\n        if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {\n            return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;\n        }\n        return 0;\n    });\n}\n/** @internal */ class ScalabilityMode {\n    constructor(scalabilityMode){\n        const results = scalabilityMode.match(/^L(\\d)T(\\d)(h|_KEY|_KEY_SHIFT){0,1}$/);\n        if (!results) {\n            throw new Error(\"invalid scalability mode\");\n        }\n        this.spatial = parseInt(results[1]);\n        this.temporal = parseInt(results[2]);\n        if (results.length > 3) {\n            switch(results[3]){\n                case \"h\":\n                case \"_KEY\":\n                case \"_KEY_SHIFT\":\n                    this.suffix = results[3];\n            }\n        }\n    }\n    toString() {\n        var _a;\n        return \"L\".concat(this.spatial, \"T\").concat(this.temporal).concat((_a = this.suffix) !== null && _a !== void 0 ? _a : \"\");\n    }\n}\nconst refreshSubscribedCodecAfterNewCodec = 5000;\nclass LocalVideoTrack extends LocalTrack {\n    /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, constraints){\n        let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        let loggerOptions = arguments.length > 3 ? arguments[3] : undefined;\n        super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack, loggerOptions);\n        /* @internal */ this.simulcastCodecs = new Map();\n        this.monitorSender = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.sender) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                let stats;\n                try {\n                    stats = yield this.getSenderStats();\n                } catch (e) {\n                    this.log.error(\"could not get audio sender stats\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    return;\n                }\n                const statsMap = new Map(stats.map((s)=>[\n                        s.rid,\n                        s\n                    ]));\n                if (this.prevStats) {\n                    let totalBitrate = 0;\n                    statsMap.forEach((s, key)=>{\n                        var _a;\n                        const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);\n                        totalBitrate += computeBitrate(s, prev);\n                    });\n                    this._currentBitrate = totalBitrate;\n                }\n                this.prevStats = statsMap;\n            });\n        this.senderLock = new Mutex();\n    }\n    get isSimulcast() {\n        if (this.sender && this.sender.getParameters().encodings.length > 1) {\n            return true;\n        }\n        return false;\n    }\n    /* @internal */ startMonitor(signalClient) {\n        var _a;\n        this.signalClient = signalClient;\n        if (!isWeb()) {\n            return;\n        }\n        // save original encodings\n        // TODO : merge simulcast tracks stats\n        const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();\n        if (params) {\n            this.encodings = params.encodings;\n        }\n        if (this.monitorInterval) {\n            return;\n        }\n        this.monitorInterval = setInterval(()=>{\n            this.monitorSender();\n        }, monitorFrequency);\n    }\n    stop() {\n        this._mediaStreamTrack.getConstraints();\n        this.simulcastCodecs.forEach((trackInfo)=>{\n            trackInfo.mediaStreamTrack.stop();\n        });\n        super.stop();\n    }\n    pauseUpstream() {\n        const _super = Object.create(null, {\n            pauseUpstream: {\n                get: ()=>super.pauseUpstream\n            }\n        });\n        var _a, e_1, _b, _c;\n        var _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.pauseUpstream.call(this);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        });\n    }\n    resumeUpstream() {\n        const _super = Object.create(null, {\n            resumeUpstream: {\n                get: ()=>super.resumeUpstream\n            }\n        });\n        var _a, e_2, _b, _c;\n        var _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.resumeUpstream.call(this);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(sc.mediaStreamTrack);\n                }\n            } catch (e_2_1) {\n                e_2 = {\n                    error: e_2_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_2) throw e_2.error;\n                }\n            }\n        });\n    }\n    mute() {\n        const _super = Object.create(null, {\n            mute: {\n                get: ()=>super.mute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (this.source === Track.Source.Camera && !this.isUserProvided) {\n                    this.log.debug(\"stopping camera track\", this.logContext);\n                    // also stop the track, so that camera indicator is turned off\n                    this._mediaStreamTrack.stop();\n                }\n                yield _super.mute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    unmute() {\n        const _super = Object.create(null, {\n            unmute: {\n                get: ()=>super.unmute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (this.source === Track.Source.Camera && !this.isUserProvided) {\n                    this.log.debug(\"reacquiring camera track\", this.logContext);\n                    yield this.restartTrack();\n                }\n                yield _super.unmute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    setTrackMuted(muted) {\n        super.setTrackMuted(muted);\n        for (const sc of this.simulcastCodecs.values()){\n            sc.mediaStreamTrack.enabled = !muted;\n        }\n    }\n    getSenderStats() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return [];\n            }\n            const items = [];\n            const stats = yield this.sender.getStats();\n            stats.forEach((v)=>{\n                var _a;\n                if (v.type === \"outbound-rtp\") {\n                    const vs = {\n                        type: \"video\",\n                        streamId: v.id,\n                        frameHeight: v.frameHeight,\n                        frameWidth: v.frameWidth,\n                        firCount: v.firCount,\n                        pliCount: v.pliCount,\n                        nackCount: v.nackCount,\n                        packetsSent: v.packetsSent,\n                        bytesSent: v.bytesSent,\n                        framesSent: v.framesSent,\n                        timestamp: v.timestamp,\n                        rid: (_a = v.rid) !== null && _a !== void 0 ? _a : v.id,\n                        retransmittedPacketsSent: v.retransmittedPacketsSent,\n                        qualityLimitationReason: v.qualityLimitationReason,\n                        qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges\n                    };\n                    //locate the appropriate remote-inbound-rtp item\n                    const r = stats.get(v.remoteId);\n                    if (r) {\n                        vs.jitter = r.jitter;\n                        vs.packetsLost = r.packetsLost;\n                        vs.roundTripTime = r.roundTripTime;\n                    }\n                    items.push(vs);\n                }\n            });\n            return items;\n        });\n    }\n    setPublishingQuality(maxQuality) {\n        const qualities = [];\n        for(let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1){\n            qualities.push(new SubscribedQuality({\n                quality: q,\n                enabled: q <= maxQuality\n            }));\n        }\n        this.log.debug(\"setting publishing quality. max quality \".concat(maxQuality), this.logContext);\n        this.setPublishingLayers(qualities);\n    }\n    setDeviceId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)) {\n                return true;\n            }\n            this._constraints.deviceId = deviceId;\n            // when video is muted, underlying media stream track is stopped and\n            // will be restarted later\n            if (!this.isMuted) {\n                yield this.restartTrack();\n            }\n            return this.isMuted || unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;\n        });\n    }\n    restartTrack(options) {\n        var _a, e_3, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            let constraints;\n            if (options) {\n                const streamConstraints = constraintsForOptions({\n                    video: options\n                });\n                if (typeof streamConstraints.video !== \"boolean\") {\n                    constraints = streamConstraints.video;\n                }\n            }\n            yield this.restart(constraints);\n            try {\n                for(var _d = true, _e = __asyncValues(this.simulcastCodecs.values()), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true){\n                    _c = _f.value;\n                    _d = false;\n                    const sc = _c;\n                    if (sc.sender) {\n                        sc.mediaStreamTrack = this.mediaStreamTrack.clone();\n                        yield sc.sender.replaceTrack(sc.mediaStreamTrack);\n                    }\n                }\n            } catch (e_3_1) {\n                e_3 = {\n                    error: e_3_1\n                };\n            } finally{\n                try {\n                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n                } finally{\n                    if (e_3) throw e_3.error;\n                }\n            }\n        });\n    }\n    setProcessor(processor) {\n        let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        const _super = Object.create(null, {\n            setProcessor: {\n                get: ()=>super.setProcessor\n            }\n        });\n        var _a, e_4, _b, _c;\n        var _d, _e;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.setProcessor.call(this, processor, showProcessedStreamLocally);\n            if ((_d = this.processor) === null || _d === void 0 ? void 0 : _d.processedTrack) {\n                try {\n                    for(var _f = true, _g = __asyncValues(this.simulcastCodecs.values()), _h; _h = yield _g.next(), _a = _h.done, !_a; _f = true){\n                        _c = _h.value;\n                        _f = false;\n                        const sc = _c;\n                        yield (_e = sc.sender) === null || _e === void 0 ? void 0 : _e.replaceTrack(this.processor.processedTrack);\n                    }\n                } catch (e_4_1) {\n                    e_4 = {\n                        error: e_4_1\n                    };\n                } finally{\n                    try {\n                        if (!_f && !_a && (_b = _g.return)) yield _b.call(_g);\n                    } finally{\n                        if (e_4) throw e_4.error;\n                    }\n                }\n            }\n        });\n    }\n    addSimulcastTrack(codec, encodings) {\n        if (this.simulcastCodecs.has(codec)) {\n            throw new Error(\"\".concat(codec, \" already added\"));\n        }\n        const simulcastCodecInfo = {\n            codec,\n            mediaStreamTrack: this.mediaStreamTrack.clone(),\n            sender: undefined,\n            encodings\n        };\n        this.simulcastCodecs.set(codec, simulcastCodecInfo);\n        return simulcastCodecInfo;\n    }\n    setSimulcastTrackSender(codec, sender) {\n        const simulcastCodecInfo = this.simulcastCodecs.get(codec);\n        if (!simulcastCodecInfo) {\n            return;\n        }\n        simulcastCodecInfo.sender = sender;\n        // browser will reenable disabled codec/layers after new codec has been published,\n        // so refresh subscribedCodecs after publish a new codec\n        setTimeout(()=>{\n            if (this.subscribedCodecs) {\n                this.setPublishingCodecs(this.subscribedCodecs);\n            }\n        }, refreshSubscribedCodecAfterNewCodec);\n    }\n    /**\n   * @internal\n   * Sets codecs that should be publishing, returns new codecs that have not yet\n   * been published\n   */ setPublishingCodecs(codecs) {\n        var _a, codecs_1, codecs_1_1;\n        var _b, e_5, _c, _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug(\"setting publishing codecs\", Object.assign(Object.assign({}, this.logContext), {\n                codecs,\n                currentCodec: this.codec\n            }));\n            // only enable simulcast codec for preference codec setted\n            if (!this.codec && codecs.length > 0) {\n                yield this.setPublishingLayers(codecs[0].qualities);\n                return [];\n            }\n            this.subscribedCodecs = codecs;\n            const newCodecs = [];\n            try {\n                for(_a = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; _a = true){\n                    _d = codecs_1_1.value;\n                    _a = false;\n                    const codec = _d;\n                    if (!this.codec || this.codec === codec.codec) {\n                        yield this.setPublishingLayers(codec.qualities);\n                    } else {\n                        const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);\n                        this.log.debug(\"try setPublishingCodec for \".concat(codec.codec), Object.assign(Object.assign({}, this.logContext), {\n                            simulcastCodecInfo\n                        }));\n                        if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {\n                            for (const q of codec.qualities){\n                                if (q.enabled) {\n                                    newCodecs.push(codec.codec);\n                                    break;\n                                }\n                            }\n                        } else if (simulcastCodecInfo.encodings) {\n                            this.log.debug(\"try setPublishingLayersForSender \".concat(codec.codec), this.logContext);\n                            yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock, this.log, this.logContext);\n                        }\n                    }\n                }\n            } catch (e_5_1) {\n                e_5 = {\n                    error: e_5_1\n                };\n            } finally{\n                try {\n                    if (!_a && !_b && (_c = codecs_1.return)) yield _c.call(codecs_1);\n                } finally{\n                    if (e_5) throw e_5.error;\n                }\n            }\n            return newCodecs;\n        });\n    }\n    /**\n   * @internal\n   * Sets layers that should be publishing\n   */ setPublishingLayers(qualities) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug(\"setting publishing layers\", Object.assign(Object.assign({}, this.logContext), {\n                qualities\n            }));\n            if (!this.sender || !this.encodings) {\n                return;\n            }\n            yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock, this.log, this.logContext);\n        });\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!isMobile()) return;\n            if (this.isInBackground && this.source === Track.Source.Camera) {\n                this._mediaStreamTrack.enabled = false;\n            }\n        });\n    }\n}\nfunction setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock, log, logContext) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const unlock = yield senderLock.lock();\n        log.debug(\"setPublishingLayersForSender\", Object.assign(Object.assign({}, logContext), {\n            sender,\n            qualities,\n            senderEncodings\n        }));\n        try {\n            const params = sender.getParameters();\n            const { encodings } = params;\n            if (!encodings) {\n                return;\n            }\n            if (encodings.length !== senderEncodings.length) {\n                log.warn(\"cannot set publishing layers, encodings mismatch\");\n                return;\n            }\n            let hasChanged = false;\n            /* disable closable spatial layer as it has video blur / frozen issue with current server / client\n      1. chrome 113: when switching to up layer with scalability Mode change, it will generate a\n            low resolution frame and recover very quickly, but noticable\n      2. livekit sfu: additional pli request cause video frozen for a few frames, also noticable */ const closableSpatial = false;\n            /* @ts-ignore */ if (closableSpatial && encodings[0].scalabilityMode) ;\n            else {\n                // simulcast dynacast encodings\n                encodings.forEach((encoding, idx)=>{\n                    var _a;\n                    let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : \"\";\n                    if (rid === \"\") {\n                        rid = \"q\";\n                    }\n                    const quality = videoQualityForRid(rid);\n                    const subscribedQuality = qualities.find((q)=>q.quality === quality);\n                    if (!subscribedQuality) {\n                        return;\n                    }\n                    if (encoding.active !== subscribedQuality.enabled) {\n                        hasChanged = true;\n                        encoding.active = subscribedQuality.enabled;\n                        log.debug(\"setting layer \".concat(subscribedQuality.quality, \" to \").concat(encoding.active ? \"enabled\" : \"disabled\"), logContext);\n                        // FireFox does not support setting encoding.active to false, so we\n                        // have a workaround of lowering its bitrate and resolution to the min.\n                        if (isFireFox()) {\n                            if (subscribedQuality.enabled) {\n                                encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;\n                                encoding.maxBitrate = senderEncodings[idx].maxBitrate;\n                                /* @ts-ignore */ encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;\n                            } else {\n                                encoding.scaleResolutionDownBy = 4;\n                                encoding.maxBitrate = 10;\n                                /* @ts-ignore */ encoding.maxFrameRate = 2;\n                            }\n                        }\n                    }\n                });\n            }\n            if (hasChanged) {\n                params.encodings = encodings;\n                log.debug(\"setting encodings\", Object.assign(Object.assign({}, logContext), {\n                    encodings: params.encodings\n                }));\n                yield sender.setParameters(params);\n            }\n        } finally{\n            unlock();\n        }\n    });\n}\nfunction videoQualityForRid(rid) {\n    switch(rid){\n        case \"f\":\n            return VideoQuality.HIGH;\n        case \"h\":\n            return VideoQuality.MEDIUM;\n        case \"q\":\n            return VideoQuality.LOW;\n        default:\n            return VideoQuality.HIGH;\n    }\n}\nfunction videoLayersFromEncodings(width, height, encodings, svc) {\n    // default to a single layer, HQ\n    if (!encodings) {\n        return [\n            new VideoLayer({\n                quality: VideoQuality.HIGH,\n                width,\n                height,\n                bitrate: 0,\n                ssrc: 0\n            })\n        ];\n    }\n    if (svc) {\n        // svc layers\n        /* @ts-ignore */ const encodingSM = encodings[0].scalabilityMode;\n        const sm = new ScalabilityMode(encodingSM);\n        const layers = [];\n        for(let i = 0; i < sm.spatial; i += 1){\n            layers.push(new VideoLayer({\n                quality: VideoQuality.HIGH - i,\n                width: Math.ceil(width / Math.pow(2, i)),\n                height: Math.ceil(height / Math.pow(2, i)),\n                bitrate: encodings[0].maxBitrate ? Math.ceil(encodings[0].maxBitrate / Math.pow(3, i)) : 0,\n                ssrc: 0\n            }));\n        }\n        return layers;\n    }\n    return encodings.map((encoding)=>{\n        var _a, _b, _c;\n        const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;\n        let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : \"\");\n        return new VideoLayer({\n            quality,\n            width: Math.ceil(width / scale),\n            height: Math.ceil(height / scale),\n            bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,\n            ssrc: 0\n        });\n    });\n}\nclass RemoteTrack extends Track {\n    constructor(mediaTrack, sid, kind, receiver, loggerOptions){\n        super(mediaTrack, kind, loggerOptions);\n        this.sid = sid;\n        this.receiver = receiver;\n    }\n    /** @internal */ setMuted(muted) {\n        if (this.isMuted !== muted) {\n            this.isMuted = muted;\n            this._mediaStreamTrack.enabled = !muted;\n            this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n        }\n    }\n    /** @internal */ setMediaStream(stream) {\n        // this is needed to determine when the track is finished\n        this.mediaStream = stream;\n        const onRemoveTrack = (event)=>{\n            if (event.track === this._mediaStreamTrack) {\n                stream.removeEventListener(\"removetrack\", onRemoveTrack);\n                this.receiver = undefined;\n                this._currentBitrate = 0;\n                this.emit(TrackEvent.Ended, this);\n            }\n        };\n        stream.addEventListener(\"removetrack\", onRemoveTrack);\n    }\n    start() {\n        this.startMonitor();\n        // use `enabled` of track to enable re-use of transceiver\n        super.enable();\n    }\n    stop() {\n        this.stopMonitor();\n        // use `enabled` of track to enable re-use of transceiver\n        super.disable();\n    }\n    /**\n   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */ getRTCStatsReport() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return;\n            }\n            const statsReport = yield this.receiver.getStats();\n            return statsReport;\n        });\n    }\n    /* @internal */ startMonitor() {\n        if (!this.monitorInterval) {\n            this.monitorInterval = setInterval(()=>this.monitorReceiver(), monitorFrequency);\n        }\n    }\n}\nclass RemoteAudioTrack extends RemoteTrack {\n    constructor(mediaTrack, sid, receiver, audioContext, audioOutput, loggerOptions){\n        super(mediaTrack, sid, Track.Kind.Audio, receiver, loggerOptions);\n        this.monitorReceiver = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.receiver) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                const stats = yield this.getReceiverStats();\n                if (stats && this.prevStats && this.receiver) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.audioContext = audioContext;\n        this.webAudioPluginNodes = [];\n        if (audioOutput) {\n            this.sinkId = audioOutput.deviceId;\n        }\n    }\n    /**\n   * sets the volume for all attached audio elements\n   */ setVolume(volume) {\n        var _a;\n        for (const el of this.attachedElements){\n            if (this.audioContext) {\n                (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);\n            } else {\n                el.volume = volume;\n            }\n        }\n        if (isReactNative()) {\n            // @ts-ignore\n            this._mediaStreamTrack._setVolume(volume);\n        }\n        this.elementVolume = volume;\n    }\n    /**\n   * gets the volume of attached audio elements (loudest)\n   */ getVolume() {\n        if (this.elementVolume) {\n            return this.elementVolume;\n        }\n        if (isReactNative()) {\n            // RN volume value defaults to 1.0 if hasn't been changed.\n            return 1.0;\n        }\n        let highestVolume = 0;\n        this.attachedElements.forEach((element)=>{\n            if (element.volume > highestVolume) {\n                highestVolume = element.volume;\n            }\n        });\n        return highestVolume;\n    }\n    /**\n   * calls setSinkId on all attached elements, if supported\n   * @param deviceId audio output device\n   */ setSinkId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.sinkId = deviceId;\n            yield Promise.all(this.attachedElements.map((elm)=>{\n                if (!supportsSetSinkId(elm)) {\n                    return;\n                }\n                /* @ts-ignore */ return elm.setSinkId(deviceId);\n            }));\n        });\n    }\n    attach(element) {\n        const needsNewWebAudioConnection = this.attachedElements.length === 0;\n        if (!element) {\n            element = super.attach();\n        } else {\n            super.attach(element);\n        }\n        if (this.sinkId && supportsSetSinkId(element)) {\n            /* @ts-ignore */ element.setSinkId(this.sinkId);\n        }\n        if (this.audioContext && needsNewWebAudioConnection) {\n            this.log.debug(\"using audio context mapping\", this.logContext);\n            this.connectWebAudio(this.audioContext, element);\n            element.volume = 0;\n            element.muted = true;\n        }\n        if (this.elementVolume) {\n            // make sure volume setting is being applied to the newly attached element\n            this.setVolume(this.elementVolume);\n        }\n        return element;\n    }\n    detach(element) {\n        let detached;\n        if (!element) {\n            detached = super.detach();\n            this.disconnectWebAudio();\n        } else {\n            detached = super.detach(element);\n            // if there are still any attached elements after detaching, connect webaudio to the first element that's left\n            // disconnect webaudio otherwise\n            if (this.audioContext) {\n                if (this.attachedElements.length > 0) {\n                    this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n                } else {\n                    this.disconnectWebAudio();\n                }\n            }\n        }\n        return detached;\n    }\n    /**\n   * @internal\n   * @experimental\n   */ setAudioContext(audioContext) {\n        this.audioContext = audioContext;\n        if (audioContext && this.attachedElements.length > 0) {\n            this.connectWebAudio(audioContext, this.attachedElements[0]);\n        } else if (!audioContext) {\n            this.disconnectWebAudio();\n        }\n    }\n    /**\n   * @internal\n   * @experimental\n   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.\n   */ setWebAudioPlugins(nodes) {\n        this.webAudioPluginNodes = nodes;\n        if (this.attachedElements.length > 0 && this.audioContext) {\n            this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n        }\n    }\n    connectWebAudio(context, element) {\n        this.disconnectWebAudio();\n        // @ts-ignore attached elements always have a srcObject set\n        this.sourceNode = context.createMediaStreamSource(element.srcObject);\n        let lastNode = this.sourceNode;\n        this.webAudioPluginNodes.forEach((node)=>{\n            lastNode.connect(node);\n            lastNode = node;\n        });\n        this.gainNode = context.createGain();\n        lastNode.connect(this.gainNode);\n        this.gainNode.connect(context.destination);\n        if (this.elementVolume) {\n            this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);\n        }\n        // try to resume the context if it isn't running already\n        if (context.state !== \"running\") {\n            context.resume().then(()=>{\n                if (context.state !== \"running\") {\n                    this.emit(TrackEvent.AudioPlaybackFailed, new Error(\"Audio Context couldn't be started automatically\"));\n                }\n            }).catch((e)=>{\n                this.emit(TrackEvent.AudioPlaybackFailed, e);\n            });\n        }\n    }\n    disconnectWebAudio() {\n        var _a, _b;\n        (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n        (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();\n        this.gainNode = undefined;\n        this.sourceNode = undefined;\n    }\n    getReceiverStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.receiver || !this.receiver.getStats) {\n                return;\n            }\n            const stats = yield this.receiver.getStats();\n            let receiverStats;\n            stats.forEach((v)=>{\n                if (v.type === \"inbound-rtp\") {\n                    receiverStats = {\n                        type: \"audio\",\n                        timestamp: v.timestamp,\n                        jitter: v.jitter,\n                        bytesReceived: v.bytesReceived,\n                        concealedSamples: v.concealedSamples,\n                        concealmentEvents: v.concealmentEvents,\n                        silentConcealedSamples: v.silentConcealedSamples,\n                        silentConcealmentEvents: v.silentConcealmentEvents,\n                        totalAudioEnergy: v.totalAudioEnergy,\n                        totalSamplesDuration: v.totalSamplesDuration\n                    };\n                }\n            });\n            return receiverStats;\n        });\n    }\n}\nconst REACTION_DELAY = 100;\nclass RemoteVideoTrack extends RemoteTrack {\n    constructor(mediaTrack, sid, receiver, adaptiveStreamSettings, loggerOptions){\n        super(mediaTrack, sid, Track.Kind.Video, receiver, loggerOptions);\n        this.elementInfos = [];\n        this.monitorReceiver = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.receiver) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                const stats = yield this.getReceiverStats();\n                if (stats && this.prevStats && this.receiver) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.debouncedHandleResize = r(()=>{\n            this.updateDimensions();\n        }, REACTION_DELAY);\n        this.adaptiveStreamSettings = adaptiveStreamSettings;\n    }\n    get isAdaptiveStream() {\n        return this.adaptiveStreamSettings !== undefined;\n    }\n    /**\n   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start\n   */ get mediaStreamTrack() {\n        return this._mediaStreamTrack;\n    }\n    /** @internal */ setMuted(muted) {\n        super.setMuted(muted);\n        this.attachedElements.forEach((element)=>{\n            // detach or attach\n            if (muted) {\n                detachTrack(this._mediaStreamTrack, element);\n            } else {\n                attachToElement(this._mediaStreamTrack, element);\n            }\n        });\n    }\n    attach(element) {\n        if (!element) {\n            element = super.attach();\n        } else {\n            super.attach(element);\n        }\n        // It's possible attach is called multiple times on an element. When that's\n        // the case, we'd want to avoid adding duplicate elementInfos\n        if (this.adaptiveStreamSettings && this.elementInfos.find((info)=>info.element === element) === undefined) {\n            const elementInfo = new HTMLElementInfo(element);\n            this.observeElementInfo(elementInfo);\n        }\n        return element;\n    }\n    /**\n   * Observe an ElementInfo for changes when adaptive streaming.\n   * @param elementInfo\n   * @internal\n   */ observeElementInfo(elementInfo) {\n        if (this.adaptiveStreamSettings && this.elementInfos.find((info)=>info === elementInfo) === undefined) {\n            elementInfo.handleResize = ()=>{\n                this.debouncedHandleResize();\n            };\n            elementInfo.handleVisibilityChanged = ()=>{\n                this.updateVisibility();\n            };\n            this.elementInfos.push(elementInfo);\n            elementInfo.observe();\n            // trigger the first resize update cycle\n            // if the tab is backgrounded, the initial resize event does not fire until\n            // the tab comes into focus for the first time.\n            this.debouncedHandleResize();\n            this.updateVisibility();\n        } else {\n            this.log.warn(\"visibility resize observer not triggered\", this.logContext);\n        }\n    }\n    /**\n   * Stop observing an ElementInfo for changes.\n   * @param elementInfo\n   * @internal\n   */ stopObservingElementInfo(elementInfo) {\n        if (!this.isAdaptiveStream) {\n            this.log.warn(\"stopObservingElementInfo ignored\", this.logContext);\n            return;\n        }\n        const stopElementInfos = this.elementInfos.filter((info)=>info === elementInfo);\n        for (const info of stopElementInfos){\n            info.stopObserving();\n        }\n        this.elementInfos = this.elementInfos.filter((info)=>info !== elementInfo);\n        this.updateVisibility();\n        this.debouncedHandleResize();\n    }\n    detach(element) {\n        let detachedElements = [];\n        if (element) {\n            this.stopObservingElement(element);\n            return super.detach(element);\n        }\n        detachedElements = super.detach();\n        for (const e of detachedElements){\n            this.stopObservingElement(e);\n        }\n        return detachedElements;\n    }\n    /** @internal */ getDecoderImplementation() {\n        var _a;\n        return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;\n    }\n    getReceiverStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.receiver || !this.receiver.getStats) {\n                return;\n            }\n            const stats = yield this.receiver.getStats();\n            let receiverStats;\n            let codecID = \"\";\n            let codecs = new Map();\n            stats.forEach((v)=>{\n                if (v.type === \"inbound-rtp\") {\n                    codecID = v.codecId;\n                    receiverStats = {\n                        type: \"video\",\n                        framesDecoded: v.framesDecoded,\n                        framesDropped: v.framesDropped,\n                        framesReceived: v.framesReceived,\n                        packetsReceived: v.packetsReceived,\n                        packetsLost: v.packetsLost,\n                        frameWidth: v.frameWidth,\n                        frameHeight: v.frameHeight,\n                        pliCount: v.pliCount,\n                        firCount: v.firCount,\n                        nackCount: v.nackCount,\n                        jitter: v.jitter,\n                        timestamp: v.timestamp,\n                        bytesReceived: v.bytesReceived,\n                        decoderImplementation: v.decoderImplementation\n                    };\n                } else if (v.type === \"codec\") {\n                    codecs.set(v.id, v);\n                }\n            });\n            if (receiverStats && codecID !== \"\" && codecs.get(codecID)) {\n                receiverStats.mimeType = codecs.get(codecID).mimeType;\n            }\n            return receiverStats;\n        });\n    }\n    stopObservingElement(element) {\n        const stopElementInfos = this.elementInfos.filter((info)=>info.element === element);\n        for (const info of stopElementInfos){\n            this.stopObservingElementInfo(info);\n        }\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!this.isAdaptiveStream) return;\n            this.updateVisibility();\n        });\n    }\n    updateVisibility() {\n        var _a, _b;\n        const lastVisibilityChange = this.elementInfos.reduce((prev, info)=>Math.max(prev, info.visibilityChangedAt || 0), 0);\n        const backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true // default to true\n        ) ? this.isInBackground : false;\n        const isPiPMode = this.elementInfos.some((info)=>info.pictureInPicture);\n        const isVisible = this.elementInfos.some((info)=>info.visible) && !backgroundPause || isPiPMode;\n        if (this.lastVisible === isVisible) {\n            return;\n        }\n        if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {\n            // delay hidden events\n            CriticalTimers.setTimeout(()=>{\n                this.updateVisibility();\n            }, REACTION_DELAY);\n            return;\n        }\n        this.lastVisible = isVisible;\n        this.emit(TrackEvent.VisibilityChanged, isVisible, this);\n    }\n    updateDimensions() {\n        var _a, _b;\n        let maxWidth = 0;\n        let maxHeight = 0;\n        const pixelDensity = this.getPixelDensity();\n        for (const info of this.elementInfos){\n            const currentElementWidth = info.width() * pixelDensity;\n            const currentElementHeight = info.height() * pixelDensity;\n            if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {\n                maxWidth = currentElementWidth;\n                maxHeight = currentElementHeight;\n            }\n        }\n        if (((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {\n            return;\n        }\n        this.lastDimensions = {\n            width: maxWidth,\n            height: maxHeight\n        };\n        this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);\n    }\n    getPixelDensity() {\n        var _a;\n        const pixelDensity = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity;\n        if (pixelDensity === \"screen\") {\n            return getDevicePixelRatio();\n        } else if (!pixelDensity) {\n            // when unset, we'll pick a sane default here.\n            // for higher pixel density devices (mobile phones, etc), we'll use 2\n            // otherwise it defaults to 1\n            const devicePixelRatio = getDevicePixelRatio();\n            if (devicePixelRatio > 2) {\n                return 2;\n            } else {\n                return 1;\n            }\n        }\n        return pixelDensity;\n    }\n}\nclass HTMLElementInfo {\n    get visible() {\n        return this.isPiP || this.isIntersecting;\n    }\n    get pictureInPicture() {\n        return this.isPiP;\n    }\n    constructor(element, visible){\n        this.onVisibilityChanged = (entry)=>{\n            var _a;\n            const { target, isIntersecting } = entry;\n            if (target === this.element) {\n                this.isIntersecting = isIntersecting;\n                this.visibilityChangedAt = Date.now();\n                (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n            }\n        };\n        this.onEnterPiP = ()=>{\n            var _a;\n            this.isPiP = true;\n            (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.onLeavePiP = ()=>{\n            var _a;\n            this.isPiP = false;\n            (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.element = element;\n        this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);\n        this.isPiP = isWeb() && document.pictureInPictureElement === element;\n        this.visibilityChangedAt = 0;\n    }\n    width() {\n        return this.element.clientWidth;\n    }\n    height() {\n        return this.element.clientHeight;\n    }\n    observe() {\n        // make sure we update the current visible state once we start to observe\n        this.isIntersecting = isElementInViewport(this.element);\n        this.isPiP = document.pictureInPictureElement === this.element;\n        this.element.handleResize = ()=>{\n            var _a;\n            (_a = this.handleResize) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.element.handleVisibilityChanged = this.onVisibilityChanged;\n        getIntersectionObserver().observe(this.element);\n        getResizeObserver().observe(this.element);\n        this.element.addEventListener(\"enterpictureinpicture\", this.onEnterPiP);\n        this.element.addEventListener(\"leavepictureinpicture\", this.onLeavePiP);\n    }\n    stopObserving() {\n        var _a, _b;\n        (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);\n        (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);\n        this.element.removeEventListener(\"enterpictureinpicture\", this.onEnterPiP);\n        this.element.removeEventListener(\"leavepictureinpicture\", this.onLeavePiP);\n    }\n}\n// does not account for occlusion by other elements\nfunction isElementInViewport(el) {\n    let top = el.offsetTop;\n    let left = el.offsetLeft;\n    const width = el.offsetWidth;\n    const height = el.offsetHeight;\n    const { hidden } = el;\n    const { opacity, display } = getComputedStyle(el);\n    while(el.offsetParent){\n        el = el.offsetParent;\n        top += el.offsetTop;\n        left += el.offsetLeft;\n    }\n    return top < window.pageYOffset + window.innerHeight && left < window.pageXOffset + window.innerWidth && top + height > window.pageYOffset && left + width > window.pageXOffset && !hidden && (opacity !== \"\" ? parseFloat(opacity) > 0 : true) && display !== \"none\";\n}\nclass TrackPublication extends eventsExports.EventEmitter {\n    constructor(kind, id, name, loggerOptions){\n        var _a;\n        super();\n        this.metadataMuted = false;\n        this.encryption = Encryption_Type.NONE;\n        this.log = livekitLogger;\n        this.handleMuted = ()=>{\n            this.emit(TrackEvent.Muted);\n        };\n        this.handleUnmuted = ()=>{\n            this.emit(TrackEvent.Unmuted);\n        };\n        this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Publication);\n        this.loggerContextCb = this.loggerContextCb;\n        this.setMaxListeners(100);\n        this.kind = kind;\n        this.trackSid = id;\n        this.trackName = name;\n        this.source = Track.Source.Unknown;\n    }\n    /** @internal */ setTrack(track) {\n        if (this.track) {\n            this.track.off(TrackEvent.Muted, this.handleMuted);\n            this.track.off(TrackEvent.Unmuted, this.handleUnmuted);\n        }\n        this.track = track;\n        if (track) {\n            // forward events\n            track.on(TrackEvent.Muted, this.handleMuted);\n            track.on(TrackEvent.Unmuted, this.handleUnmuted);\n        }\n    }\n    get logContext() {\n        var _a;\n        return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n    }\n    get isMuted() {\n        return this.metadataMuted;\n    }\n    get isEnabled() {\n        return true;\n    }\n    get isSubscribed() {\n        return this.track !== undefined;\n    }\n    get isEncrypted() {\n        return this.encryption !== Encryption_Type.NONE;\n    }\n    /**\n   * an [AudioTrack] if this publication holds an audio track\n   */ get audioTrack() {\n        if (this.track instanceof LocalAudioTrack || this.track instanceof RemoteAudioTrack) {\n            return this.track;\n        }\n    }\n    /**\n   * an [VideoTrack] if this publication holds a video track\n   */ get videoTrack() {\n        if (this.track instanceof LocalVideoTrack || this.track instanceof RemoteVideoTrack) {\n            return this.track;\n        }\n    }\n    /** @internal */ updateInfo(info) {\n        this.trackSid = info.sid;\n        this.trackName = info.name;\n        this.source = Track.sourceFromProto(info.source);\n        this.mimeType = info.mimeType;\n        if (this.kind === Track.Kind.Video && info.width > 0) {\n            this.dimensions = {\n                width: info.width,\n                height: info.height\n            };\n            this.simulcasted = info.simulcast;\n        }\n        this.encryption = info.encryption;\n        this.trackInfo = info;\n        this.log.debug(\"update publication info\", Object.assign(Object.assign({}, this.logContext), {\n            info\n        }));\n    }\n}\n(function(TrackPublication) {\n    (function(SubscriptionStatus) {\n        SubscriptionStatus[\"Desired\"] = \"desired\";\n        SubscriptionStatus[\"Subscribed\"] = \"subscribed\";\n        SubscriptionStatus[\"Unsubscribed\"] = \"unsubscribed\";\n    })(TrackPublication.SubscriptionStatus || (TrackPublication.SubscriptionStatus = {}));\n    (function(PermissionStatus) {\n        PermissionStatus[\"Allowed\"] = \"allowed\";\n        PermissionStatus[\"NotAllowed\"] = \"not_allowed\";\n    })(TrackPublication.PermissionStatus || (TrackPublication.PermissionStatus = {}));\n})(TrackPublication || (TrackPublication = {}));\nclass LocalTrackPublication extends TrackPublication {\n    get isUpstreamPaused() {\n        var _a;\n        return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;\n    }\n    constructor(kind, ti, track, loggerOptions){\n        super(kind, ti.sid, ti.name, loggerOptions);\n        this.track = undefined;\n        this.handleTrackEnded = ()=>{\n            this.emit(TrackEvent.Ended);\n        };\n        this.updateInfo(ti);\n        this.setTrack(track);\n    }\n    setTrack(track) {\n        if (this.track) {\n            this.track.off(TrackEvent.Ended, this.handleTrackEnded);\n        }\n        super.setTrack(track);\n        if (track) {\n            track.on(TrackEvent.Ended, this.handleTrackEnded);\n        }\n    }\n    get isMuted() {\n        if (this.track) {\n            return this.track.isMuted;\n        }\n        return super.isMuted;\n    }\n    get audioTrack() {\n        return super.audioTrack;\n    }\n    get videoTrack() {\n        return super.videoTrack;\n    }\n    /**\n   * Mute the track associated with this publication\n   */ mute() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();\n        });\n    }\n    /**\n   * Unmute track associated with this publication\n   */ unmute() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();\n        });\n    }\n    /**\n   * Pauses the media stream track associated with this publication from being sent to the server\n   * and signals \"muted\" event to other participants\n   * Useful if you want to pause the stream without pausing the local media stream track\n   */ pauseUpstream() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();\n        });\n    }\n    /**\n   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]\n   * and signals \"unmuted\" event to other participants (unless the track is explicitly muted)\n   */ resumeUpstream() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();\n        });\n    }\n}\nvar ConnectionQuality;\n(function(ConnectionQuality) {\n    ConnectionQuality[\"Excellent\"] = \"excellent\";\n    ConnectionQuality[\"Good\"] = \"good\";\n    ConnectionQuality[\"Poor\"] = \"poor\";\n    /**\n   * Indicates that a participant has temporarily (or permanently) lost connection to LiveKit.\n   * For permanent disconnection a `ParticipantDisconnected` event will be emitted after a timeout\n   */ ConnectionQuality[\"Lost\"] = \"lost\";\n    ConnectionQuality[\"Unknown\"] = \"unknown\";\n})(ConnectionQuality || (ConnectionQuality = {}));\nfunction qualityFromProto(q) {\n    switch(q){\n        case ConnectionQuality$1.EXCELLENT:\n            return ConnectionQuality.Excellent;\n        case ConnectionQuality$1.GOOD:\n            return ConnectionQuality.Good;\n        case ConnectionQuality$1.POOR:\n            return ConnectionQuality.Poor;\n        case ConnectionQuality$1.LOST:\n            return ConnectionQuality.Lost;\n        default:\n            return ConnectionQuality.Unknown;\n    }\n}\nclass Participant extends eventsExports.EventEmitter {\n    get logContext() {\n        var _a, _b;\n        return Object.assign(Object.assign({}, (_b = (_a = this.loggerOptions) === null || _a === void 0 ? void 0 : _a.loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a)), {\n            participantSid: this.sid,\n            participantId: this.identity\n        });\n    }\n    get isEncrypted() {\n        return this.tracks.size > 0 && Array.from(this.tracks.values()).every((tr)=>tr.isEncrypted);\n    }\n    get isAgent() {\n        var _a, _b;\n        return (_b = (_a = this.permissions) === null || _a === void 0 ? void 0 : _a.agent) !== null && _b !== void 0 ? _b : false;\n    }\n    /** @internal */ constructor(sid, identity, name, metadata, loggerOptions){\n        var _a;\n        super();\n        /** audio level between 0-1.0, 1 being loudest, 0 being softest */ this.audioLevel = 0;\n        /** if participant is currently speaking */ this.isSpeaking = false;\n        this._connectionQuality = ConnectionQuality.Unknown;\n        this.log = livekitLogger;\n        this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Participant);\n        this.loggerOptions = loggerOptions;\n        this.setMaxListeners(100);\n        this.sid = sid;\n        this.identity = identity;\n        this.name = name;\n        this.metadata = metadata;\n        this.audioTracks = new Map();\n        this.videoTracks = new Map();\n        this.tracks = new Map();\n    }\n    getTracks() {\n        return Array.from(this.tracks.values());\n    }\n    /**\n   * Finds the first track that matches the source filter, for example, getting\n   * the user's camera track with getTrackBySource(Track.Source.Camera).\n   * @param source\n   * @returns\n   */ getTrack(source) {\n        for (const [, pub] of this.tracks){\n            if (pub.source === source) {\n                return pub;\n            }\n        }\n    }\n    /**\n   * Finds the first track that matches the track's name.\n   * @param name\n   * @returns\n   */ getTrackByName(name) {\n        for (const [, pub] of this.tracks){\n            if (pub.trackName === name) {\n                return pub;\n            }\n        }\n    }\n    get connectionQuality() {\n        return this._connectionQuality;\n    }\n    get isCameraEnabled() {\n        var _a;\n        const track = this.getTrack(Track.Source.Camera);\n        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n    }\n    get isMicrophoneEnabled() {\n        var _a;\n        const track = this.getTrack(Track.Source.Microphone);\n        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n    }\n    get isScreenShareEnabled() {\n        const track = this.getTrack(Track.Source.ScreenShare);\n        return !!track;\n    }\n    get isLocal() {\n        return false;\n    }\n    /** when participant joined the room */ get joinedAt() {\n        if (this.participantInfo) {\n            return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1000);\n        }\n        return new Date();\n    }\n    /** @internal */ updateInfo(info) {\n        // it's possible the update could be applied out of order due to await\n        // during reconnect sequences. when that happens, it's possible for server\n        // to have sent more recent version of participant info while JS is waiting\n        // to process the existing payload.\n        // when the participant sid remains the same, and we already have a later version\n        // of the payload, they can be safely skipped\n        if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {\n            return false;\n        }\n        this.identity = info.identity;\n        this.sid = info.sid;\n        this._setName(info.name);\n        this._setMetadata(info.metadata);\n        if (info.permission) {\n            this.setPermissions(info.permission);\n        }\n        // set this last so setMetadata can detect changes\n        this.participantInfo = info;\n        this.log.trace(\"update participant info\", Object.assign(Object.assign({}, this.logContext), {\n            info\n        }));\n        return true;\n    }\n    /**\n   * Updates metadata from server\n   **/ _setMetadata(md) {\n        const changed = this.metadata !== md;\n        const prevMetadata = this.metadata;\n        this.metadata = md;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);\n        }\n    }\n    _setName(name) {\n        const changed = this.name !== name;\n        this.name = name;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantNameChanged, name);\n        }\n    }\n    /** @internal */ setPermissions(permissions) {\n        var _a, _b, _c, _d, _e;\n        const prevPermissions = this.permissions;\n        const changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index)=>{\n            var _a;\n            return value !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublishSources[index]);\n        });\n        this.permissions = permissions;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n        }\n        return changed;\n    }\n    /** @internal */ setIsSpeaking(speaking) {\n        if (speaking === this.isSpeaking) {\n            return;\n        }\n        this.isSpeaking = speaking;\n        if (speaking) {\n            this.lastSpokeAt = new Date();\n        }\n        this.emit(ParticipantEvent.IsSpeakingChanged, speaking);\n    }\n    /** @internal */ setConnectionQuality(q) {\n        const prevQuality = this._connectionQuality;\n        this._connectionQuality = qualityFromProto(q);\n        if (prevQuality !== this._connectionQuality) {\n            this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);\n        }\n    }\n    /**\n   * @internal\n   */ setAudioContext(ctx) {\n        this.audioContext = ctx;\n        this.audioTracks.forEach((track)=>(track.track instanceof RemoteAudioTrack || track.track instanceof LocalAudioTrack) && track.track.setAudioContext(ctx));\n    }\n    addTrackPublication(publication) {\n        // forward publication driven events\n        publication.on(TrackEvent.Muted, ()=>{\n            this.emit(ParticipantEvent.TrackMuted, publication);\n        });\n        publication.on(TrackEvent.Unmuted, ()=>{\n            this.emit(ParticipantEvent.TrackUnmuted, publication);\n        });\n        const pub = publication;\n        if (pub.track) {\n            pub.track.sid = publication.trackSid;\n        }\n        this.tracks.set(publication.trackSid, publication);\n        switch(publication.kind){\n            case Track.Kind.Audio:\n                this.audioTracks.set(publication.trackSid, publication);\n                break;\n            case Track.Kind.Video:\n                this.videoTracks.set(publication.trackSid, publication);\n                break;\n        }\n    }\n}\nfunction trackPermissionToProto(perms) {\n    var _a, _b, _c;\n    if (!perms.participantSid && !perms.participantIdentity) {\n        throw new Error(\"Invalid track permission, must provide at least one of participantIdentity and participantSid\");\n    }\n    return new TrackPermission({\n        participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : \"\",\n        participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : \"\",\n        allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,\n        trackSids: perms.allowedTrackSids || []\n    });\n}\nclass RemoteTrackPublication extends TrackPublication {\n    constructor(kind, ti, autoSubscribe, loggerOptions){\n        super(kind, ti.sid, ti.name, loggerOptions);\n        this.track = undefined;\n        /** @internal */ this.allowed = true;\n        this.disabled = false;\n        this.currentVideoQuality = VideoQuality.HIGH;\n        this.handleEnded = (track)=>{\n            this.setTrack(undefined);\n            this.emit(TrackEvent.Ended, track);\n        };\n        this.handleVisibilityChange = (visible)=>{\n            this.log.debug(\"adaptivestream video visibility \".concat(this.trackSid, \", visible=\").concat(visible), this.logContext);\n            this.disabled = !visible;\n            this.emitTrackUpdate();\n        };\n        this.handleVideoDimensionsChange = (dimensions)=>{\n            this.log.debug(\"adaptivestream video dimensions \".concat(dimensions.width, \"x\").concat(dimensions.height), this.logContext);\n            this.videoDimensions = dimensions;\n            this.emitTrackUpdate();\n        };\n        this.subscribed = autoSubscribe;\n        this.updateInfo(ti);\n    }\n    /**\n   * Subscribe or unsubscribe to this remote track\n   * @param subscribed true to subscribe to a track, false to unsubscribe\n   */ setSubscribed(subscribed) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        this.subscribed = subscribed;\n        // reset allowed status when desired subscription state changes\n        // server will notify client via signal message if it's not allowed\n        if (subscribed) {\n            this.allowed = true;\n        }\n        const sub = new UpdateSubscription({\n            trackSids: [\n                this.trackSid\n            ],\n            subscribe: this.subscribed,\n            participantTracks: [\n                new ParticipantTracks({\n                    // sending an empty participant id since TrackPublication doesn't keep it\n                    // this is filled in by the participant that receives this message\n                    participantSid: \"\",\n                    trackSids: [\n                        this.trackSid\n                    ]\n                })\n            ]\n        });\n        this.emit(TrackEvent.UpdateSubscription, sub);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n        this.emitPermissionUpdateIfChanged(prevPermission);\n    }\n    get subscriptionStatus() {\n        if (this.subscribed === false) {\n            return TrackPublication.SubscriptionStatus.Unsubscribed;\n        }\n        if (!super.isSubscribed) {\n            return TrackPublication.SubscriptionStatus.Desired;\n        }\n        return TrackPublication.SubscriptionStatus.Subscribed;\n    }\n    get permissionStatus() {\n        return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;\n    }\n    /**\n   * Returns true if track is subscribed, and ready for playback\n   */ get isSubscribed() {\n        if (this.subscribed === false) {\n            return false;\n        }\n        return super.isSubscribed;\n    }\n    // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled\n    get isDesired() {\n        return this.subscribed !== false;\n    }\n    get isEnabled() {\n        return !this.disabled;\n    }\n    /**\n   * disable server from sending down data for this track. this is useful when\n   * the participant is off screen, you may disable streaming down their video\n   * to reduce bandwidth requirements\n   * @param enabled\n   */ setEnabled(enabled) {\n        if (!this.isManualOperationAllowed() || this.disabled === !enabled) {\n            return;\n        }\n        this.disabled = !enabled;\n        this.emitTrackUpdate();\n    }\n    /**\n   * for tracks that support simulcasting, adjust subscribed quality\n   *\n   * This indicates the highest quality the client can accept. if network\n   * bandwidth does not allow, server will automatically reduce quality to\n   * optimize for uninterrupted video\n   */ setVideoQuality(quality) {\n        if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {\n            return;\n        }\n        this.currentVideoQuality = quality;\n        this.videoDimensions = undefined;\n        this.emitTrackUpdate();\n    }\n    setVideoDimensions(dimensions) {\n        var _a, _b;\n        if (!this.isManualOperationAllowed()) {\n            return;\n        }\n        if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {\n            return;\n        }\n        if (this.track instanceof RemoteVideoTrack) {\n            this.videoDimensions = dimensions;\n        }\n        this.currentVideoQuality = undefined;\n        this.emitTrackUpdate();\n    }\n    setVideoFPS(fps) {\n        if (!this.isManualOperationAllowed()) {\n            return;\n        }\n        if (!(this.track instanceof RemoteVideoTrack)) {\n            return;\n        }\n        if (this.fps === fps) {\n            return;\n        }\n        this.fps = fps;\n        this.emitTrackUpdate();\n    }\n    get videoQuality() {\n        return this.currentVideoQuality;\n    }\n    /** @internal */ setTrack(track) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        const prevTrack = this.track;\n        if (prevTrack === track) {\n            return;\n        }\n        if (prevTrack) {\n            // unregister listener\n            prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n            prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n            prevTrack.off(TrackEvent.Ended, this.handleEnded);\n            prevTrack.detach();\n            prevTrack.stopMonitor();\n            this.emit(TrackEvent.Unsubscribed, prevTrack);\n        }\n        super.setTrack(track);\n        if (track) {\n            track.sid = this.trackSid;\n            track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n            track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n            track.on(TrackEvent.Ended, this.handleEnded);\n            this.emit(TrackEvent.Subscribed, track);\n        }\n        this.emitPermissionUpdateIfChanged(prevPermission);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n    }\n    /** @internal */ setAllowed(allowed) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        this.allowed = allowed;\n        this.emitPermissionUpdateIfChanged(prevPermission);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n    }\n    /** @internal */ setSubscriptionError(error) {\n        this.emit(TrackEvent.SubscriptionFailed, error);\n    }\n    /** @internal */ updateInfo(info) {\n        super.updateInfo(info);\n        const prevMetadataMuted = this.metadataMuted;\n        this.metadataMuted = info.muted;\n        if (this.track) {\n            this.track.setMuted(info.muted);\n        } else if (prevMetadataMuted !== info.muted) {\n            this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);\n        }\n    }\n    emitSubscriptionUpdateIfChanged(previousStatus) {\n        const currentStatus = this.subscriptionStatus;\n        if (previousStatus === currentStatus) {\n            return;\n        }\n        this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);\n    }\n    emitPermissionUpdateIfChanged(previousPermissionStatus) {\n        const currentPermissionStatus = this.permissionStatus;\n        if (currentPermissionStatus !== previousPermissionStatus) {\n            this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);\n        }\n    }\n    isManualOperationAllowed() {\n        if (this.kind === Track.Kind.Video && this.isAdaptiveStream) {\n            this.log.warn(\"adaptive stream is enabled, cannot change video track settings\", this.logContext);\n            return false;\n        }\n        if (!this.isDesired) {\n            this.log.warn(\"cannot update track settings when not subscribed\", this.logContext);\n            return false;\n        }\n        return true;\n    }\n    get isAdaptiveStream() {\n        return this.track instanceof RemoteVideoTrack && this.track.isAdaptiveStream;\n    }\n    /* @internal */ emitTrackUpdate() {\n        const settings = new UpdateTrackSettings({\n            trackSids: [\n                this.trackSid\n            ],\n            disabled: this.disabled,\n            fps: this.fps\n        });\n        if (this.videoDimensions) {\n            settings.width = Math.ceil(this.videoDimensions.width);\n            settings.height = Math.ceil(this.videoDimensions.height);\n        } else if (this.currentVideoQuality !== undefined) {\n            settings.quality = this.currentVideoQuality;\n        } else {\n            // defaults to high quality\n            settings.quality = VideoQuality.HIGH;\n        }\n        this.emit(TrackEvent.UpdateSettings, settings);\n    }\n}\nclass RemoteParticipant extends Participant {\n    /** @internal */ static fromParticipantInfo(signalClient, pi) {\n        return new RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata);\n    }\n    /** @internal */ constructor(signalClient, sid, identity, name, metadata, loggerOptions){\n        super(sid, identity || \"\", name, metadata, loggerOptions);\n        this.signalClient = signalClient;\n        this.tracks = new Map();\n        this.audioTracks = new Map();\n        this.videoTracks = new Map();\n        this.volumeMap = new Map();\n    }\n    addTrackPublication(publication) {\n        super.addTrackPublication(publication);\n        // register action events\n        publication.on(TrackEvent.UpdateSettings, (settings)=>{\n            this.log.debug(\"send update settings\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n            this.signalClient.sendUpdateTrackSettings(settings);\n        });\n        publication.on(TrackEvent.UpdateSubscription, (sub)=>{\n            sub.participantTracks.forEach((pt)=>{\n                pt.participantSid = this.sid;\n            });\n            this.signalClient.sendUpdateSubscription(sub);\n        });\n        publication.on(TrackEvent.SubscriptionPermissionChanged, (status)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);\n        });\n        publication.on(TrackEvent.SubscriptionStatusChanged, (status)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);\n        });\n        publication.on(TrackEvent.Subscribed, (track)=>{\n            this.emit(ParticipantEvent.TrackSubscribed, track, publication);\n        });\n        publication.on(TrackEvent.Unsubscribed, (previousTrack)=>{\n            this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);\n        });\n        publication.on(TrackEvent.SubscriptionFailed, (error)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);\n        });\n    }\n    getTrack(source) {\n        const track = super.getTrack(source);\n        if (track) {\n            return track;\n        }\n    }\n    getTrackByName(name) {\n        const track = super.getTrackByName(name);\n        if (track) {\n            return track;\n        }\n    }\n    /**\n   * sets the volume on the participant's audio track\n   * by default, this affects the microphone publication\n   * a different source can be passed in as a second argument\n   * if no track exists the volume will be applied when the microphone track is added\n   */ setVolume(volume) {\n        let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Track.Source.Microphone;\n        this.volumeMap.set(source, volume);\n        const audioPublication = this.getTrack(source);\n        if (audioPublication && audioPublication.track) {\n            audioPublication.track.setVolume(volume);\n        }\n    }\n    /**\n   * gets the volume on the participant's microphone track\n   */ getVolume() {\n        let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Track.Source.Microphone;\n        const audioPublication = this.getTrack(source);\n        if (audioPublication && audioPublication.track) {\n            return audioPublication.track.getVolume();\n        }\n        return this.volumeMap.get(source);\n    }\n    /** @internal */ addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {\n        // find the track publication\n        // it's possible for the media track to arrive before participant info\n        let publication = this.getTrackPublication(sid);\n        // it's also possible that the browser didn't honor our original track id\n        // FireFox would use its own local uuid instead of server track id\n        if (!publication) {\n            if (!sid.startsWith(\"TR\")) {\n                // find the first track that matches type\n                this.tracks.forEach((p)=>{\n                    if (!publication && mediaTrack.kind === p.kind.toString()) {\n                        publication = p;\n                    }\n                });\n            }\n        }\n        // when we couldn't locate the track, it's possible that the metadata hasn't\n        // yet arrived. Wait a bit longer for it to arrive, or fire an error\n        if (!publication) {\n            if (triesLeft === 0) {\n                this.log.error(\"could not find published track\", Object.assign(Object.assign({}, this.logContext), {\n                    trackSid: sid\n                }));\n                this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n                return;\n            }\n            if (triesLeft === undefined) triesLeft = 20;\n            setTimeout(()=>{\n                this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);\n            }, 150);\n            return;\n        }\n        if (mediaTrack.readyState === \"ended\") {\n            this.log.error(\"unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n            this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n            return;\n        }\n        const isVideo = mediaTrack.kind === \"video\";\n        let track;\n        if (isVideo) {\n            track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);\n        } else {\n            track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);\n        }\n        // set track info\n        track.source = publication.source;\n        // keep publication's muted status\n        track.isMuted = publication.isMuted;\n        track.setMediaStream(mediaStream);\n        track.start();\n        publication.setTrack(track);\n        // set participant volumes on new audio tracks\n        if (this.volumeMap.has(publication.source) && track instanceof RemoteAudioTrack) {\n            track.setVolume(this.volumeMap.get(publication.source));\n        }\n        return publication;\n    }\n    /** @internal */ get hasMetadata() {\n        return !!this.participantInfo;\n    }\n    getTrackPublication(sid) {\n        return this.tracks.get(sid);\n    }\n    /** @internal */ updateInfo(info) {\n        if (!super.updateInfo(info)) {\n            return false;\n        }\n        // we are getting a list of all available tracks, reconcile in here\n        // and send out events for changes\n        // reconcile track publications, publish events only if metadata is already there\n        // i.e. changes since the local participant has joined\n        const validTracks = new Map();\n        const newTracks = new Map();\n        info.tracks.forEach((ti)=>{\n            var _a, _b;\n            let publication = this.getTrackPublication(ti.sid);\n            if (!publication) {\n                // new publication\n                const kind = Track.kindFromProto(ti.type);\n                if (!kind) {\n                    return;\n                }\n                publication = new RemoteTrackPublication(kind, ti, (_a = this.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe, {\n                    loggerContextCb: ()=>this.logContext,\n                    loggerName: (_b = this.loggerOptions) === null || _b === void 0 ? void 0 : _b.loggerName\n                });\n                publication.updateInfo(ti);\n                newTracks.set(ti.sid, publication);\n                const existingTrackOfSource = Array.from(this.tracks.values()).find((publishedTrack)=>publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));\n                if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {\n                    this.log.debug(\"received a second track publication for \".concat(this.identity, \" with the same source: \").concat(publication.source), Object.assign(Object.assign({}, this.logContext), {\n                        oldTrack: getLogContextFromTrack(existingTrackOfSource),\n                        newTrack: getLogContextFromTrack(publication)\n                    }));\n                }\n                this.addTrackPublication(publication);\n            } else {\n                publication.updateInfo(ti);\n            }\n            validTracks.set(ti.sid, publication);\n        });\n        // detect removed tracks\n        this.tracks.forEach((publication)=>{\n            if (!validTracks.has(publication.trackSid)) {\n                this.log.trace(\"detected removed track on remote participant, unpublishing\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n                this.unpublishTrack(publication.trackSid, true);\n            }\n        });\n        // always emit events for new publications, Room will not forward them unless it's ready\n        newTracks.forEach((publication)=>{\n            this.emit(ParticipantEvent.TrackPublished, publication);\n        });\n        return true;\n    }\n    /** @internal */ unpublishTrack(sid, sendUnpublish) {\n        const publication = this.tracks.get(sid);\n        if (!publication) {\n            return;\n        }\n        // also send unsubscribe, if track is actively subscribed\n        const { track } = publication;\n        if (track) {\n            track.stop();\n            publication.setTrack(undefined);\n        }\n        // remove track from maps only after unsubscribed has been fired\n        this.tracks.delete(sid);\n        // remove from the right type map\n        switch(publication.kind){\n            case Track.Kind.Audio:\n                this.audioTracks.delete(sid);\n                break;\n            case Track.Kind.Video:\n                this.videoTracks.delete(sid);\n                break;\n        }\n        if (sendUnpublish) {\n            this.emit(ParticipantEvent.TrackUnpublished, publication);\n        }\n    }\n    /**\n   * @internal\n   */ setAudioOutput(output) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.audioOutput = output;\n            const promises = [];\n            this.audioTracks.forEach((pub)=>{\n                var _a;\n                if (pub.track instanceof RemoteAudioTrack) {\n                    promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : \"default\"));\n                }\n            });\n            yield Promise.all(promises);\n        });\n    }\n    /** @internal */ emit(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        this.log.trace(\"participant event\", Object.assign(Object.assign({}, this.logContext), {\n            event,\n            args\n        }));\n        return super.emit(event, ...args);\n    }\n}\nclass LocalParticipant extends Participant {\n    /** @internal */ constructor(sid, identity, engine, options){\n        super(sid, identity, undefined, undefined, {\n            loggerName: options.loggerName,\n            loggerContextCb: ()=>this.engine.logContext\n        });\n        this.pendingPublishing = new Set();\n        this.pendingPublishPromises = new Map();\n        this.participantTrackPermissions = [];\n        this.allParticipantsAllowedToSubscribe = true;\n        this.encryptionType = Encryption_Type.NONE;\n        this.handleReconnecting = ()=>{\n            if (!this.reconnectFuture) {\n                this.reconnectFuture = new Future();\n            }\n        };\n        this.handleReconnected = ()=>{\n            var _a, _b;\n            (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\n            this.reconnectFuture = undefined;\n            this.updateTrackSubscriptionPermissions();\n        };\n        this.handleDisconnected = ()=>{\n            var _a, _b;\n            if (this.reconnectFuture) {\n                this.reconnectFuture.promise.catch((e)=>this.log.warn(e.message, this.logContext));\n                (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, \"Got disconnected during reconnection attempt\");\n                this.reconnectFuture = undefined;\n            }\n        };\n        this.updateTrackSubscriptionPermissions = ()=>{\n            this.log.debug(\"updating track subscription permissions\", Object.assign(Object.assign({}, this.logContext), {\n                allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,\n                participantTrackPermissions: this.participantTrackPermissions\n            }));\n            this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p)=>trackPermissionToProto(p)));\n        };\n        /** @internal */ this.onTrackUnmuted = (track)=>{\n            this.onTrackMuted(track, track.isUpstreamPaused);\n        };\n        // when the local track changes in mute status, we'll notify server as such\n        /** @internal */ this.onTrackMuted = (track, muted)=>{\n            if (muted === undefined) {\n                muted = true;\n            }\n            if (!track.sid) {\n                this.log.error(\"could not update mute status for unpublished track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                return;\n            }\n            this.engine.updateMuteStatus(track.sid, muted);\n        };\n        this.onTrackUpstreamPaused = (track)=>{\n            this.log.debug(\"upstream paused\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            this.onTrackMuted(track, true);\n        };\n        this.onTrackUpstreamResumed = (track)=>{\n            this.log.debug(\"upstream resumed\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            this.onTrackMuted(track, track.isMuted);\n        };\n        this.handleSubscribedQualityUpdate = (update)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, e_1, _b, _c;\n                var _d, _e;\n                if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {\n                    return;\n                }\n                const pub = this.videoTracks.get(update.trackSid);\n                if (!pub) {\n                    this.log.warn(\"received subscribed quality update for unknown track\", Object.assign(Object.assign({}, this.logContext), {\n                        trackSid: update.trackSid\n                    }));\n                    return;\n                }\n                if (update.subscribedCodecs.length > 0) {\n                    if (!pub.videoTrack) {\n                        return;\n                    }\n                    const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);\n                    try {\n                        for(var _f = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a = newCodecs_1_1.done, !_a; _f = true){\n                            _c = newCodecs_1_1.value;\n                            _f = false;\n                            const codec = _c;\n                            if (isBackupCodec(codec)) {\n                                this.log.debug(\"publish \".concat(codec, \" for \").concat(pub.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)));\n                                yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);\n                            }\n                        }\n                    } catch (e_1_1) {\n                        e_1 = {\n                            error: e_1_1\n                        };\n                    } finally{\n                        try {\n                            if (!_f && !_a && (_b = newCodecs_1.return)) yield _b.call(newCodecs_1);\n                        } finally{\n                            if (e_1) throw e_1.error;\n                        }\n                    }\n                } else if (update.subscribedQualities.length > 0) {\n                    yield (_e = pub.videoTrack) === null || _e === void 0 ? void 0 : _e.setPublishingLayers(update.subscribedQualities);\n                }\n            });\n        this.handleLocalTrackUnpublished = (unpublished)=>{\n            const track = this.tracks.get(unpublished.trackSid);\n            if (!track) {\n                this.log.warn(\"received unpublished event for unknown track\", Object.assign(Object.assign({}, this.logContext), {\n                    trackSid: unpublished.trackSid\n                }));\n                return;\n            }\n            this.unpublishTrack(track.track);\n        };\n        this.handleTrackEnded = (track)=>__awaiter(this, void 0, void 0, function*() {\n                if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {\n                    this.log.debug(\"unpublishing local track due to TrackEnded\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                    this.unpublishTrack(track);\n                } else if (track.isUserProvided) {\n                    yield track.mute();\n                } else if (track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) {\n                    try {\n                        if (isWeb()) {\n                            try {\n                                const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({\n                                    // the permission query for camera and microphone currently not supported in Safari and Firefox\n                                    // @ts-ignore\n                                    name: track.source === Track.Source.Camera ? \"camera\" : \"microphone\"\n                                });\n                                if (currentPermissions && currentPermissions.state === \"denied\") {\n                                    this.log.warn(\"user has revoked access to \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                                    // detect granted change after permissions were denied to try and resume then\n                                    currentPermissions.onchange = ()=>{\n                                        if (currentPermissions.state !== \"denied\") {\n                                            if (!track.isMuted) {\n                                                track.restartTrack();\n                                            }\n                                            currentPermissions.onchange = null;\n                                        }\n                                    };\n                                    throw new Error(\"GetUserMedia Permission denied\");\n                                }\n                            } catch (e) {\n                            // permissions query fails for firefox, we continue and try to restart the track\n                            }\n                        }\n                        if (!track.isMuted) {\n                            this.log.debug(\"track ended, attempting to use a different device\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                            yield track.restartTrack();\n                        }\n                    } catch (e) {\n                        this.log.warn(\"could not restart track, muting instead\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                        yield track.mute();\n                    }\n                }\n            });\n        this.audioTracks = new Map();\n        this.videoTracks = new Map();\n        this.tracks = new Map();\n        this.engine = engine;\n        this.roomOptions = options;\n        this.setupEngine(engine);\n        this.activeDeviceMap = new Map();\n    }\n    get lastCameraError() {\n        return this.cameraError;\n    }\n    get lastMicrophoneError() {\n        return this.microphoneError;\n    }\n    get isE2EEEnabled() {\n        return this.encryptionType !== Encryption_Type.NONE;\n    }\n    getTrack(source) {\n        const track = super.getTrack(source);\n        if (track) {\n            return track;\n        }\n    }\n    getTrackByName(name) {\n        const track = super.getTrackByName(name);\n        if (track) {\n            return track;\n        }\n    }\n    /**\n   * @internal\n   */ setupEngine(engine) {\n        this.engine = engine;\n        this.engine.on(EngineEvent.RemoteMute, (trackSid, muted)=>{\n            const pub = this.tracks.get(trackSid);\n            if (!pub || !pub.track) {\n                return;\n            }\n            if (muted) {\n                pub.mute();\n            } else {\n                pub.unmute();\n            }\n        });\n        this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected);\n    }\n    /**\n   * Sets and updates the metadata of the local participant.\n   * The change does not take immediate effect.\n   * If successful, a `ParticipantEvent.MetadataChanged` event will be emitted on the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * @param metadata\n   */ setMetadata(metadata) {\n        var _a;\n        this.engine.client.sendUpdateLocalMetadata(metadata, (_a = this.name) !== null && _a !== void 0 ? _a : \"\");\n    }\n    /**\n   * Sets and updates the name of the local participant.\n   * The change does not take immediate effect.\n   * If successful, a `ParticipantEvent.ParticipantNameChanged` event will be emitted on the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * @param metadata\n   */ setName(name) {\n        var _a;\n        this.engine.client.sendUpdateLocalMetadata((_a = this.metadata) !== null && _a !== void 0 ? _a : \"\", name);\n    }\n    /**\n   * Enable or disable a participant's camera track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setCameraEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);\n    }\n    /**\n   * Enable or disable a participant's microphone track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setMicrophoneEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);\n    }\n    /**\n   * Start or stop sharing a participant's screen\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setScreenShareEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);\n    }\n    /** @internal */ setPermissions(permissions) {\n        const prevPermissions = this.permissions;\n        const changed = super.setPermissions(permissions);\n        if (changed && prevPermissions) {\n            this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n        }\n        return changed;\n    }\n    /** @internal */ setE2EEEnabled(enabled) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;\n            yield this.republishAllTracks(undefined, false);\n        });\n    }\n    setTrackEnabled(source, enabled, options, publishOptions) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug(\"setTrackEnabled\", Object.assign(Object.assign({}, this.logContext), {\n                source,\n                enabled\n            }));\n            let track = this.getTrack(source);\n            if (enabled) {\n                if (track) {\n                    yield track.unmute();\n                } else {\n                    let localTracks;\n                    if (this.pendingPublishing.has(source)) {\n                        this.log.info(\"skipping duplicate published source\", Object.assign(Object.assign({}, this.logContext), {\n                            source\n                        }));\n                        // no-op it's already been requested\n                        return;\n                    }\n                    this.pendingPublishing.add(source);\n                    try {\n                        switch(source){\n                            case Track.Source.Camera:\n                                localTracks = yield this.createTracks({\n                                    video: (_a = options) !== null && _a !== void 0 ? _a : true\n                                });\n                                break;\n                            case Track.Source.Microphone:\n                                localTracks = yield this.createTracks({\n                                    audio: (_b = options) !== null && _b !== void 0 ? _b : true\n                                });\n                                break;\n                            case Track.Source.ScreenShare:\n                                localTracks = yield this.createScreenTracks(Object.assign({}, options));\n                                break;\n                            default:\n                                throw new TrackInvalidError(source);\n                        }\n                        const publishPromises = [];\n                        for (const localTrack of localTracks){\n                            this.log.info(\"publishing track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(localTrack)));\n                            publishPromises.push(this.publishTrack(localTrack, publishOptions));\n                        }\n                        const publishedTracks = yield Promise.all(publishPromises);\n                        // for screen share publications including audio, this will only return the screen share publication, not the screen share audio one\n                        // revisit if we want to return an array of tracks instead for v2\n                        [track] = publishedTracks;\n                    } catch (e) {\n                        localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr)=>{\n                            tr.stop();\n                        });\n                        if (e instanceof Error && !(e instanceof TrackInvalidError)) {\n                            this.emit(ParticipantEvent.MediaDevicesError, e);\n                        }\n                        throw e;\n                    } finally{\n                        this.pendingPublishing.delete(source);\n                    }\n                }\n            } else if (track && track.track) {\n                // screenshare cannot be muted, unpublish instead\n                if (source === Track.Source.ScreenShare) {\n                    track = yield this.unpublishTrack(track.track);\n                    const screenAudioTrack = this.getTrack(Track.Source.ScreenShareAudio);\n                    if (screenAudioTrack && screenAudioTrack.track) {\n                        this.unpublishTrack(screenAudioTrack.track);\n                    }\n                } else {\n                    yield track.mute();\n                }\n            }\n            return track;\n        });\n    }\n    /**\n   * Publish both camera and microphone at the same time. This is useful for\n   * displaying a single Permission Dialog box to the end user.\n   */ enableCameraAndMicrophone() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {\n                // no-op it's already been requested\n                return;\n            }\n            this.pendingPublishing.add(Track.Source.Camera);\n            this.pendingPublishing.add(Track.Source.Microphone);\n            try {\n                const tracks = yield this.createTracks({\n                    audio: true,\n                    video: true\n                });\n                yield Promise.all(tracks.map((track)=>this.publishTrack(track)));\n            } finally{\n                this.pendingPublishing.delete(Track.Source.Camera);\n                this.pendingPublishing.delete(Track.Source.Microphone);\n            }\n        });\n    }\n    /**\n   * Create local camera and/or microphone tracks\n   * @param options\n   * @returns\n   */ createTracks(options) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const opts = mergeDefaultOptions(options, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);\n            const constraints = constraintsForOptions(opts);\n            let stream;\n            try {\n                stream = yield navigator.mediaDevices.getUserMedia(constraints);\n            } catch (err) {\n                if (err instanceof Error) {\n                    if (constraints.audio) {\n                        this.microphoneError = err;\n                    }\n                    if (constraints.video) {\n                        this.cameraError = err;\n                    }\n                }\n                throw err;\n            }\n            if (constraints.audio) {\n                this.microphoneError = undefined;\n                this.emit(ParticipantEvent.AudioStreamAcquired);\n            }\n            if (constraints.video) {\n                this.cameraError = undefined;\n            }\n            return stream.getTracks().map((mediaStreamTrack)=>{\n                const isAudio = mediaStreamTrack.kind === \"audio\";\n                isAudio ? options.audio : options.video;\n                let trackConstraints;\n                const conOrBool = isAudio ? constraints.audio : constraints.video;\n                if (typeof conOrBool !== \"boolean\") {\n                    trackConstraints = conOrBool;\n                }\n                const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints, {\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                if (track.kind === Track.Kind.Video) {\n                    track.source = Track.Source.Camera;\n                } else if (track.kind === Track.Kind.Audio) {\n                    track.source = Track.Source.Microphone;\n                }\n                track.mediaStream = stream;\n                return track;\n            });\n        });\n    }\n    /**\n   * Creates a screen capture tracks with getDisplayMedia().\n   * A LocalVideoTrack is always created and returned.\n   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n   */ createScreenTracks(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (options === undefined) {\n                options = {};\n            }\n            if (navigator.mediaDevices.getDisplayMedia === undefined) {\n                throw new DeviceUnsupportedError(\"getDisplayMedia not supported\");\n            }\n            if (options.resolution === undefined && !isSafari17()) {\n                // we need to constrain the dimensions, otherwise it could lead to low bitrate\n                // due to encoding a huge video. Encoding such large surfaces is really expensive\n                // unfortunately Safari 17 has a but and cannot be constrained by default\n                options.resolution = ScreenSharePresets.h1080fps30.resolution;\n            }\n            const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n            const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n            const tracks = stream.getVideoTracks();\n            if (tracks.length === 0) {\n                throw new TrackInvalidError(\"no video track found\");\n            }\n            const screenVideo = new LocalVideoTrack(tracks[0], undefined, false, {\n                loggerName: this.roomOptions.loggerName,\n                loggerContextCb: ()=>this.logContext\n            });\n            screenVideo.source = Track.Source.ScreenShare;\n            if (options.contentHint) {\n                screenVideo.mediaStreamTrack.contentHint = options.contentHint;\n            }\n            const localTracks = [\n                screenVideo\n            ];\n            if (stream.getAudioTracks().length > 0) {\n                this.emit(ParticipantEvent.AudioStreamAcquired);\n                const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false, this.audioContext, {\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                screenAudio.source = Track.Source.ScreenShareAudio;\n                localTracks.push(screenAudio);\n            }\n            return localTracks;\n        });\n    }\n    /**\n   * Publish a new track to the room\n   * @param track\n   * @param options\n   */ publishTrack(track, options) {\n        var _a, _b, _c, _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;\n            if (track instanceof LocalTrack && this.pendingPublishPromises.has(track)) {\n                yield this.pendingPublishPromises.get(track);\n            }\n            let defaultConstraints;\n            if (track instanceof MediaStreamTrack) {\n                defaultConstraints = track.getConstraints();\n            } else {\n                // we want to access constraints directly as `track.mediaStreamTrack`\n                // might be pointing to a non-device track (e.g. processed track) already\n                defaultConstraints = track.constraints;\n                let deviceKind = undefined;\n                switch(track.source){\n                    case Track.Source.Microphone:\n                        deviceKind = \"audioinput\";\n                        break;\n                    case Track.Source.Camera:\n                        deviceKind = \"videoinput\";\n                }\n                if (deviceKind && this.activeDeviceMap.has(deviceKind)) {\n                    defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {\n                        deviceId: this.activeDeviceMap.get(deviceKind)\n                    });\n                }\n            }\n            // convert raw media track into audio or video track\n            if (track instanceof MediaStreamTrack) {\n                switch(track.kind){\n                    case \"audio\":\n                        track = new LocalAudioTrack(track, defaultConstraints, true, this.audioContext, {\n                            loggerName: this.roomOptions.loggerName,\n                            loggerContextCb: ()=>this.logContext\n                        });\n                        break;\n                    case \"video\":\n                        track = new LocalVideoTrack(track, defaultConstraints, true, {\n                            loggerName: this.roomOptions.loggerName,\n                            loggerContextCb: ()=>this.logContext\n                        });\n                        break;\n                    default:\n                        throw new TrackInvalidError(\"unsupported MediaStreamTrack kind \".concat(track.kind));\n                }\n            } else {\n                track.updateLoggerOptions({\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n            }\n            if (track instanceof LocalAudioTrack) {\n                track.setAudioContext(this.audioContext);\n            }\n            // is it already published? if so skip\n            let existingPublication;\n            this.tracks.forEach((publication)=>{\n                if (!publication.track) {\n                    return;\n                }\n                if (publication.track === track) {\n                    existingPublication = publication;\n                }\n            });\n            if (existingPublication) {\n                this.log.warn(\"track has already been published, skipping\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(existingPublication)));\n                return existingPublication;\n            }\n            const isStereoInput = \"channelCount\" in track.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount\n            track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;\n            const isStereo = (_b = options === null || options === void 0 ? void 0 : options.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;\n            // disable dtx for stereo track if not enabled explicitly\n            if (isStereo) {\n                if (!options) {\n                    options = {};\n                }\n                if (options.dtx === undefined) {\n                    this.log.info(\"Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                }\n                if (options.red === undefined) {\n                    this.log.info(\"Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.\");\n                }\n                (_c = options.dtx) !== null && _c !== void 0 ? _c : options.dtx = false;\n                (_d = options.red) !== null && _d !== void 0 ? _d : options.red = false;\n            }\n            const opts = Object.assign(Object.assign({}, this.roomOptions.publishDefaults), options);\n            // disable simulcast if e2ee is set on safari\n            if (isSafari() && this.roomOptions.e2ee) {\n                this.log.info(\"End-to-end encryption is set up, simulcast publishing will be disabled on Safari\", Object.assign({}, this.logContext));\n                opts.simulcast = false;\n            }\n            if (opts.source) {\n                track.source = opts.source;\n            }\n            const publishPromise = this.publish(track, opts, isStereo);\n            this.pendingPublishPromises.set(track, publishPromise);\n            try {\n                const publication = yield publishPromise;\n                return publication;\n            } catch (e) {\n                throw e;\n            } finally{\n                this.pendingPublishPromises.delete(track);\n            }\n        });\n    }\n    publish(track, opts, isStereo) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existingTrackOfSource = Array.from(this.tracks.values()).find((publishedTrack)=>track instanceof LocalTrack && publishedTrack.source === track.source);\n            if (existingTrackOfSource && track.source !== Track.Source.Unknown) {\n                this.log.info(\"publishing a second track with the same source: \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            }\n            if (opts.stopMicTrackOnMute && track instanceof LocalAudioTrack) {\n                track.stopOnMute = true;\n            }\n            if (track.source === Track.Source.ScreenShare && isFireFox()) {\n                // Firefox does not work well with simulcasted screen share\n                // we frequently get no data on layer 0 when enabled\n                opts.simulcast = false;\n            }\n            // require full AV1/VP9 SVC support prior to using it\n            if (opts.videoCodec === \"av1\" && !supportsAV1()) {\n                opts.videoCodec = undefined;\n            }\n            if (opts.videoCodec === \"vp9\" && !supportsVP9()) {\n                opts.videoCodec = undefined;\n            }\n            if (opts.videoCodec === undefined) {\n                opts.videoCodec = defaultVideoCodec;\n            }\n            const videoCodec = opts.videoCodec;\n            // handle track actions\n            track.on(TrackEvent.Muted, this.onTrackMuted);\n            track.on(TrackEvent.Unmuted, this.onTrackUnmuted);\n            track.on(TrackEvent.Ended, this.handleTrackEnded);\n            track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n            track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n            // create track publication from track\n            const req = new AddTrackRequest({\n                // get local track id for use during publishing\n                cid: track.mediaStreamTrack.id,\n                name: opts.name,\n                type: Track.kindToProto(track.kind),\n                muted: track.isMuted,\n                source: Track.sourceToProto(track.source),\n                disableDtx: !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true),\n                encryption: this.encryptionType,\n                stereo: isStereo,\n                disableRed: this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),\n                stream: opts === null || opts === void 0 ? void 0 : opts.stream\n            });\n            // compute encodings and layers for video\n            let encodings;\n            if (track.kind === Track.Kind.Video) {\n                let dims = {\n                    width: 0,\n                    height: 0\n                };\n                try {\n                    dims = yield track.waitForDimensions();\n                } catch (e) {\n                    // use defaults, it's quite painful for congestion control without simulcast\n                    // so using default dims according to publish settings\n                    const defaultRes = (_d = (_c = this.roomOptions.videoCaptureDefaults) === null || _c === void 0 ? void 0 : _c.resolution) !== null && _d !== void 0 ? _d : VideoPresets.h720.resolution;\n                    dims = {\n                        width: defaultRes.width,\n                        height: defaultRes.height\n                    };\n                    // log failure\n                    this.log.error(\"could not determine track dimensions, using defaults\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n                        dims\n                    }));\n                }\n                // width and height should be defined for video\n                req.width = dims.width;\n                req.height = dims.height;\n                // for svc codecs, disable simulcast and use vp8 for backup codec\n                if (track instanceof LocalVideoTrack) {\n                    if (isSVCCodec(videoCodec)) {\n                        // vp9 svc with screenshare has problem to encode, always use L1T3 here\n                        if (track.source === Track.Source.ScreenShare && videoCodec === \"vp9\") {\n                            opts.scalabilityMode = \"L1T3\";\n                        }\n                        // set scalabilityMode to 'L3T3_KEY' by default\n                        opts.scalabilityMode = (_e = opts.scalabilityMode) !== null && _e !== void 0 ? _e : \"L3T3_KEY\";\n                    }\n                    req.simulcastCodecs = [\n                        new SimulcastCodec({\n                            codec: videoCodec,\n                            cid: track.mediaStreamTrack.id\n                        })\n                    ];\n                    // set up backup\n                    if (opts.backupCodec === true) {\n                        opts.backupCodec = {\n                            codec: defaultVideoCodec\n                        };\n                    }\n                    if (opts.backupCodec && videoCodec !== opts.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs\n                    req.encryption === Encryption_Type.NONE) {\n                        // multi-codec simulcast requires dynacast\n                        if (!this.roomOptions.dynacast) {\n                            this.roomOptions.dynacast = true;\n                        }\n                        req.simulcastCodecs.push(new SimulcastCodec({\n                            codec: opts.backupCodec.codec,\n                            cid: \"\"\n                        }));\n                    }\n                }\n                encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n                req.layers = videoLayersFromEncodings(req.width, req.height, encodings, isSVCCodec(opts.videoCodec));\n            } else if (track.kind === Track.Kind.Audio) {\n                encodings = [\n                    {\n                        maxBitrate: (_g = (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate) !== null && _g !== void 0 ? _g : opts.audioBitrate,\n                        priority: (_j = (_h = opts.audioPreset) === null || _h === void 0 ? void 0 : _h.priority) !== null && _j !== void 0 ? _j : \"high\",\n                        networkPriority: (_l = (_k = opts.audioPreset) === null || _k === void 0 ? void 0 : _k.priority) !== null && _l !== void 0 ? _l : \"high\"\n                    }\n                ];\n            }\n            if (!this.engine || this.engine.isClosed) {\n                throw new UnexpectedConnectionState(\"cannot publish track when not connected\");\n            }\n            const ti = yield this.engine.addTrack(req);\n            // server might not support the codec the client has requested, in that case, fallback\n            // to a supported codec\n            let primaryCodecMime;\n            ti.codecs.forEach((codec)=>{\n                if (primaryCodecMime === undefined) {\n                    primaryCodecMime = codec.mimeType;\n                }\n            });\n            if (primaryCodecMime && track.kind === Track.Kind.Video) {\n                const updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);\n                if (updatedCodec !== videoCodec) {\n                    this.log.debug(\"falling back to server selected codec\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n                        codec: updatedCodec\n                    }));\n                    /* @ts-ignore */ opts.videoCodec = updatedCodec;\n                    // recompute encodings since bitrates/etc could have changed\n                    encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n                }\n            }\n            const publication = new LocalTrackPublication(track.kind, ti, track, {\n                loggerName: this.roomOptions.loggerName,\n                loggerContextCb: ()=>this.logContext\n            });\n            // save options for when it needs to be republished again\n            publication.options = opts;\n            track.sid = ti.sid;\n            if (!this.engine.pcManager) {\n                throw new UnexpectedConnectionState(\"pcManager is not ready\");\n            }\n            this.log.debug(\"publishing \".concat(track.kind, \" with encodings\"), Object.assign(Object.assign({}, this.logContext), {\n                encodings,\n                trackInfo: ti\n            }));\n            track.sender = yield this.engine.createSender(track, opts, encodings);\n            if (encodings) {\n                if (isFireFox() && track.kind === Track.Kind.Audio) {\n                    /* Refer to RFC https://datatracker.ietf.org/doc/html/rfc7587#section-6.1,\n             livekit-server uses maxaveragebitrate=510000 in the answer sdp to permit client to\n             publish high quality audio track. But firefox always uses this value as the actual\n             bitrates, causing the audio bitrates to rise to 510Kbps in any stereo case unexpectedly.\n             So the client need to modify maxaverragebitrates in answer sdp to user provided value to\n             fix the issue.\n           */ let trackTransceiver = undefined;\n                    for (const transceiver of this.engine.pcManager.publisher.getTransceivers()){\n                        if (transceiver.sender === track.sender) {\n                            trackTransceiver = transceiver;\n                            break;\n                        }\n                    }\n                    if (trackTransceiver) {\n                        this.engine.pcManager.publisher.setTrackCodecBitrate({\n                            transceiver: trackTransceiver,\n                            codec: \"opus\",\n                            maxbr: ((_m = encodings[0]) === null || _m === void 0 ? void 0 : _m.maxBitrate) ? encodings[0].maxBitrate / 1000 : 0\n                        });\n                    }\n                } else if (track.codec && isSVCCodec(track.codec) && ((_o = encodings[0]) === null || _o === void 0 ? void 0 : _o.maxBitrate)) {\n                    this.engine.pcManager.publisher.setTrackCodecBitrate({\n                        cid: req.cid,\n                        codec: track.codec,\n                        maxbr: encodings[0].maxBitrate / 1000\n                    });\n                }\n            }\n            yield this.engine.negotiate();\n            if (track instanceof LocalVideoTrack) {\n                track.startMonitor(this.engine.client);\n            } else if (track instanceof LocalAudioTrack) {\n                track.startMonitor();\n            }\n            this.addTrackPublication(publication);\n            // send event for publication\n            this.emit(ParticipantEvent.LocalTrackPublished, publication);\n            return publication;\n        });\n    }\n    get isLocal() {\n        return true;\n    }\n    /** @internal\n   * publish additional codec to existing track\n   */ publishAdditionalCodecForTrack(track, videoCodec, options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            // TODO remove once e2ee is supported for backup tracks\n            if (this.encryptionType !== Encryption_Type.NONE) {\n                return;\n            }\n            // is it not published? if so skip\n            let existingPublication;\n            this.tracks.forEach((publication)=>{\n                if (!publication.track) {\n                    return;\n                }\n                if (publication.track === track) {\n                    existingPublication = publication;\n                }\n            });\n            if (!existingPublication) {\n                throw new TrackInvalidError(\"track is not published\");\n            }\n            if (!(track instanceof LocalVideoTrack)) {\n                throw new TrackInvalidError(\"track is not a video track\");\n            }\n            const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);\n            const encodings = computeTrackBackupEncodings(track, videoCodec, opts);\n            if (!encodings) {\n                this.log.info(\"backup codec has been disabled, ignoring request to add additional codec for track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                return;\n            }\n            const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);\n            const req = new AddTrackRequest({\n                cid: simulcastTrack.mediaStreamTrack.id,\n                type: Track.kindToProto(track.kind),\n                muted: track.isMuted,\n                source: Track.sourceToProto(track.source),\n                sid: track.sid,\n                simulcastCodecs: [\n                    {\n                        codec: opts.videoCodec,\n                        cid: simulcastTrack.mediaStreamTrack.id\n                    }\n                ]\n            });\n            req.layers = videoLayersFromEncodings(req.width, req.height, encodings);\n            if (!this.engine || this.engine.isClosed) {\n                throw new UnexpectedConnectionState(\"cannot publish track when not connected\");\n            }\n            const ti = yield this.engine.addTrack(req);\n            yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);\n            yield this.engine.negotiate();\n            this.log.debug(\"published \".concat(videoCodec, \" for track \").concat(track.sid), Object.assign(Object.assign({}, this.logContext), {\n                encodings,\n                trackInfo: ti\n            }));\n        });\n    }\n    unpublishTrack(track, stopOnUnpublish) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            // look through all published tracks to find the right ones\n            const publication = this.getPublicationForTrack(track);\n            const pubLogContext = publication ? getLogContextFromTrack(publication) : undefined;\n            this.log.debug(\"unpublishing track\", Object.assign(Object.assign({}, this.logContext), pubLogContext));\n            if (!publication || !publication.track) {\n                this.log.warn(\"track was not unpublished because no publication was found\", Object.assign(Object.assign({}, this.logContext), pubLogContext));\n                return undefined;\n            }\n            track = publication.track;\n            track.off(TrackEvent.Muted, this.onTrackMuted);\n            track.off(TrackEvent.Unmuted, this.onTrackUnmuted);\n            track.off(TrackEvent.Ended, this.handleTrackEnded);\n            track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n            track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n            if (stopOnUnpublish === undefined) {\n                stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;\n            }\n            if (stopOnUnpublish) {\n                track.stop();\n            }\n            let negotiationNeeded = false;\n            const trackSender = track.sender;\n            track.sender = undefined;\n            if (this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && trackSender) {\n                try {\n                    for (const transceiver of this.engine.pcManager.publisher.getTransceivers()){\n                        // if sender is not currently sending (after replaceTrack(null))\n                        // removeTrack would have no effect.\n                        // to ensure we end up successfully removing the track, manually set\n                        // the transceiver to inactive\n                        if (transceiver.sender === trackSender) {\n                            transceiver.direction = \"inactive\";\n                            negotiationNeeded = true;\n                        }\n                    }\n                    if (this.engine.removeTrack(trackSender)) {\n                        negotiationNeeded = true;\n                    }\n                    if (track instanceof LocalVideoTrack) {\n                        for (const [, trackInfo] of track.simulcastCodecs){\n                            if (trackInfo.sender) {\n                                if (this.engine.removeTrack(trackInfo.sender)) {\n                                    negotiationNeeded = true;\n                                }\n                                trackInfo.sender = undefined;\n                            }\n                        }\n                        track.simulcastCodecs.clear();\n                    }\n                } catch (e) {\n                    this.log.warn(\"failed to unpublish track\", Object.assign(Object.assign(Object.assign({}, this.logContext), pubLogContext), {\n                        error: e\n                    }));\n                }\n            }\n            // remove from our maps\n            this.tracks.delete(publication.trackSid);\n            switch(publication.kind){\n                case Track.Kind.Audio:\n                    this.audioTracks.delete(publication.trackSid);\n                    break;\n                case Track.Kind.Video:\n                    this.videoTracks.delete(publication.trackSid);\n                    break;\n            }\n            this.emit(ParticipantEvent.LocalTrackUnpublished, publication);\n            publication.setTrack(undefined);\n            if (negotiationNeeded) {\n                yield this.engine.negotiate();\n            }\n            return publication;\n        });\n    }\n    unpublishTracks(tracks) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const results = yield Promise.all(tracks.map((track)=>this.unpublishTrack(track)));\n            return results.filter((track)=>track instanceof LocalTrackPublication);\n        });\n    }\n    republishAllTracks(options) {\n        let restartTracks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return __awaiter(this, void 0, void 0, function*() {\n            const localPubs = [];\n            this.tracks.forEach((pub)=>{\n                if (pub.track) {\n                    if (options) {\n                        pub.options = Object.assign(Object.assign({}, pub.options), options);\n                    }\n                    localPubs.push(pub);\n                }\n            });\n            yield Promise.all(localPubs.map((pub)=>__awaiter(this, void 0, void 0, function*() {\n                    const track = pub.track;\n                    yield this.unpublishTrack(track, false);\n                    if (restartTracks && !track.isMuted && track.source !== Track.Source.ScreenShare && track.source !== Track.Source.ScreenShareAudio && (track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) && !track.isUserProvided) {\n                        // generally we need to restart the track before publishing, often a full reconnect\n                        // is necessary because computer had gone to sleep.\n                        this.log.debug(\"restarting existing track\", Object.assign(Object.assign({}, this.logContext), {\n                            track: pub.trackSid\n                        }));\n                        yield track.restartTrack();\n                    }\n                    yield this.publishTrack(track, pub.options);\n                })));\n        });\n    }\n    publishData(data, kind) {\n        let publishOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return __awaiter(this, void 0, void 0, function*() {\n            const destination = Array.isArray(publishOptions) ? publishOptions : publishOptions === null || publishOptions === void 0 ? void 0 : publishOptions.destination;\n            const destinationSids = [];\n            const topic = !Array.isArray(publishOptions) ? publishOptions.topic : undefined;\n            if (destination !== undefined) {\n                destination.forEach((val)=>{\n                    if (val instanceof RemoteParticipant) {\n                        destinationSids.push(val.sid);\n                    } else {\n                        destinationSids.push(val);\n                    }\n                });\n            }\n            const packet = new DataPacket({\n                kind,\n                value: {\n                    case: \"user\",\n                    value: new UserPacket({\n                        participantSid: this.sid,\n                        payload: data,\n                        destinationSids: destinationSids,\n                        topic\n                    })\n                }\n            });\n            yield this.engine.sendDataPacket(packet, kind);\n        });\n    }\n    /**\n   * Control who can subscribe to LocalParticipant's published tracks.\n   *\n   * By default, all participants can subscribe. This allows fine-grained control over\n   * who is able to subscribe at a participant and track level.\n   *\n   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and\n   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks\n   * will not grant permissions to any participants and will require a subsequent\n   * permissions update to allow subscription.\n   *\n   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.\n   *  Takes precedence over [[participantTrackPermissions]] if set to true.\n   *  By default this is set to true.\n   * @param participantTrackPermissions Full list of individual permissions per\n   *  participant/track. Any omitted participants will not receive any permissions.\n   */ setTrackSubscriptionPermissions(allParticipantsAllowed) {\n        let participantTrackPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        this.participantTrackPermissions = participantTrackPermissions;\n        this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;\n        if (!this.engine.client.isDisconnected) {\n            this.updateTrackSubscriptionPermissions();\n        }\n    }\n    /** @internal */ updateInfo(info) {\n        if (info.sid !== this.sid) {\n            // drop updates that specify a wrong sid.\n            // the sid for local participant is only explicitly set on join and full reconnect\n            return false;\n        }\n        if (!super.updateInfo(info)) {\n            return false;\n        }\n        // reconcile track mute status.\n        // if server's track mute status doesn't match actual, we'll have to update\n        // the server's copy\n        info.tracks.forEach((ti)=>{\n            var _a, _b;\n            const pub = this.tracks.get(ti.sid);\n            if (pub) {\n                const mutedOnServer = pub.isMuted || ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);\n                if (mutedOnServer !== ti.muted) {\n                    this.log.debug(\"updating server mute state after reconcile\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)), {\n                        mutedOnServer\n                    }));\n                    this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);\n                }\n            }\n        });\n        return true;\n    }\n    getPublicationForTrack(track) {\n        let publication;\n        this.tracks.forEach((pub)=>{\n            const localTrack = pub.track;\n            if (!localTrack) {\n                return;\n            }\n            // this looks overly complicated due to this object tree\n            if (track instanceof MediaStreamTrack) {\n                if (localTrack instanceof LocalAudioTrack || localTrack instanceof LocalVideoTrack) {\n                    if (localTrack.mediaStreamTrack === track) {\n                        publication = pub;\n                    }\n                }\n            } else if (track === localTrack) {\n                publication = pub;\n            }\n        });\n        return publication;\n    }\n}\nvar ConnectionState;\n(function(ConnectionState) {\n    ConnectionState[\"Disconnected\"] = \"disconnected\";\n    ConnectionState[\"Connecting\"] = \"connecting\";\n    ConnectionState[\"Connected\"] = \"connected\";\n    ConnectionState[\"Reconnecting\"] = \"reconnecting\";\n})(ConnectionState || (ConnectionState = {}));\nconst connectionReconcileFrequency = 2 * 1000;\n/** @deprecated RoomState has been renamed to [[ConnectionState]] */ const RoomState = ConnectionState;\n/**\n * In LiveKit, a room is the logical grouping for a list of participants.\n * Participants in a room can publish tracks, and subscribe to others' tracks.\n *\n * a Room fires [[RoomEvent | RoomEvents]].\n *\n * @noInheritDoc\n */ class Room extends eventsExports.EventEmitter {\n    /**\n   * Creates a new Room, the primary construct for a LiveKit session.\n   * @param options\n   */ constructor(options){\n        var _this;\n        var _a, _b;\n        super();\n        _this = this;\n        this.state = ConnectionState.Disconnected;\n        /**\n     * list of participants that are actively speaking. when this changes\n     * a [[RoomEvent.ActiveSpeakersChanged]] event is fired\n     */ this.activeSpeakers = [];\n        /** reflects the sender encryption status of the local participant */ this.isE2EEEnabled = false;\n        this.audioEnabled = true;\n        this.isVideoPlaybackBlocked = false;\n        this.log = livekitLogger;\n        this.connect = (url, token, opts)=>__awaiter(this, void 0, void 0, function*() {\n                var _c;\n                // In case a disconnect called happened right before the connect call, make sure the disconnect is completed first by awaiting its lock\n                const unlockDisconnect = yield this.disconnectLock.lock();\n                if (this.state === ConnectionState.Connected) {\n                    // when the state is reconnecting or connected, this function returns immediately\n                    this.log.info(\"already connected to room \".concat(this.name), this.logContext);\n                    unlockDisconnect();\n                    return Promise.resolve();\n                }\n                if (this.connectFuture) {\n                    unlockDisconnect();\n                    return this.connectFuture.promise;\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connecting);\n                if (((_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.getServerUrl().toString()) !== url) {\n                    this.regionUrl = undefined;\n                    this.regionUrlProvider = undefined;\n                }\n                if (isCloud(new URL(url))) {\n                    if (this.regionUrlProvider === undefined) {\n                        this.regionUrlProvider = new RegionUrlProvider(url, token);\n                    } else {\n                        this.regionUrlProvider.updateToken(token);\n                    }\n                    // trigger the first fetch without waiting for a response\n                    // if initial connection fails, this will speed up picking regional url\n                    // on subsequent runs\n                    this.regionUrlProvider.fetchRegionSettings().catch((e)=>{\n                        this.log.warn(\"could not fetch region settings\", Object.assign(Object.assign({}, this.logContext), {\n                            error: e\n                        }));\n                    });\n                }\n                const connectFn = (resolve, reject, regionUrl)=>__awaiter(this, void 0, void 0, function*() {\n                        var _d;\n                        if (this.abortController) {\n                            this.abortController.abort();\n                        }\n                        // explicit creation as local var needed to satisfy TS compiler when passing it to `attemptConnection` further down\n                        const abortController = new AbortController();\n                        this.abortController = abortController;\n                        // at this point the intention to connect has been signalled so we can allow cancelling of the connection via disconnect() again\n                        unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();\n                        try {\n                            yield this.attemptConnection(regionUrl !== null && regionUrl !== void 0 ? regionUrl : url, token, opts, abortController);\n                            this.abortController = undefined;\n                            resolve();\n                        } catch (e) {\n                            if (this.regionUrlProvider && e instanceof ConnectionError && e.reason !== 3 /* ConnectionErrorReason.Cancelled */  && e.reason !== 0 /* ConnectionErrorReason.NotAllowed */ ) {\n                                let nextUrl = null;\n                                try {\n                                    nextUrl = yield this.regionUrlProvider.getNextBestRegionUrl((_d = this.abortController) === null || _d === void 0 ? void 0 : _d.signal);\n                                } catch (error) {\n                                    if (error instanceof ConnectionError && (error.status === 401 || error.reason === 3 /* ConnectionErrorReason.Cancelled */ )) {\n                                        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                        reject(error);\n                                        return;\n                                    }\n                                }\n                                if (nextUrl) {\n                                    this.log.info(\"Initial connection failed with ConnectionError: \".concat(e.message, \". Retrying with another region: \").concat(nextUrl), this.logContext);\n                                    yield connectFn(resolve, reject, nextUrl);\n                                } else {\n                                    this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                    reject(e);\n                                }\n                            } else {\n                                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                reject(e);\n                            }\n                        }\n                    });\n                const regionUrl = this.regionUrl;\n                this.regionUrl = undefined;\n                this.connectFuture = new Future((resolve, reject)=>{\n                    connectFn(resolve, reject, regionUrl);\n                }, ()=>{\n                    this.clearConnectionFutures();\n                });\n                return this.connectFuture.promise;\n            });\n        this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController)=>__awaiter(this, void 0, void 0, function*() {\n                var _e, _f, _g;\n                const joinResponse = yield engine.join(url, token, {\n                    autoSubscribe: connectOptions.autoSubscribe,\n                    publishOnly: connectOptions.publishOnly,\n                    adaptiveStream: typeof roomOptions.adaptiveStream === \"object\" ? true : roomOptions.adaptiveStream,\n                    maxRetries: connectOptions.maxRetries,\n                    e2eeEnabled: !!this.e2eeManager,\n                    websocketTimeout: connectOptions.websocketTimeout\n                }, abortController.signal);\n                let serverInfo = joinResponse.serverInfo;\n                if (!serverInfo) {\n                    serverInfo = {\n                        version: joinResponse.serverVersion,\n                        region: joinResponse.serverRegion\n                    };\n                }\n                this.log.debug(\"connected to Livekit Server \".concat(Object.entries(serverInfo).map((_ref)=>{\n                    let [key, value] = _ref;\n                    return \"\".concat(key, \": \").concat(value);\n                }).join(\", \")), {\n                    room: (_e = joinResponse.room) === null || _e === void 0 ? void 0 : _e.name,\n                    roomSid: (_f = joinResponse.room) === null || _f === void 0 ? void 0 : _f.sid,\n                    identity: (_g = joinResponse.participant) === null || _g === void 0 ? void 0 : _g.identity\n                });\n                if (!joinResponse.serverVersion) {\n                    throw new UnsupportedServer(\"unknown server version\");\n                }\n                if (joinResponse.serverVersion === \"0.15.1\" && this.options.dynacast) {\n                    this.log.debug(\"disabling dynacast due to server version\", this.logContext);\n                    // dynacast has a bug in 0.15.1, so we cannot use it then\n                    roomOptions.dynacast = false;\n                }\n                return joinResponse;\n            });\n        this.applyJoinResponse = (joinResponse)=>{\n            const pi = joinResponse.participant;\n            this.localParticipant.sid = pi.sid;\n            this.localParticipant.identity = pi.identity;\n            // populate remote participants, these should not trigger new events\n            this.handleParticipantUpdates([\n                pi,\n                ...joinResponse.otherParticipants\n            ]);\n            if (joinResponse.room) {\n                this.handleRoomUpdate(joinResponse.room);\n            }\n            if (this.options.e2ee && this.e2eeManager) {\n                this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);\n            }\n        };\n        this.attemptConnection = (url, token, opts, abortController)=>__awaiter(this, void 0, void 0, function*() {\n                var _h, _j;\n                if (this.state === ConnectionState.Reconnecting) {\n                    this.log.info(\"Reconnection attempt replaced by new connection attempt\", this.logContext);\n                    // make sure we close and recreate the existing engine in order to get rid of any potentially ongoing reconnection attempts\n                    this.recreateEngine();\n                } else {\n                    // create engine if previously disconnected\n                    this.maybeCreateEngine();\n                }\n                if ((_h = this.regionUrlProvider) === null || _h === void 0 ? void 0 : _h.isCloud()) {\n                    this.engine.setRegionUrlProvider(this.regionUrlProvider);\n                }\n                this.acquireAudioContext();\n                this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);\n                if (this.connOptions.rtcConfig) {\n                    this.engine.rtcConfig = this.connOptions.rtcConfig;\n                }\n                if (this.connOptions.peerConnectionTimeout) {\n                    this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;\n                }\n                try {\n                    const joinResponse = yield this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController);\n                    this.applyJoinResponse(joinResponse);\n                    // forward metadata changed for the local participant\n                    this.setupLocalParticipantEvents();\n                    this.emit(RoomEvent.SignalConnected);\n                } catch (err) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    const resultingError = new ConnectionError(\"could not establish signal connection\");\n                    if (err instanceof Error) {\n                        resultingError.message = \"\".concat(resultingError.message, \": \").concat(err.message);\n                    }\n                    if (err instanceof ConnectionError) {\n                        resultingError.reason = err.reason;\n                        resultingError.status = err.status;\n                    }\n                    this.log.debug(\"error trying to establish signal connection\", Object.assign(Object.assign({}, this.logContext), {\n                        error: err\n                    }));\n                    throw resultingError;\n                }\n                if (abortController.signal.aborted) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    throw new ConnectionError(\"Connection attempt aborted\");\n                }\n                try {\n                    yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);\n                } catch (e) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    throw e;\n                }\n                // also hook unload event\n                if (isWeb() && this.options.disconnectOnPageLeave) {\n                    // capturing both 'pagehide' and 'beforeunload' to capture broadest set of browser behaviors\n                    window.addEventListener(\"pagehide\", this.onPageLeave);\n                    window.addEventListener(\"beforeunload\", this.onPageLeave);\n                }\n                if (isWeb()) {\n                    document.addEventListener(\"freeze\", this.onPageLeave);\n                    (_j = navigator.mediaDevices) === null || _j === void 0 ? void 0 : _j.addEventListener(\"devicechange\", this.handleDeviceChange);\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connected);\n                this.emit(RoomEvent.Connected);\n                this.registerConnectionReconcile();\n            });\n        /**\n     * disconnects the room, emits [[RoomEvent.Disconnected]]\n     */ this.disconnect = function() {\n            let stopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n            return __awaiter(_this, void 0, void 0, function*() {\n                var _k, _l, _m, _o;\n                const unlock = yield this.disconnectLock.lock();\n                try {\n                    if (this.state === ConnectionState.Disconnected) {\n                        this.log.debug(\"already disconnected\", this.logContext);\n                        return;\n                    }\n                    this.log.info(\"disconnect from room\", Object.assign({}, this.logContext));\n                    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n                        // try aborting pending connection attempt\n                        this.log.warn(\"abort connection attempt\", this.logContext);\n                        (_k = this.abortController) === null || _k === void 0 ? void 0 : _k.abort();\n                        // in case the abort controller didn't manage to cancel the connection attempt, reject the connect promise explicitly\n                        (_m = (_l = this.connectFuture) === null || _l === void 0 ? void 0 : _l.reject) === null || _m === void 0 ? void 0 : _m.call(_l, new ConnectionError(\"Client initiated disconnect\"));\n                        this.connectFuture = undefined;\n                    }\n                    // send leave\n                    if (!((_o = this.engine) === null || _o === void 0 ? void 0 : _o.client.isDisconnected)) {\n                        yield this.engine.client.sendLeave();\n                    }\n                    // close engine (also closes client)\n                    if (this.engine) {\n                        yield this.engine.close();\n                    }\n                    this.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);\n                    /* @ts-ignore */ this.engine = undefined;\n                } finally{\n                    unlock();\n                }\n            });\n        };\n        this.onPageLeave = ()=>__awaiter(this, void 0, void 0, function*() {\n                yield this.disconnect();\n            });\n        /**\n     * Browsers have different policies regarding audio playback. Most requiring\n     * some form of user interaction (click/tap/etc).\n     * In those cases, audio will be silent until a click/tap triggering one of the following\n     * - `startAudio`\n     * - `getUserMedia`\n     */ this.startAudio = ()=>__awaiter(this, void 0, void 0, function*() {\n                const elements = [];\n                const browser = getBrowser();\n                if (browser && browser.os === \"iOS\") {\n                    /**\n         * iOS blocks audio element playback if\n         * - user is not publishing audio themselves and\n         * - no other audio source is playing\n         *\n         * as a workaround, we create an audio element with an empty track, so that\n         * silent audio is always playing\n         */ const audioId = \"livekit-dummy-audio-el\";\n                    let dummyAudioEl = document.getElementById(audioId);\n                    if (!dummyAudioEl) {\n                        dummyAudioEl = document.createElement(\"audio\");\n                        dummyAudioEl.id = audioId;\n                        dummyAudioEl.autoplay = true;\n                        dummyAudioEl.hidden = true;\n                        const track = getEmptyAudioStreamTrack();\n                        track.enabled = true;\n                        const stream = new MediaStream([\n                            track\n                        ]);\n                        dummyAudioEl.srcObject = stream;\n                        document.addEventListener(\"visibilitychange\", ()=>{\n                            if (!dummyAudioEl) {\n                                return;\n                            }\n                            // set the srcObject to null on page hide in order to prevent lock screen controls to show up for it\n                            dummyAudioEl.srcObject = document.hidden ? null : stream;\n                        });\n                        document.body.append(dummyAudioEl);\n                        this.once(RoomEvent.Disconnected, ()=>{\n                            dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();\n                        });\n                    }\n                    elements.push(dummyAudioEl);\n                }\n                this.participants.forEach((p)=>{\n                    p.audioTracks.forEach((t)=>{\n                        if (t.track) {\n                            t.track.attachedElements.forEach((e)=>{\n                                elements.push(e);\n                            });\n                        }\n                    });\n                });\n                try {\n                    yield Promise.all([\n                        this.acquireAudioContext(),\n                        ...elements.map((e)=>{\n                            e.muted = false;\n                            return e.play();\n                        })\n                    ]);\n                    this.handleAudioPlaybackStarted();\n                } catch (err) {\n                    this.handleAudioPlaybackFailed(err);\n                    throw err;\n                }\n            });\n        this.startVideo = ()=>__awaiter(this, void 0, void 0, function*() {\n                const elements = [];\n                for (const p of this.participants.values()){\n                    p.videoTracks.forEach((tr)=>{\n                        var _a;\n                        (_a = tr.track) === null || _a === void 0 ? void 0 : _a.attachedElements.forEach((el)=>{\n                            if (!elements.includes(el)) {\n                                elements.push(el);\n                            }\n                        });\n                    });\n                }\n                yield Promise.all(elements.map((el)=>el.play())).then(()=>{\n                    this.handleVideoPlaybackStarted();\n                }).catch((e)=>{\n                    if (e.name === \"NotAllowedError\") {\n                        this.handleVideoPlaybackFailed();\n                    } else {\n                        this.log.warn(\"Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler\", this.logContext);\n                    }\n                });\n            });\n        this.handleRestarting = ()=>{\n            this.clearConnectionReconcile();\n            // also unwind existing participants & existing subscriptions\n            for (const p of this.participants.values()){\n                this.handleParticipantDisconnected(p.sid, p);\n            }\n            if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n                this.emit(RoomEvent.Reconnecting);\n            }\n        };\n        this.handleSignalRestarted = (joinResponse)=>__awaiter(this, void 0, void 0, function*() {\n                this.log.debug(\"signal reconnected to server, region \".concat(joinResponse.serverRegion), Object.assign(Object.assign({}, this.logContext), {\n                    region: joinResponse.serverRegion\n                }));\n                this.cachedParticipantSids = [];\n                this.applyJoinResponse(joinResponse);\n                try {\n                    // unpublish & republish tracks\n                    yield this.localParticipant.republishAllTracks(undefined, true);\n                } catch (error) {\n                    this.log.error(\"error trying to re-publish tracks after reconnection\", Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    }));\n                }\n                try {\n                    yield this.engine.waitForRestarted();\n                    this.log.debug(\"fully reconnected to server\", Object.assign(Object.assign({}, this.logContext), {\n                        region: joinResponse.serverRegion\n                    }));\n                } catch (_p) {\n                    // reconnection failed, handleDisconnect is being invoked already, just return here\n                    return;\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connected);\n                this.emit(RoomEvent.Reconnected);\n                this.registerConnectionReconcile();\n                // emit participant connected events after connection has been re-established\n                this.participants.forEach((participant)=>{\n                    this.emit(RoomEvent.ParticipantConnected, participant);\n                });\n            });\n        this.handleParticipantUpdates = (participantInfos)=>{\n            // handle changes to participant state, and send events\n            participantInfos.forEach((info)=>{\n                if (info.identity === this.localParticipant.identity) {\n                    this.localParticipant.updateInfo(info);\n                    return;\n                }\n                // ensure identity <=> sid mapping\n                const sid = this.identityToSid.get(info.identity);\n                if (sid && sid !== info.sid) {\n                    // sid had changed, need to remove previous participant\n                    this.handleParticipantDisconnected(sid, this.participants.get(sid));\n                }\n                let remoteParticipant = this.participants.get(info.sid);\n                const isNewParticipant = !remoteParticipant;\n                // when it's disconnected, send updates\n                if (info.state === ParticipantInfo_State.DISCONNECTED) {\n                    this.handleParticipantDisconnected(info.sid, remoteParticipant);\n                } else {\n                    // create participant if doesn't exist\n                    remoteParticipant = this.getOrCreateParticipant(info.sid, info);\n                    if (!isNewParticipant) {\n                        // just update, no events\n                        remoteParticipant.updateInfo(info);\n                    }\n                }\n            });\n        };\n        // updates are sent only when there's a change to speaker ordering\n        this.handleActiveSpeakersUpdate = (speakers)=>{\n            const activeSpeakers = [];\n            const seenSids = {};\n            speakers.forEach((speaker)=>{\n                seenSids[speaker.sid] = true;\n                if (speaker.sid === this.localParticipant.sid) {\n                    this.localParticipant.audioLevel = speaker.level;\n                    this.localParticipant.setIsSpeaking(true);\n                    activeSpeakers.push(this.localParticipant);\n                } else {\n                    const p = this.participants.get(speaker.sid);\n                    if (p) {\n                        p.audioLevel = speaker.level;\n                        p.setIsSpeaking(true);\n                        activeSpeakers.push(p);\n                    }\n                }\n            });\n            if (!seenSids[this.localParticipant.sid]) {\n                this.localParticipant.audioLevel = 0;\n                this.localParticipant.setIsSpeaking(false);\n            }\n            this.participants.forEach((p)=>{\n                if (!seenSids[p.sid]) {\n                    p.audioLevel = 0;\n                    p.setIsSpeaking(false);\n                }\n            });\n            this.activeSpeakers = activeSpeakers;\n            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n        };\n        // process list of changed speakers\n        this.handleSpeakersChanged = (speakerUpdates)=>{\n            const lastSpeakers = new Map();\n            this.activeSpeakers.forEach((p)=>{\n                lastSpeakers.set(p.sid, p);\n            });\n            speakerUpdates.forEach((speaker)=>{\n                let p = this.participants.get(speaker.sid);\n                if (speaker.sid === this.localParticipant.sid) {\n                    p = this.localParticipant;\n                }\n                if (!p) {\n                    return;\n                }\n                p.audioLevel = speaker.level;\n                p.setIsSpeaking(speaker.active);\n                if (speaker.active) {\n                    lastSpeakers.set(speaker.sid, p);\n                } else {\n                    lastSpeakers.delete(speaker.sid);\n                }\n            });\n            const activeSpeakers = Array.from(lastSpeakers.values());\n            activeSpeakers.sort((a, b)=>b.audioLevel - a.audioLevel);\n            this.activeSpeakers = activeSpeakers;\n            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n        };\n        this.handleStreamStateUpdate = (streamStateUpdate)=>{\n            streamStateUpdate.streamStates.forEach((streamState)=>{\n                const participant = this.participants.get(streamState.participantSid);\n                if (!participant) {\n                    return;\n                }\n                const pub = participant.getTrackPublication(streamState.trackSid);\n                if (!pub || !pub.track) {\n                    return;\n                }\n                pub.track.streamState = Track.streamStateFromProto(streamState.state);\n                participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);\n                this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);\n            });\n        };\n        this.handleSubscriptionPermissionUpdate = (update)=>{\n            const participant = this.participants.get(update.participantSid);\n            if (!participant) {\n                return;\n            }\n            const pub = participant.getTrackPublication(update.trackSid);\n            if (!pub) {\n                return;\n            }\n            pub.setAllowed(update.allowed);\n        };\n        this.handleSubscriptionError = (update)=>{\n            const participant = Array.from(this.participants.values()).find((p)=>p.tracks.has(update.trackSid));\n            if (!participant) {\n                return;\n            }\n            const pub = participant.getTrackPublication(update.trackSid);\n            if (!pub) {\n                return;\n            }\n            pub.setSubscriptionError(update.err);\n        };\n        this.handleDataPacket = (userPacket, kind)=>{\n            // find the participant\n            const participant = this.participants.get(userPacket.participantSid);\n            this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);\n            // also emit on the participant\n            participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind);\n        };\n        this.handleAudioPlaybackStarted = ()=>{\n            if (this.canPlaybackAudio) {\n                return;\n            }\n            this.audioEnabled = true;\n            this.emit(RoomEvent.AudioPlaybackStatusChanged, true);\n        };\n        this.handleAudioPlaybackFailed = (e)=>{\n            this.log.warn(\"could not playback audio\", Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n            if (!this.canPlaybackAudio) {\n                return;\n            }\n            this.audioEnabled = false;\n            this.emit(RoomEvent.AudioPlaybackStatusChanged, false);\n        };\n        this.handleVideoPlaybackStarted = ()=>{\n            if (this.isVideoPlaybackBlocked) {\n                this.isVideoPlaybackBlocked = false;\n                this.emit(RoomEvent.VideoPlaybackStatusChanged, true);\n            }\n        };\n        this.handleVideoPlaybackFailed = ()=>{\n            if (!this.isVideoPlaybackBlocked) {\n                this.isVideoPlaybackBlocked = true;\n                this.emit(RoomEvent.VideoPlaybackStatusChanged, false);\n            }\n        };\n        this.handleDeviceChange = ()=>__awaiter(this, void 0, void 0, function*() {\n                this.emit(RoomEvent.MediaDevicesChanged);\n            });\n        this.handleRoomUpdate = (room)=>{\n            const oldRoom = this.roomInfo;\n            this.roomInfo = room;\n            if (oldRoom && oldRoom.metadata !== room.metadata) {\n                this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);\n            }\n            if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {\n                this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);\n            }\n        };\n        this.handleConnectionQualityUpdate = (update)=>{\n            update.updates.forEach((info)=>{\n                if (info.participantSid === this.localParticipant.sid) {\n                    this.localParticipant.setConnectionQuality(info.quality);\n                    return;\n                }\n                const participant = this.participants.get(info.participantSid);\n                if (participant) {\n                    participant.setConnectionQuality(info.quality);\n                }\n            });\n        };\n        this.onLocalParticipantMetadataChanged = (metadata)=>{\n            this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);\n        };\n        this.onLocalParticipantNameChanged = (name)=>{\n            this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);\n        };\n        this.onLocalTrackMuted = (pub)=>{\n            this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);\n        };\n        this.onLocalTrackUnmuted = (pub)=>{\n            this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);\n        };\n        this.onLocalTrackPublished = (pub)=>__awaiter(this, void 0, void 0, function*() {\n                var _q;\n                this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);\n                if (pub.track instanceof LocalAudioTrack) {\n                    const trackIsSilent = yield pub.track.checkForSilence();\n                    if (trackIsSilent) {\n                        this.emit(RoomEvent.LocalAudioSilenceDetected, pub);\n                    }\n                }\n                const deviceId = yield (_q = pub.track) === null || _q === void 0 ? void 0 : _q.getDeviceId();\n                const deviceKind = sourceToKind(pub.source);\n                if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\n                    this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\n                    this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\n                }\n            });\n        this.onLocalTrackUnpublished = (pub)=>{\n            this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);\n        };\n        this.onLocalConnectionQualityChanged = (quality)=>{\n            this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);\n        };\n        this.onMediaDevicesError = (e)=>{\n            this.emit(RoomEvent.MediaDevicesError, e);\n        };\n        this.onLocalParticipantPermissionsChanged = (prevPermissions)=>{\n            this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);\n        };\n        this.setMaxListeners(100);\n        this.participants = new Map();\n        this.cachedParticipantSids = [];\n        this.identityToSid = new Map();\n        this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);\n        this.log = getLogger((_a = this.options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Room);\n        this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);\n        this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);\n        this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);\n        this.maybeCreateEngine();\n        this.disconnectLock = new Mutex();\n        this.localParticipant = new LocalParticipant(\"\", \"\", this.engine, this.options);\n        if (this.options.videoCaptureDefaults.deviceId) {\n            this.localParticipant.activeDeviceMap.set(\"videoinput\", unwrapConstraint(this.options.videoCaptureDefaults.deviceId));\n        }\n        if (this.options.audioCaptureDefaults.deviceId) {\n            this.localParticipant.activeDeviceMap.set(\"audioinput\", unwrapConstraint(this.options.audioCaptureDefaults.deviceId));\n        }\n        if ((_b = this.options.audioOutput) === null || _b === void 0 ? void 0 : _b.deviceId) {\n            this.switchActiveDevice(\"audiooutput\", unwrapConstraint(this.options.audioOutput.deviceId)).catch((e)=>this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\n        }\n        if (this.options.e2ee) {\n            this.setupE2EE();\n        }\n    }\n    /**\n   * @experimental\n   */ setE2EEEnabled(enabled) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.e2eeManager) {\n                yield Promise.all([\n                    this.localParticipant.setE2EEEnabled(enabled)\n                ]);\n                if (this.localParticipant.identity !== \"\") {\n                    this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);\n                }\n            } else {\n                throw Error(\"e2ee not configured, please set e2ee settings within the room options\");\n            }\n        });\n    }\n    setupE2EE() {\n        var _a;\n        if (this.options.e2ee) {\n            this.e2eeManager = new E2EEManager(this.options.e2ee);\n            this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (enabled, participant)=>{\n                if (participant instanceof LocalParticipant) {\n                    this.isE2EEEnabled = enabled;\n                }\n                this.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);\n            });\n            this.e2eeManager.on(EncryptionEvent.EncryptionError, (error)=>this.emit(RoomEvent.EncryptionError, error));\n            (_a = this.e2eeManager) === null || _a === void 0 ? void 0 : _a.setup(this);\n        }\n    }\n    get logContext() {\n        return {\n            room: this.name,\n            roomSid: this.sid,\n            identity: this.localParticipant.identity\n        };\n    }\n    /**\n   * if the current room has a participant with `recorder: true` in its JWT grant\n   **/ get isRecording() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;\n    }\n    /** server assigned unique room id */ get sid() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid) !== null && _b !== void 0 ? _b : \"\";\n    }\n    /** user assigned name, derived from JWT token */ get name() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : \"\";\n    }\n    /** room metadata */ get metadata() {\n        var _a;\n        return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;\n    }\n    get numParticipants() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;\n    }\n    get numPublishers() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;\n    }\n    maybeCreateEngine() {\n        if (this.engine && !this.engine.isClosed) {\n            return;\n        }\n        this.engine = new RTCEngine(this.options);\n        this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver)=>{\n            this.onTrackAdded(mediaTrack, stream, receiver);\n        }).on(EngineEvent.Disconnected, (reason)=>{\n            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);\n        }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, ()=>{\n            this.clearConnectionReconcile();\n            if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n                this.emit(RoomEvent.Reconnecting);\n            }\n            this.cachedParticipantSids = Array.from(this.participants.keys());\n        }).on(EngineEvent.Resumed, ()=>{\n            this.setAndEmitConnectionState(ConnectionState.Connected);\n            this.emit(RoomEvent.Reconnected);\n            this.registerConnectionReconcile();\n            this.updateSubscriptions();\n            // once reconnected, figure out if any participants connected during reconnect and emit events for it\n            const diffParticipants = Array.from(this.participants.values()).filter((p)=>!this.cachedParticipantSids.includes(p.sid));\n            diffParticipants.forEach((p)=>this.emit(RoomEvent.ParticipantConnected, p));\n            this.cachedParticipantSids = [];\n        }).on(EngineEvent.SignalResumed, ()=>{\n            if (this.state === ConnectionState.Reconnecting) {\n                this.sendSyncState();\n            }\n        }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.DCBufferStatusChanged, (status, kind)=>{\n            this.emit(RoomEvent.DCBufferStatusChanged, status, kind);\n        });\n        if (this.localParticipant) {\n            this.localParticipant.setupEngine(this.engine);\n        }\n        if (this.e2eeManager) {\n            this.e2eeManager.setupEngine(this.engine);\n        }\n    }\n    /**\n   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.\n   * In particular, it handles Chrome's unique behavior of creating `default`\n   * devices. When encountered, it'll be removed from the list of devices.\n   * The actual default device will be placed at top.\n   * @param kind\n   * @returns a list of available local devices\n   */ static getLocalDevices(kind) {\n        let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return DeviceManager.getInstance().getDevices(kind, requestPermissions);\n    }\n    /**\n   * prepareConnection should be called as soon as the page is loaded, in order\n   * to speed up the connection attempt. This function will\n   * - perform DNS resolution and pre-warm the DNS cache\n   * - establish TLS connection and cache TLS keys\n   *\n   * With LiveKit Cloud, it will also determine the best edge data center for\n   * the current client to connect to if a token is provided.\n   */ prepareConnection(url, token) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state !== ConnectionState.Disconnected) {\n                return;\n            }\n            this.log.debug(\"prepareConnection to \".concat(url), this.logContext);\n            try {\n                if (isCloud(new URL(url)) && token) {\n                    this.regionUrlProvider = new RegionUrlProvider(url, token);\n                    const regionUrl = yield this.regionUrlProvider.getNextBestRegionUrl();\n                    // we will not replace the regionUrl if an attempt had already started\n                    // to avoid overriding regionUrl after a new connection attempt had started\n                    if (regionUrl && this.state === ConnectionState.Disconnected) {\n                        this.regionUrl = regionUrl;\n                        yield fetch(toHttpUrl(regionUrl), {\n                            method: \"HEAD\"\n                        });\n                        this.log.debug(\"prepared connection to \".concat(regionUrl), this.logContext);\n                    }\n                } else {\n                    yield fetch(toHttpUrl(url), {\n                        method: \"HEAD\"\n                    });\n                }\n            } catch (e) {\n                this.log.warn(\"could not prepare connection\", Object.assign(Object.assign({}, this.logContext), {\n                    error: e\n                }));\n            }\n        });\n    }\n    /**\n   * retrieves a participant by identity\n   * @param identity\n   * @returns\n   */ getParticipantByIdentity(identity) {\n        if (this.localParticipant.identity === identity) {\n            return this.localParticipant;\n        }\n        const sid = this.identityToSid.get(identity);\n        if (sid) {\n            return this.participants.get(sid);\n        }\n    }\n    clearConnectionFutures() {\n        this.connectFuture = undefined;\n    }\n    /**\n   * @internal for testing\n   */ simulateScenario(scenario, arg) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let postAction = ()=>{};\n            let req;\n            switch(scenario){\n                case \"signal-reconnect\":\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose(\"simulate disconnect\");\n                    break;\n                case \"speaker\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"speakerUpdate\",\n                            value: 3\n                        }\n                    });\n                    break;\n                case \"node-failure\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"nodeFailure\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"server-leave\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"serverLeave\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"migration\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"migration\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"resume-reconnect\":\n                    this.engine.failNext();\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose(\"simulate resume-disconnect\");\n                    break;\n                case \"disconnect-signal-on-resume\":\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            // @ts-expect-error function is private\n                            yield this.engine.client.handleOnClose(\"simulate resume-disconnect\");\n                        });\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"disconnectSignalOnResume\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"disconnect-signal-on-resume-no-messages\":\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            // @ts-expect-error function is private\n                            yield this.engine.client.handleOnClose(\"simulate resume-disconnect\");\n                        });\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"disconnectSignalOnResumeNoMessages\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"full-reconnect\":\n                    this.engine.fullReconnectOnNext = true;\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose(\"simulate full-reconnect\");\n                    break;\n                case \"force-tcp\":\n                case \"force-tls\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"switchCandidateProtocol\",\n                            value: scenario === \"force-tls\" ? 2 : 1\n                        }\n                    });\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            const onLeave = this.engine.client.onLeave;\n                            if (onLeave) {\n                                onLeave(new LeaveRequest({\n                                    reason: DisconnectReason.CLIENT_INITIATED,\n                                    canReconnect: true\n                                }));\n                            }\n                        });\n                    break;\n                case \"subscriber-bandwidth\":\n                    if (arg === undefined || typeof arg !== \"number\") {\n                        throw new Error(\"subscriber-bandwidth requires a number as argument\");\n                    }\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"subscriberBandwidth\",\n                            value: BigInt(arg)\n                        }\n                    });\n                    break;\n            }\n            if (req) {\n                yield this.engine.client.sendSimulateScenario(req);\n                yield postAction();\n            }\n        });\n    }\n    /**\n   * Returns true if audio playback is enabled\n   */ get canPlaybackAudio() {\n        return this.audioEnabled;\n    }\n    /**\n   * Returns true if video playback is enabled\n   */ get canPlaybackVideo() {\n        return !this.isVideoPlaybackBlocked;\n    }\n    /**\n   * Returns the active audio output device used in this room.\n   * @return the previously successfully set audio output device ID or an empty string if the default device is used.\n   * @deprecated use `getActiveDevice('audiooutput')` instead\n   */ getActiveAudioOutputDevice() {\n        var _a, _b;\n        return (_b = (_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) !== null && _b !== void 0 ? _b : \"\";\n    }\n    getActiveDevice(kind) {\n        return this.localParticipant.activeDeviceMap.get(kind);\n    }\n    /**\n   * Switches all active devices used in this room to the given device.\n   *\n   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)\n   *\n   * @param kind use `videoinput` for camera track,\n   *  `audioinput` for microphone track,\n   *  `audiooutput` to set speaker for all incoming audio tracks\n   * @param deviceId\n   */ switchActiveDevice(kind, deviceId) {\n        let exact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var _a, _b;\n        var _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            let deviceHasChanged = false;\n            let success = true;\n            const deviceConstraint = exact ? {\n                exact: deviceId\n            } : deviceId;\n            if (kind === \"audioinput\") {\n                const prevDeviceId = this.options.audioCaptureDefaults.deviceId;\n                this.options.audioCaptureDefaults.deviceId = deviceConstraint;\n                deviceHasChanged = prevDeviceId !== deviceConstraint;\n                const tracks = Array.from(this.localParticipant.audioTracks.values()).filter((track)=>track.source === Track.Source.Microphone);\n                try {\n                    success = (yield Promise.all(tracks.map((t)=>{\n                        var _a;\n                        return (_a = t.audioTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n                    }))).every((val)=>val === true);\n                } catch (e) {\n                    this.options.audioCaptureDefaults.deviceId = prevDeviceId;\n                    throw e;\n                }\n            } else if (kind === \"videoinput\") {\n                const prevDeviceId = this.options.videoCaptureDefaults.deviceId;\n                this.options.videoCaptureDefaults.deviceId = deviceConstraint;\n                deviceHasChanged = prevDeviceId !== deviceConstraint;\n                const tracks = Array.from(this.localParticipant.videoTracks.values()).filter((track)=>track.source === Track.Source.Camera);\n                try {\n                    success = (yield Promise.all(tracks.map((t)=>{\n                        var _a;\n                        return (_a = t.videoTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n                    }))).every((val)=>val === true);\n                } catch (e) {\n                    this.options.videoCaptureDefaults.deviceId = prevDeviceId;\n                    throw e;\n                }\n            } else if (kind === \"audiooutput\") {\n                if (!supportsSetSinkId() && !this.options.expWebAudioMix || this.options.expWebAudioMix && this.audioContext && !(\"setSinkId\" in this.audioContext)) {\n                    throw new Error(\"cannot switch audio output, setSinkId not supported\");\n                }\n                (_a = (_c = this.options).audioOutput) !== null && _a !== void 0 ? _a : _c.audioOutput = {};\n                const prevDeviceId = this.options.audioOutput.deviceId;\n                this.options.audioOutput.deviceId = deviceId;\n                deviceHasChanged = prevDeviceId !== deviceConstraint;\n                try {\n                    if (this.options.expWebAudioMix) {\n                        // @ts-expect-error setSinkId is not yet in the typescript type of AudioContext\n                        (_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.setSinkId(deviceId);\n                    } else {\n                        yield Promise.all(Array.from(this.participants.values()).map((p)=>p.setAudioOutput({\n                                deviceId\n                            })));\n                    }\n                } catch (e) {\n                    this.options.audioOutput.deviceId = prevDeviceId;\n                    throw e;\n                }\n            }\n            if (deviceHasChanged && success) {\n                this.localParticipant.activeDeviceMap.set(kind, deviceId);\n                this.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);\n            }\n            return success;\n        });\n    }\n    setupLocalParticipantEvents() {\n        this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n    }\n    recreateEngine() {\n        var _a;\n        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\n        /* @ts-ignore */ this.engine = undefined;\n        // clear out existing remote participants, since they may have attached\n        // the old engine\n        this.participants.clear();\n        this.maybeCreateEngine();\n    }\n    onTrackAdded(mediaTrack, stream, receiver) {\n        // don't fire onSubscribed when connecting\n        // WebRTC fires onTrack as soon as setRemoteDescription is called on the offer\n        // at that time, ICE connectivity has not been established so the track is not\n        // technically subscribed.\n        // We'll defer these events until when the room is connected or eventually disconnected.\n        if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n            const reconnectedHandler = ()=>{\n                this.onTrackAdded(mediaTrack, stream, receiver);\n                cleanup();\n            };\n            const cleanup = ()=>{\n                this.off(RoomEvent.Reconnected, reconnectedHandler);\n                this.off(RoomEvent.Connected, reconnectedHandler);\n                this.off(RoomEvent.Disconnected, cleanup);\n            };\n            this.once(RoomEvent.Reconnected, reconnectedHandler);\n            this.once(RoomEvent.Connected, reconnectedHandler);\n            this.once(RoomEvent.Disconnected, cleanup);\n            return;\n        }\n        if (this.state === ConnectionState.Disconnected) {\n            this.log.warn(\"skipping incoming track after Room disconnected\", this.logContext);\n            return;\n        }\n        const parts = unpackStreamId(stream.id);\n        const participantId = parts[0];\n        let streamId = parts[1];\n        let trackId = mediaTrack.id;\n        // firefox will get streamId (pID|trackId) instead of (pID|streamId) as it doesn't support sync tracks by stream\n        // and generates its own track id instead of infer from sdp track id.\n        if (streamId && streamId.startsWith(\"TR\")) trackId = streamId;\n        if (participantId === this.localParticipant.sid) {\n            this.log.warn(\"tried to create RemoteParticipant for local participant\", this.logContext);\n            return;\n        }\n        const participant = this.participants.get(participantId);\n        if (!participant) {\n            this.log.error(\"Tried to add a track for a participant, that's not present. Sid: \".concat(participantId), this.logContext);\n            return;\n        }\n        let adaptiveStreamSettings;\n        if (this.options.adaptiveStream) {\n            if (typeof this.options.adaptiveStream === \"object\") {\n                adaptiveStreamSettings = this.options.adaptiveStream;\n            } else {\n                adaptiveStreamSettings = {};\n            }\n        }\n        participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);\n    }\n    handleDisconnect() {\n        let shouldStopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        let reason = arguments.length > 1 ? arguments[1] : undefined;\n        var _a;\n        this.clearConnectionReconcile();\n        if (this.state === ConnectionState.Disconnected) {\n            return;\n        }\n        this.regionUrl = undefined;\n        try {\n            this.participants.forEach((p)=>{\n                p.tracks.forEach((pub)=>{\n                    p.unpublishTrack(pub.trackSid);\n                });\n            });\n            this.localParticipant.tracks.forEach((pub)=>{\n                var _a, _b;\n                if (pub.track) {\n                    this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);\n                }\n                if (shouldStopTracks) {\n                    (_a = pub.track) === null || _a === void 0 ? void 0 : _a.detach();\n                    (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();\n                }\n            });\n            this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n            this.localParticipant.tracks.clear();\n            this.localParticipant.videoTracks.clear();\n            this.localParticipant.audioTracks.clear();\n            this.participants.clear();\n            this.activeSpeakers = [];\n            if (this.audioContext && typeof this.options.expWebAudioMix === \"boolean\") {\n                this.audioContext.close();\n                this.audioContext = undefined;\n            }\n            if (isWeb()) {\n                window.removeEventListener(\"beforeunload\", this.onPageLeave);\n                window.removeEventListener(\"pagehide\", this.onPageLeave);\n                window.removeEventListener(\"freeze\", this.onPageLeave);\n                (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"devicechange\", this.handleDeviceChange);\n            }\n        } finally{\n            this.setAndEmitConnectionState(ConnectionState.Disconnected);\n            this.emit(RoomEvent.Disconnected, reason);\n        }\n    }\n    handleParticipantDisconnected(sid, participant) {\n        // remove and send event\n        this.participants.delete(sid);\n        if (!participant) {\n            return;\n        }\n        this.identityToSid.delete(participant.identity);\n        participant.tracks.forEach((publication)=>{\n            participant.unpublishTrack(publication.trackSid, true);\n        });\n        this.emit(RoomEvent.ParticipantDisconnected, participant);\n    }\n    acquireAudioContext() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (typeof this.options.expWebAudioMix !== \"boolean\" && this.options.expWebAudioMix.audioContext) {\n                // override audio context with custom audio context if supplied by user\n                this.audioContext = this.options.expWebAudioMix.audioContext;\n            } else if (!this.audioContext || this.audioContext.state === \"closed\") {\n                // by using an AudioContext, it reduces lag on audio elements\n                // https://stackoverflow.com/questions/9811429/html5-audio-tag-on-safari-has-a-delay/54119854#54119854\n                this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : undefined;\n            }\n            if (this.audioContext && this.audioContext.state === \"suspended\") {\n                // for iOS a newly created AudioContext is always in `suspended` state.\n                // we try our best to resume the context here, if that doesn't work, we just continue with regular processing\n                try {\n                    yield this.audioContext.resume();\n                } catch (e) {\n                    this.log.warn(\"Could not resume audio context\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                }\n            }\n            if (this.options.expWebAudioMix) {\n                this.participants.forEach((participant)=>participant.setAudioContext(this.audioContext));\n            }\n            this.localParticipant.setAudioContext(this.audioContext);\n            const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === \"running\";\n            if (newContextIsRunning !== this.canPlaybackAudio) {\n                this.audioEnabled = newContextIsRunning;\n                this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);\n            }\n        });\n    }\n    createParticipant(id, info) {\n        var _a;\n        let participant;\n        if (info) {\n            participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info);\n        } else {\n            participant = new RemoteParticipant(this.engine.client, id, \"\", undefined, undefined, {\n                loggerContextCb: ()=>this.logContext,\n                loggerName: this.options.loggerName\n            });\n        }\n        if (this.options.expWebAudioMix) {\n            participant.setAudioContext(this.audioContext);\n        }\n        if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {\n            participant.setAudioOutput(this.options.audioOutput).catch((e)=>this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\n        }\n        return participant;\n    }\n    getOrCreateParticipant(id, info) {\n        if (this.participants.has(id)) {\n            return this.participants.get(id);\n        }\n        const participant = this.createParticipant(id, info);\n        this.participants.set(id, participant);\n        this.identityToSid.set(info.identity, info.sid);\n        // if we have valid info and the participant wasn't in the map before, we can assume the participant is new\n        // firing here to make sure that `ParticipantConnected` fires before the initial track events\n        this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);\n        // also forward events\n        // trackPublished is only fired for tracks added after both local participant\n        // and remote participant joined the room\n        participant.on(ParticipantEvent.TrackPublished, (trackPublication)=>{\n            this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);\n        }).on(ParticipantEvent.TrackSubscribed, (track, publication)=>{\n            // monitor playback status\n            if (track.kind === Track.Kind.Audio) {\n                track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);\n                track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);\n            } else if (track.kind === Track.Kind.Video) {\n                track.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed);\n                track.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted);\n            }\n            this.emit(RoomEvent.TrackSubscribed, track, publication, participant);\n        }).on(ParticipantEvent.TrackUnpublished, (publication)=>{\n            this.emit(RoomEvent.TrackUnpublished, publication, participant);\n        }).on(ParticipantEvent.TrackUnsubscribed, (track, publication)=>{\n            this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);\n        }).on(ParticipantEvent.TrackSubscriptionFailed, (sid)=>{\n            this.emit(RoomEvent.TrackSubscriptionFailed, sid, participant);\n        }).on(ParticipantEvent.TrackMuted, (pub)=>{\n            this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);\n        }).on(ParticipantEvent.TrackUnmuted, (pub)=>{\n            this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);\n        }).on(ParticipantEvent.ParticipantMetadataChanged, (metadata)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);\n        }).on(ParticipantEvent.ParticipantNameChanged, (name)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);\n        }).on(ParticipantEvent.ConnectionQualityChanged, (quality)=>{\n            this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);\n        }).on(ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);\n        }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status)=>{\n            this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);\n        }).on(ParticipantEvent.TrackSubscriptionFailed, (trackSid, error)=>{\n            this.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);\n        }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status)=>{\n            this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);\n        });\n        // update info at the end after callbacks have been set up\n        if (info) {\n            participant.updateInfo(info);\n        }\n        return participant;\n    }\n    sendSyncState() {\n        const remoteTracks = Array.from(this.participants.values()).reduce((acc, participant)=>{\n            acc.push(...participant.getTracks()); // FIXME would be nice to have this return RemoteTrackPublications directly instead of the type cast\n            return acc;\n        }, []);\n        const localTracks = this.localParticipant.getTracks(); // FIXME would be nice to have this return LocalTrackPublications directly instead of the type cast\n        this.engine.sendSyncState(remoteTracks, localTracks);\n    }\n    /**\n   * After resuming, we'll need to notify the server of the current\n   * subscription settings.\n   */ updateSubscriptions() {\n        for (const p of this.participants.values()){\n            for (const pub of p.videoTracks.values()){\n                if (pub.isSubscribed && pub instanceof RemoteTrackPublication) {\n                    pub.emitTrackUpdate();\n                }\n            }\n        }\n    }\n    registerConnectionReconcile() {\n        this.clearConnectionReconcile();\n        let consecutiveFailures = 0;\n        this.connectionReconcileInterval = CriticalTimers.setInterval(()=>{\n            if (// ensure we didn't tear it down\n            !this.engine || // engine detected close, but Room missed it\n            this.engine.isClosed || // transports failed without notifying engine\n            !this.engine.verifyTransport()) {\n                consecutiveFailures++;\n                this.log.warn(\"detected connection state mismatch\", Object.assign(Object.assign({}, this.logContext), {\n                    numFailures: consecutiveFailures,\n                    engine: {\n                        closed: this.engine.isClosed,\n                        transportsConnected: this.engine.verifyTransport()\n                    }\n                }));\n                if (consecutiveFailures >= 3) {\n                    this.recreateEngine();\n                    this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH);\n                }\n            } else {\n                consecutiveFailures = 0;\n            }\n        }, connectionReconcileFrequency);\n    }\n    clearConnectionReconcile() {\n        if (this.connectionReconcileInterval) {\n            CriticalTimers.clearInterval(this.connectionReconcileInterval);\n        }\n    }\n    setAndEmitConnectionState(state) {\n        if (state === this.state) {\n            // unchanged\n            return false;\n        }\n        this.state = state;\n        this.emit(RoomEvent.ConnectionStateChanged, this.state);\n        return true;\n    }\n    emitWhenConnected(event) {\n        if (this.state === ConnectionState.Connected) {\n            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                args[_key - 1] = arguments[_key];\n            }\n            return this.emit(event, ...args);\n        }\n        return false;\n    }\n    /**\n   * Allows to populate a room with simulated participants.\n   * No actual connection to a server will be established, all state is\n   * @experimental\n   */ simulateParticipants(options) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const publishOptions = Object.assign({\n                audio: true,\n                video: true,\n                useRealTracks: false\n            }, options.publish);\n            const participantOptions = Object.assign({\n                count: 9,\n                audio: false,\n                video: true,\n                aspectRatios: [\n                    1.66,\n                    1.7,\n                    1.3\n                ]\n            }, options.participants);\n            this.handleDisconnect();\n            this.roomInfo = new Room$1({\n                sid: \"RM_SIMULATED\",\n                name: \"simulated-room\",\n                emptyTimeout: 0,\n                maxParticipants: 0,\n                creationTime: protoInt64.parse(new Date().getTime()),\n                metadata: \"\",\n                numParticipants: 1,\n                numPublishers: 1,\n                turnPassword: \"\",\n                enabledCodecs: [],\n                activeRecording: false\n            });\n            this.localParticipant.updateInfo(new ParticipantInfo({\n                identity: \"simulated-local\",\n                name: \"local-name\"\n            }));\n            this.setupLocalParticipantEvents();\n            this.emit(RoomEvent.SignalConnected);\n            this.emit(RoomEvent.Connected);\n            this.setAndEmitConnectionState(ConnectionState.Connected);\n            if (publishOptions.video) {\n                const camPub = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({\n                    source: TrackSource.CAMERA,\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    type: TrackType.AUDIO,\n                    name: \"video-dummy\"\n                }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({\n                    video: true\n                })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((_a = participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1), 160, true, true), undefined, false, {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                }), {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                // @ts-ignore\n                this.localParticipant.addTrackPublication(camPub);\n                this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);\n            }\n            if (publishOptions.audio) {\n                const audioPub = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({\n                    source: TrackSource.MICROPHONE,\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    type: TrackType.AUDIO\n                }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({\n                    audio: true\n                })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), undefined, false, this.audioContext, {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                }), {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                // @ts-ignore\n                this.localParticipant.addTrackPublication(audioPub);\n                this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);\n            }\n            for(let i = 0; i < participantOptions.count - 1; i += 1){\n                let info = new ParticipantInfo({\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    identity: \"simulated-\".concat(i),\n                    state: ParticipantInfo_State.ACTIVE,\n                    tracks: [],\n                    joinedAt: protoInt64.parse(Date.now())\n                });\n                const p = this.getOrCreateParticipant(info.identity, info);\n                if (participantOptions.video) {\n                    const dummyVideo = createDummyVideoStreamTrack(160 * ((_b = participantOptions.aspectRatios[i % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1), 160, false, true);\n                    const videoTrack = new TrackInfo({\n                        source: TrackSource.CAMERA,\n                        sid: Math.floor(Math.random() * 10000).toString(),\n                        type: TrackType.AUDIO\n                    });\n                    p.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([\n                        dummyVideo\n                    ]));\n                    info.tracks = [\n                        ...info.tracks,\n                        videoTrack\n                    ];\n                }\n                if (participantOptions.audio) {\n                    const dummyTrack = getEmptyAudioStreamTrack();\n                    const audioTrack = new TrackInfo({\n                        source: TrackSource.MICROPHONE,\n                        sid: Math.floor(Math.random() * 10000).toString(),\n                        type: TrackType.AUDIO\n                    });\n                    p.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([\n                        dummyTrack\n                    ]));\n                    info.tracks = [\n                        ...info.tracks,\n                        audioTrack\n                    ];\n                }\n                p.updateInfo(info);\n            }\n        });\n    }\n    // /** @internal */\n    emit(event) {\n        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n            args[_key2 - 1] = arguments[_key2];\n        }\n        // active speaker updates are too spammy\n        if (event !== RoomEvent.ActiveSpeakersChanged) {\n            // only extract logContext from arguments in order to avoid logging the whole object tree\n            const minimizedArgs = mapArgs(args).filter((arg)=>arg !== undefined);\n            this.log.debug(\"room event \".concat(event), Object.assign(Object.assign({}, this.logContext), {\n                event,\n                args: minimizedArgs\n            }));\n        }\n        return super.emit(event, ...args);\n    }\n}\nfunction mapArgs(args) {\n    return args.map((arg)=>{\n        if (!arg) {\n            return;\n        }\n        if (Array.isArray(arg)) {\n            return mapArgs(arg);\n        }\n        if (typeof arg === \"object\") {\n            return \"logContext\" in arg && arg.logContext;\n        }\n        return arg;\n    });\n}\nvar CheckStatus;\n(function(CheckStatus) {\n    CheckStatus[CheckStatus[\"IDLE\"] = 0] = \"IDLE\";\n    CheckStatus[CheckStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n    CheckStatus[CheckStatus[\"SKIPPED\"] = 2] = \"SKIPPED\";\n    CheckStatus[CheckStatus[\"SUCCESS\"] = 3] = \"SUCCESS\";\n    CheckStatus[CheckStatus[\"FAILED\"] = 4] = \"FAILED\";\n})(CheckStatus || (CheckStatus = {}));\nclass Checker extends eventsExports.EventEmitter {\n    constructor(url, token){\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        super();\n        this.status = CheckStatus.IDLE;\n        this.logs = [];\n        this.errorsAsWarnings = false;\n        this.url = url;\n        this.token = token;\n        this.name = this.constructor.name;\n        this.room = new Room(options.roomOptions);\n        this.connectOptions = options.connectOptions;\n        if (options.errorsAsWarnings) {\n            this.errorsAsWarnings = options.errorsAsWarnings;\n        }\n    }\n    run(onComplete) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.status !== CheckStatus.IDLE) {\n                throw Error(\"check is running already\");\n            }\n            this.setStatus(CheckStatus.RUNNING);\n            try {\n                yield this.perform();\n            } catch (err) {\n                if (err instanceof Error) {\n                    if (this.errorsAsWarnings) {\n                        this.appendWarning(err.message);\n                    } else {\n                        this.appendError(err.message);\n                    }\n                }\n            }\n            yield this.disconnect();\n            // sleep for a bit to ensure disconnect\n            yield new Promise((resolve)=>setTimeout(resolve, 500));\n            // @ts-ignore\n            if (this.status !== CheckStatus.SKIPPED) {\n                this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);\n            }\n            if (onComplete) {\n                onComplete();\n            }\n            return this.getInfo();\n        });\n    }\n    isSuccess() {\n        return !this.logs.some((l)=>l.level === \"error\");\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.room.state === ConnectionState.Connected) {\n                return this.room;\n            }\n            yield this.room.connect(this.url, this.token);\n            return this.room;\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.room && this.room.state !== ConnectionState.Disconnected) {\n                yield this.room.disconnect();\n                // wait for it to go through\n                yield new Promise((resolve)=>setTimeout(resolve, 500));\n            }\n        });\n    }\n    skip() {\n        this.setStatus(CheckStatus.SKIPPED);\n    }\n    appendMessage(message) {\n        this.logs.push({\n            level: \"info\",\n            message\n        });\n        this.emit(\"update\", this.getInfo());\n    }\n    appendWarning(message) {\n        this.logs.push({\n            level: \"warning\",\n            message\n        });\n        this.emit(\"update\", this.getInfo());\n    }\n    appendError(message) {\n        this.logs.push({\n            level: \"error\",\n            message\n        });\n        this.emit(\"update\", this.getInfo());\n    }\n    setStatus(status) {\n        this.status = status;\n        this.emit(\"update\", this.getInfo());\n    }\n    get engine() {\n        var _a;\n        return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;\n    }\n    getInfo() {\n        return {\n            logs: this.logs,\n            name: this.name,\n            status: this.status,\n            description: this.description\n        };\n    }\n}\n/**\n * Creates a local video and audio track at the same time. When acquiring both\n * audio and video tracks together, it'll display a single permission prompt to\n * the user instead of two separate ones.\n * @param options\n */ function createLocalTracks(options) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function*() {\n        // set default options to true\n        options !== null && options !== void 0 ? options : options = {};\n        (_a = options.audio) !== null && _a !== void 0 ? _a : options.audio = true;\n        (_b = options.video) !== null && _b !== void 0 ? _b : options.video = true;\n        const opts = mergeDefaultOptions(options, audioDefaults, videoDefaults);\n        const constraints = constraintsForOptions(opts);\n        // Keep a reference to the promise on DeviceManager and await it in getLocalDevices()\n        // works around iOS Safari Bug https://bugs.webkit.org/show_bug.cgi?id=179363\n        const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);\n        if (options.audio) {\n            DeviceManager.userMediaPromiseMap.set(\"audioinput\", mediaPromise);\n            mediaPromise.catch(()=>DeviceManager.userMediaPromiseMap.delete(\"audioinput\"));\n        }\n        if (options.video) {\n            DeviceManager.userMediaPromiseMap.set(\"videoinput\", mediaPromise);\n            mediaPromise.catch(()=>DeviceManager.userMediaPromiseMap.delete(\"videoinput\"));\n        }\n        const stream = yield mediaPromise;\n        return stream.getTracks().map((mediaStreamTrack)=>{\n            const isAudio = mediaStreamTrack.kind === \"audio\";\n            isAudio ? options.audio : options.video;\n            let trackConstraints;\n            const conOrBool = isAudio ? constraints.audio : constraints.video;\n            if (typeof conOrBool !== \"boolean\") {\n                trackConstraints = conOrBool;\n            }\n            // update the constraints with the device id the user gave permissions to in the permission prompt\n            // otherwise each track restart (e.g. mute - unmute) will try to initialize the device again -> causing additional permission prompts\n            if (trackConstraints) {\n                trackConstraints.deviceId = mediaStreamTrack.getSettings().deviceId;\n            } else {\n                trackConstraints = {\n                    deviceId: mediaStreamTrack.getSettings().deviceId\n                };\n            }\n            const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);\n            if (track.kind === Track.Kind.Video) {\n                track.source = Track.Source.Camera;\n            } else if (track.kind === Track.Kind.Audio) {\n                track.source = Track.Source.Microphone;\n            }\n            track.mediaStream = stream;\n            return track;\n        });\n    });\n}\n/**\n * Creates a [[LocalVideoTrack]] with getUserMedia()\n * @param options\n */ function createLocalVideoTrack(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const tracks = yield createLocalTracks({\n            audio: false,\n            video: options\n        });\n        return tracks[0];\n    });\n}\nfunction createLocalAudioTrack(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const tracks = yield createLocalTracks({\n            audio: options,\n            video: false\n        });\n        return tracks[0];\n    });\n}\n/**\n * Creates a screen capture tracks with getDisplayMedia().\n * A LocalVideoTrack is always created and returned.\n * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n */ function createLocalScreenTracks(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (options === undefined) {\n            options = {};\n        }\n        if (options.resolution === undefined && !isSafari17()) {\n            options.resolution = ScreenSharePresets.h1080fps30.resolution;\n        }\n        if (navigator.mediaDevices.getDisplayMedia === undefined) {\n            throw new DeviceUnsupportedError(\"getDisplayMedia not supported\");\n        }\n        const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n        const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n        const tracks = stream.getVideoTracks();\n        if (tracks.length === 0) {\n            throw new TrackInvalidError(\"no video track found\");\n        }\n        const screenVideo = new LocalVideoTrack(tracks[0], undefined, false);\n        screenVideo.source = Track.Source.ScreenShare;\n        const localTracks = [\n            screenVideo\n        ];\n        if (stream.getAudioTracks().length > 0) {\n            const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false);\n            screenAudio.source = Track.Source.ScreenShareAudio;\n            localTracks.push(screenAudio);\n        }\n        return localTracks;\n    });\n}\nclass PublishAudioCheck extends Checker {\n    get description() {\n        return \"Can publish audio\";\n    }\n    perform() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const room = yield this.connect();\n            const track = yield createLocalAudioTrack();\n            room.localParticipant.publishTrack(track);\n            // wait for a few seconds to publish\n            yield new Promise((resolve)=>setTimeout(resolve, 3000));\n            // verify RTC stats that it's publishing\n            const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n            if (!stats) {\n                throw new Error(\"Could not get RTCStats\");\n            }\n            let numPackets = 0;\n            stats.forEach((stat)=>{\n                if (stat.type === \"outbound-rtp\" && stat.mediaType === \"audio\") {\n                    numPackets = stat.packetsSent;\n                }\n            });\n            if (numPackets === 0) {\n                throw new Error(\"Could not determine packets are sent\");\n            }\n            this.appendMessage(\"published \".concat(numPackets, \" audio packets\"));\n        });\n    }\n}\nclass PublishVideoCheck extends Checker {\n    get description() {\n        return \"Can publish video\";\n    }\n    perform() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const room = yield this.connect();\n            const track = yield createLocalVideoTrack();\n            room.localParticipant.publishTrack(track);\n            // wait for a few seconds to publish\n            yield new Promise((resolve)=>setTimeout(resolve, 3000));\n            // verify RTC stats that it's publishing\n            const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n            if (!stats) {\n                throw new Error(\"Could not get RTCStats\");\n            }\n            let numPackets = 0;\n            stats.forEach((stat)=>{\n                if (stat.type === \"outbound-rtp\" && stat.mediaType === \"video\") {\n                    numPackets = stat.packetsSent;\n                }\n            });\n            if (numPackets === 0) {\n                throw new Error(\"Could not determine packets are sent\");\n            }\n            this.appendMessage(\"published \".concat(numPackets, \" video packets\"));\n        });\n    }\n}\nclass ReconnectCheck extends Checker {\n    get description() {\n        return \"Resuming connection after interruption\";\n    }\n    perform() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const room = yield this.connect();\n            let reconnectingTriggered = false;\n            let reconnected = false;\n            let reconnectResolver;\n            const reconnectTimeout = new Promise((resolve)=>{\n                setTimeout(resolve, 5000);\n                reconnectResolver = resolve;\n            });\n            room.on(RoomEvent.Reconnecting, ()=>{\n                reconnectingTriggered = true;\n            }).on(RoomEvent.Reconnected, ()=>{\n                reconnected = true;\n                reconnectResolver(true);\n            });\n            (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();\n            const onClose = room.engine.client.onClose;\n            if (onClose) {\n                onClose(\"\");\n            }\n            yield reconnectTimeout;\n            if (!reconnectingTriggered) {\n                throw new Error(\"Did not attempt to reconnect\");\n            } else if (!reconnected || room.state !== ConnectionState.Connected) {\n                this.appendWarning(\"reconnection is only possible in Redis-based configurations\");\n                throw new Error(\"Not able to reconnect\");\n            }\n        });\n    }\n}\nclass TURNCheck extends Checker {\n    get description() {\n        return \"Can connect via TURN\";\n    }\n    perform() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const signalClient = new SignalClient();\n            const joinRes = yield signalClient.join(this.url, this.token, {\n                autoSubscribe: true,\n                maxRetries: 0,\n                e2eeEnabled: false,\n                websocketTimeout: 15000\n            });\n            let hasTLS = false;\n            let hasTURN = false;\n            let hasSTUN = false;\n            for (let iceServer of joinRes.iceServers){\n                for (let url of iceServer.urls){\n                    if (url.startsWith(\"turn:\")) {\n                        hasTURN = true;\n                        hasSTUN = true;\n                    } else if (url.startsWith(\"turns:\")) {\n                        hasTURN = true;\n                        hasSTUN = true;\n                        hasTLS = true;\n                    }\n                    if (url.startsWith(\"stun:\")) {\n                        hasSTUN = true;\n                    }\n                }\n            }\n            if (!hasSTUN) {\n                this.appendWarning(\"No STUN servers configured on server side.\");\n            } else if (hasTURN && !hasTLS) {\n                this.appendWarning(\"TURN is configured server side, but TURN/TLS is unavailable.\");\n            }\n            yield signalClient.close();\n            if (((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN) {\n                yield this.room.connect(this.url, this.token, {\n                    rtcConfig: {\n                        iceTransportPolicy: \"relay\"\n                    }\n                });\n            } else {\n                this.appendWarning(\"No TURN servers configured.\");\n                this.skip();\n                yield new Promise((resolve)=>setTimeout(resolve, 0));\n            }\n        });\n    }\n}\nclass WebRTCCheck extends Checker {\n    get description() {\n        return \"Establishing WebRTC connection\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            let hasTcp = false;\n            let hasIpv4Udp = false;\n            this.room.on(RoomEvent.SignalConnected, ()=>{\n                const prevTrickle = this.room.engine.client.onTrickle;\n                this.room.engine.client.onTrickle = (sd, target)=>{\n                    if (sd.candidate) {\n                        const candidate = new RTCIceCandidate(sd);\n                        let str = \"\".concat(candidate.protocol, \" \").concat(candidate.address, \":\").concat(candidate.port, \" \").concat(candidate.type);\n                        if (candidate.address) {\n                            if (isIPPrivate(candidate.address)) {\n                                str += \" (private)\";\n                            } else {\n                                if (candidate.protocol === \"tcp\" && candidate.tcpType === \"passive\") {\n                                    hasTcp = true;\n                                    str += \" (passive)\";\n                                } else if (candidate.protocol === \"udp\") {\n                                    hasIpv4Udp = true;\n                                }\n                            }\n                        }\n                        this.appendMessage(str);\n                    }\n                    if (prevTrickle) {\n                        prevTrickle(sd, target);\n                    }\n                };\n                if (this.room.engine.pcManager) {\n                    this.room.engine.pcManager.subscriber.onIceCandidateError = (ev)=>{\n                        if (ev instanceof RTCPeerConnectionIceErrorEvent) {\n                            this.appendWarning(\"error with ICE candidate: \".concat(ev.errorCode, \" \").concat(ev.errorText, \" \").concat(ev.url));\n                        }\n                    };\n                }\n            });\n            try {\n                yield this.connect();\n                livekitLogger.info(\"now the room is connected\");\n            } catch (err) {\n                this.appendWarning(\"ports need to be open on firewall in order to connect.\");\n                throw err;\n            }\n            if (!hasTcp) {\n                this.appendWarning(\"Server is not configured for ICE/TCP\");\n            }\n            if (!hasIpv4Udp) {\n                this.appendWarning(\"No public IPv4 UDP candidates were found. Your server is likely not configured correctly\");\n            }\n        });\n    }\n}\nfunction isIPPrivate(address) {\n    const parts = address.split(\".\");\n    if (parts.length === 4) {\n        if (parts[0] === \"10\") {\n            return true;\n        } else if (parts[0] === \"192\" && parts[1] === \"168\") {\n            return true;\n        } else if (parts[0] === \"172\") {\n            const second = parseInt(parts[1], 10);\n            if (second >= 16 && second <= 31) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nclass WebSocketCheck extends Checker {\n    get description() {\n        return \"Connecting to signal connection via WebSocket\";\n    }\n    perform() {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.url.startsWith(\"ws:\") || this.url.startsWith(\"http:\")) {\n                this.appendWarning(\"Server is insecure, clients may block connections to it\");\n            }\n            let signalClient = new SignalClient();\n            const joinRes = yield signalClient.join(this.url, this.token, {\n                autoSubscribe: true,\n                maxRetries: 0,\n                e2eeEnabled: false,\n                websocketTimeout: 15000\n            });\n            this.appendMessage(\"Connected to server, version \".concat(joinRes.serverVersion, \".\"));\n            if (((_a = joinRes.serverInfo) === null || _a === void 0 ? void 0 : _a.edition) === ServerInfo_Edition.Cloud && ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)) {\n                this.appendMessage(\"LiveKit Cloud: \".concat((_c = joinRes.serverInfo) === null || _c === void 0 ? void 0 : _c.region));\n            }\n            yield signalClient.close();\n        });\n    }\n}\nclass ConnectionCheck extends eventsExports.EventEmitter {\n    constructor(url, token){\n        super();\n        this.checkResults = new Map();\n        this.url = url;\n        this.token = token;\n    }\n    getNextCheckId() {\n        const nextId = this.checkResults.size;\n        this.checkResults.set(nextId, {\n            logs: [],\n            status: CheckStatus.IDLE,\n            name: \"\",\n            description: \"\"\n        });\n        return nextId;\n    }\n    updateCheck(checkId, info) {\n        this.checkResults.set(checkId, info);\n        this.emit(\"checkUpdate\", checkId, info);\n    }\n    isSuccess() {\n        return Array.from(this.checkResults.values()).every((r)=>r.status !== CheckStatus.FAILED);\n    }\n    getResults() {\n        return Array.from(this.checkResults.values());\n    }\n    createAndRunCheck(check) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const checkId = this.getNextCheckId();\n            const test = new check(this.url, this.token);\n            const handleUpdate = (info)=>{\n                this.updateCheck(checkId, info);\n            };\n            test.on(\"update\", handleUpdate);\n            const result = yield test.run();\n            test.off(\"update\", handleUpdate);\n            return result;\n        });\n    }\n    checkWebsocket() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(WebSocketCheck);\n        });\n    }\n    checkWebRTC() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(WebRTCCheck);\n        });\n    }\n    checkTURN() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(TURNCheck);\n        });\n    }\n    checkReconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(ReconnectCheck);\n        });\n    }\n    checkPublishAudio() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(PublishAudioCheck);\n        });\n    }\n    checkPublishVideo() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(PublishVideoCheck);\n        });\n    }\n}\n/**\n * Try to analyze the local track to determine the facing mode of a track.\n *\n * @remarks\n * There is no property supported by all browsers to detect whether a video track originated from a user- or environment-facing camera device.\n * For this reason, we use the `facingMode` property when available, but will fall back on a string-based analysis of the device label to determine the facing mode.\n * If both methods fail, the default facing mode will be used.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\n * @experimental\n */ function facingModeFromLocalTrack(localTrack) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    const track = localTrack instanceof LocalTrack ? localTrack.mediaStreamTrack : localTrack;\n    const trackSettings = track.getSettings();\n    let result = {\n        facingMode: (_a = options.defaultFacingMode) !== null && _a !== void 0 ? _a : \"user\",\n        confidence: \"low\"\n    };\n    // 1. Try to get facingMode from track settings.\n    if (\"facingMode\" in trackSettings) {\n        const rawFacingMode = trackSettings.facingMode;\n        livekitLogger.debug(\"rawFacingMode\", {\n            rawFacingMode\n        });\n        if (rawFacingMode && typeof rawFacingMode === \"string\" && isFacingModeValue(rawFacingMode)) {\n            result = {\n                facingMode: rawFacingMode,\n                confidence: \"high\"\n            };\n        }\n    }\n    // 2. If we don't have a high confidence we try to get the facing mode from the device label.\n    if ([\n        \"low\",\n        \"medium\"\n    ].includes(result.confidence)) {\n        livekitLogger.debug(\"Try to get facing mode from device label: (\".concat(track.label, \")\"));\n        const labelAnalysisResult = facingModeFromDeviceLabel(track.label);\n        if (labelAnalysisResult !== undefined) {\n            result = labelAnalysisResult;\n        }\n    }\n    return result;\n}\nconst knownDeviceLabels = new Map([\n    [\n        \"obs virtual camera\",\n        {\n            facingMode: \"environment\",\n            confidence: \"medium\"\n        }\n    ]\n]);\nconst knownDeviceLabelSections = new Map([\n    [\n        \"iphone\",\n        {\n            facingMode: \"environment\",\n            confidence: \"medium\"\n        }\n    ],\n    [\n        \"ipad\",\n        {\n            facingMode: \"environment\",\n            confidence: \"medium\"\n        }\n    ]\n]);\n/**\n * Attempt to analyze the device label to determine the facing mode.\n *\n * @experimental\n */ function facingModeFromDeviceLabel(deviceLabel) {\n    var _a;\n    const label = deviceLabel.trim().toLowerCase();\n    // Empty string is a valid device label but we can't infer anything from it.\n    if (label === \"\") {\n        return undefined;\n    }\n    // Can we match against widely known device labels.\n    if (knownDeviceLabels.has(label)) {\n        return knownDeviceLabels.get(label);\n    }\n    // Can we match against sections of the device label.\n    return (_a = Array.from(knownDeviceLabelSections.entries()).find((_ref)=>{\n        let [section] = _ref;\n        return label.includes(section);\n    })) === null || _a === void 0 ? void 0 : _a[1];\n}\nfunction isFacingModeValue(item) {\n    const allowedValues = [\n        \"user\",\n        \"environment\",\n        \"left\",\n        \"right\"\n    ];\n    return item === undefined || allowedValues.includes(item);\n}\n //# sourceMappingURL=livekit-client.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9saXZla2l0LWNsaWVudC5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLGlCQUFpQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQzdCQSxFQUFFQyxPQUFPLENBQUMsU0FBVUMsQ0FBQztRQUNwQkEsS0FBSyxPQUFPQSxNQUFNLFlBQVksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDRixNQUFNRyxPQUFPQyxJQUFJLENBQUNKLEdBQUdELE9BQU8sQ0FBQyxTQUFVTSxDQUFDO1lBQ3BGLElBQUlBLE1BQU0sYUFBYSxDQUFFQSxDQUFBQSxLQUFLUixDQUFBQSxHQUFJO2dCQUNqQyxJQUFJUyxJQUFJSCxPQUFPSSx3QkFBd0IsQ0FBQ1AsR0FBR0s7Z0JBQzNDRixPQUFPSyxjQUFjLENBQUNYLEdBQUdRLEdBQUdDLEVBQUVHLEdBQUcsR0FBR0gsSUFBSTtvQkFDdkNJLFlBQVk7b0JBQ1pELEtBQUs7d0JBQWMsT0FBT1QsQ0FBQyxDQUFDSyxFQUFFO29CQUFFO2dCQUNqQztZQUNEO1FBQ0Q7SUFDRDtJQUNBLE9BQU9GLE9BQU9RLE1BQU0sQ0FBQ2Q7QUFDdEI7QUFFQSxJQUFJZSxpQkFBaUIsT0FBT0MsZUFBZSxjQUFjQSxhQUFhLE1BQWtCLEdBQWNDLENBQU1BLEdBQUcsT0FBT0MsV0FBVyxjQUFjQSxTQUFTLE9BQU9DLFNBQVMsY0FBY0EsT0FBTyxDQUFDO0FBRTlMLFNBQVNDLHdCQUF5QkMsQ0FBQztJQUNsQyxPQUFPQSxLQUFLQSxFQUFFQyxVQUFVLElBQUloQixPQUFPaUIsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osR0FBRyxhQUFhQSxDQUFDLENBQUMsVUFBVSxHQUFHQTtBQUNqRztBQUVBLElBQUlLLFdBQVc7SUFBQ0MsU0FB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Q2pTLENBQUFBO1FBQy9ELElBQUksQ0FBQys3RixRQUFRLEdBQUcvN0Y7UUFDaEIsT0FBTyt4QixNQUFNQyxRQUFRLENBQUMrcEU7SUFDeEIsRUFBQyxNQUFPLFFBQVFwMkYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxFQUFFLENBQUMsRUFBRTtBQUNoRDtBQUNBLFNBQVM4MUYsa0JBQWtCcG5GLElBQUk7SUFDN0IsTUFBTTJuRixnQkFBZ0I7UUFBQztRQUFRO1FBQWU7UUFBUTtLQUFRO0lBQzlELE9BQU8zbkYsU0FBU2pZLGFBQWE0L0YsY0FBY2hxRSxRQUFRLENBQUMzZDtBQUN0RDtBQUVvOEMsQ0FDcDhDLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9kaXN0L2xpdmVraXQtY2xpZW50LmVzbS5tanM/MzI5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfbWVyZ2VOYW1lc3BhY2VzKG4sIG0pIHtcblx0bS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG5cdFx0ZSAmJiB0eXBlb2YgZSAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkoZSkgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRcdFx0aWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhKGsgaW4gbikpIHtcblx0XHRcdFx0dmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0cmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG52YXIgbG9nbGV2ZWwgPSB7ZXhwb3J0czoge319O1xuXG4vKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKG1vZHVsZSkge1xuICAoZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcblxuICAgIGlmIChtb2R1bGUuZXhwb3J0cykge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbiAgfSkoY29tbW9uanNHbG9iYWwsIGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcbiAgICB2YXIgaXNJRSA9IHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiYgdHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3IgIT09IHVuZGVmaW5lZFR5cGUgJiYgL1RyaWRlbnRcXC98TVNJRSAvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIHZhciBsb2dNZXRob2RzID0gW1widHJhY2VcIiwgXCJkZWJ1Z1wiLCBcImluZm9cIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIl07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJhY2UoKSBkb2Vzbid0IHByaW50IHRoZSBtZXNzYWdlIGluIElFLCBzbyBmb3IgdGhhdCBjYXNlIHdlIG5lZWQgdG8gd3JhcCBpdFxuICAgIGZ1bmN0aW9uIHRyYWNlRm9ySUUoKSB7XG4gICAgICBpZiAoY29uc29sZS5sb2cpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XG4gICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJbiBvbGQgSUUsIG5hdGl2ZSBjb25zb2xlIG1ldGhvZHMgdGhlbXNlbHZlcyBkb24ndCBoYXZlIGFwcGx5KCkuXG4gICAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KGNvbnNvbGUubG9nLCBbY29uc29sZSwgYXJndW1lbnRzXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb25zb2xlLnRyYWNlKSBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09ICd0cmFjZScgJiYgaXNJRSkge1xuICAgICAgICByZXR1cm4gdHJhY2VGb3JJRTtcbiAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xuICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSBpIDwgbGV2ZWwgPyBub29wIDogdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHwgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZGVmYXVsdExldmVsLCBmYWN0b3J5KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY3VycmVudExldmVsO1xuICAgICAgZGVmYXVsdExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICBzdG9yYWdlS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgIHZhciBzdG9yZWRMZXZlbDtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjbGVhclBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPSBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj07IGV4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBVVENcIjtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuICAgICAgc2VsZi5sZXZlbHMgPSB7XG4gICAgICAgIFwiVFJBQ0VcIjogMCxcbiAgICAgICAgXCJERUJVR1wiOiAxLFxuICAgICAgICBcIklORk9cIjogMixcbiAgICAgICAgXCJXQVJOXCI6IDMsXG4gICAgICAgIFwiRVJST1JcIjogNCxcbiAgICAgICAgXCJTSUxFTlRcIjogNVxuICAgICAgfTtcbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3VycmVudExldmVsO1xuICAgICAgfTtcbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgZGVmYXVsdExldmVsID0gbGV2ZWw7XG4gICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNlbGYucmVzZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5zZXRMZXZlbChkZWZhdWx0TGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgY2xlYXJQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgfTtcbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24gKHBlcnNpc3QpIHtcbiAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24gKHBlcnNpc3QpIHtcbiAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3ltYm9sXCIgJiYgdHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIH07XG5cbiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICB2YXIgX2xvZyA9IHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XG4gICAgfTtcblxuICAgIC8vIEVTNiBkZWZhdWx0IGV4cG9ydCwgZm9yIGNvbXBhdGliaWxpdHlcbiAgICBkZWZhdWx0TG9nZ2VyWydkZWZhdWx0J10gPSBkZWZhdWx0TG9nZ2VyO1xuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xuICB9KTtcbn0pKGxvZ2xldmVsKTtcbnZhciBsb2dsZXZlbEV4cG9ydHMgPSBsb2dsZXZlbC5leHBvcnRzO1xuXG52YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gIExvZ0xldmVsW0xvZ0xldmVsW1widHJhY2VcIl0gPSAwXSA9IFwidHJhY2VcIjtcbiAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJkZWJ1Z1wiXSA9IDFdID0gXCJkZWJ1Z1wiO1xuICBMb2dMZXZlbFtMb2dMZXZlbFtcImluZm9cIl0gPSAyXSA9IFwiaW5mb1wiO1xuICBMb2dMZXZlbFtMb2dMZXZlbFtcIndhcm5cIl0gPSAzXSA9IFwid2FyblwiO1xuICBMb2dMZXZlbFtMb2dMZXZlbFtcImVycm9yXCJdID0gNF0gPSBcImVycm9yXCI7XG4gIExvZ0xldmVsW0xvZ0xldmVsW1wic2lsZW50XCJdID0gNV0gPSBcInNpbGVudFwiO1xufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcbnZhciBMb2dnZXJOYW1lcztcbihmdW5jdGlvbiAoTG9nZ2VyTmFtZXMpIHtcbiAgTG9nZ2VyTmFtZXNbXCJEZWZhdWx0XCJdID0gXCJsaXZla2l0XCI7XG4gIExvZ2dlck5hbWVzW1wiUm9vbVwiXSA9IFwibGl2ZWtpdC1yb29tXCI7XG4gIExvZ2dlck5hbWVzW1wiUGFydGljaXBhbnRcIl0gPSBcImxpdmVraXQtcGFydGljaXBhbnRcIjtcbiAgTG9nZ2VyTmFtZXNbXCJUcmFja1wiXSA9IFwibGl2ZWtpdC10cmFja1wiO1xuICBMb2dnZXJOYW1lc1tcIlB1YmxpY2F0aW9uXCJdID0gXCJsaXZla2l0LXRyYWNrLXB1YmxpY2F0aW9uXCI7XG4gIExvZ2dlck5hbWVzW1wiRW5naW5lXCJdID0gXCJsaXZla2l0LWVuZ2luZVwiO1xuICBMb2dnZXJOYW1lc1tcIlNpZ25hbFwiXSA9IFwibGl2ZWtpdC1zaWduYWxcIjtcbiAgTG9nZ2VyTmFtZXNbXCJQQ01hbmFnZXJcIl0gPSBcImxpdmVraXQtcGMtbWFuYWdlclwiO1xuICBMb2dnZXJOYW1lc1tcIlBDVHJhbnNwb3J0XCJdID0gXCJsaXZla2l0LXBjLXRyYW5zcG9ydFwiO1xuICBMb2dnZXJOYW1lc1tcIkUyRUVcIl0gPSBcImxrLWUyZWVcIjtcbn0pKExvZ2dlck5hbWVzIHx8IChMb2dnZXJOYW1lcyA9IHt9KSk7XG5sZXQgbGl2ZWtpdExvZ2dlciA9IGxvZ2xldmVsRXhwb3J0cy5nZXRMb2dnZXIoJ2xpdmVraXQnKTtcbmxpdmVraXRMb2dnZXIuc2V0RGVmYXVsdExldmVsKExvZ0xldmVsLmluZm8pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgY29uc3QgbG9nZ2VyID0gbG9nbGV2ZWxFeHBvcnRzLmdldExvZ2dlcihuYW1lKTtcbiAgbG9nZ2VyLnNldERlZmF1bHRMZXZlbChsaXZla2l0TG9nZ2VyLmdldExldmVsKCkpO1xuICByZXR1cm4gbG9nZ2VyO1xufVxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgaWYgKGxvZ2dlck5hbWUpIHtcbiAgICBsb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VyKGxvZ2dlck5hbWUpLnNldExldmVsKGxldmVsKTtcbiAgfVxuICBmb3IgKGNvbnN0IGxvZ2dlciBvZiBPYmplY3QuZW50cmllcyhsb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VycygpKS5maWx0ZXIoX3JlZiA9PiB7XG4gICAgbGV0IFtsb2dyTmFtZV0gPSBfcmVmO1xuICAgIHJldHVybiBsb2dyTmFtZS5zdGFydHNXaXRoKCdsaXZla2l0Jyk7XG4gIH0pLm1hcChfcmVmMiA9PiB7XG4gICAgbGV0IFssIGxvZ3JdID0gX3JlZjI7XG4gICAgcmV0dXJuIGxvZ3I7XG4gIH0pKSB7XG4gICAgbG9nZ2VyLnNldExldmVsKGxldmVsKTtcbiAgfVxufVxuLyoqXG4gKiB1c2UgdGhpcyB0byBob29rIGludG8gdGhlIGxvZ2dpbmcgZnVuY3Rpb24gdG8gYWxsb3cgc2VuZGluZyBpbnRlcm5hbCBsaXZla2l0IGxvZ3MgdG8gdGhpcmQgcGFydHkgc2VydmljZXNcbiAqIGlmIHNldCwgdGhlIGJyb3dzZXIgbG9ncyB3aWxsIGxvc2UgdGhlaXIgc3RhY2t0cmFjZSBpbmZvcm1hdGlvbiAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCN3cml0aW5nLXBsdWdpbnMpXG4gKi9cbmZ1bmN0aW9uIHNldExvZ0V4dGVuc2lvbihleHRlbnNpb24pIHtcbiAgbGV0IGxvZ2dlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbGl2ZWtpdExvZ2dlcjtcbiAgY29uc3Qgb3JpZ2luYWxGYWN0b3J5ID0gbG9nZ2VyLm1ldGhvZEZhY3Rvcnk7XG4gIGxvZ2dlci5tZXRob2RGYWN0b3J5ID0gKG1ldGhvZE5hbWUsIGNvbmZpZ0xldmVsLCBsb2dnZXJOYW1lKSA9PiB7XG4gICAgY29uc3QgcmF3TWV0aG9kID0gb3JpZ2luYWxGYWN0b3J5KG1ldGhvZE5hbWUsIGNvbmZpZ0xldmVsLCBsb2dnZXJOYW1lKTtcbiAgICBjb25zdCBsb2dMZXZlbCA9IExvZ0xldmVsW21ldGhvZE5hbWVdO1xuICAgIGNvbnN0IG5lZWRMb2cgPSBsb2dMZXZlbCA+PSBjb25maWdMZXZlbCAmJiBsb2dMZXZlbCA8IExvZ0xldmVsLnNpbGVudDtcbiAgICByZXR1cm4gKG1zZywgY29udGV4dCkgPT4ge1xuICAgICAgaWYgKGNvbnRleHQpIHJhd01ldGhvZChtc2csIGNvbnRleHQpO2Vsc2UgcmF3TWV0aG9kKG1zZyk7XG4gICAgICBpZiAobmVlZExvZykge1xuICAgICAgICBleHRlbnNpb24obG9nTGV2ZWwsIG1zZywgY29udGV4dCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgbG9nZ2VyLnNldExldmVsKGxvZ2dlci5nZXRMZXZlbCgpKTsgLy8gQmUgc3VyZSB0byBjYWxsIHNldExldmVsIG1ldGhvZCBpbiBvcmRlciB0byBhcHBseSBwbHVnaW5cbn1cbmxvZ2xldmVsRXhwb3J0cy5nZXRMb2dnZXIoJ2xrLWUyZWUnKTtcblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQXNzZXJ0IHRoYXQgY29uZGl0aW9uIGlzIHRydXRoeSBvciB0aHJvdyBlcnJvciAod2l0aCBtZXNzYWdlKVxuICovXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtc2cpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9ucyAtLSB3ZSB3YW50IHRoZSBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIGJvb2xlYW5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxufVxuY29uc3QgRkxPQVQzMl9NQVggPSAzLjQwMjgyMzQ2NjM4NTI4ODZlMzgsXG4gIEZMT0FUMzJfTUlOID0gLTMuNDAyODIzNDY2Mzg1Mjg4NmUzOCxcbiAgVUlOVDMyX01BWCA9IDB4ZmZmZmZmZmYsXG4gIElOVDMyX01BWCA9IDB4N2ZmZmZmZmYsXG4gIElOVDMyX01JTiA9IC0weDgwMDAwMDAwO1xuLyoqXG4gKiBBc3NlcnQgYSB2YWxpZCBzaWduZWQgcHJvdG9idWYgMzItYml0IGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEludDMyKGFyZykge1xuICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnQgMzI6IFwiICsgdHlwZW9mIGFyZyk7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihhcmcpIHx8IGFyZyA+IElOVDMyX01BWCB8fCBhcmcgPCBJTlQzMl9NSU4pIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcbn1cbi8qKlxuICogQXNzZXJ0IGEgdmFsaWQgdW5zaWduZWQgcHJvdG9idWYgMzItYml0IGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFVJbnQzMihhcmcpIHtcbiAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGFyZykgfHwgYXJnID4gVUlOVDMyX01BWCB8fCBhcmcgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQgMzI6IFwiICsgYXJnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAtLSB3ZSB3YW50IHRoZSBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIHN0cmluZ1xufVxuLyoqXG4gKiBBc3NlcnQgYSB2YWxpZCBwcm90b2J1ZiBmbG9hdCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0RmxvYXQzMihhcmcpIHtcbiAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmxvYXQgMzI6IFwiICsgdHlwZW9mIGFyZyk7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGFyZykpIHJldHVybjtcbiAgaWYgKGFyZyA+IEZMT0FUMzJfTUFYIHx8IGFyZyA8IEZMT0FUMzJfTUlOKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZsb2F0IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmNvbnN0IGVudW1UeXBlU3ltYm9sID0gU3ltYm9sKFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmL2VudW0tdHlwZVwiKTtcbi8qKlxuICogR2V0IHJlZmxlY3Rpb24gaW5mb3JtYXRpb24gZnJvbSBhIGdlbmVyYXRlZCBlbnVtLlxuICogSWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gc29tZXRoaW5nIG90aGVyIHRoYW4gYSBnZW5lcmF0ZWRcbiAqIGVudW0sIGl0IHJhaXNlcyBhbiBlcnJvci5cbiAqL1xuZnVuY3Rpb24gZ2V0RW51bVR5cGUoZW51bU9iamVjdCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGNvbnN0IHQgPSBlbnVtT2JqZWN0W2VudW1UeXBlU3ltYm9sXTtcbiAgYXNzZXJ0KHQsIFwibWlzc2luZyBlbnVtIHR5cGUgb24gZW51bSBvYmplY3RcIik7XG4gIHJldHVybiB0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG59XG4vKipcbiAqIFNldHMgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiBvbiBhIGdlbmVyYXRlZCBlbnVtLlxuICovXG5mdW5jdGlvbiBzZXRFbnVtVHlwZShlbnVtT2JqZWN0LCB0eXBlTmFtZSwgdmFsdWVzLCBvcHQpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBlbnVtT2JqZWN0W2VudW1UeXBlU3ltYm9sXSA9IG1ha2VFbnVtVHlwZSh0eXBlTmFtZSwgdmFsdWVzLm1hcCh2ID0+ICh7XG4gICAgbm86IHYubm8sXG4gICAgbmFtZTogdi5uYW1lLFxuICAgIGxvY2FsTmFtZTogZW51bU9iamVjdFt2Lm5vXVxuICB9KSkpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgRW51bVR5cGUgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzLlxuICovXG5mdW5jdGlvbiBtYWtlRW51bVR5cGUodHlwZU5hbWUsIHZhbHVlcyxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbl9vcHQpIHtcbiAgY29uc3QgbmFtZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBudW1iZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qgbm9ybWFsVmFsdWVzID0gW107XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgLy8gV2UgZG8gbm90IHN1cmZhY2Ugb3B0aW9ucyBhdCB0aGlzIHRpbWVcbiAgICAvLyBjb25zdCB2YWx1ZTogRW51bVZhbHVlSW5mbyA9IHsuLi52LCBvcHRpb25zOiB2Lm9wdGlvbnMgPz8gZW1wdHlSZWFkb25seU9iamVjdH07XG4gICAgY29uc3QgbiA9IG5vcm1hbGl6ZUVudW1WYWx1ZSh2YWx1ZSk7XG4gICAgbm9ybWFsVmFsdWVzLnB1c2gobik7XG4gICAgbmFtZXNbdmFsdWUubmFtZV0gPSBuO1xuICAgIG51bWJlcnNbdmFsdWUubm9dID0gbjtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGVOYW1lLFxuICAgIHZhbHVlczogbm9ybWFsVmFsdWVzLFxuICAgIC8vIFdlIGRvIG5vdCBzdXJmYWNlIG9wdGlvbnMgYXQgdGhpcyB0aW1lXG4gICAgLy8gb3B0aW9uczogb3B0Py5vcHRpb25zID8/IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgZmluZE5hbWUobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWVzW25hbWVdO1xuICAgIH0sXG4gICAgZmluZE51bWJlcihubykge1xuICAgICAgcmV0dXJuIG51bWJlcnNbbm9dO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGVudW0gb2JqZWN0IHdpdGggdGhlIGdpdmVuIHZhbHVlcy5cbiAqIFNldHMgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFrZUVudW0odHlwZU5hbWUsIHZhbHVlcywgb3B0KSB7XG4gIGNvbnN0IGVudW1PYmplY3QgPSB7fTtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICBjb25zdCBuID0gbm9ybWFsaXplRW51bVZhbHVlKHZhbHVlKTtcbiAgICBlbnVtT2JqZWN0W24ubG9jYWxOYW1lXSA9IG4ubm87XG4gICAgZW51bU9iamVjdFtuLm5vXSA9IG4ubG9jYWxOYW1lO1xuICB9XG4gIHNldEVudW1UeXBlKGVudW1PYmplY3QsIHR5cGVOYW1lLCB2YWx1ZXMpO1xuICByZXR1cm4gZW51bU9iamVjdDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVudW1WYWx1ZSh2YWx1ZSkge1xuICBpZiAoXCJsb2NhbE5hbWVcIiBpbiB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSksIHtcbiAgICBsb2NhbE5hbWU6IHZhbHVlLm5hbWVcbiAgfSk7XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIE1lc3NhZ2UgaXMgdGhlIGJhc2UgY2xhc3Mgb2YgZXZlcnkgbWVzc2FnZSwgZ2VuZXJhdGVkLCBvciBjcmVhdGVkIGF0XG4gKiBydW50aW1lLlxuICpcbiAqIEl0IGlzIF9ub3RfIHNhZmUgdG8gZXh0ZW5kIHRoaXMgY2xhc3MuIElmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIG1lc3NhZ2UgYXRcbiAqIHJ1biB0aW1lLCB1c2UgcHJvdG8zLm1ha2VNZXNzYWdlVHlwZSgpLlxuICovXG5jbGFzcyBNZXNzYWdlIHtcbiAgLyoqXG4gICAqIENvbXBhcmUgd2l0aCBhIG1lc3NhZ2Ugb2YgdGhlIHNhbWUgdHlwZS5cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmdldFR5cGUoKS5ydW50aW1lLnV0aWwuZXF1YWxzKHRoaXMuZ2V0VHlwZSgpLCB0aGlzLCBvdGhlcik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGRlZXAgY29weS5cbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiB0aGlzLmdldFR5cGUoKS5ydW50aW1lLnV0aWwuY2xvbmUodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGZyb20gYmluYXJ5IGRhdGEsIG1lcmdpbmcgZmllbGRzLlxuICAgKlxuICAgKiBSZXBlYXRlZCBmaWVsZHMgYXJlIGFwcGVuZGVkLiBNYXAgZW50cmllcyBhcmUgYWRkZWQsIG92ZXJ3cml0aW5nXG4gICAqIGV4aXN0aW5nIGtleXMuXG4gICAqXG4gICAqIElmIGEgbWVzc2FnZSBmaWVsZCBpcyBhbHJlYWR5IHByZXNlbnQsIGl0IHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlXG4gICAqIG5ldyBkYXRhLlxuICAgKi9cbiAgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSxcbiAgICAgIGZvcm1hdCA9IHR5cGUucnVudGltZS5iaW4sXG4gICAgICBvcHQgPSBmb3JtYXQubWFrZVJlYWRPcHRpb25zKG9wdGlvbnMpO1xuICAgIGZvcm1hdC5yZWFkTWVzc2FnZSh0aGlzLCBvcHQucmVhZGVyRmFjdG9yeShieXRlcyksIGJ5dGVzLmJ5dGVMZW5ndGgsIG9wdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGEgbWVzc2FnZSBmcm9tIGEgSlNPTiB2YWx1ZS5cbiAgICovXG4gIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSxcbiAgICAgIGZvcm1hdCA9IHR5cGUucnVudGltZS5qc29uLFxuICAgICAgb3B0ID0gZm9ybWF0Lm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgICBmb3JtYXQucmVhZE1lc3NhZ2UodHlwZSwganNvblZhbHVlLCBvcHQsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBhIG1lc3NhZ2UgZnJvbSBhIEpTT04gc3RyaW5nLlxuICAgKi9cbiAgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIGxldCBqc29uO1xuICAgIHRyeSB7XG4gICAgICBqc29uID0gSlNPTi5wYXJzZShqc29uU3RyaW5nKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIFwiLmNvbmNhdCh0aGlzLmdldFR5cGUoKS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mcm9tSnNvbihqc29uLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBtZXNzYWdlIHRvIGJpbmFyeSBkYXRhLlxuICAgKi9cbiAgdG9CaW5hcnkob3B0aW9ucykge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSxcbiAgICAgIGJpbiA9IHR5cGUucnVudGltZS5iaW4sXG4gICAgICBvcHQgPSBiaW4ubWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKSxcbiAgICAgIHdyaXRlciA9IG9wdC53cml0ZXJGYWN0b3J5KCk7XG4gICAgYmluLndyaXRlTWVzc2FnZSh0aGlzLCB3cml0ZXIsIG9wdCk7XG4gICAgcmV0dXJuIHdyaXRlci5maW5pc2goKTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBtZXNzYWdlIHRvIGEgSlNPTiB2YWx1ZSwgYSBKYXZhU2NyaXB0IHZhbHVlIHRoYXQgY2FuIGJlXG4gICAqIHBhc3NlZCB0byBKU09OLnN0cmluZ2lmeSgpLlxuICAgKi9cbiAgdG9Kc29uKG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksXG4gICAgICBqc29uID0gdHlwZS5ydW50aW1lLmpzb24sXG4gICAgICBvcHQgPSBqc29uLm1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIGpzb24ud3JpdGVNZXNzYWdlKHRoaXMsIG9wdCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBhIEpTT04gc3RyaW5nLlxuICAgKi9cbiAgdG9Kc29uU3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnRvSnNvbihvcHRpb25zKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV0dHlTcGFjZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkZSBmb3Igc2VyaWFsaXphdGlvbiBiZWhhdmlvci4gVGhpcyB3aWxsIGJlIGludm9rZWQgd2hlbiBjYWxsaW5nXG4gICAqIEpTT04uc3RyaW5naWZ5IG9uIHRoaXMgbWVzc2FnZSAoaS5lLiBKU09OLnN0cmluZ2lmeShtc2cpKS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCBub3Qgc2VyaWFsaXplIGdvb2dsZS5wcm90b2J1Zi5Bbnkgd2l0aCBhIHBhY2tlZFxuICAgKiBtZXNzYWdlIGJlY2F1c2UgdGhlIHByb3RvYnVmIEpTT04gZm9ybWF0IHNwZWNpZmllcyB0aGF0IGl0IG5lZWRzIHRvIGJlXG4gICAqIHVucGFja2VkLCBhbmQgdGhpcyBpcyBvbmx5IHBvc3NpYmxlIHdpdGggYSB0eXBlIHJlZ2lzdHJ5IHRvIGxvb2sgdXAgdGhlXG4gICAqIG1lc3NhZ2UgdHlwZS4gIEFzIGEgcmVzdWx0LCBhdHRlbXB0aW5nIHRvIHNlcmlhbGl6ZSBhIG1lc3NhZ2Ugd2l0aCB0aGlzXG4gICAqIHR5cGUgd2lsbCB0aHJvdyBhbiBFcnJvci5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgcHJvdGVjdGVkIGJlY2F1c2UgeW91IHNob3VsZCBub3QgbmVlZCB0byBpbnZva2UgaXRcbiAgICogZGlyZWN0bHkgLS0gaW5zdGVhZCB1c2UgSlNPTi5zdHJpbmdpZnkgb3IgdG9Kc29uU3RyaW5nIGZvclxuICAgKiBzdHJpbmdpZmllZCBKU09OLiAgQWx0ZXJuYXRpdmVseSwgaWYgYWN0dWFsIEpTT04gaXMgZGVzaXJlZCwgeW91IHNob3VsZFxuICAgKiB1c2UgdG9Kc29uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSnNvbih7XG4gICAgICBlbWl0RGVmYXVsdFZhbHVlczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgTWVzc2FnZVR5cGUgb2YgdGhpcyBtZXNzYWdlIC0gYSBzaW5nbGV0b24gdGhhdCByZXByZXNlbnRzXG4gICAqIHRoZSBwcm90b2J1ZiBtZXNzYWdlIGRlY2xhcmF0aW9uIGFuZCBwcm92aWRlcyBtZXRhZGF0YSBmb3IgcmVmbGVjdGlvbi1cbiAgICogYmFzZWQgb3BlcmF0aW9ucy5cbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgLy8gQW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBNZXNzYWdlIF9tdXN0XyBwcm92aWRlIGEgY29tcGxldGUgc3RhdGljXG4gICAgLy8gaW1wbGVtZW50YXRpb24gb2YgTWVzc2FnZVR5cGUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gIH1cbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1lc3NhZ2UgdHlwZSB1c2luZyB0aGUgZ2l2ZW4gcnVudGltZS5cbiAqL1xuZnVuY3Rpb24gbWFrZU1lc3NhZ2VUeXBlKHJ1bnRpbWUsIHR5cGVOYW1lLCBmaWVsZHMsIG9wdCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGxvY2FsTmFtZSA9IChfYSA9IG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5sb2NhbE5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHR5cGVOYW1lLnN1YnN0cmluZyh0eXBlTmFtZS5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcbiAgY29uc3QgdHlwZSA9IHtcbiAgICBbbG9jYWxOYW1lXTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHJ1bnRpbWUudXRpbC5pbml0RmllbGRzKHRoaXMpO1xuICAgICAgcnVudGltZS51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgfVtsb2NhbE5hbWVdO1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YodHlwZS5wcm90b3R5cGUsIG5ldyBNZXNzYWdlKCkpO1xuICBPYmplY3QuYXNzaWduKHR5cGUsIHtcbiAgICBydW50aW1lLFxuICAgIHR5cGVOYW1lLFxuICAgIGZpZWxkczogcnVudGltZS51dGlsLm5ld0ZpZWxkTGlzdChmaWVsZHMpLFxuICAgIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBlcXVhbHMoYSwgYikge1xuICAgICAgcmV0dXJuIHJ1bnRpbWUudXRpbC5lcXVhbHModHlwZSwgYSwgYik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHR5cGU7XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5mdW5jdGlvbiBtYWtlUHJvdG9SdW50aW1lKHN5bnRheCwganNvbiwgYmluLCB1dGlsKSB7XG4gIHJldHVybiB7XG4gICAgc3ludGF4LFxuICAgIGpzb24sXG4gICAgYmluLFxuICAgIHV0aWwsXG4gICAgbWFrZU1lc3NhZ2VUeXBlKHR5cGVOYW1lLCBmaWVsZHMsIG9wdCkge1xuICAgICAgcmV0dXJuIG1ha2VNZXNzYWdlVHlwZSh0aGlzLCB0eXBlTmFtZSwgZmllbGRzLCBvcHQpO1xuICAgIH0sXG4gICAgbWFrZUVudW0sXG4gICAgbWFrZUVudW1UeXBlLFxuICAgIGdldEVudW1UeXBlXG4gIH07XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFNjYWxhciB2YWx1ZSB0eXBlcy4gVGhpcyBpcyBhIHN1YnNldCBvZiBmaWVsZCB0eXBlcyBkZWNsYXJlZCBieSBwcm90b2J1ZlxuICogZW51bSBnb29nbGUucHJvdG9idWYuRmllbGREZXNjcmlwdG9yUHJvdG8uVHlwZSBUaGUgdHlwZXMgR1JPVVAgYW5kIE1FU1NBR0VcbiAqIGFyZSBvbWl0dGVkLCBidXQgdGhlIG51bWVyaWNhbCB2YWx1ZXMgYXJlIGlkZW50aWNhbC5cbiAqL1xudmFyIFNjYWxhclR5cGU7XG4oZnVuY3Rpb24gKFNjYWxhclR5cGUpIHtcbiAgLy8gMCBpcyByZXNlcnZlZCBmb3IgZXJyb3JzLlxuICAvLyBPcmRlciBpcyB3ZWlyZCBmb3IgaGlzdG9yaWNhbCByZWFzb25zLlxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJET1VCTEVcIl0gPSAxXSA9IFwiRE9VQkxFXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZMT0FUXCJdID0gMl0gPSBcIkZMT0FUXCI7XG4gIC8vIE5vdCBaaWdaYWcgZW5jb2RlZC4gIE5lZ2F0aXZlIG51bWJlcnMgdGFrZSAxMCBieXRlcy4gIFVzZSBUWVBFX1NJTlQ2NCBpZlxuICAvLyBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiSU5UNjRcIl0gPSAzXSA9IFwiSU5UNjRcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiVUlOVDY0XCJdID0gNF0gPSBcIlVJTlQ2NFwiO1xuICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UMzIgaWZcbiAgLy8gbmVnYXRpdmUgdmFsdWVzIGFyZSBsaWtlbHkuXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIklOVDMyXCJdID0gNV0gPSBcIklOVDMyXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZJWEVENjRcIl0gPSA2XSA9IFwiRklYRUQ2NFwiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJGSVhFRDMyXCJdID0gN10gPSBcIkZJWEVEMzJcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiQk9PTFwiXSA9IDhdID0gXCJCT09MXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNUUklOR1wiXSA9IDldID0gXCJTVFJJTkdcIjtcbiAgLy8gVGFnLWRlbGltaXRlZCBhZ2dyZWdhdGUuXG4gIC8vIEdyb3VwIHR5cGUgaXMgZGVwcmVjYXRlZCBhbmQgbm90IHN1cHBvcnRlZCBpbiBwcm90bzMuIEhvd2V2ZXIsIFByb3RvM1xuICAvLyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHN0aWxsIGJlIGFibGUgdG8gcGFyc2UgdGhlIGdyb3VwIHdpcmUgZm9ybWF0IGFuZFxuICAvLyB0cmVhdCBncm91cCBmaWVsZHMgYXMgdW5rbm93biBmaWVsZHMuXG4gIC8vIFRZUEVfR1JPVVAgPSAxMCxcbiAgLy8gVFlQRV9NRVNTQUdFID0gMTEsICAvLyBMZW5ndGgtZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cbiAgLy8gTmV3IGluIHZlcnNpb24gMi5cbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiQllURVNcIl0gPSAxMl0gPSBcIkJZVEVTXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQzMlwiXSA9IDEzXSA9IFwiVUlOVDMyXCI7XG4gIC8vIFRZUEVfRU5VTSA9IDE0LFxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTRklYRUQzMlwiXSA9IDE1XSA9IFwiU0ZJWEVEMzJcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVENjRcIl0gPSAxNl0gPSBcIlNGSVhFRDY0XCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNJTlQzMlwiXSA9IDE3XSA9IFwiU0lOVDMyXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNJTlQ2NFwiXSA9IDE4XSA9IFwiU0lOVDY0XCI7XG59KShTY2FsYXJUeXBlIHx8IChTY2FsYXJUeXBlID0ge30pKTtcbi8qKlxuICogSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiBmaWVsZHMgd2l0aCA2NCBiaXQgaW50ZWdyYWwgdHlwZXMgKGludDY0LCB1aW50NjQsXG4gKiBzaW50NjQsIGZpeGVkNjQsIHNmaXhlZDY0KS5cbiAqXG4gKiBUaGlzIGlzIGEgc3Vic2V0IG9mIGdvb2dsZS5wcm90b2J1Zi5GaWVsZE9wdGlvbnMuSlNUeXBlLCB3aGljaCBkZWZpbmVzIEpTX05PUk1BTCxcbiAqIEpTX1NUUklORywgYW5kIEpTX05VTUJFUi4gUHJvdG9idWYtRVMgdXNlcyBCaWdJbnQgYnkgZGVmYXVsdCwgYnV0IHdpbGwgdXNlXG4gKiBTdHJpbmcgaWYgYFtqc3R5cGUgPSBKU19TVFJJTkddYCBpcyBzcGVjaWZpZWQuXG4gKlxuICogYGBgcHJvdG9idWZcbiAqIHVpbnQ2NCBmaWVsZF9hID0gMTsgLy8gQmlnSW50XG4gKiB1aW50NjQgZmllbGRfYiA9IDIgW2pzdHlwZSA9IEpTX05PUk1BTF07IC8vIEJpZ0ludFxuICogdWludDY0IGZpZWxkX2IgPSAyIFtqc3R5cGUgPSBKU19OVU1CRVJdOyAvLyBCaWdJbnRcbiAqIHVpbnQ2NCBmaWVsZF9iID0gMiBbanN0eXBlID0gSlNfU1RSSU5HXTsgLy8gU3RyaW5nXG4gKiBgYGBcbiAqL1xudmFyIExvbmdUeXBlO1xuKGZ1bmN0aW9uIChMb25nVHlwZSkge1xuICAvKipcbiAgICogVXNlIEphdmFTY3JpcHQgQmlnSW50LlxuICAgKi9cbiAgTG9uZ1R5cGVbTG9uZ1R5cGVbXCJCSUdJTlRcIl0gPSAwXSA9IFwiQklHSU5UXCI7XG4gIC8qKlxuICAgKiBVc2UgSmF2YVNjcmlwdCBTdHJpbmcuXG4gICAqXG4gICAqIEZpZWxkIG9wdGlvbiBgW2pzdHlwZSA9IEpTX1NUUklOR11gLlxuICAgKi9cbiAgTG9uZ1R5cGVbTG9uZ1R5cGVbXCJTVFJJTkdcIl0gPSAxXSA9IFwiU1RSSU5HXCI7XG59KShMb25nVHlwZSB8fCAoTG9uZ1R5cGUgPSB7fSkpO1xuXG4vLyBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbi8vIG1ldDpcbi8vXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIGRpc3RyaWJ1dGlvbi5cbi8vICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuLy8gY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbi8vIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vL1xuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuLy8gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4vLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuLy8gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4vLyBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuLy9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBQcm90b2NvbCBCdWZmZXIgY29tcGlsZXIgaXMgb3duZWQgYnkgdGhlIG93bmVyXG4vLyBvZiB0aGUgaW5wdXQgZmlsZSB1c2VkIHdoZW4gZ2VuZXJhdGluZyBpdC4gIFRoaXMgY29kZSBpcyBub3Rcbi8vIHN0YW5kYWxvbmUgYW5kIHJlcXVpcmVzIGEgc3VwcG9ydCBsaWJyYXJ5IHRvIGJlIGxpbmtlZCB3aXRoIGl0LiAgVGhpc1xuLy8gc3VwcG9ydCBsaWJyYXJ5IGlzIGl0c2VsZiBjb3ZlcmVkIGJ5IHRoZSBhYm92ZSBsaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWNvbnN0LEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzICovXG4vKipcbiAqIFJlYWQgYSA2NCBiaXQgdmFyaW50IGFzIHR3byBKUyBudW1iZXJzLlxuICpcbiAqIFJldHVybnMgdHVwbGU6XG4gKiBbMF06IGxvdyBiaXRzXG4gKiBbMV06IGhpZ2ggYml0c1xuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvOGE3MTkyN2Q3NGE0Y2UzNGVmZTJkODc2OWZkYTE5OGY1MmQyMGQxMi9qcy9leHBlcmltZW50YWwvcnVudGltZS9rZXJuZWwvYnVmZmVyX2RlY29kZXIuanMjTDE3NVxuICovXG5mdW5jdGlvbiB2YXJpbnQ2NHJlYWQoKSB7XG4gIGxldCBsb3dCaXRzID0gMDtcbiAgbGV0IGhpZ2hCaXRzID0gMDtcbiAgZm9yIChsZXQgc2hpZnQgPSAwOyBzaGlmdCA8IDI4OyBzaGlmdCArPSA3KSB7XG4gICAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICBsb3dCaXRzIHw9IChiICYgMHg3ZikgPDwgc2hpZnQ7XG4gICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICAgIH1cbiAgfVxuICBsZXQgbWlkZGxlQnl0ZSA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAvLyBsYXN0IGZvdXIgYml0cyBvZiB0aGUgZmlyc3QgMzIgYml0IG51bWJlclxuICBsb3dCaXRzIHw9IChtaWRkbGVCeXRlICYgMHgwZikgPDwgMjg7XG4gIC8vIDMgdXBwZXIgYml0cyBhcmUgcGFydCBvZiB0aGUgbmV4dCAzMiBiaXQgbnVtYmVyXG4gIGhpZ2hCaXRzID0gKG1pZGRsZUJ5dGUgJiAweDcwKSA+PiA0O1xuICBpZiAoKG1pZGRsZUJ5dGUgJiAweDgwKSA9PSAwKSB7XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICByZXR1cm4gW2xvd0JpdHMsIGhpZ2hCaXRzXTtcbiAgfVxuICBmb3IgKGxldCBzaGlmdCA9IDM7IHNoaWZ0IDw9IDMxOyBzaGlmdCArPSA3KSB7XG4gICAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICBoaWdoQml0cyB8PSAoYiAmIDB4N2YpIDw8IHNoaWZ0O1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICByZXR1cm4gW2xvd0JpdHMsIGhpZ2hCaXRzXTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB2YXJpbnRcIik7XG59XG4vKipcbiAqIFdyaXRlIGEgNjQgYml0IHZhcmludCwgZ2l2ZW4gYXMgdHdvIEpTIG51bWJlcnMsIHRvIHRoZSBnaXZlbiBieXRlcyBhcnJheS5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL3dyaXRlci5qcyNMMzQ0XG4gKi9cbmZ1bmN0aW9uIHZhcmludDY0d3JpdGUobG8sIGhpLCBieXRlcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDI4OyBpID0gaSArIDcpIHtcbiAgICBjb25zdCBzaGlmdCA9IGxvID4+PiBpO1xuICAgIGNvbnN0IGhhc05leHQgPSAhKHNoaWZ0ID4+PiA3ID09IDAgJiYgaGkgPT0gMCk7XG4gICAgY29uc3QgYnl0ZSA9IChoYXNOZXh0ID8gc2hpZnQgfCAweDgwIDogc2hpZnQpICYgMHhmZjtcbiAgICBieXRlcy5wdXNoKGJ5dGUpO1xuICAgIGlmICghaGFzTmV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBjb25zdCBzcGxpdEJpdHMgPSBsbyA+Pj4gMjggJiAweDBmIHwgKGhpICYgMHgwNykgPDwgNDtcbiAgY29uc3QgaGFzTW9yZUJpdHMgPSAhKGhpID4+IDMgPT0gMCk7XG4gIGJ5dGVzLnB1c2goKGhhc01vcmVCaXRzID8gc3BsaXRCaXRzIHwgMHg4MCA6IHNwbGl0Qml0cykgJiAweGZmKTtcbiAgaWYgKCFoYXNNb3JlQml0cykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGxldCBpID0gMzsgaSA8IDMxOyBpID0gaSArIDcpIHtcbiAgICBjb25zdCBzaGlmdCA9IGhpID4+PiBpO1xuICAgIGNvbnN0IGhhc05leHQgPSAhKHNoaWZ0ID4+PiA3ID09IDApO1xuICAgIGNvbnN0IGJ5dGUgPSAoaGFzTmV4dCA/IHNoaWZ0IHwgMHg4MCA6IHNoaWZ0KSAmIDB4ZmY7XG4gICAgYnl0ZXMucHVzaChieXRlKTtcbiAgICBpZiAoIWhhc05leHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgYnl0ZXMucHVzaChoaSA+Pj4gMzEgJiAweDAxKTtcbn1cbi8vIGNvbnN0YW50cyBmb3IgYmluYXJ5IG1hdGhcbmNvbnN0IFRXT19QV1JfMzJfREJMID0gMHgxMDAwMDAwMDA7XG4vKipcbiAqIFBhcnNlIGRlY2ltYWwgc3RyaW5nIG9mIDY0IGJpdCBpbnRlZ2VyIHZhbHVlIGFzIHR3byBKUyBudW1iZXJzLlxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmLWphdmFzY3JpcHQvYmxvYi9hNDI4YzU4MjczYWJhZDA3YzY2MDcxZDk3NTNiYzRkMTI4OWRlNDI2L2V4cGVyaW1lbnRhbC9ydW50aW1lL2ludDY0LmpzI0wxMFxuICovXG5mdW5jdGlvbiBpbnQ2NEZyb21TdHJpbmcoZGVjKSB7XG4gIC8vIENoZWNrIGZvciBtaW51cyBzaWduLlxuICBjb25zdCBtaW51cyA9IGRlY1swXSA9PT0gXCItXCI7XG4gIGlmIChtaW51cykge1xuICAgIGRlYyA9IGRlYy5zbGljZSgxKTtcbiAgfVxuICAvLyBXb3JrIDYgZGVjaW1hbCBkaWdpdHMgYXQgYSB0aW1lLCBhY3RpbmcgbGlrZSB3ZSdyZSBjb252ZXJ0aW5nIGJhc2UgMWU2XG4gIC8vIGRpZ2l0cyB0byBiaW5hcnkuIFRoaXMgaXMgc2FmZSB0byBkbyB3aXRoIGZsb2F0aW5nIHBvaW50IG1hdGggYmVjYXVzZVxuICAvLyBOdW1iZXIuaXNTYWZlSW50ZWdlcihBTExfMzJfQklUUyAqIDFlNikgPT0gdHJ1ZS5cbiAgY29uc3QgYmFzZSA9IDFlNjtcbiAgbGV0IGxvd0JpdHMgPSAwO1xuICBsZXQgaGlnaEJpdHMgPSAwO1xuICBmdW5jdGlvbiBhZGQxZTZkaWdpdChiZWdpbiwgZW5kKSB7XG4gICAgLy8gTm90ZTogTnVtYmVyKCcnKSBpcyAwLlxuICAgIGNvbnN0IGRpZ2l0MWU2ID0gTnVtYmVyKGRlYy5zbGljZShiZWdpbiwgZW5kKSk7XG4gICAgaGlnaEJpdHMgKj0gYmFzZTtcbiAgICBsb3dCaXRzID0gbG93Qml0cyAqIGJhc2UgKyBkaWdpdDFlNjtcbiAgICAvLyBDYXJyeSBiaXRzIGZyb20gbG93Qml0cyB0b1xuICAgIGlmIChsb3dCaXRzID49IFRXT19QV1JfMzJfREJMKSB7XG4gICAgICBoaWdoQml0cyA9IGhpZ2hCaXRzICsgKGxvd0JpdHMgLyBUV09fUFdSXzMyX0RCTCB8IDApO1xuICAgICAgbG93Qml0cyA9IGxvd0JpdHMgJSBUV09fUFdSXzMyX0RCTDtcbiAgICB9XG4gIH1cbiAgYWRkMWU2ZGlnaXQoLTI0LCAtMTgpO1xuICBhZGQxZTZkaWdpdCgtMTgsIC0xMik7XG4gIGFkZDFlNmRpZ2l0KC0xMiwgLTYpO1xuICBhZGQxZTZkaWdpdCgtNik7XG4gIHJldHVybiBtaW51cyA/IG5lZ2F0ZShsb3dCaXRzLCBoaWdoQml0cykgOiBuZXdCaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKTtcbn1cbi8qKlxuICogTG9zc2xlc3NseSBjb252ZXJ0cyBhIDY0LWJpdCBzaWduZWQgaW50ZWdlciBpbiAzMjozMiBzcGxpdCByZXByZXNlbnRhdGlvblxuICogaW50byBhIGRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmLWphdmFzY3JpcHQvYmxvYi9hNDI4YzU4MjczYWJhZDA3YzY2MDcxZDk3NTNiYzRkMTI4OWRlNDI2L2V4cGVyaW1lbnRhbC9ydW50aW1lL2ludDY0LmpzI0wxMFxuICovXG5mdW5jdGlvbiBpbnQ2NFRvU3RyaW5nKGxvLCBoaSkge1xuICBsZXQgYml0cyA9IG5ld0JpdHMobG8sIGhpKTtcbiAgLy8gSWYgd2UncmUgdHJlYXRpbmcgdGhlIGlucHV0IGFzIGEgc2lnbmVkIHZhbHVlIGFuZCB0aGUgaGlnaCBiaXQgaXMgc2V0LCBkb1xuICAvLyBhIG1hbnVhbCB0d28ncyBjb21wbGVtZW50IGNvbnZlcnNpb24gYmVmb3JlIHRoZSBkZWNpbWFsIGNvbnZlcnNpb24uXG4gIGNvbnN0IG5lZ2F0aXZlID0gYml0cy5oaSAmIDB4ODAwMDAwMDA7XG4gIGlmIChuZWdhdGl2ZSkge1xuICAgIGJpdHMgPSBuZWdhdGUoYml0cy5sbywgYml0cy5oaSk7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gdUludDY0VG9TdHJpbmcoYml0cy5sbywgYml0cy5oaSk7XG4gIHJldHVybiBuZWdhdGl2ZSA/IFwiLVwiICsgcmVzdWx0IDogcmVzdWx0O1xufVxuLyoqXG4gKiBMb3NzbGVzc2x5IGNvbnZlcnRzIGEgNjQtYml0IHVuc2lnbmVkIGludGVnZXIgaW4gMzI6MzIgc3BsaXQgcmVwcmVzZW50YXRpb25cbiAqIGludG8gYSBkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZnVuY3Rpb24gdUludDY0VG9TdHJpbmcobG8sIGhpKSB7XG4gICh7XG4gICAgbG8sXG4gICAgaGlcbiAgfSA9IHRvVW5zaWduZWQobG8sIGhpKSk7XG4gIC8vIFNraXAgdGhlIGV4cGVuc2l2ZSBjb252ZXJzaW9uIGlmIHRoZSBudW1iZXIgaXMgc21hbGwgZW5vdWdoIHRvIHVzZSB0aGVcbiAgLy8gYnVpbHQtaW4gY29udmVyc2lvbnMuXG4gIC8vIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSID0gMHgwMDFGRkZGRiBGRkZGRkZGRiwgdGh1cyBhbnkgbnVtYmVyIHdpdGhcbiAgLy8gaGlnaEJpdHMgPD0gMHgxRkZGRkYgY2FuIGJlIHNhZmVseSBleHByZXNzZWQgd2l0aCBhIGRvdWJsZSBhbmQgcmV0YWluXG4gIC8vIGludGVnZXIgcHJlY2lzaW9uLlxuICAvLyBQcm92ZW4gYnk6IE51bWJlci5pc1NhZmVJbnRlZ2VyKDB4MUZGRkZGICogMioqMzIgKyAweEZGRkZGRkZGKSA9PSB0cnVlLlxuICBpZiAoaGkgPD0gMHgxRkZGRkYpIHtcbiAgICByZXR1cm4gU3RyaW5nKFRXT19QV1JfMzJfREJMICogaGkgKyBsbyk7XG4gIH1cbiAgLy8gV2hhdCB0aGlzIGNvZGUgaXMgZG9pbmcgaXMgZXNzZW50aWFsbHkgY29udmVydGluZyB0aGUgaW5wdXQgbnVtYmVyIGZyb21cbiAgLy8gYmFzZS0yIHRvIGJhc2UtMWU3LCB3aGljaCBhbGxvd3MgdXMgdG8gcmVwcmVzZW50IHRoZSA2NC1iaXQgcmFuZ2Ugd2l0aFxuICAvLyBvbmx5IDMgKHZlcnkgbGFyZ2UpIGRpZ2l0cy4gVGhvc2UgZGlnaXRzIGFyZSB0aGVuIHRyaXZpYWwgdG8gY29udmVydCB0b1xuICAvLyBhIGJhc2UtMTAgc3RyaW5nLlxuICAvLyBUaGUgbWFnaWMgbnVtYmVycyB1c2VkIGhlcmUgYXJlIC1cbiAgLy8gMl4yNCA9IDE2Nzc3MjE2ID0gKDEsNjc3NzIxNikgaW4gYmFzZS0xZTcuXG4gIC8vIDJeNDggPSAyODE0NzQ5NzY3MTA2NTYgPSAoMiw4MTQ3NDk3LDY3MTA2NTYpIGluIGJhc2UtMWU3LlxuICAvLyBTcGxpdCAzMjozMiByZXByZXNlbnRhdGlvbiBpbnRvIDE2OjI0OjI0IHJlcHJlc2VudGF0aW9uIHNvIG91clxuICAvLyBpbnRlcm1lZGlhdGUgZGlnaXRzIGRvbid0IG92ZXJmbG93LlxuICBjb25zdCBsb3cgPSBsbyAmIDB4RkZGRkZGO1xuICBjb25zdCBtaWQgPSAobG8gPj4+IDI0IHwgaGkgPDwgOCkgJiAweEZGRkZGRjtcbiAgY29uc3QgaGlnaCA9IGhpID4+IDE2ICYgMHhGRkZGO1xuICAvLyBBc3NlbWJsZSBvdXIgdGhyZWUgYmFzZS0xZTcgZGlnaXRzLCBpZ25vcmluZyBjYXJyaWVzLiBUaGUgbWF4aW11bVxuICAvLyB2YWx1ZSBpbiBhIGRpZ2l0IGF0IHRoaXMgc3RlcCBpcyByZXByZXNlbnRhYmxlIGFzIGEgNDgtYml0IGludGVnZXIsIHdoaWNoXG4gIC8vIGNhbiBiZSBzdG9yZWQgaW4gYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICBsZXQgZGlnaXRBID0gbG93ICsgbWlkICogNjc3NzIxNiArIGhpZ2ggKiA2NzEwNjU2O1xuICBsZXQgZGlnaXRCID0gbWlkICsgaGlnaCAqIDgxNDc0OTc7XG4gIGxldCBkaWdpdEMgPSBoaWdoICogMjtcbiAgLy8gQXBwbHkgY2FycmllcyBmcm9tIEEgdG8gQiBhbmQgZnJvbSBCIHRvIEMuXG4gIGNvbnN0IGJhc2UgPSAxMDAwMDAwMDtcbiAgaWYgKGRpZ2l0QSA+PSBiYXNlKSB7XG4gICAgZGlnaXRCICs9IE1hdGguZmxvb3IoZGlnaXRBIC8gYmFzZSk7XG4gICAgZGlnaXRBICU9IGJhc2U7XG4gIH1cbiAgaWYgKGRpZ2l0QiA+PSBiYXNlKSB7XG4gICAgZGlnaXRDICs9IE1hdGguZmxvb3IoZGlnaXRCIC8gYmFzZSk7XG4gICAgZGlnaXRCICU9IGJhc2U7XG4gIH1cbiAgLy8gSWYgZGlnaXRDIGlzIDAsIHRoZW4gd2Ugc2hvdWxkIGhhdmUgcmV0dXJuZWQgaW4gdGhlIHRyaXZpYWwgY29kZSBwYXRoXG4gIC8vIGF0IHRoZSB0b3AgZm9yIG5vbi1zYWZlIGludGVnZXJzLiBHaXZlbiB0aGlzLCB3ZSBjYW4gYXNzdW1lIGJvdGggZGlnaXRCXG4gIC8vIGFuZCBkaWdpdEEgbmVlZCBsZWFkaW5nIHplcm9zLlxuICByZXR1cm4gZGlnaXRDLnRvU3RyaW5nKCkgKyBkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MoZGlnaXRCKSArIGRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyhkaWdpdEEpO1xufVxuZnVuY3Rpb24gdG9VbnNpZ25lZChsbywgaGkpIHtcbiAgcmV0dXJuIHtcbiAgICBsbzogbG8gPj4+IDAsXG4gICAgaGk6IGhpID4+PiAwXG4gIH07XG59XG5mdW5jdGlvbiBuZXdCaXRzKGxvLCBoaSkge1xuICByZXR1cm4ge1xuICAgIGxvOiBsbyB8IDAsXG4gICAgaGk6IGhpIHwgMFxuICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHR3bydzIGNvbXBsaW1lbnQgbmVnYXRpb24gb2YgaW5wdXQuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9CaXR3aXNlX09wZXJhdG9ycyNTaWduZWRfMzItYml0X2ludGVnZXJzXG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShsb3dCaXRzLCBoaWdoQml0cykge1xuICBoaWdoQml0cyA9IH5oaWdoQml0cztcbiAgaWYgKGxvd0JpdHMpIHtcbiAgICBsb3dCaXRzID0gfmxvd0JpdHMgKyAxO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIGxvd0JpdHMgaXMgMCwgdGhlbiBiaXR3aXNlLW5vdCBpcyAweEZGRkZGRkZGLFxuICAgIC8vIGFkZGluZyAxIHRvIHRoYXQsIHJlc3VsdHMgaW4gMHgxMDAwMDAwMDAsIHdoaWNoIGxlYXZlc1xuICAgIC8vIHRoZSBsb3cgYml0cyAweDAgYW5kIHNpbXBseSBhZGRzIG9uZSB0byB0aGUgaGlnaCBiaXRzLlxuICAgIGhpZ2hCaXRzICs9IDE7XG4gIH1cbiAgcmV0dXJuIG5ld0JpdHMobG93Qml0cywgaGlnaEJpdHMpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgZGlnaXQxZTcgd2l0aCBsZWFkaW5nIHplcm9zLlxuICovXG5jb25zdCBkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MgPSBkaWdpdDFlNyA9PiB7XG4gIGNvbnN0IHBhcnRpYWwgPSBTdHJpbmcoZGlnaXQxZTcpO1xuICByZXR1cm4gXCIwMDAwMDAwXCIuc2xpY2UocGFydGlhbC5sZW5ndGgpICsgcGFydGlhbDtcbn07XG4vKipcbiAqIFdyaXRlIGEgMzIgYml0IHZhcmludCwgc2lnbmVkIG9yIHVuc2lnbmVkLiBTYW1lIGFzIGB2YXJpbnQ2NHdyaXRlKDAsIHZhbHVlLCBieXRlcylgXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi8xYjE4ODMzZjRmMmEyZjY4MWY0ZTRhMjVjZGYzYjBhNDMxMTVlYzI2L2pzL2JpbmFyeS9lbmNvZGVyLmpzI0wxNDRcbiAqL1xuZnVuY3Rpb24gdmFyaW50MzJ3cml0ZSh2YWx1ZSwgYnl0ZXMpIHtcbiAgaWYgKHZhbHVlID49IDApIHtcbiAgICAvLyB3cml0ZSB2YWx1ZSBhcyB2YXJpbnQgMzJcbiAgICB3aGlsZSAodmFsdWUgPiAweDdmKSB7XG4gICAgICBieXRlcy5wdXNoKHZhbHVlICYgMHg3ZiB8IDB4ODApO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gNztcbiAgICB9XG4gICAgYnl0ZXMucHVzaCh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcbiAgICAgIGJ5dGVzLnB1c2godmFsdWUgJiAxMjcgfCAxMjgpO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA+PiA3O1xuICAgIH1cbiAgICBieXRlcy5wdXNoKDEpO1xuICB9XG59XG4vKipcbiAqIFJlYWQgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL2J1ZmZlcl9kZWNvZGVyLmpzI0wyMjBcbiAqL1xuZnVuY3Rpb24gdmFyaW50MzJyZWFkKCkge1xuICBsZXQgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICBsZXQgcmVzdWx0ID0gYiAmIDB4N2Y7XG4gIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICByZXN1bHQgfD0gKGIgJiAweDdmKSA8PCA3O1xuICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgMTQ7XG4gIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICByZXN1bHQgfD0gKGIgJiAweDdmKSA8PCAyMTtcbiAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvLyBFeHRyYWN0IG9ubHkgbGFzdCA0IGJpdHNcbiAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICByZXN1bHQgfD0gKGIgJiAweDBmKSA8PCAyODtcbiAgZm9yIChsZXQgcmVhZEJ5dGVzID0gNTsgKGIgJiAweDgwKSAhPT0gMCAmJiByZWFkQnl0ZXMgPCAxMDsgcmVhZEJ5dGVzKyspIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgaWYgKChiICYgMHg4MCkgIT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB2YXJpbnRcIik7XG4gIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gIC8vIFJlc3VsdCBjYW4gaGF2ZSAzMiBiaXRzLCBjb252ZXJ0IGl0IHRvIHVuc2lnbmVkXG4gIHJldHVybiByZXN1bHQgPj4+IDA7XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5mdW5jdGlvbiBtYWtlSW50NjRTdXBwb3J0KCkge1xuICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoOCkpO1xuICAvLyBub3RlIHRoYXQgU2FmYXJpIDE0IGltcGxlbWVudHMgQmlnSW50LCBidXQgbm90IHRoZSBEYXRhVmlldyBtZXRob2RzXG4gIGNvbnN0IG9rID0gdHlwZW9mIEJpZ0ludCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkdi5nZXRCaWdJbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkdi5nZXRCaWdVaW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZHYuc2V0QmlnSW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZHYuc2V0QmlnVWludDY0ID09PSBcImZ1bmN0aW9uXCIgJiYgKHR5cGVvZiBwcm9jZXNzICE9IFwib2JqZWN0XCIgfHwgdHlwZW9mIHByb2Nlc3MuZW52ICE9IFwib2JqZWN0XCIgfHwgcHJvY2Vzcy5lbnYuQlVGX0JJR0lOVF9ESVNBQkxFICE9PSBcIjFcIik7XG4gIGlmIChvaykge1xuICAgIGNvbnN0IE1JTiA9IEJpZ0ludChcIi05MjIzMzcyMDM2ODU0Nzc1ODA4XCIpLFxuICAgICAgTUFYID0gQmlnSW50KFwiOTIyMzM3MjAzNjg1NDc3NTgwN1wiKSxcbiAgICAgIFVNSU4gPSBCaWdJbnQoXCIwXCIpLFxuICAgICAgVU1BWCA9IEJpZ0ludChcIjE4NDQ2NzQ0MDczNzA5NTUxNjE1XCIpO1xuICAgIHJldHVybiB7XG4gICAgICB6ZXJvOiBCaWdJbnQoMCksXG4gICAgICBzdXBwb3J0ZWQ6IHRydWUsXG4gICAgICBwYXJzZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBiaSA9IHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiID8gdmFsdWUgOiBCaWdJbnQodmFsdWUpO1xuICAgICAgICBpZiAoYmkgPiBNQVggfHwgYmkgPCBNSU4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnQ2NCBpbnZhbGlkOiBcIi5jb25jYXQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmk7XG4gICAgICB9LFxuICAgICAgdVBhcnNlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGJpID0gdHlwZW9mIHZhbHVlID09IFwiYmlnaW50XCIgPyB2YWx1ZSA6IEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIGlmIChiaSA+IFVNQVggfHwgYmkgPCBVTUlOKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidWludDY0IGludmFsaWQ6IFwiLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaTtcbiAgICAgIH0sXG4gICAgICBlbmModmFsdWUpIHtcbiAgICAgICAgZHYuc2V0QmlnSW50NjQoMCwgdGhpcy5wYXJzZSh2YWx1ZSksIHRydWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxvOiBkdi5nZXRJbnQzMigwLCB0cnVlKSxcbiAgICAgICAgICBoaTogZHYuZ2V0SW50MzIoNCwgdHJ1ZSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB1RW5jKHZhbHVlKSB7XG4gICAgICAgIGR2LnNldEJpZ0ludDY0KDAsIHRoaXMudVBhcnNlKHZhbHVlKSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbG86IGR2LmdldEludDMyKDAsIHRydWUpLFxuICAgICAgICAgIGhpOiBkdi5nZXRJbnQzMig0LCB0cnVlKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGRlYyhsbywgaGkpIHtcbiAgICAgICAgZHYuc2V0SW50MzIoMCwgbG8sIHRydWUpO1xuICAgICAgICBkdi5zZXRJbnQzMig0LCBoaSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkdi5nZXRCaWdJbnQ2NCgwLCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICB1RGVjKGxvLCBoaSkge1xuICAgICAgICBkdi5zZXRJbnQzMigwLCBsbywgdHJ1ZSk7XG4gICAgICAgIGR2LnNldEludDMyKDQsIGhpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGR2LmdldEJpZ1VpbnQ2NCgwLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGNvbnN0IGFzc2VydEludDY0U3RyaW5nID0gdmFsdWUgPT4gYXNzZXJ0KC9eLT9bMC05XSskLy50ZXN0KHZhbHVlKSwgXCJpbnQ2NCBpbnZhbGlkOiBcIi5jb25jYXQodmFsdWUpKTtcbiAgY29uc3QgYXNzZXJ0VUludDY0U3RyaW5nID0gdmFsdWUgPT4gYXNzZXJ0KC9eWzAtOV0rJC8udGVzdCh2YWx1ZSksIFwidWludDY0IGludmFsaWQ6IFwiLmNvbmNhdCh2YWx1ZSkpO1xuICByZXR1cm4ge1xuICAgIHplcm86IFwiMFwiLFxuICAgIHN1cHBvcnRlZDogZmFsc2UsXG4gICAgcGFyc2UodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnRJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICB1UGFyc2UodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnRVSW50NjRTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgZW5jKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0SW50NjRTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIGludDY0RnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgfSxcbiAgICB1RW5jKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0VUludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgIHJldHVybiBpbnQ2NEZyb21TdHJpbmcodmFsdWUpO1xuICAgIH0sXG4gICAgZGVjKGxvLCBoaSkge1xuICAgICAgcmV0dXJuIGludDY0VG9TdHJpbmcobG8sIGhpKTtcbiAgICB9LFxuICAgIHVEZWMobG8sIGhpKSB7XG4gICAgICByZXR1cm4gdUludDY0VG9TdHJpbmcobG8sIGhpKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBwcm90b0ludDY0ID0gbWFrZUludDY0U3VwcG9ydCgpO1xuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWNvbnN0LG5vLWNhc2UtZGVjbGFyYXRpb25zLEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzICovXG4vKipcbiAqIFByb3RvYnVmIGJpbmFyeSBmb3JtYXQgd2lyZSB0eXBlcy5cbiAqXG4gKiBBIHdpcmUgdHlwZSBwcm92aWRlcyBqdXN0IGVub3VnaCBpbmZvcm1hdGlvbiB0byBmaW5kIHRoZSBsZW5ndGggb2YgdGhlXG4gKiBmb2xsb3dpbmcgdmFsdWUuXG4gKlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9lbmNvZGluZyNzdHJ1Y3R1cmVcbiAqL1xudmFyIFdpcmVUeXBlO1xuKGZ1bmN0aW9uIChXaXJlVHlwZSkge1xuICAvKipcbiAgICogVXNlZCBmb3IgaW50MzIsIGludDY0LCB1aW50MzIsIHVpbnQ2NCwgc2ludDMyLCBzaW50NjQsIGJvb2wsIGVudW1cbiAgICovXG4gIFdpcmVUeXBlW1dpcmVUeXBlW1wiVmFyaW50XCJdID0gMF0gPSBcIlZhcmludFwiO1xuICAvKipcbiAgICogVXNlZCBmb3IgZml4ZWQ2NCwgc2ZpeGVkNjQsIGRvdWJsZS5cbiAgICogQWx3YXlzIDggYnl0ZXMgd2l0aCBsaXR0bGUtZW5kaWFuIGJ5dGUgb3JkZXIuXG4gICAqL1xuICBXaXJlVHlwZVtXaXJlVHlwZVtcIkJpdDY0XCJdID0gMV0gPSBcIkJpdDY0XCI7XG4gIC8qKlxuICAgKiBVc2VkIGZvciBzdHJpbmcsIGJ5dGVzLCBlbWJlZGRlZCBtZXNzYWdlcywgcGFja2VkIHJlcGVhdGVkIGZpZWxkc1xuICAgKlxuICAgKiBPbmx5IHJlcGVhdGVkIG51bWVyaWMgdHlwZXMgKHR5cGVzIHdoaWNoIHVzZSB0aGUgdmFyaW50LCAzMi1iaXQsXG4gICAqIG9yIDY0LWJpdCB3aXJlIHR5cGVzKSBjYW4gYmUgcGFja2VkLiBJbiBwcm90bzMsIHN1Y2ggZmllbGRzIGFyZVxuICAgKiBwYWNrZWQgYnkgZGVmYXVsdC5cbiAgICovXG4gIFdpcmVUeXBlW1dpcmVUeXBlW1wiTGVuZ3RoRGVsaW1pdGVkXCJdID0gMl0gPSBcIkxlbmd0aERlbGltaXRlZFwiO1xuICAvKipcbiAgICogVXNlZCBmb3IgZ3JvdXBzXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBXaXJlVHlwZVtXaXJlVHlwZVtcIlN0YXJ0R3JvdXBcIl0gPSAzXSA9IFwiU3RhcnRHcm91cFwiO1xuICAvKipcbiAgICogVXNlZCBmb3IgZ3JvdXBzXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBXaXJlVHlwZVtXaXJlVHlwZVtcIkVuZEdyb3VwXCJdID0gNF0gPSBcIkVuZEdyb3VwXCI7XG4gIC8qKlxuICAgKiBVc2VkIGZvciBmaXhlZDMyLCBzZml4ZWQzMiwgZmxvYXQuXG4gICAqIEFsd2F5cyA0IGJ5dGVzIHdpdGggbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICAgKi9cbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJCaXQzMlwiXSA9IDVdID0gXCJCaXQzMlwiO1xufSkoV2lyZVR5cGUgfHwgKFdpcmVUeXBlID0ge30pKTtcbmNsYXNzIEJpbmFyeVdyaXRlciB7XG4gIGNvbnN0cnVjdG9yKHRleHRFbmNvZGVyKSB7XG4gICAgLyoqXG4gICAgICogUHJldmlvdXMgZm9yayBzdGF0ZXMuXG4gICAgICovXG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMudGV4dEVuY29kZXIgPSB0ZXh0RW5jb2RlciAhPT0gbnVsbCAmJiB0ZXh0RW5jb2RlciAhPT0gdm9pZCAwID8gdGV4dEVuY29kZXIgOiBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgIHRoaXMuYnVmID0gW107XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgYnl0ZXMgd3JpdHRlbiBhbmQgcmVzZXQgdGhpcyB3cml0ZXIuXG4gICAqL1xuICBmaW5pc2goKSB7XG4gICAgdGhpcy5jaHVua3MucHVzaChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZikpOyAvLyBmbHVzaCB0aGUgYnVmZmVyXG4gICAgbGV0IGxlbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykgbGVuICs9IHRoaXMuY2h1bmtzW2ldLmxlbmd0aDtcbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ5dGVzLnNldCh0aGlzLmNodW5rc1tpXSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSB0aGlzLmNodW5rc1tpXS5sZW5ndGg7XG4gICAgfVxuICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBhIG5ldyBmb3JrIGZvciBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgbGlrZSBhIG1lc3NhZ2VcbiAgICogb3IgYSBwYWNrZWQgcmVwZWF0ZWQgZmllbGQuXG4gICAqXG4gICAqIE11c3QgYmUgam9pbmVkIGxhdGVyIHdpdGggYGpvaW4oKWAuXG4gICAqL1xuICBmb3JrKCkge1xuICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICBjaHVua3M6IHRoaXMuY2h1bmtzLFxuICAgICAgYnVmOiB0aGlzLmJ1ZlxuICAgIH0pO1xuICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgdGhpcy5idWYgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogSm9pbiB0aGUgbGFzdCBmb3JrLiBXcml0ZSBpdHMgbGVuZ3RoIGFuZCBieXRlcywgdGhlblxuICAgKiByZXR1cm4gdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxuICAgKi9cbiAgam9pbigpIHtcbiAgICAvLyBnZXQgY2h1bmsgb2YgZm9ya1xuICAgIGxldCBjaHVuayA9IHRoaXMuZmluaXNoKCk7XG4gICAgLy8gcmVzdG9yZSBwcmV2aW91cyBzdGF0ZVxuICAgIGxldCBwcmV2ID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICBpZiAoIXByZXYpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc3RhdGUsIGZvcmsgc3RhY2sgZW1wdHlcIik7XG4gICAgdGhpcy5jaHVua3MgPSBwcmV2LmNodW5rcztcbiAgICB0aGlzLmJ1ZiA9IHByZXYuYnVmO1xuICAgIC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICB0aGlzLnVpbnQzMihjaHVuay5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZXMgYSB0YWcgKGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlKS5cbiAgICpcbiAgICogRXF1aXZhbGVudCB0byBgdWludDMyKCAoZmllbGRObyA8PCAzIHwgdHlwZSkgPj4+IDAgKWAuXG4gICAqXG4gICAqIEdlbmVyYXRlZCBjb2RlIHNob3VsZCBjb21wdXRlIHRoZSB0YWcgYWhlYWQgb2YgdGltZSBhbmQgY2FsbCBgdWludDMyKClgLlxuICAgKi9cbiAgdGFnKGZpZWxkTm8sIHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKGZpZWxkTm8gPDwgMyB8IHR5cGUpID4+PiAwKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBjaHVuayBvZiByYXcgYnl0ZXMuXG4gICAqL1xuICByYXcoY2h1bmspIHtcbiAgICBpZiAodGhpcy5idWYubGVuZ3RoKSB7XG4gICAgICB0aGlzLmNodW5rcy5wdXNoKG5ldyBVaW50OEFycmF5KHRoaXMuYnVmKSk7XG4gICAgICB0aGlzLmJ1ZiA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgdWludDMyYCB2YWx1ZSwgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cbiAgICovXG4gIHVpbnQzMih2YWx1ZSkge1xuICAgIGFzc2VydFVJbnQzMih2YWx1ZSk7XG4gICAgLy8gd3JpdGUgdmFsdWUgYXMgdmFyaW50IDMyLCBpbmxpbmVkIGZvciBzcGVlZFxuICAgIHdoaWxlICh2YWx1ZSA+IDB4N2YpIHtcbiAgICAgIHRoaXMuYnVmLnB1c2godmFsdWUgJiAweDdmIHwgMHg4MCk7XG4gICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xuICAgIH1cbiAgICB0aGlzLmJ1Zi5wdXNoKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgaW50MzJgIHZhbHVlLCBhIHNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgKi9cbiAgaW50MzIodmFsdWUpIHtcbiAgICBhc3NlcnRJbnQzMih2YWx1ZSk7XG4gICAgdmFyaW50MzJ3cml0ZSh2YWx1ZSwgdGhpcy5idWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBib29sYCB2YWx1ZSwgYSB2YXJpYW50LlxuICAgKi9cbiAgYm9vbCh2YWx1ZSkge1xuICAgIHRoaXMuYnVmLnB1c2godmFsdWUgPyAxIDogMCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYGJ5dGVzYCB2YWx1ZSwgbGVuZ3RoLWRlbGltaXRlZCBhcmJpdHJhcnkgZGF0YS5cbiAgICovXG4gIGJ5dGVzKHZhbHVlKSB7XG4gICAgdGhpcy51aW50MzIodmFsdWUuYnl0ZUxlbmd0aCk7IC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICByZXR1cm4gdGhpcy5yYXcodmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBzdHJpbmdgIHZhbHVlLCBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgY29udmVydGVkIHRvIFVURi04IHRleHQuXG4gICAqL1xuICBzdHJpbmcodmFsdWUpIHtcbiAgICBsZXQgY2h1bmsgPSB0aGlzLnRleHRFbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgdGhpcy51aW50MzIoY2h1bmsuYnl0ZUxlbmd0aCk7IC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBmbG9hdGAgdmFsdWUsIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAqL1xuICBmbG9hdCh2YWx1ZSkge1xuICAgIGFzc2VydEZsb2F0MzIodmFsdWUpO1xuICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEZsb2F0MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYGRvdWJsZWAgdmFsdWUsIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICovXG4gIGRvdWJsZSh2YWx1ZSkge1xuICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEZsb2F0NjQoMCwgdmFsdWUsIHRydWUpO1xuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYGZpeGVkMzJgIHZhbHVlLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgKi9cbiAgZml4ZWQzMih2YWx1ZSkge1xuICAgIGFzc2VydFVJbnQzMih2YWx1ZSk7XG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0VWludDMyKDAsIHZhbHVlLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBzZml4ZWQzMmAgdmFsdWUsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAqL1xuICBzZml4ZWQzMih2YWx1ZSkge1xuICAgIGFzc2VydEludDMyKHZhbHVlKTtcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRJbnQzMigwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgc2ludDMyYCB2YWx1ZSwgYSBzaWduZWQsIHppZ3phZy1lbmNvZGVkIDMyLWJpdCB2YXJpbnQuXG4gICAqL1xuICBzaW50MzIodmFsdWUpIHtcbiAgICBhc3NlcnRJbnQzMih2YWx1ZSk7XG4gICAgLy8gemlnemFnIGVuY29kZVxuICAgIHZhbHVlID0gKHZhbHVlIDw8IDEgXiB2YWx1ZSA+PiAzMSkgPj4+IDA7XG4gICAgdmFyaW50MzJ3cml0ZSh2YWx1ZSwgdGhpcy5idWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBmaXhlZDY0YCB2YWx1ZSwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCA2NC1iaXQgaW50ZWdlci5cbiAgICovXG4gIHNmaXhlZDY0KHZhbHVlKSB7XG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCksXG4gICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlciksXG4gICAgICB0YyA9IHByb3RvSW50NjQuZW5jKHZhbHVlKTtcbiAgICB2aWV3LnNldEludDMyKDAsIHRjLmxvLCB0cnVlKTtcbiAgICB2aWV3LnNldEludDMyKDQsIHRjLmhpLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBmaXhlZDY0YCB2YWx1ZSwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCA2NCBiaXQgaW50ZWdlci5cbiAgICovXG4gIGZpeGVkNjQodmFsdWUpIHtcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg4KSxcbiAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKSxcbiAgICAgIHRjID0gcHJvdG9JbnQ2NC51RW5jKHZhbHVlKTtcbiAgICB2aWV3LnNldEludDMyKDAsIHRjLmxvLCB0cnVlKTtcbiAgICB2aWV3LnNldEludDMyKDQsIHRjLmhpLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBpbnQ2NGAgdmFsdWUsIGEgc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAqL1xuICBpbnQ2NCh2YWx1ZSkge1xuICAgIGxldCB0YyA9IHByb3RvSW50NjQuZW5jKHZhbHVlKTtcbiAgICB2YXJpbnQ2NHdyaXRlKHRjLmxvLCB0Yy5oaSwgdGhpcy5idWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBzaW50NjRgIHZhbHVlLCBhIHNpZ25lZCwgemlnLXphZy1lbmNvZGVkIDY0LWJpdCB2YXJpbnQuXG4gICAqL1xuICBzaW50NjQodmFsdWUpIHtcbiAgICBsZXQgdGMgPSBwcm90b0ludDY0LmVuYyh2YWx1ZSksXG4gICAgICAvLyB6aWd6YWcgZW5jb2RlXG4gICAgICBzaWduID0gdGMuaGkgPj4gMzEsXG4gICAgICBsbyA9IHRjLmxvIDw8IDEgXiBzaWduLFxuICAgICAgaGkgPSAodGMuaGkgPDwgMSB8IHRjLmxvID4+PiAzMSkgXiBzaWduO1xuICAgIHZhcmludDY0d3JpdGUobG8sIGhpLCB0aGlzLmJ1Zik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYHVpbnQ2NGAgdmFsdWUsIGFuIHVuc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAqL1xuICB1aW50NjQodmFsdWUpIHtcbiAgICBsZXQgdGMgPSBwcm90b0ludDY0LnVFbmModmFsdWUpO1xuICAgIHZhcmludDY0d3JpdGUodGMubG8sIHRjLmhpLCB0aGlzLmJ1Zik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmNsYXNzIEJpbmFyeVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKGJ1ZiwgdGV4dERlY29kZXIpIHtcbiAgICB0aGlzLnZhcmludDY0ID0gdmFyaW50NjRyZWFkOyAvLyBkaXJ0eSBjYXN0IGZvciBgdGhpc2BcbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHVpbnQzMmAgZmllbGQsIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgdGhpcy51aW50MzIgPSB2YXJpbnQzMnJlYWQ7IC8vIGRpcnR5IGNhc3QgZm9yIGB0aGlzYCBhbmQgYWNjZXNzIHRvIHByb3RlY3RlZCBgYnVmYFxuICAgIHRoaXMuYnVmID0gYnVmO1xuICAgIHRoaXMubGVuID0gYnVmLmxlbmd0aDtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy52aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gICAgdGhpcy50ZXh0RGVjb2RlciA9IHRleHREZWNvZGVyICE9PSBudWxsICYmIHRleHREZWNvZGVyICE9PSB2b2lkIDAgPyB0ZXh0RGVjb2RlciA6IG5ldyBUZXh0RGVjb2RlcigpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkcyBhIHRhZyAtIGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlLlxuICAgKi9cbiAgdGFnKCkge1xuICAgIGxldCB0YWcgPSB0aGlzLnVpbnQzMigpLFxuICAgICAgZmllbGRObyA9IHRhZyA+Pj4gMyxcbiAgICAgIHdpcmVUeXBlID0gdGFnICYgNztcbiAgICBpZiAoZmllbGRObyA8PSAwIHx8IHdpcmVUeXBlIDwgMCB8fCB3aXJlVHlwZSA+IDUpIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdGFnOiBmaWVsZCBubyBcIiArIGZpZWxkTm8gKyBcIiB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSk7XG4gICAgcmV0dXJuIFtmaWVsZE5vLCB3aXJlVHlwZV07XG4gIH1cbiAgLyoqXG4gICAqIFNraXAgb25lIGVsZW1lbnQgb24gdGhlIHdpcmUgYW5kIHJldHVybiB0aGUgc2tpcHBlZCBkYXRhLlxuICAgKiBTdXBwb3J0cyBXaXJlVHlwZS5TdGFydEdyb3VwIHNpbmNlIHYyLjAuMC1hbHBoYS4yMy5cbiAgICovXG4gIHNraXAod2lyZVR5cGUpIHtcbiAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICBjYXNlIFdpcmVUeXBlLlZhcmludDpcbiAgICAgICAgd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMHg4MCkge1xuICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcbiAgICAgIGNhc2UgV2lyZVR5cGUuQml0NjQ6XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgY2FzZSBXaXJlVHlwZS5CaXQzMjpcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDpcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMudWludDMyKCk7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFdpcmVUeXBlLlN0YXJ0R3JvdXA6XG4gICAgICAgIC8vIEZyb20gZGVzY3JpcHRvci5wcm90bzogR3JvdXAgdHlwZSBpcyBkZXByZWNhdGVkLCBub3Qgc3VwcG9ydGVkIGluIHByb3RvMy5cbiAgICAgICAgLy8gQnV0IHdlIG11c3Qgc3RpbGwgYmUgYWJsZSB0byBwYXJzZSBhbmQgdHJlYXQgYXMgdW5rbm93bi5cbiAgICAgICAgbGV0IHQ7XG4gICAgICAgIHdoaWxlICgodCA9IHRoaXMudGFnKClbMV0pICE9PSBXaXJlVHlwZS5FbmRHcm91cCkge1xuICAgICAgICAgIHRoaXMuc2tpcCh0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbnQgc2tpcCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSk7XG4gICAgfVxuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgcmV0dXJuIHRoaXMuYnVmLnN1YmFycmF5KHN0YXJ0LCB0aGlzLnBvcyk7XG4gIH1cbiAgLyoqXG4gICAqIFRocm93cyBlcnJvciBpZiBwb3NpdGlvbiBpbiBieXRlIGFycmF5IGlzIG91dCBvZiByYW5nZS5cbiAgICovXG4gIGFzc2VydEJvdW5kcygpIHtcbiAgICBpZiAodGhpcy5wb3MgPiB0aGlzLmxlbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJwcmVtYXR1cmUgRU9GXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGludDMyYCBmaWVsZCwgYSBzaWduZWQgMzIgYml0IHZhcmludC5cbiAgICovXG4gIGludDMyKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpIHwgMDtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBzaW50MzJgIGZpZWxkLCBhIHNpZ25lZCwgemlnemFnLWVuY29kZWQgMzItYml0IHZhcmludC5cbiAgICovXG4gIHNpbnQzMigpIHtcbiAgICBsZXQgenplID0gdGhpcy51aW50MzIoKTtcbiAgICAvLyBkZWNvZGUgemlnemFnXG4gICAgcmV0dXJuIHp6ZSA+Pj4gMSBeIC0oenplICYgMSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgaW50NjRgIGZpZWxkLCBhIHNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgKi9cbiAgaW50NjQoKSB7XG4gICAgcmV0dXJuIHByb3RvSW50NjQuZGVjKC4uLnRoaXMudmFyaW50NjQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgdWludDY0YCBmaWVsZCwgYW4gdW5zaWduZWQgNjQtYml0IHZhcmludC5cbiAgICovXG4gIHVpbnQ2NCgpIHtcbiAgICByZXR1cm4gcHJvdG9JbnQ2NC51RGVjKC4uLnRoaXMudmFyaW50NjQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgc2ludDY0YCBmaWVsZCwgYSBzaWduZWQsIHppZy16YWctZW5jb2RlZCA2NC1iaXQgdmFyaW50LlxuICAgKi9cbiAgc2ludDY0KCkge1xuICAgIGxldCBbbG8sIGhpXSA9IHRoaXMudmFyaW50NjQoKTtcbiAgICAvLyBkZWNvZGUgemlnIHphZ1xuICAgIGxldCBzID0gLShsbyAmIDEpO1xuICAgIGxvID0gKGxvID4+PiAxIHwgKGhpICYgMSkgPDwgMzEpIF4gcztcbiAgICBoaSA9IGhpID4+PiAxIF4gcztcbiAgICByZXR1cm4gcHJvdG9JbnQ2NC5kZWMobG8sIGhpKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBib29sYCBmaWVsZCwgYSB2YXJpYW50LlxuICAgKi9cbiAgYm9vbCgpIHtcbiAgICBsZXQgW2xvLCBoaV0gPSB0aGlzLnZhcmludDY0KCk7XG4gICAgcmV0dXJuIGxvICE9PSAwIHx8IGhpICE9PSAwO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGZpeGVkMzJgIGZpZWxkLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgKi9cbiAgZml4ZWQzMigpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldFVpbnQzMigodGhpcy5wb3MgKz0gNCkgLSA0LCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBzZml4ZWQzMmAgZmllbGQsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAqL1xuICBzZml4ZWQzMigpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldEludDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGZpeGVkNjRgIGZpZWxkLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0IGJpdCBpbnRlZ2VyLlxuICAgKi9cbiAgZml4ZWQ2NCgpIHtcbiAgICByZXR1cm4gcHJvdG9JbnQ2NC51RGVjKHRoaXMuc2ZpeGVkMzIoKSwgdGhpcy5zZml4ZWQzMigpKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBmaXhlZDY0YCBmaWVsZCwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCA2NC1iaXQgaW50ZWdlci5cbiAgICovXG4gIHNmaXhlZDY0KCkge1xuICAgIHJldHVybiBwcm90b0ludDY0LmRlYyh0aGlzLnNmaXhlZDMyKCksIHRoaXMuc2ZpeGVkMzIoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgZmxvYXRgIGZpZWxkLCAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICAgKi9cbiAgZmxvYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRGbG9hdDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGRvdWJsZWAgZmllbGQsIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICovXG4gIGRvdWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldEZsb2F0NjQoKHRoaXMucG9zICs9IDgpIC0gOCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgYnl0ZXNgIGZpZWxkLCBsZW5ndGgtZGVsaW1pdGVkIGFyYml0cmFyeSBkYXRhLlxuICAgKi9cbiAgYnl0ZXMoKSB7XG4gICAgbGV0IGxlbiA9IHRoaXMudWludDMyKCksXG4gICAgICBzdGFydCA9IHRoaXMucG9zO1xuICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYHN0cmluZ2AgZmllbGQsIGxlbmd0aC1kZWxpbWl0ZWQgZGF0YSBjb252ZXJ0ZWQgdG8gVVRGLTggdGV4dC5cbiAgICovXG4gIHN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0RGVjb2Rlci5kZWNvZGUodGhpcy5ieXRlcygpKTtcbiAgfVxufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBXcmFwIGEgcHJpbWl0aXZlIG1lc3NhZ2UgZmllbGQgdmFsdWUgaW4gaXRzIGNvcnJlc3BvbmRpbmcgd3JhcHBlclxuICogbWVzc2FnZS4gVGhpcyBmdW5jdGlvbiBpcyBpZGVtcG90ZW50LlxuICovXG5mdW5jdGlvbiB3cmFwRmllbGQodHlwZSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWVzc2FnZSB8fCAhdHlwZS5maWVsZFdyYXBwZXIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHR5cGUuZmllbGRXcmFwcGVyLndyYXBGaWVsZCh2YWx1ZSk7XG59XG4oe1xuICBcImdvb2dsZS5wcm90b2J1Zi5Eb3VibGVWYWx1ZVwiOiBTY2FsYXJUeXBlLkRPVUJMRSxcbiAgXCJnb29nbGUucHJvdG9idWYuRmxvYXRWYWx1ZVwiOiBTY2FsYXJUeXBlLkZMT0FULFxuICBcImdvb2dsZS5wcm90b2J1Zi5JbnQ2NFZhbHVlXCI6IFNjYWxhclR5cGUuSU5UNjQsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLlVJbnQ2NFZhbHVlXCI6IFNjYWxhclR5cGUuVUlOVDY0LFxuICBcImdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlXCI6IFNjYWxhclR5cGUuSU5UMzIsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlXCI6IFNjYWxhclR5cGUuVUlOVDMyLFxuICBcImdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWVcIjogU2NhbGFyVHlwZS5CT09MLFxuICBcImdvb2dsZS5wcm90b2J1Zi5TdHJpbmdWYWx1ZVwiOiBTY2FsYXJUeXBlLlNUUklORyxcbiAgXCJnb29nbGUucHJvdG9idWYuQnl0ZXNWYWx1ZVwiOiBTY2FsYXJUeXBlLkJZVEVTXG59KTtcblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJvdGggc2NhbGFyIHZhbHVlcyBhcmUgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIHNjYWxhckVxdWFscyh0eXBlLCBhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgLy8gVGhpcyBjb3JyZWN0bHkgbWF0Y2hlcyBlcXVhbCB2YWx1ZXMgZXhjZXB0IEJZVEVTIGFuZCAocG9zc2libHkpIDY0LWJpdCBpbnRlZ2Vycy5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBTcGVjaWFsIGNhc2UgQllURVMgLSB3ZSBuZWVkIHRvIGNvbXBhcmUgZWFjaCBieXRlIGluZGl2aWR1YWxseVxuICBpZiAodHlwZSA9PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgaWYgKCEoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHx8ICEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIFNwZWNpYWwgY2FzZSA2NC1iaXQgaW50ZWdlcnMgLSB3ZSBzdXBwb3J0IG51bWJlciwgc3RyaW5nIGFuZCBiaWdpbnQgcmVwcmVzZW50YXRpb24uXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgLy8gTG9vc2UgY29tcGFyaXNvbiB3aWxsIG1hdGNoIGJldHdlZW4gMG4sIDAgYW5kIFwiMFwiLlxuICAgICAgcmV0dXJuIGEgPT0gYjtcbiAgfVxuICAvLyBBbnl0aGluZyB0aGF0IGhhc24ndCBiZWVuIGNhdWdodCBieSBzdHJpY3QgY29tcGFyaXNvbiBvciBzcGVjaWFsIGNhc2VkXG4gIC8vIEJZVEVTIGFuZCA2NC1iaXQgaW50ZWdlcnMgaXMgbm90IGVxdWFsLlxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBnaXZlbiBzY2FsYXIgdHlwZSwgZm9sbG93aW5nXG4gKiBwcm90bzMgc2VtYW50aWNzLlxuICovXG5mdW5jdGlvbiBzY2FsYXJEZWZhdWx0VmFsdWUodHlwZSwgbG9uZ1R5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb24gLS0gYWNjZXB0YWJsZSBzaW5jZSBpdCdzIGNvdmVyZWQgYnkgdGVzdHNcbiAgICAgIHJldHVybiBsb25nVHlwZSA9PSAwID8gcHJvdG9JbnQ2NC56ZXJvIDogXCIwXCI7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICByZXR1cm4gMC4wO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEhhbmRsZXMgSU5UMzIsIFVJTlQzMiwgU0lOVDMyLCBGSVhFRDMyLCBTRklYRUQzMi5cbiAgICAgIC8vIFdlIGRvIG5vdCB1c2UgaW5kaXZpZHVhbCBjYXNlcyB0byBzYXZlIGEgZmV3IGJ5dGVzIGNvZGUgc2l6ZS5cbiAgICAgIHJldHVybiAwO1xuICB9XG59XG4vKipcbiAqIEdldCBpbmZvcm1hdGlvbiBmb3Igd3JpdGluZyBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBSZXR1cm5zIHR1cGxlOlxuICogWzBdOiBhcHByb3ByaWF0ZSBXaXJlVHlwZVxuICogWzFdOiBuYW1lIG9mIHRoZSBhcHByb3ByaWF0ZSBtZXRob2Qgb2YgSUJpbmFyeVdyaXRlclxuICogWzJdOiB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGRlZmF1bHQgdmFsdWUgZm9yIHByb3RvMyBzZW1hbnRpY3NcbiAqXG4gKiBJZiBhcmd1bWVudCBgdmFsdWVgIGlzIG9taXR0ZWQsIFsyXSBpcyBhbHdheXMgZmFsc2UuXG4gKi9cbmZ1bmN0aW9uIHNjYWxhclR5cGVJbmZvKHR5cGUsIHZhbHVlKSB7XG4gIGNvbnN0IGlzVW5kZWZpbmVkID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgbGV0IHdpcmVUeXBlID0gV2lyZVR5cGUuVmFyaW50O1xuICBsZXQgaXNJbnRyaW5zaWNEZWZhdWx0ID0gdmFsdWUgPT09IDA7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIElOVDMyLCBVSU5UMzIsIFNJTlQzMiBhcmUgY292ZXJlZCBieSB0aGUgZGVmYXVsdHNcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8ICF2YWx1ZS5sZW5ndGg7XG4gICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgaXNJbnRyaW5zaWNEZWZhdWx0ID0gdmFsdWUgPT09IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuQml0NjQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDMyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgaXNJbnRyaW5zaWNEZWZhdWx0ID0gaXNVbmRlZmluZWQgfHwgdmFsdWUgPT0gMDsgLy8gTG9vc2UgY29tcGFyaXNvbiBtYXRjaGVzIDBuLCAwIGFuZCBcIjBcIlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7IC8vIExvb3NlIGNvbXBhcmlzb24gbWF0Y2hlcyAwbiwgMCBhbmQgXCIwXCJcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgaXNJbnRyaW5zaWNEZWZhdWx0ID0gaXNVbmRlZmluZWQgfHwgdmFsdWUgPT0gMDsgLy8gTG9vc2UgY29tcGFyaXNvbiBtYXRjaGVzIDBuLCAwIGFuZCBcIjBcIlxuICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQ2NDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8ICF2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuQml0MzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDMyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgaXNJbnRyaW5zaWNEZWZhdWx0ID0gaXNVbmRlZmluZWQgfHwgdmFsdWUgPT0gMDtcbiAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuQml0NjQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgaXNJbnRyaW5zaWNEZWZhdWx0ID0gaXNVbmRlZmluZWQgfHwgdmFsdWUgPT0gMDtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGNvbnN0IG1ldGhvZCA9IFNjYWxhclR5cGVbdHlwZV0udG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIFt3aXJlVHlwZSwgbWV0aG9kLCBpc1VuZGVmaW5lZCB8fCBpc0ludHJpbnNpY0RlZmF1bHRdO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4sIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGwsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24sIG5vLWNhc2UtZGVjbGFyYXRpb25zLCBwcmVmZXItY29uc3QgKi9cbmNvbnN0IHVua25vd25GaWVsZHNTeW1ib2wgPSBTeW1ib2woXCJAYnVmYnVpbGQvcHJvdG9idWYvdW5rbm93bi1maWVsZHNcIik7XG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHBhcnNpbmcgYmluYXJ5IGRhdGEuXG5jb25zdCByZWFkRGVmYXVsdHMgPSB7XG4gIHJlYWRVbmtub3duRmllbGRzOiB0cnVlLFxuICByZWFkZXJGYWN0b3J5OiBieXRlcyA9PiBuZXcgQmluYXJ5UmVhZGVyKGJ5dGVzKVxufTtcbi8vIERlZmF1bHQgb3B0aW9ucyBmb3Igc2VyaWFsaXppbmcgYmluYXJ5IGRhdGEuXG5jb25zdCB3cml0ZURlZmF1bHRzID0ge1xuICB3cml0ZVVua25vd25GaWVsZHM6IHRydWUsXG4gIHdyaXRlckZhY3Rvcnk6ICgpID0+IG5ldyBCaW5hcnlXcml0ZXIoKVxufTtcbmZ1bmN0aW9uIG1ha2VSZWFkT3B0aW9ucyQxKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlYWREZWZhdWx0cyksIG9wdGlvbnMpIDogcmVhZERlZmF1bHRzO1xufVxuZnVuY3Rpb24gbWFrZVdyaXRlT3B0aW9ucyQxKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdyaXRlRGVmYXVsdHMpLCBvcHRpb25zKSA6IHdyaXRlRGVmYXVsdHM7XG59XG5mdW5jdGlvbiBtYWtlQmluYXJ5Rm9ybWF0Q29tbW9uKCkge1xuICByZXR1cm4ge1xuICAgIG1ha2VSZWFkT3B0aW9uczogbWFrZVJlYWRPcHRpb25zJDEsXG4gICAgbWFrZVdyaXRlT3B0aW9uczogbWFrZVdyaXRlT3B0aW9ucyQxLFxuICAgIGxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoX2EgPSBtZXNzYWdlW3Vua25vd25GaWVsZHNTeW1ib2xdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICB9LFxuICAgIGRpc2NhcmRVbmtub3duRmllbGRzKG1lc3NhZ2UpIHtcbiAgICAgIGRlbGV0ZSBtZXNzYWdlW3Vua25vd25GaWVsZHNTeW1ib2xdO1xuICAgIH0sXG4gICAgd3JpdGVVbmtub3duRmllbGRzKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgY29uc3QgbSA9IG1lc3NhZ2U7XG4gICAgICBjb25zdCBjID0gbVt1bmtub3duRmllbGRzU3ltYm9sXTtcbiAgICAgIGlmIChjKSB7XG4gICAgICAgIGZvciAoY29uc3QgZiBvZiBjKSB7XG4gICAgICAgICAgd3JpdGVyLnRhZyhmLm5vLCBmLndpcmVUeXBlKS5yYXcoZi5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb25Vbmtub3duRmllbGQobWVzc2FnZSwgbm8sIHdpcmVUeXBlLCBkYXRhKSB7XG4gICAgICBjb25zdCBtID0gbWVzc2FnZTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShtW3Vua25vd25GaWVsZHNTeW1ib2xdKSkge1xuICAgICAgICBtW3Vua25vd25GaWVsZHNTeW1ib2xdID0gW107XG4gICAgICB9XG4gICAgICBtW3Vua25vd25GaWVsZHNTeW1ib2xdLnB1c2goe1xuICAgICAgICBubyxcbiAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcmVhZE1lc3NhZ2UobWVzc2FnZSwgcmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKTtcbiAgICAgIGNvbnN0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICBjb25zdCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpLFxuICAgICAgICAgIGZpZWxkID0gdHlwZS5maWVsZHMuZmluZChmaWVsZE5vKTtcbiAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMucmVhZFVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgIHRoaXMub25Vbmtub3duRmllbGQobWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFyZ2V0ID0gbWVzc2FnZSxcbiAgICAgICAgICByZXBlYXRlZCA9IGZpZWxkLnJlcGVhdGVkLFxuICAgICAgICAgIGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV07XG4gICAgICAgICAgaWYgKHRhcmdldC5jYXNlICE9IGxvY2FsTmFtZSkge1xuICAgICAgICAgICAgZGVsZXRlIHRhcmdldC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0LmNhc2UgPSBsb2NhbE5hbWU7XG4gICAgICAgICAgbG9jYWxOYW1lID0gXCJ2YWx1ZVwiO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgY29uc3Qgc2NhbGFyVHlwZSA9IGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgPyBTY2FsYXJUeXBlLklOVDMyIDogZmllbGQuVDtcbiAgICAgICAgICAgIGxldCByZWFkID0gcmVhZFNjYWxhciQxO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uIC0tIGFjY2VwdGFibGUgc2luY2UgaXQncyBjb3ZlcmVkIGJ5IHRlc3RzXG4gICAgICAgICAgICBpZiAoZmllbGQua2luZCA9PSBcInNjYWxhclwiICYmIGZpZWxkLkwgPiAwKSB7XG4gICAgICAgICAgICAgIHJlYWQgPSByZWFkU2NhbGFyTFRTdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgbGV0IGFyciA9IHRhcmdldFtsb2NhbE5hbWVdOyAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBhcnJheSwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQgJiYgc2NhbGFyVHlwZSAhPSBTY2FsYXJUeXBlLlNUUklORyAmJiBzY2FsYXJUeXBlICE9IFNjYWxhclR5cGUuQllURVMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZSA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlKSB7XG4gICAgICAgICAgICAgICAgICBhcnIucHVzaChyZWFkKHJlYWRlciwgc2NhbGFyVHlwZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChyZWFkKHJlYWRlciwgc2NhbGFyVHlwZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHJlYWQocmVhZGVyLCBzY2FsYXJUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IGZpZWxkLlQ7XG4gICAgICAgICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgYXJyYXksIG9uZW9mIGNhbm5vdCBjb250YWluIHJlcGVhdGVkIHZhbHVlc1xuICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXS5wdXNoKHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBuZXcgbWVzc2FnZVR5cGUoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRhcmdldFtsb2NhbE5hbWVdIGluc3RhbmNlb2YgTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCB0YXJnZXRbbG9jYWxOYW1lXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbmV3IG1lc3NhZ2VUeXBlKCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIgJiYgIWZpZWxkLm9uZW9mICYmICFmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIudW53cmFwRmllbGQodGFyZ2V0W2xvY2FsTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgbGV0IFttYXBLZXksIG1hcFZhbF0gPSByZWFkTWFwRW50cnkoZmllbGQsIHJlYWRlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBtYXAgb2JqZWN0LCBvbmVvZiBjYW5ub3QgY29udGFpbiByZXBlYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdW21hcEtleV0gPSBtYXBWYWw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbi8vIFJlYWQgYSBtZXNzYWdlLCBhdm9pZGluZyBNZXNzYWdlVHlwZS5mcm9tQmluYXJ5KCkgdG8gcmUtdXNlIHRoZVxuLy8gQmluYXJ5UmVhZE9wdGlvbnMgYW5kIHRoZSBJQmluYXJ5UmVhZGVyLlxuZnVuY3Rpb24gcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgY29uc3QgZm9ybWF0ID0gbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW47XG4gIGZvcm1hdC5yZWFkTWVzc2FnZShtZXNzYWdlLCByZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucyk7XG4gIHJldHVybiBtZXNzYWdlO1xufVxuLy8gUmVhZCBhIG1hcCBmaWVsZCwgZXhwZWN0aW5nIGtleSBmaWVsZCA9IDEsIHZhbHVlIGZpZWxkID0gMlxuZnVuY3Rpb24gcmVhZE1hcEVudHJ5KGZpZWxkLCByZWFkZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgbGVuZ3RoID0gcmVhZGVyLnVpbnQzMigpLFxuICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gIGxldCBrZXksIHZhbDtcbiAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICBsZXQgW2ZpZWxkTm9dID0gcmVhZGVyLnRhZygpO1xuICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBrZXkgPSByZWFkU2NhbGFyJDEocmVhZGVyLCBmaWVsZC5LKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgdmFsID0gcmVhZFNjYWxhciQxKHJlYWRlciwgZmllbGQuVi5UKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICB2YWwgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICB2YWwgPSByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbmV3IGZpZWxkLlYuVCgpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICBsZXQga2V5UmF3ID0gc2NhbGFyRGVmYXVsdFZhbHVlKGZpZWxkLkssIExvbmdUeXBlLkJJR0lOVCk7XG4gICAga2V5ID0gZmllbGQuSyA9PSBTY2FsYXJUeXBlLkJPT0wgPyBrZXlSYXcudG9TdHJpbmcoKSA6IGtleVJhdztcbiAgfVxuICBpZiAodHlwZW9mIGtleSAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBrZXkgIT0gXCJudW1iZXJcIikge1xuICAgIGtleSA9IGtleS50b1N0cmluZygpO1xuICB9XG4gIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIHZhbCA9IHNjYWxhckRlZmF1bHRWYWx1ZShmaWVsZC5WLlQsIExvbmdUeXBlLkJJR0lOVCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgdmFsID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICB2YWwgPSBuZXcgZmllbGQuVi5UKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2tleSwgdmFsXTtcbn1cbi8vIFJlYWQgYSBzY2FsYXIgdmFsdWUsIGJ1dCByZXR1cm4gNjQgYml0IGludGVncmFsIHR5cGVzIChpbnQ2NCwgdWludDY0LFxuLy8gc2ludDY0LCBmaXhlZDY0LCBzZml4ZWQ2NCkgYXMgc3RyaW5nIGluc3RlYWQgb2YgYmlnaW50LlxuZnVuY3Rpb24gcmVhZFNjYWxhckxUU3RyaW5nKHJlYWRlciwgdHlwZSkge1xuICBjb25zdCB2ID0gcmVhZFNjYWxhciQxKHJlYWRlciwgdHlwZSk7XG4gIHJldHVybiB0eXBlb2YgdiA9PSBcImJpZ2ludFwiID8gdi50b1N0cmluZygpIDogdjtcbn1cbi8vIERvZXMgbm90IHVzZSBzY2FsYXJUeXBlSW5mbygpIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG5mdW5jdGlvbiByZWFkU2NhbGFyJDEocmVhZGVyLCB0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICByZXR1cm4gcmVhZGVyLnN0cmluZygpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgcmV0dXJuIHJlYWRlci5ib29sKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgIHJldHVybiByZWFkZXIuZG91YmxlKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgcmV0dXJuIHJlYWRlci5mbG9hdCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICAgIHJldHVybiByZWFkZXIuaW50MzIoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICByZXR1cm4gcmVhZGVyLmludDY0KCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgIHJldHVybiByZWFkZXIudWludDY0KCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgICByZXR1cm4gcmVhZGVyLmZpeGVkNjQoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICByZXR1cm4gcmVhZGVyLmJ5dGVzKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICByZXR1cm4gcmVhZGVyLmZpeGVkMzIoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICByZXR1cm4gcmVhZGVyLnNmaXhlZDMyKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgcmV0dXJuIHJlYWRlci5zZml4ZWQ2NCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICByZXR1cm4gcmVhZGVyLnNpbnQ2NCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgICByZXR1cm4gcmVhZGVyLnVpbnQzMigpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICByZXR1cm4gcmVhZGVyLnNpbnQzMigpO1xuICB9XG59XG5mdW5jdGlvbiB3cml0ZU1hcEVudHJ5KHdyaXRlciwgb3B0aW9ucywgZmllbGQsIGtleSwgdmFsdWUpIHtcbiAgd3JpdGVyLnRhZyhmaWVsZC5ubywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKTtcbiAgd3JpdGVyLmZvcmsoKTtcbiAgLy8gamF2YXNjcmlwdCBvbmx5IGFsbG93cyBudW1iZXIgb3Igc3RyaW5nIGZvciBvYmplY3QgcHJvcGVydGllc1xuICAvLyB3ZSBjb252ZXJ0IGZyb20gb3VyIHJlcHJlc2VudGF0aW9uIHRvIHRoZSBwcm90b2J1ZiB0eXBlXG4gIGxldCBrZXlWYWx1ZSA9IGtleTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gd2UgZGVsaWJlcmF0ZWx5IGhhbmRsZSBqdXN0IHRoZSBzcGVjaWFsIGNhc2VzIGZvciBtYXAga2V5c1xuICBzd2l0Y2ggKGZpZWxkLkspIHtcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICAgIGtleVZhbHVlID0gTnVtYmVyLnBhcnNlSW50KGtleSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIGFzc2VydChrZXkgPT0gXCJ0cnVlXCIgfHwga2V5ID09IFwiZmFsc2VcIik7XG4gICAgICBrZXlWYWx1ZSA9IGtleSA9PSBcInRydWVcIjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIC8vIHdyaXRlIGtleSwgZXhwZWN0aW5nIGtleSBmaWVsZCBudW1iZXIgPSAxXG4gIHdyaXRlU2NhbGFyJDEod3JpdGVyLCBmaWVsZC5LLCAxLCBrZXlWYWx1ZSwgdHJ1ZSk7XG4gIC8vIHdyaXRlIHZhbHVlLCBleHBlY3RpbmcgdmFsdWUgZmllbGQgbnVtYmVyID0gMlxuICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgIHdyaXRlU2NhbGFyJDEod3JpdGVyLCBmaWVsZC5WLlQsIDIsIHZhbHVlLCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICB3cml0ZVNjYWxhciQxKHdyaXRlciwgU2NhbGFyVHlwZS5JTlQzMiwgMiwgdmFsdWUsIHRydWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgIHdyaXRlTWVzc2FnZUZpZWxkKHdyaXRlciwgb3B0aW9ucywgZmllbGQuVi5ULCAyLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgfVxuICB3cml0ZXIuam9pbigpO1xufVxuZnVuY3Rpb24gd3JpdGVNZXNzYWdlRmllbGQod3JpdGVyLCBvcHRpb25zLCB0eXBlLCBmaWVsZE5vLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB3cmFwRmllbGQodHlwZSwgdmFsdWUpO1xuICAgIHdyaXRlci50YWcoZmllbGRObywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5ieXRlcyhtZXNzYWdlLnRvQmluYXJ5KG9wdGlvbnMpKTtcbiAgfVxufVxuZnVuY3Rpb24gd3JpdGVTY2FsYXIkMSh3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlLCBlbWl0SW50cmluc2ljRGVmYXVsdCkge1xuICBsZXQgW3dpcmVUeXBlLCBtZXRob2QsIGlzSW50cmluc2ljRGVmYXVsdF0gPSBzY2FsYXJUeXBlSW5mbyh0eXBlLCB2YWx1ZSk7XG4gIGlmICghaXNJbnRyaW5zaWNEZWZhdWx0IHx8IGVtaXRJbnRyaW5zaWNEZWZhdWx0KSB7XG4gICAgd3JpdGVyLnRhZyhmaWVsZE5vLCB3aXJlVHlwZSlbbWV0aG9kXSh2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkKHdyaXRlciwgdHlwZSwgZmllbGRObywgdmFsdWUpIHtcbiAgaWYgKCF2YWx1ZS5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd3JpdGVyLnRhZyhmaWVsZE5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKTtcbiAgbGV0IFssIG1ldGhvZF0gPSBzY2FsYXJUeXBlSW5mbyh0eXBlKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlclttZXRob2RdKHZhbHVlW2ldKTtcbiAgfVxuICB3cml0ZXIuam9pbigpO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9ucywgcHJlZmVyLWNvbnN0LCBuby1jYXNlLWRlY2xhcmF0aW9ucyAqL1xuZnVuY3Rpb24gbWFrZUJpbmFyeUZvcm1hdFByb3RvMygpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWFrZUJpbmFyeUZvcm1hdENvbW1vbigpKSwge1xuICAgIHdyaXRlTWVzc2FnZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKTtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZS5maWVsZHMuYnlOdW1iZXIoKSkge1xuICAgICAgICBsZXQgdmFsdWUsXG4gICAgICAgICAgLy8gdGhpcyB3aWxsIGJlIG91ciBmaWVsZCB2YWx1ZSwgd2hldGhlciBpdCBpcyBtZW1iZXIgb2YgYSBvbmVvZiBvciByZWd1bGFyIGZpZWxkXG4gICAgICAgICAgcmVwZWF0ZWQgPSBmaWVsZC5yZXBlYXRlZCxcbiAgICAgICAgICBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gICAgICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICAgIGNvbnN0IG9uZW9mID0gbWVzc2FnZVtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdO1xuICAgICAgICAgIGlmIChvbmVvZi5jYXNlICE9PSBsb2NhbE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBmaWVsZCBpcyBub3Qgc2VsZWN0ZWQsIHNraXBcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBvbmVvZi52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IG1lc3NhZ2VbbG9jYWxOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIGxldCBzY2FsYXJUeXBlID0gZmllbGQua2luZCA9PSBcImVudW1cIiA/IFNjYWxhclR5cGUuSU5UMzIgOiBmaWVsZC5UO1xuICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgIGlmIChmaWVsZC5wYWNrZWQpIHtcbiAgICAgICAgICAgICAgICB3cml0ZVBhY2tlZCh3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICB3cml0ZVNjYWxhciQxKHdyaXRlciwgc2NhbGFyVHlwZSwgZmllbGQubm8sIGl0ZW0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB3cml0ZVNjYWxhciQxKHdyaXRlciwgc2NhbGFyVHlwZSwgZmllbGQubm8sIHZhbHVlLCAhIWZpZWxkLm9uZW9mIHx8IGZpZWxkLm9wdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVNZXNzYWdlRmllbGQod3JpdGVyLCBvcHRpb25zLCBmaWVsZC5ULCBmaWVsZC5ubywgaXRlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdyaXRlTWVzc2FnZUZpZWxkKHdyaXRlciwgb3B0aW9ucywgZmllbGQuVCwgZmllbGQubm8sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgd3JpdGVNYXBFbnRyeSh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCBrZXksIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzKSB7XG4gICAgICAgIHRoaXMud3JpdGVVbmtub3duRmllbGRzKG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24sIHByZWZlci1jb25zdCAqL1xuLy8gbG9va3VwIHRhYmxlIGZyb20gYmFzZTY0IGNoYXJhY3RlciB0byBieXRlXG5sZXQgZW5jVGFibGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIi5zcGxpdChcIlwiKTtcbi8vIGxvb2t1cCB0YWJsZSBmcm9tIGJhc2U2NCBjaGFyYWN0ZXIgKmNvZGUqIHRvIGJ5dGUgYmVjYXVzZSBsb29rdXAgYnkgbnVtYmVyIGlzIGZhc3RcbmxldCBkZWNUYWJsZSA9IFtdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNUYWJsZS5sZW5ndGg7IGkrKykgZGVjVGFibGVbZW5jVGFibGVbaV0uY2hhckNvZGVBdCgwKV0gPSBpO1xuLy8gc3VwcG9ydCBiYXNlNjR1cmwgdmFyaWFudHNcbmRlY1RhYmxlW1wiLVwiLmNoYXJDb2RlQXQoMCldID0gZW5jVGFibGUuaW5kZXhPZihcIitcIik7XG5kZWNUYWJsZVtcIl9cIi5jaGFyQ29kZUF0KDApXSA9IGVuY1RhYmxlLmluZGV4T2YoXCIvXCIpO1xuY29uc3QgcHJvdG9CYXNlNjQgPSB7XG4gIC8qKlxuICAgKiBEZWNvZGVzIGEgYmFzZTY0IHN0cmluZyB0byBhIGJ5dGUgYXJyYXkuXG4gICAqXG4gICAqIC0gaWdub3JlcyB3aGl0ZS1zcGFjZSwgaW5jbHVkaW5nIGxpbmUgYnJlYWtzIGFuZCB0YWJzXG4gICAqIC0gYWxsb3dzIGlubmVyIHBhZGRpbmcgKGNhbiBkZWNvZGUgY29uY2F0ZW5hdGVkIGJhc2U2NCBzdHJpbmdzKVxuICAgKiAtIGRvZXMgbm90IHJlcXVpcmUgcGFkZGluZ1xuICAgKiAtIHVuZGVyc3RhbmRzIGJhc2U2NHVybCBlbmNvZGluZzpcbiAgICogICBcIi1cIiBpbnN0ZWFkIG9mIFwiK1wiLFxuICAgKiAgIFwiX1wiIGluc3RlYWQgb2YgXCIvXCIsXG4gICAqICAgbm8gcGFkZGluZ1xuICAgKi9cbiAgZGVjKGJhc2U2NFN0cikge1xuICAgIC8vIGVzdGltYXRlIGJ5dGUgc2l6ZSwgbm90IGFjY291bnRpbmcgZm9yIGlubmVyIHBhZGRpbmcgYW5kIHdoaXRlc3BhY2VcbiAgICBsZXQgZXMgPSBiYXNlNjRTdHIubGVuZ3RoICogMyAvIDQ7XG4gICAgaWYgKGJhc2U2NFN0cltiYXNlNjRTdHIubGVuZ3RoIC0gMl0gPT0gXCI9XCIpIGVzIC09IDI7ZWxzZSBpZiAoYmFzZTY0U3RyW2Jhc2U2NFN0ci5sZW5ndGggLSAxXSA9PSBcIj1cIikgZXMgLT0gMTtcbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShlcyksXG4gICAgICBieXRlUG9zID0gMCxcbiAgICAgIC8vIHBvc2l0aW9uIGluIGJ5dGUgYXJyYXlcbiAgICAgIGdyb3VwUG9zID0gMCxcbiAgICAgIC8vIHBvc2l0aW9uIGluIGJhc2U2NCBncm91cFxuICAgICAgYixcbiAgICAgIC8vIGN1cnJlbnQgYnl0ZVxuICAgICAgcCA9IDA7IC8vIHByZXZpb3VzIGJ5dGVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2U2NFN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgYiA9IGRlY1RhYmxlW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3dpdGNoIChiYXNlNjRTdHJbaV0pIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcbiAgICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgICAgZ3JvdXBQb3MgPSAwO1xuICAgICAgICAgIC8vIHJlc2V0IHN0YXRlIHdoZW4gcGFkZGluZyBmb3VuZFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgY2FzZSBcIlxcdFwiOlxuICAgICAgICAgIGNhc2UgXCIgXCI6XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAvLyBza2lwIHdoaXRlLXNwYWNlLCBhbmQgcGFkZGluZ1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgYmFzZTY0IHN0cmluZy5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZ3JvdXBQb3MpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHAgPSBiO1xuICAgICAgICAgIGdyb3VwUG9zID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGJ5dGVzW2J5dGVQb3MrK10gPSBwIDw8IDIgfCAoYiAmIDQ4KSA+PiA0O1xuICAgICAgICAgIHAgPSBiO1xuICAgICAgICAgIGdyb3VwUG9zID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGJ5dGVzW2J5dGVQb3MrK10gPSAocCAmIDE1KSA8PCA0IHwgKGIgJiA2MCkgPj4gMjtcbiAgICAgICAgICBwID0gYjtcbiAgICAgICAgICBncm91cFBvcyA9IDM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gKHAgJiAzKSA8PCA2IHwgYjtcbiAgICAgICAgICBncm91cFBvcyA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChncm91cFBvcyA9PSAxKSB0aHJvdyBFcnJvcihcImludmFsaWQgYmFzZTY0IHN0cmluZy5cIik7XG4gICAgcmV0dXJuIGJ5dGVzLnN1YmFycmF5KDAsIGJ5dGVQb3MpO1xuICB9LFxuICAvKipcbiAgICogRW5jb2RlIGEgYnl0ZSBhcnJheSB0byBhIGJhc2U2NCBzdHJpbmcuXG4gICAqL1xuICBlbmMoYnl0ZXMpIHtcbiAgICBsZXQgYmFzZTY0ID0gXCJcIixcbiAgICAgIGdyb3VwUG9zID0gMCxcbiAgICAgIC8vIHBvc2l0aW9uIGluIGJhc2U2NCBncm91cFxuICAgICAgYixcbiAgICAgIC8vIGN1cnJlbnQgYnl0ZVxuICAgICAgcCA9IDA7IC8vIGNhcnJ5IG92ZXIgZnJvbSBwcmV2aW91cyBieXRlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgYiA9IGJ5dGVzW2ldO1xuICAgICAgc3dpdGNoIChncm91cFBvcykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW2IgPj4gMl07XG4gICAgICAgICAgcCA9IChiICYgMykgPDwgNDtcbiAgICAgICAgICBncm91cFBvcyA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcCB8IGIgPj4gNF07XG4gICAgICAgICAgcCA9IChiICYgMTUpIDw8IDI7XG4gICAgICAgICAgZ3JvdXBQb3MgPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW3AgfCBiID4+IDZdO1xuICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtiICYgNjNdO1xuICAgICAgICAgIGdyb3VwUG9zID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIG91dHB1dCBwYWRkaW5nXG4gICAgaWYgKGdyb3VwUG9zKSB7XG4gICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcF07XG4gICAgICBiYXNlNjQgKz0gXCI9XCI7XG4gICAgICBpZiAoZ3JvdXBQb3MgPT0gMSkgYmFzZTY0ICs9IFwiPVwiO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9XG59O1xuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgbm8tY2FzZS1kZWNsYXJhdGlvbnMsIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzLEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCAqL1xuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBwYXJzaW5nIEpTT04uXG5jb25zdCBqc29uUmVhZERlZmF1bHRzID0ge1xuICBpZ25vcmVVbmtub3duRmllbGRzOiBmYWxzZVxufTtcbi8vIERlZmF1bHQgb3B0aW9ucyBmb3Igc2VyaWFsaXppbmcgdG8gSlNPTi5cbmNvbnN0IGpzb25Xcml0ZURlZmF1bHRzID0ge1xuICBlbWl0RGVmYXVsdFZhbHVlczogZmFsc2UsXG4gIGVudW1Bc0ludGVnZXI6IGZhbHNlLFxuICB1c2VQcm90b0ZpZWxkTmFtZTogZmFsc2UsXG4gIHByZXR0eVNwYWNlczogMFxufTtcbmZ1bmN0aW9uIG1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBqc29uUmVhZERlZmF1bHRzKSwgb3B0aW9ucykgOiBqc29uUmVhZERlZmF1bHRzO1xufVxuZnVuY3Rpb24gbWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBqc29uV3JpdGVEZWZhdWx0cyksIG9wdGlvbnMpIDoganNvbldyaXRlRGVmYXVsdHM7XG59XG5mdW5jdGlvbiBtYWtlSnNvbkZvcm1hdENvbW1vbihtYWtlV3JpdGVGaWVsZCkge1xuICBjb25zdCB3cml0ZUZpZWxkID0gbWFrZVdyaXRlRmllbGQod3JpdGVFbnVtLCB3cml0ZVNjYWxhcik7XG4gIHJldHVybiB7XG4gICAgbWFrZVJlYWRPcHRpb25zLFxuICAgIG1ha2VXcml0ZU9wdGlvbnMsXG4gICAgcmVhZE1lc3NhZ2UodHlwZSwganNvbiwgb3B0aW9ucywgbWVzc2FnZSkge1xuICAgICAgaWYgKGpzb24gPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGpzb24pIHx8IHR5cGVvZiBqc29uICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBtZXNzYWdlIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQodGhpcy5kZWJ1Zyhqc29uKSkpO1xuICAgICAgfVxuICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IG5ldyB0eXBlKCk7XG4gICAgICBjb25zdCBvbmVvZlNlZW4gPSB7fTtcbiAgICAgIGZvciAoY29uc3QgW2pzb25LZXksIGpzb25WYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoanNvbikpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSB0eXBlLmZpZWxkcy5maW5kSnNvbk5hbWUoanNvbktleSk7XG4gICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBtZXNzYWdlIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIiBmcm9tIEpTT046IGtleSBcXFwiXCIpLmNvbmNhdChqc29uS2V5LCBcIlxcXCIgaXMgdW5rbm93blwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gICAgICAgIGxldCB0YXJnZXQgPSBtZXNzYWdlO1xuICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsICYmIGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIikge1xuICAgICAgICAgICAgLy8gc2VlIGNvbmZvcm1hbmNlIHRlc3QgUmVxdWlyZWQuUHJvdG8zLkpzb25JbnB1dC5PbmVvZkZpZWxkTnVsbHtGaXJzdCxTZWNvbmR9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2VlbiA9IG9uZW9mU2VlbltmaWVsZC5vbmVvZi5sb2NhbE5hbWVdO1xuICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiIGZyb20gSlNPTjogbXVsdGlwbGUga2V5cyBmb3Igb25lb2YgXFxcIlwiKS5jb25jYXQoZmllbGQub25lb2YubmFtZSwgXCJcXFwiIHByZXNlbnQ6IFxcXCJcIikuY29uY2F0KHNlZW4sIFwiXFxcIiwgXFxcIlwiKS5jb25jYXQoanNvbktleSwgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb25lb2ZTZWVuW2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV0gPSBqc29uS2V5O1xuICAgICAgICAgIHRhcmdldCA9IHRhcmdldFtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdID0ge1xuICAgICAgICAgICAgY2FzZTogbG9jYWxOYW1lXG4gICAgICAgICAgfTtcbiAgICAgICAgICBsb2NhbE5hbWUgPSBcInZhbHVlXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uVmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdCh0aGlzLmRlYnVnKGpzb25WYWx1ZSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdGFyZ2V0QXJyYXkgPSB0YXJnZXRbbG9jYWxOYW1lXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGpzb25JdGVtIG9mIGpzb25WYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGpzb25JdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KHRoaXMuZGVidWcoanNvbkl0ZW0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gXCJtYXBcIiBpcyBpbnZhbGlkIGZvciByZXBlYXRlZCBmaWVsZHNcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIHZhbCA9IGZpZWxkLlQuZnJvbUpzb24oanNvbkl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRFbnVtKGZpZWxkLlQsIGpzb25JdGVtLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMpO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFsID0gcmVhZFNjYWxhcihmaWVsZC5ULCBqc29uSXRlbSwgZmllbGQuTCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgbGV0IG0gPSBcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KHRoaXMuZGVidWcoanNvbkl0ZW0pKTtcbiAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbSArPSBcIjogXCIuY29uY2F0KGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0QXJyYXkucHVzaCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5raW5kID09IFwibWFwXCIpIHtcbiAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoanNvblZhbHVlKSB8fCB0eXBlb2YganNvblZhbHVlICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KHRoaXMuZGVidWcoanNvblZhbHVlKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0YXJnZXRNYXAgPSB0YXJnZXRbbG9jYWxOYW1lXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtqc29uTWFwS2V5LCBqc29uTWFwVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGpzb25WYWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChqc29uTWFwVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBmaWVsZCBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IG1hcCB2YWx1ZSBudWxsXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB2YWw7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIHZhbCA9IGZpZWxkLlYuVC5mcm9tSnNvbihqc29uTWFwVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRFbnVtKGZpZWxkLlYuVCwganNvbk1hcFZhbHVlLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMpO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFsID0gcmVhZFNjYWxhcihmaWVsZC5WLlQsIGpzb25NYXBWYWx1ZSwgTG9uZ1R5cGUuQklHSU5UKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgbSA9IFwiY2Fubm90IGRlY29kZSBtYXAgdmFsdWUgZm9yIGZpZWxkIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdCh0aGlzLmRlYnVnKGpzb25WYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtICs9IFwiOiBcIi5jb25jYXQoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0YXJnZXRNYXBbcmVhZFNjYWxhcihmaWVsZC5LLCBmaWVsZC5LID09IFNjYWxhclR5cGUuQk9PTCA/IGpzb25NYXBLZXkgPT0gXCJ0cnVlXCIgPyB0cnVlIDoganNvbk1hcEtleSA9PSBcImZhbHNlXCIgPyBmYWxzZSA6IGpzb25NYXBLZXkgOiBqc29uTWFwS2V5LCBMb25nVHlwZS5CSUdJTlQpLnRvU3RyaW5nKCldID0gdmFsO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBsZXQgbSA9IFwiY2Fubm90IGRlY29kZSBtYXAga2V5IGZvciBmaWVsZCBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQodGhpcy5kZWJ1Zyhqc29uVmFsdWUpKTtcbiAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG0gKz0gXCI6IFwiLmNvbmNhdChlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IGZpZWxkLlQ7XG4gICAgICAgICAgICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwgJiYgbWVzc2FnZVR5cGUudHlwZU5hbWUgIT0gXCJnb29nbGUucHJvdG9idWYuVmFsdWVcIikge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBmaWVsZCBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IG51bGwgaXMgaW52YWxpZCBmb3Igb25lb2YgZmllbGQgXFxcIlwiKS5jb25jYXQoanNvbktleSwgXCJcXFwiXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRhcmdldFtsb2NhbE5hbWVdIGluc3RhbmNlb2YgTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBtZXNzYWdlVHlwZS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIgJiYgIWZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IG1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlci51bndyYXBGaWVsZCh0YXJnZXRbbG9jYWxOYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgY29uc3QgZW51bVZhbHVlID0gcmVhZEVudW0oZmllbGQuVCwganNvblZhbHVlLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMpO1xuICAgICAgICAgICAgICBpZiAoZW51bVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGVudW1WYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHJlYWRTY2FsYXIoZmllbGQuVCwganNvblZhbHVlLCBmaWVsZC5MKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxldCBtID0gXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdCh0aGlzLmRlYnVnKGpzb25WYWx1ZSkpO1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIG0gKz0gXCI6IFwiLmNvbmNhdChlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIHdyaXRlTWVzc2FnZShtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgICBjb25zdCBqc29uID0ge307XG4gICAgICBsZXQgZmllbGQ7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0eXBlLmZpZWxkcy5ieU1lbWJlcigpKSB7XG4gICAgICAgICAgbGV0IGpzb25WYWx1ZTtcbiAgICAgICAgICBpZiAobWVtYmVyLmtpbmQgPT0gXCJvbmVvZlwiKSB7XG4gICAgICAgICAgICBjb25zdCBvbmVvZiA9IG1lc3NhZ2VbbWVtYmVyLmxvY2FsTmFtZV07XG4gICAgICAgICAgICBpZiAob25lb2YudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpZWxkID0gbWVtYmVyLmZpbmRGaWVsZChvbmVvZi5jYXNlKTtcbiAgICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJvbmVvZiBjYXNlIG5vdCBmb3VuZDogXCIgKyBvbmVvZi5jYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAganNvblZhbHVlID0gd3JpdGVGaWVsZChmaWVsZCwgb25lb2YudmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWVsZCA9IG1lbWJlcjtcbiAgICAgICAgICAgIGpzb25WYWx1ZSA9IHdyaXRlRmllbGQoZmllbGQsIG1lc3NhZ2VbZmllbGQubG9jYWxOYW1lXSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChqc29uVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAganNvbltvcHRpb25zLnVzZVByb3RvRmllbGROYW1lID8gZmllbGQubmFtZSA6IGZpZWxkLmpzb25OYW1lXSA9IGpzb25WYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgbSA9IGZpZWxkID8gXCJjYW5ub3QgZW5jb2RlIGZpZWxkIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIHRvIEpTT05cIikgOiBcImNhbm5vdCBlbmNvZGUgbWVzc2FnZSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgdG8gSlNPTlwiKTtcbiAgICAgICAgY29uc3QgciA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0gKyAoci5sZW5ndGggPiAwID8gXCI6IFwiLmNvbmNhdChyKSA6IFwiXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBqc29uO1xuICAgIH0sXG4gICAgcmVhZFNjYWxhcixcbiAgICB3cml0ZVNjYWxhcixcbiAgICBkZWJ1ZzogZGVidWdKc29uVmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlYnVnSnNvblZhbHVlKGpzb24pIHtcbiAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YganNvbikge1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGpzb24pID8gXCJhcnJheVwiIDogXCJvYmplY3RcIjtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4ganNvbi5sZW5ndGggPiAxMDAgPyBcInN0cmluZ1wiIDogXCJcXFwiXCIuY29uY2F0KGpzb24uc3BsaXQoJ1wiJykuam9pbignXFxcXFwiJyksIFwiXFxcIlwiKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFN0cmluZyhqc29uKTtcbiAgfVxufVxuLy8gTWF5IHRocm93IGFuIGVycm9yLiBJZiB0aGUgZXJyb3IgbWVzc2FnZSBpcyBub24tYmxhbmssIGl0IHNob3VsZCBiZSBzaG93bi5cbi8vIEl0IGlzIHVwIHRvIHRoZSBjYWxsZXIgdG8gcHJvdmlkZSBjb250ZXh0LlxuZnVuY3Rpb24gcmVhZFNjYWxhcih0eXBlLCBqc29uLCBsb25nVHlwZSkge1xuICAvLyBldmVyeSB2YWxpZCBjYXNlIGluIHRoZSBzd2l0Y2ggYmVsb3cgcmV0dXJucywgYW5kIGV2ZXJ5IGZhbGxcbiAgLy8gdGhyb3VnaCBpcyByZWdhcmRlZCBhcyBhIGZhaWx1cmUuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIC8vIGZsb2F0LCBkb3VibGU6IEpTT04gdmFsdWUgd2lsbCBiZSBhIG51bWJlciBvciBvbmUgb2YgdGhlIHNwZWNpYWwgc3RyaW5nIHZhbHVlcyBcIk5hTlwiLCBcIkluZmluaXR5XCIsIGFuZCBcIi1JbmZpbml0eVwiLlxuICAgIC8vIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLiBFeHBvbmVudCBub3RhdGlvbiBpcyBhbHNvIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgaWYgKGpzb24gPT09IG51bGwpIHJldHVybiAwLjA7XG4gICAgICBpZiAoanNvbiA9PT0gXCJOYU5cIikgcmV0dXJuIE51bWJlci5OYU47XG4gICAgICBpZiAoanNvbiA9PT0gXCJJbmZpbml0eVwiKSByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgaWYgKGpzb24gPT09IFwiLUluZmluaXR5XCIpIHJldHVybiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICBpZiAoanNvbiA9PT0gXCJcIikge1xuICAgICAgICAvLyBlbXB0eSBzdHJpbmcgaXMgbm90IGEgbnVtYmVyXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBqc29uID09IFwic3RyaW5nXCIgJiYganNvbi50cmltKCkubGVuZ3RoICE9PSBqc29uLmxlbmd0aCkge1xuICAgICAgICAvLyBleHRyYSB3aGl0ZXNwYWNlXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBqc29uICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZsb2F0ID0gTnVtYmVyKGpzb24pO1xuICAgICAgaWYgKE51bWJlci5pc05hTihmbG9hdCkpIHtcbiAgICAgICAgLy8gbm90IGEgbnVtYmVyXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZmxvYXQpKSB7XG4gICAgICAgIC8vIGluZmluaXR5IGFuZCAtaW5maW5pdHkgYXJlIGhhbmRsZWQgYnkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGFib3ZlLCBzbyB0aGlzIGlzIGFuIGVycm9yXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5GTE9BVCkgYXNzZXJ0RmxvYXQzMihmbG9hdCk7XG4gICAgICByZXR1cm4gZmxvYXQ7XG4gICAgLy8gaW50MzIsIGZpeGVkMzIsIHVpbnQzMjogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBudW1iZXIuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgaWYgKGpzb24gPT09IG51bGwpIHJldHVybiAwO1xuICAgICAgbGV0IGludDMyO1xuICAgICAgaWYgKHR5cGVvZiBqc29uID09IFwibnVtYmVyXCIpIGludDMyID0ganNvbjtlbHNlIGlmICh0eXBlb2YganNvbiA9PSBcInN0cmluZ1wiICYmIGpzb24ubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoanNvbi50cmltKCkubGVuZ3RoID09PSBqc29uLmxlbmd0aCkgaW50MzIgPSBOdW1iZXIoanNvbik7XG4gICAgICB9XG4gICAgICBpZiAoaW50MzIgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG4gICAgICBpZiAodHlwZSA9PSBTY2FsYXJUeXBlLlVJTlQzMikgYXNzZXJ0VUludDMyKGludDMyKTtlbHNlIGFzc2VydEludDMyKGludDMyKTtcbiAgICAgIHJldHVybiBpbnQzMjtcbiAgICAvLyBpbnQ2NCwgZml4ZWQ2NCwgdWludDY0OiBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIHN0cmluZy4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgaWYgKGpzb24gPT09IG51bGwpIHJldHVybiBwcm90b0ludDY0Lnplcm87XG4gICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIiAmJiB0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiKSBicmVhaztcbiAgICAgIGNvbnN0IGxvbmcgPSBwcm90b0ludDY0LnBhcnNlKGpzb24pO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgcmV0dXJuIGxvbmdUeXBlID8gbG9uZy50b1N0cmluZygpIDogbG9uZztcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgICAgaWYgKGpzb24gPT09IG51bGwpIHJldHVybiBwcm90b0ludDY0Lnplcm87XG4gICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIiAmJiB0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiKSBicmVhaztcbiAgICAgIGNvbnN0IHVMb25nID0gcHJvdG9JbnQ2NC51UGFyc2UoanNvbik7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICByZXR1cm4gbG9uZ1R5cGUgPyB1TG9uZy50b1N0cmluZygpIDogdUxvbmc7XG4gICAgLy8gYm9vbDpcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIGlmIChqc29uID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwiYm9vbGVhblwiKSBicmVhaztcbiAgICAgIHJldHVybiBqc29uO1xuICAgIC8vIHN0cmluZzpcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgaWYgKGpzb24gPT09IG51bGwpIHJldHVybiBcIlwiO1xuICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gQSBzdHJpbmcgbXVzdCBhbHdheXMgY29udGFpbiBVVEYtOCBlbmNvZGVkIG9yIDctYml0IEFTQ0lJLlxuICAgICAgLy8gV2UgdmFsaWRhdGUgd2l0aCBlbmNvZGVVUklDb21wb25lbnQsIHdoaWNoIGFwcGVhcnMgdG8gYmUgdGhlIGZhc3Rlc3Qgd2lkZWx5IGF2YWlsYWJsZSBvcHRpb24uXG4gICAgICB0cnkge1xuICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoanNvbik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVVRGOFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBqc29uO1xuICAgIC8vIGJ5dGVzOiBKU09OIHZhbHVlIHdpbGwgYmUgdGhlIGRhdGEgZW5jb2RlZCBhcyBhIHN0cmluZyB1c2luZyBzdGFuZGFyZCBiYXNlNjQgZW5jb2Rpbmcgd2l0aCBwYWRkaW5ncy5cbiAgICAvLyBFaXRoZXIgc3RhbmRhcmQgb3IgVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nIHdpdGgvd2l0aG91dCBwYWRkaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgaWYgKGpzb24gPT09IG51bGwgfHwganNvbiA9PT0gXCJcIikgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcInN0cmluZ1wiKSBicmVhaztcbiAgICAgIHJldHVybiBwcm90b0Jhc2U2NC5kZWMoanNvbik7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCk7XG59XG5mdW5jdGlvbiByZWFkRW51bSh0eXBlLCBqc29uLCBpZ25vcmVVbmtub3duRmllbGRzKSB7XG4gIGlmIChqc29uID09PSBudWxsKSB7XG4gICAgLy8gcHJvdG8zIHJlcXVpcmVzIDAgdG8gYmUgZGVmYXVsdCB2YWx1ZSBmb3IgYWxsIGVudW1zXG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2tcbiAgc3dpdGNoICh0eXBlb2YganNvbikge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGpzb24pKSB7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgY29uc3QgdmFsdWUgPSB0eXBlLmZpbmROYW1lKGpzb24pO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nXG4gICAgICBpZiAodmFsdWUgfHwgaWdub3JlVW5rbm93bkZpZWxkcykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLm5vO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBlbnVtIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvbikpKTtcbn1cbmZ1bmN0aW9uIHdyaXRlRW51bSh0eXBlLCB2YWx1ZSwgZW1pdEludHJpbnNpY0RlZmF1bHQsIGVudW1Bc0ludGVnZXIpIHtcbiAgdmFyIF9hO1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT09IDAgJiYgIWVtaXRJbnRyaW5zaWNEZWZhdWx0KSB7XG4gICAgLy8gcHJvdG8zIHJlcXVpcmVzIDAgdG8gYmUgZGVmYXVsdCB2YWx1ZSBmb3IgYWxsIGVudW1zXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoZW51bUFzSW50ZWdlcikge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZS50eXBlTmFtZSA9PSBcImdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWVcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHZhbCA9IHR5cGUuZmluZE51bWJlcih2YWx1ZSk7XG4gIHJldHVybiAoX2EgPSB2YWwgPT09IG51bGwgfHwgdmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWwubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsdWU7IC8vIGlmIHdlIGRvbid0IGtub3cgdGhlIGVudW0gdmFsdWUsIGp1c3QgcmV0dXJuIHRoZSBudW1iZXJcbn1cbmZ1bmN0aW9uIHdyaXRlU2NhbGFyKHR5cGUsIHZhbHVlLCBlbWl0SW50cmluc2ljRGVmYXVsdCkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgLy8gaW50MzIsIGZpeGVkMzIsIHVpbnQzMjogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBudW1iZXIuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSAwIHx8IGVtaXRJbnRyaW5zaWNEZWZhdWx0ID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgLy8gZmxvYXQsIGRvdWJsZTogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgbnVtYmVyIG9yIG9uZSBvZiB0aGUgc3BlY2lhbCBzdHJpbmcgdmFsdWVzIFwiTmFOXCIsIFwiSW5maW5pdHlcIiwgYW5kIFwiLUluZmluaXR5XCIuXG4gICAgLy8gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuIEV4cG9uZW50IG5vdGF0aW9uIGlzIGFsc28gYWNjZXB0ZWQuXG4gICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgIC8vIGFzc2VydEZsb2F0MzIodmFsdWUpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpO1xuICAgICAgaWYgKE51bWJlci5pc05hTih2YWx1ZSkpIHJldHVybiBcIk5hTlwiO1xuICAgICAgaWYgKHZhbHVlID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHJldHVybiBcIkluZmluaXR5XCI7XG4gICAgICBpZiAodmFsdWUgPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkgcmV0dXJuIFwiLUluZmluaXR5XCI7XG4gICAgICByZXR1cm4gdmFsdWUgIT09IDAgfHwgZW1pdEludHJpbnNpY0RlZmF1bHQgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAvLyBzdHJpbmc6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIik7XG4gICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID4gMCB8fCBlbWl0SW50cmluc2ljRGVmYXVsdCA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIC8vIGJvb2w6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwiYm9vbGVhblwiKTtcbiAgICAgIHJldHVybiB2YWx1ZSB8fCBlbWl0SW50cmluc2ljRGVmYXVsdCA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIC8vIEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgc3RyaW5nLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJiaWdpbnRcIiB8fCB0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgICAvLyBXZSB1c2UgaW1wbGljaXQgY29udmVyc2lvbiB3aXRoIGB2YWx1ZSAhPSAwYCB0byBjYXRjaCBib3RoIDBuIGFuZCBcIjBcIlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmV0dXJuIGVtaXRJbnRyaW5zaWNEZWZhdWx0IHx8IHZhbHVlICE9IDAgPyB2YWx1ZS50b1N0cmluZygxMCkgOiB1bmRlZmluZWQ7XG4gICAgLy8gYnl0ZXM6IEpTT04gdmFsdWUgd2lsbCBiZSB0aGUgZGF0YSBlbmNvZGVkIGFzIGEgc3RyaW5nIHVzaW5nIHN0YW5kYXJkIGJhc2U2NCBlbmNvZGluZyB3aXRoIHBhZGRpbmdzLlxuICAgIC8vIEVpdGhlciBzdGFuZGFyZCBvciBVUkwtc2FmZSBiYXNlNjQgZW5jb2Rpbmcgd2l0aC93aXRob3V0IHBhZGRpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICBhc3NlcnQodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KTtcbiAgICAgIHJldHVybiBlbWl0SW50cmluc2ljRGVmYXVsdCB8fCB2YWx1ZS5ieXRlTGVuZ3RoID4gMCA/IHByb3RvQmFzZTY0LmVuYyh2YWx1ZSkgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNhc2UtZGVjbGFyYXRpb25zLCBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGwsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQgKi9cbmZ1bmN0aW9uIG1ha2VKc29uRm9ybWF0UHJvdG8zKCkge1xuICByZXR1cm4gbWFrZUpzb25Gb3JtYXRDb21tb24oKHdyaXRlRW51bSwgd3JpdGVTY2FsYXIpID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gd3JpdGVGaWVsZChmaWVsZCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChmaWVsZC5raW5kID09IFwibWFwXCIpIHtcbiAgICAgICAgY29uc3QganNvbk9iaiA9IHt9O1xuICAgICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsID0gd3JpdGVTY2FsYXIoZmllbGQuVi5ULCBlbnRyeVZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgYXNzZXJ0KHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IHZhbDsgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxuICAgICAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gZW50cnlWYWx1ZS50b0pzb24ob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgY29uc3QgZW51bVR5cGUgPSBmaWVsZC5WLlQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeUtleSwgZW50cnlWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgIGFzc2VydChlbnRyeVZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGVudHJ5VmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHdyaXRlRW51bShlbnVtVHlwZSwgZW50cnlWYWx1ZSwgdHJ1ZSwgb3B0aW9ucy5lbnVtQXNJbnRlZ2VyKTtcbiAgICAgICAgICAgICAgYXNzZXJ0KHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IHZhbDsgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMgfHwgT2JqZWN0LmtleXMoanNvbk9iaikubGVuZ3RoID4gMCA/IGpzb25PYmogOiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgICAgIGNvbnN0IGpzb25BcnIgPSBbXTtcbiAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBqc29uQXJyLnB1c2god3JpdGVTY2FsYXIoZmllbGQuVCwgdmFsdWVbaV0sIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGpzb25BcnIucHVzaCh3cml0ZUVudW0oZmllbGQuVCwgdmFsdWVbaV0sIHRydWUsIG9wdGlvbnMuZW51bUFzSW50ZWdlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAganNvbkFyci5wdXNoKHdyYXBGaWVsZChmaWVsZC5ULCB2YWx1ZVtpXSkudG9Kc29uKG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzIHx8IGpzb25BcnIubGVuZ3RoID4gMCA/IGpzb25BcnIgOiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVTY2FsYXIoZmllbGQuVCwgdmFsdWUsICEhZmllbGQub25lb2YgfHwgZmllbGQub3B0IHx8IG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMpO1xuICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVFbnVtKGZpZWxkLlQsIHZhbHVlLCAhIWZpZWxkLm9uZW9mIHx8IGZpZWxkLm9wdCB8fCBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzLCBvcHRpb25zLmVudW1Bc0ludGVnZXIpO1xuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHdyYXBGaWVsZChmaWVsZC5ULCB2YWx1ZSkudG9Kc29uKG9wdGlvbnMpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4sQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCxuby1jYXNlLWRlY2xhcmF0aW9ucyAqL1xuZnVuY3Rpb24gbWFrZVV0aWxDb21tb24oKSB7XG4gIHJldHVybiB7XG4gICAgc2V0RW51bVR5cGUsXG4gICAgaW5pdFBhcnRpYWwoc291cmNlLCB0YXJnZXQpIHtcbiAgICAgIGlmIChzb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0gdGFyZ2V0LmdldFR5cGUoKTtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkpIHtcbiAgICAgICAgY29uc3QgbG9jYWxOYW1lID0gbWVtYmVyLmxvY2FsTmFtZSxcbiAgICAgICAgICB0ID0gdGFyZ2V0LFxuICAgICAgICAgIHMgPSBzb3VyY2U7XG4gICAgICAgIGlmIChzW2xvY2FsTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobWVtYmVyLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIFwib25lb2ZcIjpcbiAgICAgICAgICAgIGNvbnN0IHNrID0gc1tsb2NhbE5hbWVdLmNhc2U7XG4gICAgICAgICAgICBpZiAoc2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUZpZWxkID0gbWVtYmVyLmZpbmRGaWVsZChzayk7XG4gICAgICAgICAgICBsZXQgdmFsID0gc1tsb2NhbE5hbWVdLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUZpZWxkICYmIHNvdXJjZUZpZWxkLmtpbmQgPT0gXCJtZXNzYWdlXCIgJiYgISh2YWwgaW5zdGFuY2VvZiBzb3VyY2VGaWVsZC5UKSkge1xuICAgICAgICAgICAgICB2YWwgPSBuZXcgc291cmNlRmllbGQuVCh2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VGaWVsZCAmJiBzb3VyY2VGaWVsZC5raW5kID09PSBcInNjYWxhclwiICYmIHNvdXJjZUZpZWxkLlQgPT09IFNjYWxhclR5cGUuQllURVMpIHtcbiAgICAgICAgICAgICAgdmFsID0gdG9VOEFycih2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0ge1xuICAgICAgICAgICAgICBjYXNlOiBzayxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgbGV0IGNvcHkgPSBzW2xvY2FsTmFtZV07XG4gICAgICAgICAgICBpZiAobWVtYmVyLlQgPT09IFNjYWxhclR5cGUuQllURVMpIHtcbiAgICAgICAgICAgICAgY29weSA9IG1lbWJlci5yZXBlYXRlZCA/IGNvcHkubWFwKHRvVThBcnIpIDogdG9VOEFycihjb3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IGNvcHk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICBzd2l0Y2ggKG1lbWJlci5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIGlmIChtZW1iZXIuVi5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhzW2xvY2FsTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXVtrXSA9IHRvVThBcnIodik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odFtsb2NhbE5hbWVdLCBzW2xvY2FsTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IG1lbWJlci5WLlQ7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKHNbbG9jYWxOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBzW2xvY2FsTmFtZV1ba107XG4gICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHRha2UgcGFydGlhbCBpbnB1dCBmb3IgbWVzc2FnZXMgdGhhdCBhcmUgbm90IGEgd3JhcHBlciB0eXBlLlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgdGhvc2UgbWVzc2FnZXMsIHdlIHJlY3Vyc2l2ZWx5IG5vcm1hbGl6ZSB0aGUgcGFydGlhbCBpbnB1dC5cbiAgICAgICAgICAgICAgICAgICAgdmFsID0gbmV3IG1lc3NhZ2VUeXBlKHZhbCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV1ba10gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgIGNvbnN0IG10ID0gbWVtYmVyLlQ7XG4gICAgICAgICAgICBpZiAobWVtYmVyLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHNbbG9jYWxOYW1lXS5tYXAodmFsID0+IHZhbCBpbnN0YW5jZW9mIG10ID8gdmFsIDogbmV3IG10KHZhbCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzW2xvY2FsTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSBzW2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgIGlmIChtdC5maWVsZFdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgdXNlIEJ5dGVzVmFsdWUudHlwZU5hbWUgYXMgdGhhdCB3aWxsIGNyZWF0ZSBhIGNpcmN1bGFyIGltcG9ydFxuICAgICAgICAgICAgICAgIG10LnR5cGVOYW1lID09PSBcImdvb2dsZS5wcm90b2J1Zi5CeXRlc1ZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHRvVThBcnIodmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSB2YWwgaW5zdGFuY2VvZiBtdCA/IHZhbCA6IG5ldyBtdCh2YWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZXF1YWxzKHR5cGUsIGEsIGIpIHtcbiAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFhIHx8ICFiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlLmZpZWxkcy5ieU1lbWJlcigpLmV2ZXJ5KG0gPT4ge1xuICAgICAgICBjb25zdCB2YSA9IGFbbS5sb2NhbE5hbWVdO1xuICAgICAgICBjb25zdCB2YiA9IGJbbS5sb2NhbE5hbWVdO1xuICAgICAgICBpZiAobS5yZXBlYXRlZCkge1xuICAgICAgICAgIGlmICh2YS5sZW5ndGggIT09IHZiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSByZXBlYXRlZCBmaWVsZHMgYXJlIG5ldmVyIFwibWFwXCJcbiAgICAgICAgICBzd2l0Y2ggKG0ua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHZhLmV2ZXJ5KChhLCBpKSA9PiBtLlQuZXF1YWxzKGEsIHZiW2ldKSk7XG4gICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gc2NhbGFyRXF1YWxzKG0uVCwgYSwgdmJbaV0pKTtcbiAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIGEsIHZiW2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlcGVhdGVkIGNhbm5vdCBjb250YWluIFwiLmNvbmNhdChtLmtpbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG0ua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICByZXR1cm4gbS5ULmVxdWFscyh2YSwgdmIpO1xuICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICByZXR1cm4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIHZhLCB2Yik7XG4gICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhtLlQsIHZhLCB2Yik7XG4gICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICBpZiAodmEuY2FzZSAhPT0gdmIuY2FzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzID0gbS5maW5kRmllbGQodmEuY2FzZSk7XG4gICAgICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gb25lb2YgZmllbGRzIGFyZSBuZXZlciBcIm1hcFwiXG4gICAgICAgICAgICBzd2l0Y2ggKHMua2luZCkge1xuICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzLlQuZXF1YWxzKHZhLnZhbHVlLCB2Yi52YWx1ZSk7XG4gICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhTY2FsYXJUeXBlLklOVDMyLCB2YS52YWx1ZSwgdmIudmFsdWUpO1xuICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhzLlQsIHZhLnZhbHVlLCB2Yi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvbmVvZiBjYW5ub3QgY29udGFpbiBcIi5jb25jYXQocy5raW5kKSk7XG4gICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhKS5jb25jYXQoT2JqZWN0LmtleXModmIpKTtcbiAgICAgICAgICAgIHN3aXRjaCAobS5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IG0uVi5UO1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KGsgPT4gbWVzc2FnZVR5cGUuZXF1YWxzKHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KGsgPT4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGFyVHlwZSA9IG0uVi5UO1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KGsgPT4gc2NhbGFyRXF1YWxzKHNjYWxhclR5cGUsIHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY2xvbmUobWVzc2FnZSkge1xuICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpLFxuICAgICAgICB0YXJnZXQgPSBuZXcgdHlwZSgpLFxuICAgICAgICBhbnkgPSB0YXJnZXQ7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0eXBlLmZpZWxkcy5ieU1lbWJlcigpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG1lc3NhZ2VbbWVtYmVyLmxvY2FsTmFtZV07XG4gICAgICAgIGxldCBjb3B5O1xuICAgICAgICBpZiAobWVtYmVyLnJlcGVhdGVkKSB7XG4gICAgICAgICAgY29weSA9IHNvdXJjZS5tYXAoY2xvbmVTaW5ndWxhckZpZWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZW1iZXIua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgICAgICAgY29weSA9IGFueVttZW1iZXIubG9jYWxOYW1lXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IGNsb25lU2luZ3VsYXJGaWVsZCh2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWVtYmVyLmtpbmQgPT0gXCJvbmVvZlwiKSB7XG4gICAgICAgICAgY29uc3QgZiA9IG1lbWJlci5maW5kRmllbGQoc291cmNlLmNhc2UpO1xuICAgICAgICAgIGNvcHkgPSBmID8ge1xuICAgICAgICAgICAgY2FzZTogc291cmNlLmNhc2UsXG4gICAgICAgICAgICB2YWx1ZTogY2xvbmVTaW5ndWxhckZpZWxkKHNvdXJjZS52YWx1ZSlcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgY2FzZTogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3B5ID0gY2xvbmVTaW5ndWxhckZpZWxkKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgYW55W21lbWJlci5sb2NhbE5hbWVdID0gY29weTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9O1xufVxuLy8gY2xvbmUgYSBzaW5nbGUgZmllbGQgdmFsdWUgLSBpLmUuIHRoZSBlbGVtZW50IHR5cGUgb2YgcmVwZWF0ZWQgZmllbGRzLCB0aGUgdmFsdWUgdHlwZSBvZiBtYXBzXG5mdW5jdGlvbiBjbG9uZVNpbmd1bGFyRmllbGQodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWVzc2FnZSkge1xuICAgIHJldHVybiB2YWx1ZS5jbG9uZSgpO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUuYnl0ZUxlbmd0aCk7XG4gICAgYy5zZXQodmFsdWUpO1xuICAgIHJldHVybiBjO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbi8vIGNvbnZlcnRzIGFueSBBcnJheUxpa2U8bnVtYmVyPiB0byBVaW50OEFycmF5IGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIHRvVThBcnIoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSA/IGlucHV0IDogbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuY2xhc3MgSW50ZXJuYWxGaWVsZExpc3Qge1xuICBjb25zdHJ1Y3RvcihmaWVsZHMsIG5vcm1hbGl6ZXIpIHtcbiAgICB0aGlzLl9maWVsZHMgPSBmaWVsZHM7XG4gICAgdGhpcy5fbm9ybWFsaXplciA9IG5vcm1hbGl6ZXI7XG4gIH1cbiAgZmluZEpzb25OYW1lKGpzb25OYW1lKSB7XG4gICAgaWYgKCF0aGlzLmpzb25OYW1lcykge1xuICAgICAgY29uc3QgdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMubGlzdCgpKSB7XG4gICAgICAgIHRbZi5qc29uTmFtZV0gPSB0W2YubmFtZV0gPSBmO1xuICAgICAgfVxuICAgICAgdGhpcy5qc29uTmFtZXMgPSB0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5qc29uTmFtZXNbanNvbk5hbWVdO1xuICB9XG4gIGZpbmQoZmllbGRObykge1xuICAgIGlmICghdGhpcy5udW1iZXJzKSB7XG4gICAgICBjb25zdCB0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5saXN0KCkpIHtcbiAgICAgICAgdFtmLm5vXSA9IGY7XG4gICAgICB9XG4gICAgICB0aGlzLm51bWJlcnMgPSB0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5udW1iZXJzW2ZpZWxkTm9dO1xuICB9XG4gIGxpc3QoKSB7XG4gICAgaWYgKCF0aGlzLmFsbCkge1xuICAgICAgdGhpcy5hbGwgPSB0aGlzLl9ub3JtYWxpemVyKHRoaXMuX2ZpZWxkcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFsbDtcbiAgfVxuICBieU51bWJlcigpIHtcbiAgICBpZiAoIXRoaXMubnVtYmVyc0FzYykge1xuICAgICAgdGhpcy5udW1iZXJzQXNjID0gdGhpcy5saXN0KCkuY29uY2F0KCkuc29ydCgoYSwgYikgPT4gYS5ubyAtIGIubm8pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5udW1iZXJzQXNjO1xuICB9XG4gIGJ5TWVtYmVyKCkge1xuICAgIGlmICghdGhpcy5tZW1iZXJzKSB7XG4gICAgICB0aGlzLm1lbWJlcnMgPSBbXTtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLm1lbWJlcnM7XG4gICAgICBsZXQgbztcbiAgICAgIGZvciAoY29uc3QgZiBvZiB0aGlzLmxpc3QoKSkge1xuICAgICAgICBpZiAoZi5vbmVvZikge1xuICAgICAgICAgIGlmIChmLm9uZW9mICE9PSBvKSB7XG4gICAgICAgICAgICBvID0gZi5vbmVvZjtcbiAgICAgICAgICAgIGEucHVzaChvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYS5wdXNoKGYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lbWJlcnM7XG4gIH1cbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIHByb3RvYnVmIGVsZW1lbnQgaW4gZ2VuZXJhdGVkIGNvZGUuXG4gKlxuICogRmllbGQgbmFtZXMgLSBpbmNsdWRpbmcgb25lb2ZzIC0gYXJlIGNvbnZlcnRlZCB0byBsb3dlckNhbWVsQ2FzZS4gRm9yXG4gKiBtZXNzYWdlcywgZW51bWVyYXRpb25zIGFuZCBzZXJ2aWNlcywgdGhlIHBhY2thZ2UgbmFtZSBpcyBzdHJpcHBlZCBmcm9tXG4gKiB0aGUgdHlwZSBuYW1lLiBGb3IgbmVzdGVkIG1lc3NhZ2VzIGFuZCBlbnVtZXJhdGlvbnMsIHRoZSBuYW1lcyBhcmUgam9pbmVkXG4gKiB3aXRoIGFuIHVuZGVyc2NvcmUuIEZvciBtZXRob2RzLCB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIG1hZGUgbG93ZXJjYXNlLlxuICovXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBmaWVsZCBpbiBnZW5lcmF0ZWQgY29kZS5cbiAqL1xuZnVuY3Rpb24gbG9jYWxGaWVsZE5hbWUocHJvdG9OYW1lLCBpbk9uZW9mKSB7XG4gIGNvbnN0IG5hbWUgPSBwcm90b0NhbWVsQ2FzZShwcm90b05hbWUpO1xuICBpZiAoaW5PbmVvZikge1xuICAgIC8vIG9uZW9mIG1lbWJlciBuYW1lcyBhcmUgbm90IHByb3BlcnRpZXMsIGJ1dCB2YWx1ZXMgb2YgdGhlIGBjYXNlYCBwcm9wZXJ0eS5cbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICByZXR1cm4gc2FmZU9iamVjdFByb3BlcnR5KHNhZmVNZXNzYWdlUHJvcGVydHkobmFtZSkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgb25lb2YgZ3JvdXAgaW4gZ2VuZXJhdGVkIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsT25lb2ZOYW1lKHByb3RvTmFtZSkge1xuICByZXR1cm4gbG9jYWxGaWVsZE5hbWUocHJvdG9OYW1lLCBmYWxzZSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIEpTT04gbmFtZSBmb3IgYSBwcm90b2J1ZiBmaWVsZCwgZXhhY3RseSBsaWtlIHByb3RvYyBkb2VzLlxuICovXG5jb25zdCBmaWVsZEpzb25OYW1lID0gcHJvdG9DYW1lbENhc2U7XG4vKipcbiAqIENvbnZlcnRzIHNuYWtlX2Nhc2UgdG8gcHJvdG9DYW1lbENhc2UgYWNjb3JkaW5nIHRvIHRoZSBjb252ZW50aW9uXG4gKiB1c2VkIGJ5IHByb3RvYyB0byBjb252ZXJ0IGEgZmllbGQgbmFtZSB0byBhIEpTT04gbmFtZS5cbiAqL1xuZnVuY3Rpb24gcHJvdG9DYW1lbENhc2Uoc25ha2VDYXNlKSB7XG4gIGxldCBjYXBOZXh0ID0gZmFsc2U7XG4gIGNvbnN0IGIgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbmFrZUNhc2UubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgYyA9IHNuYWtlQ2FzZS5jaGFyQXQoaSk7XG4gICAgc3dpdGNoIChjKSB7XG4gICAgICBjYXNlIFwiX1wiOlxuICAgICAgICBjYXBOZXh0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiMFwiOlxuICAgICAgY2FzZSBcIjFcIjpcbiAgICAgIGNhc2UgXCIyXCI6XG4gICAgICBjYXNlIFwiM1wiOlxuICAgICAgY2FzZSBcIjRcIjpcbiAgICAgIGNhc2UgXCI1XCI6XG4gICAgICBjYXNlIFwiNlwiOlxuICAgICAgY2FzZSBcIjdcIjpcbiAgICAgIGNhc2UgXCI4XCI6XG4gICAgICBjYXNlIFwiOVwiOlxuICAgICAgICBiLnB1c2goYyk7XG4gICAgICAgIGNhcE5leHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoY2FwTmV4dCkge1xuICAgICAgICAgIGNhcE5leHQgPSBmYWxzZTtcbiAgICAgICAgICBjID0gYy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGIucHVzaChjKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBiLmpvaW4oXCJcIik7XG59XG4vKipcbiAqIE5hbWVzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIG9iamVjdCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBhcmUgcmVzZXJ2ZWRcbiAqIGJ5IGJ1aWx0LWluIEphdmFTY3JpcHQgcHJvcGVydGllcy5cbiAqL1xuY29uc3QgcmVzZXJ2ZWRPYmplY3RQcm9wZXJ0aWVzID0gbmV3IFNldChbXG4vLyBuYW1lcyByZXNlcnZlZCBieSBKYXZhU2NyaXB0XG5cImNvbnN0cnVjdG9yXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0pTT05cIiwgXCJ2YWx1ZU9mXCJdKTtcbi8qKlxuICogTmFtZXMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3Igb2JqZWN0IHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGFyZSByZXNlcnZlZFxuICogYnkgdGhlIHJ1bnRpbWUuXG4gKi9cbmNvbnN0IHJlc2VydmVkTWVzc2FnZVByb3BlcnRpZXMgPSBuZXcgU2V0KFtcbi8vIG5hbWVzIHJlc2VydmVkIGJ5IHRoZSBydW50aW1lXG5cImdldFR5cGVcIiwgXCJjbG9uZVwiLCBcImVxdWFsc1wiLCBcImZyb21CaW5hcnlcIiwgXCJmcm9tSnNvblwiLCBcImZyb21Kc29uU3RyaW5nXCIsIFwidG9CaW5hcnlcIiwgXCJ0b0pzb25cIiwgXCJ0b0pzb25TdHJpbmdcIixcbi8vIG5hbWVzIHJlc2VydmVkIGJ5IHRoZSBydW50aW1lIGZvciB0aGUgZnV0dXJlXG5cInRvT2JqZWN0XCJdKTtcbmNvbnN0IGZhbGxiYWNrID0gbmFtZSA9PiBcIlwiLmNvbmNhdChuYW1lLCBcIiRcIik7XG4vKipcbiAqIFdpbGwgd3JhcCBuYW1lcyB0aGF0IGFyZSBPYmplY3QgcHJvdG90eXBlIHByb3BlcnRpZXMgb3IgbmFtZXMgcmVzZXJ2ZWRcbiAqIGZvciBgTWVzc2FnZWBzLlxuICovXG5jb25zdCBzYWZlTWVzc2FnZVByb3BlcnR5ID0gbmFtZSA9PiB7XG4gIGlmIChyZXNlcnZlZE1lc3NhZ2VQcm9wZXJ0aWVzLmhhcyhuYW1lKSkge1xuICAgIHJldHVybiBmYWxsYmFjayhuYW1lKTtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn07XG4vKipcbiAqIE5hbWVzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIG9iamVjdCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBhcmUgcmVzZXJ2ZWRcbiAqIGJ5IGJ1aWx0LWluIEphdmFTY3JpcHQgcHJvcGVydGllcy5cbiAqL1xuY29uc3Qgc2FmZU9iamVjdFByb3BlcnR5ID0gbmFtZSA9PiB7XG4gIGlmIChyZXNlcnZlZE9iamVjdFByb3BlcnRpZXMuaGFzKG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrKG5hbWUpO1xuICB9XG4gIHJldHVybiBuYW1lO1xufTtcblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmNsYXNzIEludGVybmFsT25lb2ZJbmZvIHtcbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIHRoaXMua2luZCA9IFwib25lb2ZcIjtcbiAgICB0aGlzLnJlcGVhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5wYWNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9wdCA9IGZhbHNlO1xuICAgIHRoaXMuZGVmYXVsdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZpZWxkcyA9IFtdO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5sb2NhbE5hbWUgPSBsb2NhbE9uZW9mTmFtZShuYW1lKTtcbiAgfVxuICBhZGRGaWVsZChmaWVsZCkge1xuICAgIGFzc2VydChmaWVsZC5vbmVvZiA9PT0gdGhpcywgXCJmaWVsZCBcIi5jb25jYXQoZmllbGQubmFtZSwgXCIgbm90IG9uZSBvZiBcIikuY29uY2F0KHRoaXMubmFtZSkpO1xuICAgIHRoaXMuZmllbGRzLnB1c2goZmllbGQpO1xuICB9XG4gIGZpbmRGaWVsZChsb2NhbE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2xvb2t1cCkge1xuICAgICAgdGhpcy5fbG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fbG9va3VwW3RoaXMuZmllbGRzW2ldLmxvY2FsTmFtZV0gPSB0aGlzLmZpZWxkc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2xvb2t1cFtsb2NhbE5hbWVdO1xuICB9XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIG1lc3NhZ2VzIGRlZmluZWQgd2l0aCB0aGUgcHJvdG8zIHN5bnRheC5cbiAqL1xuY29uc3QgcHJvdG8zID0gbWFrZVByb3RvUnVudGltZShcInByb3RvM1wiLCBtYWtlSnNvbkZvcm1hdFByb3RvMygpLCBtYWtlQmluYXJ5Rm9ybWF0UHJvdG8zKCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWFrZVV0aWxDb21tb24oKSksIHtcbiAgbmV3RmllbGRMaXN0KGZpZWxkcykge1xuICAgIHJldHVybiBuZXcgSW50ZXJuYWxGaWVsZExpc3QoZmllbGRzLCBub3JtYWxpemVGaWVsZEluZm9zUHJvdG8zKTtcbiAgfSxcbiAgaW5pdEZpZWxkcyh0YXJnZXQpIHtcbiAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0YXJnZXQuZ2V0VHlwZSgpLmZpZWxkcy5ieU1lbWJlcigpKSB7XG4gICAgICBpZiAobWVtYmVyLm9wdCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5hbWUgPSBtZW1iZXIubG9jYWxOYW1lLFxuICAgICAgICB0ID0gdGFyZ2V0O1xuICAgICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xuICAgICAgICB0W25hbWVdID0gW107XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChtZW1iZXIua2luZCkge1xuICAgICAgICBjYXNlIFwib25lb2ZcIjpcbiAgICAgICAgICB0W25hbWVdID0ge1xuICAgICAgICAgICAgY2FzZTogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICB0W25hbWVdID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgIHRbbmFtZV0gPSB7fTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgIHRbbmFtZV0gPSBzY2FsYXJEZWZhdWx0VmFsdWUobWVtYmVyLlQsIG1lbWJlci5MKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pKTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50ICovXG5mdW5jdGlvbiBub3JtYWxpemVGaWVsZEluZm9zUHJvdG8zKGZpZWxkSW5mb3MpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICBjb25zdCByID0gW107XG4gIGxldCBvO1xuICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVvZiBmaWVsZEluZm9zID09IFwiZnVuY3Rpb25cIiA/IGZpZWxkSW5mb3MoKSA6IGZpZWxkSW5mb3MpIHtcbiAgICBjb25zdCBmID0gZmllbGQ7XG4gICAgZi5sb2NhbE5hbWUgPSBsb2NhbEZpZWxkTmFtZShmaWVsZC5uYW1lLCBmaWVsZC5vbmVvZiAhPT0gdW5kZWZpbmVkKTtcbiAgICBmLmpzb25OYW1lID0gKF9hID0gZmllbGQuanNvbk5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpZWxkSnNvbk5hbWUoZmllbGQubmFtZSk7XG4gICAgZi5yZXBlYXRlZCA9IChfYiA9IGZpZWxkLnJlcGVhdGVkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICBpZiAoZmllbGQua2luZCA9PSBcInNjYWxhclwiKSB7XG4gICAgICBmLkwgPSAoX2MgPSBmaWVsZC5MKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBMb25nVHlwZS5CSUdJTlQ7XG4gICAgfVxuICAgIC8vIEZyb20gdGhlIHByb3RvMyBsYW5ndWFnZSBndWlkZTpcbiAgICAvLyA+IEluIHByb3RvMywgcmVwZWF0ZWQgZmllbGRzIG9mIHNjYWxhciBudW1lcmljIHR5cGVzIGFyZSBwYWNrZWQgYnkgZGVmYXVsdC5cbiAgICAvLyBUaGlzIGluZm9ybWF0aW9uIGlzIGluY29tcGxldGUgLSBhY2NvcmRpbmcgdG8gdGhlIGNvbmZvcm1hbmNlIHRlc3RzLCBCT09MXG4gICAgLy8gYW5kIEVOVU0gYXJlIHBhY2tlZCBieSBkZWZhdWx0IGFzIHdlbGwuIFRoaXMgbWVhbnMgb25seSBTVFJJTkcgYW5kIEJZVEVTXG4gICAgLy8gYXJlIG5vdCBwYWNrZWQgYnkgZGVmYXVsdCwgd2hpY2ggbWFrZXMgc2Vuc2UgYmVjYXVzZSB0aGV5IGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxuICAgIGYucGFja2VkID0gKF9kID0gZmllbGQucGFja2VkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmaWVsZC5raW5kID09IFwiZW51bVwiIHx8IGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIiAmJiBmaWVsZC5UICE9IFNjYWxhclR5cGUuQllURVMgJiYgZmllbGQuVCAhPSBTY2FsYXJUeXBlLlNUUklORztcbiAgICAvLyBXZSBkbyBub3Qgc3VyZmFjZSBvcHRpb25zIGF0IHRoaXMgdGltZVxuICAgIC8vIGYub3B0aW9ucyA9IGZpZWxkLm9wdGlvbnMgPz8gZW1wdHlSZWFkb25seU9iamVjdDtcbiAgICBpZiAoZmllbGQub25lb2YgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3Qgb29uYW1lID0gdHlwZW9mIGZpZWxkLm9uZW9mID09IFwic3RyaW5nXCIgPyBmaWVsZC5vbmVvZiA6IGZpZWxkLm9uZW9mLm5hbWU7XG4gICAgICBpZiAoIW8gfHwgby5uYW1lICE9IG9vbmFtZSkge1xuICAgICAgICBvID0gbmV3IEludGVybmFsT25lb2ZJbmZvKG9vbmFtZSk7XG4gICAgICB9XG4gICAgICBmLm9uZW9mID0gbztcbiAgICAgIG8uYWRkRmllbGQoZik7XG4gICAgfVxuICAgIHIucHVzaChmKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQSBUaW1lc3RhbXAgcmVwcmVzZW50cyBhIHBvaW50IGluIHRpbWUgaW5kZXBlbmRlbnQgb2YgYW55IHRpbWUgem9uZSBvciBsb2NhbFxuICogY2FsZW5kYXIsIGVuY29kZWQgYXMgYSBjb3VudCBvZiBzZWNvbmRzIGFuZCBmcmFjdGlvbnMgb2Ygc2Vjb25kcyBhdFxuICogbmFub3NlY29uZCByZXNvbHV0aW9uLiBUaGUgY291bnQgaXMgcmVsYXRpdmUgdG8gYW4gZXBvY2ggYXQgVVRDIG1pZG5pZ2h0IG9uXG4gKiBKYW51YXJ5IDEsIDE5NzAsIGluIHRoZSBwcm9sZXB0aWMgR3JlZ29yaWFuIGNhbGVuZGFyIHdoaWNoIGV4dGVuZHMgdGhlXG4gKiBHcmVnb3JpYW4gY2FsZW5kYXIgYmFja3dhcmRzIHRvIHllYXIgb25lLlxuICpcbiAqIEFsbCBtaW51dGVzIGFyZSA2MCBzZWNvbmRzIGxvbmcuIExlYXAgc2Vjb25kcyBhcmUgXCJzbWVhcmVkXCIgc28gdGhhdCBubyBsZWFwXG4gKiBzZWNvbmQgdGFibGUgaXMgbmVlZGVkIGZvciBpbnRlcnByZXRhdGlvbiwgdXNpbmcgYSBbMjQtaG91ciBsaW5lYXJcbiAqIHNtZWFyXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS90aW1lL3NtZWFyKS5cbiAqXG4gKiBUaGUgcmFuZ2UgaXMgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0byA5OTk5LTEyLTMxVDIzOjU5OjU5Ljk5OTk5OTk5OVouIEJ5XG4gKiByZXN0cmljdGluZyB0byB0aGF0IHJhbmdlLCB3ZSBlbnN1cmUgdGhhdCB3ZSBjYW4gY29udmVydCB0byBhbmQgZnJvbSBbUkZDXG4gKiAzMzM5XShodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzMzOS50eHQpIGRhdGUgc3RyaW5ncy5cbiAqXG4gKiAjIEV4YW1wbGVzXG4gKlxuICogRXhhbXBsZSAxOiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIFBPU0lYIGB0aW1lKClgLlxuICpcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wO1xuICogICAgIHRpbWVzdGFtcC5zZXRfc2Vjb25kcyh0aW1lKE5VTEwpKTtcbiAqICAgICB0aW1lc3RhbXAuc2V0X25hbm9zKDApO1xuICpcbiAqIEV4YW1wbGUgMjogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBQT1NJWCBgZ2V0dGltZW9mZGF5KClgLlxuICpcbiAqICAgICBzdHJ1Y3QgdGltZXZhbCB0djtcbiAqICAgICBnZXR0aW1lb2ZkYXkoJnR2LCBOVUxMKTtcbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHModHYudHZfc2VjKTtcbiAqICAgICB0aW1lc3RhbXAuc2V0X25hbm9zKHR2LnR2X3VzZWMgKiAxMDAwKTtcbiAqXG4gKiBFeGFtcGxlIDM6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gV2luMzIgYEdldFN5c3RlbVRpbWVBc0ZpbGVUaW1lKClgLlxuICpcbiAqICAgICBGSUxFVElNRSBmdDtcbiAqICAgICBHZXRTeXN0ZW1UaW1lQXNGaWxlVGltZSgmZnQpO1xuICogICAgIFVJTlQ2NCB0aWNrcyA9ICgoKFVJTlQ2NClmdC5kd0hpZ2hEYXRlVGltZSkgPDwgMzIpIHwgZnQuZHdMb3dEYXRlVGltZTtcbiAqXG4gKiAgICAgLy8gQSBXaW5kb3dzIHRpY2sgaXMgMTAwIG5hbm9zZWNvbmRzLiBXaW5kb3dzIGVwb2NoIDE2MDEtMDEtMDFUMDA6MDA6MDBaXG4gKiAgICAgLy8gaXMgMTE2NDQ0NzM2MDAgc2Vjb25kcyBiZWZvcmUgVW5peCBlcG9jaCAxOTcwLTAxLTAxVDAwOjAwOjAwWi5cbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wO1xuICogICAgIHRpbWVzdGFtcC5zZXRfc2Vjb25kcygoSU5UNjQpICgodGlja3MgLyAxMDAwMDAwMCkgLSAxMTY0NDQ3MzYwMExMKSk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcygoSU5UMzIpICgodGlja3MgJSAxMDAwMDAwMCkgKiAxMDApKTtcbiAqXG4gKiBFeGFtcGxlIDQ6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gSmF2YSBgU3lzdGVtLmN1cnJlbnRUaW1lTWlsbGlzKClgLlxuICpcbiAqICAgICBsb25nIG1pbGxpcyA9IFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpO1xuICpcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wID0gVGltZXN0YW1wLm5ld0J1aWxkZXIoKS5zZXRTZWNvbmRzKG1pbGxpcyAvIDEwMDApXG4gKiAgICAgICAgIC5zZXROYW5vcygoaW50KSAoKG1pbGxpcyAlIDEwMDApICogMTAwMDAwMCkpLmJ1aWxkKCk7XG4gKlxuICogRXhhbXBsZSA1OiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIEphdmEgYEluc3RhbnQubm93KClgLlxuICpcbiAqICAgICBJbnN0YW50IG5vdyA9IEluc3RhbnQubm93KCk7XG4gKlxuICogICAgIFRpbWVzdGFtcCB0aW1lc3RhbXAgPVxuICogICAgICAgICBUaW1lc3RhbXAubmV3QnVpbGRlcigpLnNldFNlY29uZHMobm93LmdldEVwb2NoU2Vjb25kKCkpXG4gKiAgICAgICAgICAgICAuc2V0TmFub3Mobm93LmdldE5hbm8oKSkuYnVpbGQoKTtcbiAqXG4gKiBFeGFtcGxlIDY6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gY3VycmVudCB0aW1lIGluIFB5dGhvbi5cbiAqXG4gKiAgICAgdGltZXN0YW1wID0gVGltZXN0YW1wKClcbiAqICAgICB0aW1lc3RhbXAuR2V0Q3VycmVudFRpbWUoKVxuICpcbiAqICMgSlNPTiBNYXBwaW5nXG4gKlxuICogSW4gSlNPTiBmb3JtYXQsIHRoZSBUaW1lc3RhbXAgdHlwZSBpcyBlbmNvZGVkIGFzIGEgc3RyaW5nIGluIHRoZVxuICogW1JGQyAzMzM5XShodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzMzOS50eHQpIGZvcm1hdC4gVGhhdCBpcywgdGhlXG4gKiBmb3JtYXQgaXMgXCJ7eWVhcn0te21vbnRofS17ZGF5fVR7aG91cn06e21pbn06e3NlY31bLntmcmFjX3NlY31dWlwiXG4gKiB3aGVyZSB7eWVhcn0gaXMgYWx3YXlzIGV4cHJlc3NlZCB1c2luZyBmb3VyIGRpZ2l0cyB3aGlsZSB7bW9udGh9LCB7ZGF5fSxcbiAqIHtob3VyfSwge21pbn0sIGFuZCB7c2VjfSBhcmUgemVyby1wYWRkZWQgdG8gdHdvIGRpZ2l0cyBlYWNoLiBUaGUgZnJhY3Rpb25hbFxuICogc2Vjb25kcywgd2hpY2ggY2FuIGdvIHVwIHRvIDkgZGlnaXRzIChpLmUuIHVwIHRvIDEgbmFub3NlY29uZCByZXNvbHV0aW9uKSxcbiAqIGFyZSBvcHRpb25hbC4gVGhlIFwiWlwiIHN1ZmZpeCBpbmRpY2F0ZXMgdGhlIHRpbWV6b25lIChcIlVUQ1wiKTsgdGhlIHRpbWV6b25lXG4gKiBpcyByZXF1aXJlZC4gQSBwcm90bzMgSlNPTiBzZXJpYWxpemVyIHNob3VsZCBhbHdheXMgdXNlIFVUQyAoYXMgaW5kaWNhdGVkIGJ5XG4gKiBcIlpcIikgd2hlbiBwcmludGluZyB0aGUgVGltZXN0YW1wIHR5cGUgYW5kIGEgcHJvdG8zIEpTT04gcGFyc2VyIHNob3VsZCBiZVxuICogYWJsZSB0byBhY2NlcHQgYm90aCBVVEMgYW5kIG90aGVyIHRpbWV6b25lcyAoYXMgaW5kaWNhdGVkIGJ5IGFuIG9mZnNldCkuXG4gKlxuICogRm9yIGV4YW1wbGUsIFwiMjAxNy0wMS0xNVQwMTozMDoxNS4wMVpcIiBlbmNvZGVzIDE1LjAxIHNlY29uZHMgcGFzdFxuICogMDE6MzAgVVRDIG9uIEphbnVhcnkgMTUsIDIwMTcuXG4gKlxuICogSW4gSmF2YVNjcmlwdCwgb25lIGNhbiBjb252ZXJ0IGEgRGF0ZSBvYmplY3QgdG8gdGhpcyBmb3JtYXQgdXNpbmcgdGhlXG4gKiBzdGFuZGFyZFxuICogW3RvSVNPU3RyaW5nKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9JU09TdHJpbmcpXG4gKiBtZXRob2QuIEluIFB5dGhvbiwgYSBzdGFuZGFyZCBgZGF0ZXRpbWUuZGF0ZXRpbWVgIG9iamVjdCBjYW4gYmUgY29udmVydGVkXG4gKiB0byB0aGlzIGZvcm1hdCB1c2luZ1xuICogW2BzdHJmdGltZWBdKGh0dHBzOi8vZG9jcy5weXRob24ub3JnLzIvbGlicmFyeS90aW1lLmh0bWwjdGltZS5zdHJmdGltZSkgd2l0aFxuICogdGhlIHRpbWUgZm9ybWF0IHNwZWMgJyVZLSVtLSVkVCVIOiVNOiVTLiVmWicuIExpa2V3aXNlLCBpbiBKYXZhLCBvbmUgY2FuIHVzZVxuICogdGhlIEpvZGEgVGltZSdzIFtgSVNPRGF0ZVRpbWVGb3JtYXQuZGF0ZVRpbWUoKWBdKFxuICogaHR0cDovL2pvZGEtdGltZS5zb3VyY2Vmb3JnZS5uZXQvYXBpZG9jcy9vcmcvam9kYS90aW1lL2Zvcm1hdC9JU09EYXRlVGltZUZvcm1hdC5odG1sI2RhdGVUaW1lKClcbiAqICkgdG8gb2J0YWluIGEgZm9ybWF0dGVyIGNhcGFibGUgb2YgZ2VuZXJhdGluZyB0aW1lc3RhbXBzIGluIHRoaXMgZm9ybWF0LlxuICpcbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXG4gKi9cbmNsYXNzIFRpbWVzdGFtcCBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIHNlY29uZHMgb2YgVVRDIHRpbWUgc2luY2UgVW5peCBlcG9jaFxuICAgICAqIDE5NzAtMDEtMDFUMDA6MDA6MDBaLiBNdXN0IGJlIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG9cbiAgICAgKiA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmUuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IHNlY29uZHMgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuc2Vjb25kcyA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBOb24tbmVnYXRpdmUgZnJhY3Rpb25zIG9mIGEgc2Vjb25kIGF0IG5hbm9zZWNvbmQgcmVzb2x1dGlvbi4gTmVnYXRpdmVcbiAgICAgKiBzZWNvbmQgdmFsdWVzIHdpdGggZnJhY3Rpb25zIG11c3Qgc3RpbGwgaGF2ZSBub24tbmVnYXRpdmUgbmFub3MgdmFsdWVzXG4gICAgICogdGhhdCBjb3VudCBmb3J3YXJkIGluIHRpbWUuIE11c3QgYmUgZnJvbSAwIHRvIDk5OSw5OTksOTk5XG4gICAgICogaW5jbHVzaXZlLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQzMiBuYW5vcyA9IDI7XG4gICAgICovXG4gICAgdGhpcy5uYW5vcyA9IDA7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgZnJvbUpzb24oanNvbiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGZyb20gSlNPTjogXCIuY29uY2F0KHByb3RvMy5qc29uLmRlYnVnKGpzb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoZXMgPSBqc29uLm1hdGNoKC9eKFswLTldezR9KS0oWzAtOV17Mn0pLShbMC05XXsyfSlUKFswLTldezJ9KTooWzAtOV17Mn0pOihbMC05XXsyfSkoPzpafFxcLihbMC05XXszLDl9KVp8KFsrLV1bMC05XVswLTldOlswLTldWzAtOV0pKSQvKTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IGludmFsaWQgUkZDIDMzMzkgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBjb25zdCBtcyA9IERhdGUucGFyc2UobWF0Y2hlc1sxXSArIFwiLVwiICsgbWF0Y2hlc1syXSArIFwiLVwiICsgbWF0Y2hlc1szXSArIFwiVFwiICsgbWF0Y2hlc1s0XSArIFwiOlwiICsgbWF0Y2hlc1s1XSArIFwiOlwiICsgbWF0Y2hlc1s2XSArIChtYXRjaGVzWzhdID8gbWF0Y2hlc1s4XSA6IFwiWlwiKSk7XG4gICAgaWYgKE51bWJlci5pc05hTihtcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IGludmFsaWQgUkZDIDMzMzkgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBpZiAobXMgPCBEYXRlLnBhcnNlKFwiMDAwMS0wMS0wMVQwMDowMDowMFpcIikgfHwgbXMgPiBEYXRlLnBhcnNlKFwiOTk5OS0xMi0zMVQyMzo1OTo1OVpcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgbWVzc2FnZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGZyb20gSlNPTjogbXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZVwiKTtcbiAgICB9XG4gICAgdGhpcy5zZWNvbmRzID0gcHJvdG9JbnQ2NC5wYXJzZShtcyAvIDEwMDApO1xuICAgIHRoaXMubmFub3MgPSAwO1xuICAgIGlmIChtYXRjaGVzWzddKSB7XG4gICAgICB0aGlzLm5hbm9zID0gcGFyc2VJbnQoXCIxXCIgKyBtYXRjaGVzWzddICsgXCIwXCIucmVwZWF0KDkgLSBtYXRjaGVzWzddLmxlbmd0aCkpIC0gMTAwMDAwMDAwMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdG9Kc29uKG9wdGlvbnMpIHtcbiAgICBjb25zdCBtcyA9IE51bWJlcih0aGlzLnNlY29uZHMpICogMTAwMDtcbiAgICBpZiAobXMgPCBEYXRlLnBhcnNlKFwiMDAwMS0wMS0wMVQwMDowMDowMFpcIikgfHwgbXMgPiBEYXRlLnBhcnNlKFwiOTk5OS0xMi0zMVQyMzo1OTo1OVpcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCB0byBKU09OOiBtdXN0IGJlIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG8gOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5uYW5vcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCB0byBKU09OOiBuYW5vcyBtdXN0IG5vdCBiZSBuZWdhdGl2ZVwiKTtcbiAgICB9XG4gICAgbGV0IHogPSBcIlpcIjtcbiAgICBpZiAodGhpcy5uYW5vcyA+IDApIHtcbiAgICAgIGNvbnN0IG5hbm9zU3RyID0gKHRoaXMubmFub3MgKyAxMDAwMDAwMDAwKS50b1N0cmluZygpLnN1YnN0cmluZygxKTtcbiAgICAgIGlmIChuYW5vc1N0ci5zdWJzdHJpbmcoMykgPT09IFwiMDAwMDAwXCIpIHtcbiAgICAgICAgeiA9IFwiLlwiICsgbmFub3NTdHIuc3Vic3RyaW5nKDAsIDMpICsgXCJaXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbm9zU3RyLnN1YnN0cmluZyg2KSA9PT0gXCIwMDBcIikge1xuICAgICAgICB6ID0gXCIuXCIgKyBuYW5vc1N0ci5zdWJzdHJpbmcoMCwgNikgKyBcIlpcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHogPSBcIi5cIiArIG5hbm9zU3RyICsgXCJaXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShtcykudG9JU09TdHJpbmcoKS5yZXBsYWNlKFwiLjAwMFpcIiwgeik7XG4gIH1cbiAgdG9EYXRlKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIodGhpcy5zZWNvbmRzKSAqIDEwMDAgKyBNYXRoLmNlaWwodGhpcy5uYW5vcyAvIDEwMDAwMDApKTtcbiAgfVxuICBzdGF0aWMgbm93KCkge1xuICAgIHJldHVybiBUaW1lc3RhbXAuZnJvbURhdGUobmV3IERhdGUoKSk7XG4gIH1cbiAgc3RhdGljIGZyb21EYXRlKGRhdGUpIHtcbiAgICBjb25zdCBtcyA9IGRhdGUuZ2V0VGltZSgpO1xuICAgIHJldHVybiBuZXcgVGltZXN0YW1wKHtcbiAgICAgIHNlY29uZHM6IHByb3RvSW50NjQucGFyc2UoTWF0aC5mbG9vcihtcyAvIDEwMDApKSxcbiAgICAgIG5hbm9zOiBtcyAlIDEwMDAgKiAxMDAwMDAwXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVGltZXN0YW1wLCBhLCBiKTtcbiAgfVxufVxuVGltZXN0YW1wLnJ1bnRpbWUgPSBwcm90bzM7XG5UaW1lc3RhbXAudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIjtcblRpbWVzdGFtcC5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic2Vjb25kc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibmFub3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59XSk7XG5cbi8vIENvcHlyaWdodCAyMDIzIExpdmVLaXQsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuQXVkaW9Db2RlY1xuICovXG52YXIgQXVkaW9Db2RlYztcbihmdW5jdGlvbiAoQXVkaW9Db2RlYykge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IERFRkFVTFRfQUMgPSAwO1xuICAgKi9cbiAgQXVkaW9Db2RlY1tBdWRpb0NvZGVjW1wiREVGQVVMVF9BQ1wiXSA9IDBdID0gXCJERUZBVUxUX0FDXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogT1BVUyA9IDE7XG4gICAqL1xuICBBdWRpb0NvZGVjW0F1ZGlvQ29kZWNbXCJPUFVTXCJdID0gMV0gPSBcIk9QVVNcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBBQUMgPSAyO1xuICAgKi9cbiAgQXVkaW9Db2RlY1tBdWRpb0NvZGVjW1wiQUFDXCJdID0gMl0gPSBcIkFBQ1wiO1xufSkoQXVkaW9Db2RlYyB8fCAoQXVkaW9Db2RlYyA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShBdWRpb0NvZGVjKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoQXVkaW9Db2RlYywgXCJsaXZla2l0LkF1ZGlvQ29kZWNcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiREVGQVVMVF9BQ1wiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIk9QVVNcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJBQUNcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlZpZGVvQ29kZWNcbiAqL1xudmFyIFZpZGVvQ29kZWM7XG4oZnVuY3Rpb24gKFZpZGVvQ29kZWMpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBERUZBVUxUX1ZDID0gMDtcbiAgICovXG4gIFZpZGVvQ29kZWNbVmlkZW9Db2RlY1tcIkRFRkFVTFRfVkNcIl0gPSAwXSA9IFwiREVGQVVMVF9WQ1wiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEgyNjRfQkFTRUxJTkUgPSAxO1xuICAgKi9cbiAgVmlkZW9Db2RlY1tWaWRlb0NvZGVjW1wiSDI2NF9CQVNFTElORVwiXSA9IDFdID0gXCJIMjY0X0JBU0VMSU5FXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSDI2NF9NQUlOID0gMjtcbiAgICovXG4gIFZpZGVvQ29kZWNbVmlkZW9Db2RlY1tcIkgyNjRfTUFJTlwiXSA9IDJdID0gXCJIMjY0X01BSU5cIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBIMjY0X0hJR0ggPSAzO1xuICAgKi9cbiAgVmlkZW9Db2RlY1tWaWRlb0NvZGVjW1wiSDI2NF9ISUdIXCJdID0gM10gPSBcIkgyNjRfSElHSFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFZQOCA9IDQ7XG4gICAqL1xuICBWaWRlb0NvZGVjW1ZpZGVvQ29kZWNbXCJWUDhcIl0gPSA0XSA9IFwiVlA4XCI7XG59KShWaWRlb0NvZGVjIHx8IChWaWRlb0NvZGVjID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvQ29kZWMpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShWaWRlb0NvZGVjLCBcImxpdmVraXQuVmlkZW9Db2RlY1wiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJERUZBVUxUX1ZDXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiSDI2NF9CQVNFTElORVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkgyNjRfTUFJTlwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIkgyNjRfSElHSFwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIlZQOFwiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuSW1hZ2VDb2RlY1xuICovXG52YXIgSW1hZ2VDb2RlYztcbihmdW5jdGlvbiAoSW1hZ2VDb2RlYykge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IElDX0RFRkFVTFQgPSAwO1xuICAgKi9cbiAgSW1hZ2VDb2RlY1tJbWFnZUNvZGVjW1wiSUNfREVGQVVMVFwiXSA9IDBdID0gXCJJQ19ERUZBVUxUXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSUNfSlBFRyA9IDE7XG4gICAqL1xuICBJbWFnZUNvZGVjW0ltYWdlQ29kZWNbXCJJQ19KUEVHXCJdID0gMV0gPSBcIklDX0pQRUdcIjtcbn0pKEltYWdlQ29kZWMgfHwgKEltYWdlQ29kZWMgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoSW1hZ2VDb2RlYylcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKEltYWdlQ29kZWMsIFwibGl2ZWtpdC5JbWFnZUNvZGVjXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIklDX0RFRkFVTFRcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJJQ19KUEVHXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5UcmFja1R5cGVcbiAqL1xudmFyIFRyYWNrVHlwZTtcbihmdW5jdGlvbiAoVHJhY2tUeXBlKSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQVVESU8gPSAwO1xuICAgKi9cbiAgVHJhY2tUeXBlW1RyYWNrVHlwZVtcIkFVRElPXCJdID0gMF0gPSBcIkFVRElPXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVklERU8gPSAxO1xuICAgKi9cbiAgVHJhY2tUeXBlW1RyYWNrVHlwZVtcIlZJREVPXCJdID0gMV0gPSBcIlZJREVPXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogREFUQSA9IDI7XG4gICAqL1xuICBUcmFja1R5cGVbVHJhY2tUeXBlW1wiREFUQVwiXSA9IDJdID0gXCJEQVRBXCI7XG59KShUcmFja1R5cGUgfHwgKFRyYWNrVHlwZSA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1R5cGUpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShUcmFja1R5cGUsIFwibGl2ZWtpdC5UcmFja1R5cGVcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiQVVESU9cIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJWSURFT1wiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkRBVEFcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlRyYWNrU291cmNlXG4gKi9cbnZhciBUcmFja1NvdXJjZTtcbihmdW5jdGlvbiAoVHJhY2tTb3VyY2UpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBVTktOT1dOID0gMDtcbiAgICovXG4gIFRyYWNrU291cmNlW1RyYWNrU291cmNlW1wiVU5LTk9XTlwiXSA9IDBdID0gXCJVTktOT1dOXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQ0FNRVJBID0gMTtcbiAgICovXG4gIFRyYWNrU291cmNlW1RyYWNrU291cmNlW1wiQ0FNRVJBXCJdID0gMV0gPSBcIkNBTUVSQVwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IE1JQ1JPUEhPTkUgPSAyO1xuICAgKi9cbiAgVHJhY2tTb3VyY2VbVHJhY2tTb3VyY2VbXCJNSUNST1BIT05FXCJdID0gMl0gPSBcIk1JQ1JPUEhPTkVcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTQ1JFRU5fU0hBUkUgPSAzO1xuICAgKi9cbiAgVHJhY2tTb3VyY2VbVHJhY2tTb3VyY2VbXCJTQ1JFRU5fU0hBUkVcIl0gPSAzXSA9IFwiU0NSRUVOX1NIQVJFXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU0NSRUVOX1NIQVJFX0FVRElPID0gNDtcbiAgICovXG4gIFRyYWNrU291cmNlW1RyYWNrU291cmNlW1wiU0NSRUVOX1NIQVJFX0FVRElPXCJdID0gNF0gPSBcIlNDUkVFTl9TSEFSRV9BVURJT1wiO1xufSkoVHJhY2tTb3VyY2UgfHwgKFRyYWNrU291cmNlID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrU291cmNlKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoVHJhY2tTb3VyY2UsIFwibGl2ZWtpdC5UcmFja1NvdXJjZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJVTktOT1dOXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiQ0FNRVJBXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiTUlDUk9QSE9ORVwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIlNDUkVFTl9TSEFSRVwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIlNDUkVFTl9TSEFSRV9BVURJT1wiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuVmlkZW9RdWFsaXR5XG4gKi9cbnZhciBWaWRlb1F1YWxpdHk7XG4oZnVuY3Rpb24gKFZpZGVvUXVhbGl0eSkge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IExPVyA9IDA7XG4gICAqL1xuICBWaWRlb1F1YWxpdHlbVmlkZW9RdWFsaXR5W1wiTE9XXCJdID0gMF0gPSBcIkxPV1wiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IE1FRElVTSA9IDE7XG4gICAqL1xuICBWaWRlb1F1YWxpdHlbVmlkZW9RdWFsaXR5W1wiTUVESVVNXCJdID0gMV0gPSBcIk1FRElVTVwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEhJR0ggPSAyO1xuICAgKi9cbiAgVmlkZW9RdWFsaXR5W1ZpZGVvUXVhbGl0eVtcIkhJR0hcIl0gPSAyXSA9IFwiSElHSFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IE9GRiA9IDM7XG4gICAqL1xuICBWaWRlb1F1YWxpdHlbVmlkZW9RdWFsaXR5W1wiT0ZGXCJdID0gM10gPSBcIk9GRlwiO1xufSkoVmlkZW9RdWFsaXR5IHx8IChWaWRlb1F1YWxpdHkgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5KVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5LCBcImxpdmVraXQuVmlkZW9RdWFsaXR5XCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkxPV1wiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIk1FRElVTVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkhJR0hcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJPRkZcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5XG4gKi9cbnZhciBDb25uZWN0aW9uUXVhbGl0eSQxO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uUXVhbGl0eSkge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFBPT1IgPSAwO1xuICAgKi9cbiAgQ29ubmVjdGlvblF1YWxpdHlbQ29ubmVjdGlvblF1YWxpdHlbXCJQT09SXCJdID0gMF0gPSBcIlBPT1JcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBHT09EID0gMTtcbiAgICovXG4gIENvbm5lY3Rpb25RdWFsaXR5W0Nvbm5lY3Rpb25RdWFsaXR5W1wiR09PRFwiXSA9IDFdID0gXCJHT09EXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogRVhDRUxMRU5UID0gMjtcbiAgICovXG4gIENvbm5lY3Rpb25RdWFsaXR5W0Nvbm5lY3Rpb25RdWFsaXR5W1wiRVhDRUxMRU5UXCJdID0gMl0gPSBcIkVYQ0VMTEVOVFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IExPU1QgPSAzO1xuICAgKi9cbiAgQ29ubmVjdGlvblF1YWxpdHlbQ29ubmVjdGlvblF1YWxpdHlbXCJMT1NUXCJdID0gM10gPSBcIkxPU1RcIjtcbn0pKENvbm5lY3Rpb25RdWFsaXR5JDEgfHwgKENvbm5lY3Rpb25RdWFsaXR5JDEgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoQ29ubmVjdGlvblF1YWxpdHkpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShDb25uZWN0aW9uUXVhbGl0eSQxLCBcImxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiUE9PUlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkdPT0RcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJFWENFTExFTlRcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJMT1NUXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5DbGllbnRDb25maWdTZXR0aW5nXG4gKi9cbnZhciBDbGllbnRDb25maWdTZXR0aW5nO1xuKGZ1bmN0aW9uIChDbGllbnRDb25maWdTZXR0aW5nKSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVU5TRVQgPSAwO1xuICAgKi9cbiAgQ2xpZW50Q29uZmlnU2V0dGluZ1tDbGllbnRDb25maWdTZXR0aW5nW1wiVU5TRVRcIl0gPSAwXSA9IFwiVU5TRVRcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBESVNBQkxFRCA9IDE7XG4gICAqL1xuICBDbGllbnRDb25maWdTZXR0aW5nW0NsaWVudENvbmZpZ1NldHRpbmdbXCJESVNBQkxFRFwiXSA9IDFdID0gXCJESVNBQkxFRFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEVOQUJMRUQgPSAyO1xuICAgKi9cbiAgQ2xpZW50Q29uZmlnU2V0dGluZ1tDbGllbnRDb25maWdTZXR0aW5nW1wiRU5BQkxFRFwiXSA9IDJdID0gXCJFTkFCTEVEXCI7XG59KShDbGllbnRDb25maWdTZXR0aW5nIHx8IChDbGllbnRDb25maWdTZXR0aW5nID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudENvbmZpZ1NldHRpbmcpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nLCBcImxpdmVraXQuQ2xpZW50Q29uZmlnU2V0dGluZ1wiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJVTlNFVFwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkRJU0FCTEVEXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiRU5BQkxFRFwiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuRGlzY29ubmVjdFJlYXNvblxuICovXG52YXIgRGlzY29ubmVjdFJlYXNvbjtcbihmdW5jdGlvbiAoRGlzY29ubmVjdFJlYXNvbikge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFVOS05PV05fUkVBU09OID0gMDtcbiAgICovXG4gIERpc2Nvbm5lY3RSZWFzb25bRGlzY29ubmVjdFJlYXNvbltcIlVOS05PV05fUkVBU09OXCJdID0gMF0gPSBcIlVOS05PV05fUkVBU09OXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQ0xJRU5UX0lOSVRJQVRFRCA9IDE7XG4gICAqL1xuICBEaXNjb25uZWN0UmVhc29uW0Rpc2Nvbm5lY3RSZWFzb25bXCJDTElFTlRfSU5JVElBVEVEXCJdID0gMV0gPSBcIkNMSUVOVF9JTklUSUFURURcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBEVVBMSUNBVEVfSURFTlRJVFkgPSAyO1xuICAgKi9cbiAgRGlzY29ubmVjdFJlYXNvbltEaXNjb25uZWN0UmVhc29uW1wiRFVQTElDQVRFX0lERU5USVRZXCJdID0gMl0gPSBcIkRVUExJQ0FURV9JREVOVElUWVwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNFUlZFUl9TSFVURE9XTiA9IDM7XG4gICAqL1xuICBEaXNjb25uZWN0UmVhc29uW0Rpc2Nvbm5lY3RSZWFzb25bXCJTRVJWRVJfU0hVVERPV05cIl0gPSAzXSA9IFwiU0VSVkVSX1NIVVRET1dOXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUEFSVElDSVBBTlRfUkVNT1ZFRCA9IDQ7XG4gICAqL1xuICBEaXNjb25uZWN0UmVhc29uW0Rpc2Nvbm5lY3RSZWFzb25bXCJQQVJUSUNJUEFOVF9SRU1PVkVEXCJdID0gNF0gPSBcIlBBUlRJQ0lQQU5UX1JFTU9WRURcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBST09NX0RFTEVURUQgPSA1O1xuICAgKi9cbiAgRGlzY29ubmVjdFJlYXNvbltEaXNjb25uZWN0UmVhc29uW1wiUk9PTV9ERUxFVEVEXCJdID0gNV0gPSBcIlJPT01fREVMRVRFRFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNUQVRFX01JU01BVENIID0gNjtcbiAgICovXG4gIERpc2Nvbm5lY3RSZWFzb25bRGlzY29ubmVjdFJlYXNvbltcIlNUQVRFX01JU01BVENIXCJdID0gNl0gPSBcIlNUQVRFX01JU01BVENIXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSk9JTl9GQUlMVVJFID0gNztcbiAgICovXG4gIERpc2Nvbm5lY3RSZWFzb25bRGlzY29ubmVjdFJlYXNvbltcIkpPSU5fRkFJTFVSRVwiXSA9IDddID0gXCJKT0lOX0ZBSUxVUkVcIjtcbn0pKERpc2Nvbm5lY3RSZWFzb24gfHwgKERpc2Nvbm5lY3RSZWFzb24gPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoRGlzY29ubmVjdFJlYXNvbilcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKERpc2Nvbm5lY3RSZWFzb24sIFwibGl2ZWtpdC5EaXNjb25uZWN0UmVhc29uXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlVOS05PV05fUkVBU09OXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiQ0xJRU5UX0lOSVRJQVRFRFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkRVUExJQ0FURV9JREVOVElUWVwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIlNFUlZFUl9TSFVURE9XTlwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIlBBUlRJQ0lQQU5UX1JFTU9WRURcIlxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJST09NX0RFTEVURURcIlxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJTVEFURV9NSVNNQVRDSFwiXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcIkpPSU5fRkFJTFVSRVwiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuUmVjb25uZWN0UmVhc29uXG4gKi9cbnZhciBSZWNvbm5lY3RSZWFzb247XG4oZnVuY3Rpb24gKFJlY29ubmVjdFJlYXNvbikge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFJSX1VOS05PV04gPSAwO1xuICAgKi9cbiAgUmVjb25uZWN0UmVhc29uW1JlY29ubmVjdFJlYXNvbltcIlJSX1VOS05PV05cIl0gPSAwXSA9IFwiUlJfVU5LTk9XTlwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFJSX1NJR05BTF9ESVNDT05ORUNURUQgPSAxO1xuICAgKi9cbiAgUmVjb25uZWN0UmVhc29uW1JlY29ubmVjdFJlYXNvbltcIlJSX1NJR05BTF9ESVNDT05ORUNURURcIl0gPSAxXSA9IFwiUlJfU0lHTkFMX0RJU0NPTk5FQ1RFRFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFJSX1BVQkxJU0hFUl9GQUlMRUQgPSAyO1xuICAgKi9cbiAgUmVjb25uZWN0UmVhc29uW1JlY29ubmVjdFJlYXNvbltcIlJSX1BVQkxJU0hFUl9GQUlMRURcIl0gPSAyXSA9IFwiUlJfUFVCTElTSEVSX0ZBSUxFRFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFJSX1NVQlNDUklCRVJfRkFJTEVEID0gMztcbiAgICovXG4gIFJlY29ubmVjdFJlYXNvbltSZWNvbm5lY3RSZWFzb25bXCJSUl9TVUJTQ1JJQkVSX0ZBSUxFRFwiXSA9IDNdID0gXCJSUl9TVUJTQ1JJQkVSX0ZBSUxFRFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFJSX1NXSVRDSF9DQU5ESURBVEUgPSA0O1xuICAgKi9cbiAgUmVjb25uZWN0UmVhc29uW1JlY29ubmVjdFJlYXNvbltcIlJSX1NXSVRDSF9DQU5ESURBVEVcIl0gPSA0XSA9IFwiUlJfU1dJVENIX0NBTkRJREFURVwiO1xufSkoUmVjb25uZWN0UmVhc29uIHx8IChSZWNvbm5lY3RSZWFzb24gPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoUmVjb25uZWN0UmVhc29uKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoUmVjb25uZWN0UmVhc29uLCBcImxpdmVraXQuUmVjb25uZWN0UmVhc29uXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlJSX1VOS05PV05cIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJSUl9TSUdOQUxfRElTQ09OTkVDVEVEXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiUlJfUFVCTElTSEVSX0ZBSUxFRFwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIlJSX1NVQlNDUklCRVJfRkFJTEVEXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiUlJfU1dJVENIX0NBTkRJREFURVwiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuU3Vic2NyaXB0aW9uRXJyb3JcbiAqL1xudmFyIFN1YnNjcmlwdGlvbkVycm9yO1xuKGZ1bmN0aW9uIChTdWJzY3JpcHRpb25FcnJvcikge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNFX1VOS05PV04gPSAwO1xuICAgKi9cbiAgU3Vic2NyaXB0aW9uRXJyb3JbU3Vic2NyaXB0aW9uRXJyb3JbXCJTRV9VTktOT1dOXCJdID0gMF0gPSBcIlNFX1VOS05PV05cIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTRV9DT0RFQ19VTlNVUFBPUlRFRCA9IDE7XG4gICAqL1xuICBTdWJzY3JpcHRpb25FcnJvcltTdWJzY3JpcHRpb25FcnJvcltcIlNFX0NPREVDX1VOU1VQUE9SVEVEXCJdID0gMV0gPSBcIlNFX0NPREVDX1VOU1VQUE9SVEVEXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU0VfVFJBQ0tfTk9URk9VTkQgPSAyO1xuICAgKi9cbiAgU3Vic2NyaXB0aW9uRXJyb3JbU3Vic2NyaXB0aW9uRXJyb3JbXCJTRV9UUkFDS19OT1RGT1VORFwiXSA9IDJdID0gXCJTRV9UUkFDS19OT1RGT1VORFwiO1xufSkoU3Vic2NyaXB0aW9uRXJyb3IgfHwgKFN1YnNjcmlwdGlvbkVycm9yID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFN1YnNjcmlwdGlvbkVycm9yKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoU3Vic2NyaXB0aW9uRXJyb3IsIFwibGl2ZWtpdC5TdWJzY3JpcHRpb25FcnJvclwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJTRV9VTktOT1dOXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiU0VfQ09ERUNfVU5TVVBQT1JURURcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJTRV9UUkFDS19OT1RGT1VORFwiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUm9vbVxuICovXG5sZXQgUm9vbSQxID0gY2xhc3MgUm9vbSBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzaWQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuc2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBuYW1lID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGVtcHR5X3RpbWVvdXQgPSAzO1xuICAgICAqL1xuICAgIHRoaXMuZW1wdHlUaW1lb3V0ID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBtYXhfcGFydGljaXBhbnRzID0gNDtcbiAgICAgKi9cbiAgICB0aGlzLm1heFBhcnRpY2lwYW50cyA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBjcmVhdGlvbl90aW1lID0gNTtcbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0aW9uVGltZSA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB0dXJuX3Bhc3N3b3JkID0gNjtcbiAgICAgKi9cbiAgICB0aGlzLnR1cm5QYXNzd29yZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LkNvZGVjIGVuYWJsZWRfY29kZWNzID0gNztcbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZWRDb2RlY3MgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBtZXRhZGF0YSA9IDg7XG4gICAgICovXG4gICAgdGhpcy5tZXRhZGF0YSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgbnVtX3BhcnRpY2lwYW50cyA9IDk7XG4gICAgICovXG4gICAgdGhpcy5udW1QYXJ0aWNpcGFudHMgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIG51bV9wdWJsaXNoZXJzID0gMTE7XG4gICAgICovXG4gICAgdGhpcy5udW1QdWJsaXNoZXJzID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgYWN0aXZlX3JlY29yZGluZyA9IDEwO1xuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlUmVjb3JkaW5nID0gZmFsc2U7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJvb20oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSb29tKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUm9vbSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUm9vbSwgYSwgYik7XG4gIH1cbn07XG5Sb29tJDEucnVudGltZSA9IHByb3RvMztcblJvb20kMS50eXBlTmFtZSA9IFwibGl2ZWtpdC5Sb29tXCI7XG5Sb29tJDEuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJlbXB0eV90aW1lb3V0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIm1heF9wYXJ0aWNpcGFudHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiY3JlYXRpb25fdGltZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwidHVybl9wYXNzd29yZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImVuYWJsZWRfY29kZWNzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDb2RlYyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwibWV0YWRhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJudW1fcGFydGljaXBhbnRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJudW1fcHVibGlzaGVyc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwiYWN0aXZlX3JlY29yZGluZ1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkNvZGVjXG4gKi9cbmNsYXNzIENvZGVjIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG1pbWUgPSAxO1xuICAgICAqL1xuICAgIHRoaXMubWltZSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgZm10cF9saW5lID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLmZtdHBMaW5lID0gXCJcIjtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ29kZWMoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDb2RlYygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IENvZGVjKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhDb2RlYywgYSwgYik7XG4gIH1cbn1cbkNvZGVjLnJ1bnRpbWUgPSBwcm90bzM7XG5Db2RlYy50eXBlTmFtZSA9IFwibGl2ZWtpdC5Db2RlY1wiO1xuQ29kZWMuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcIm1pbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJmbXRwX2xpbmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlBsYXlvdXREZWxheVxuICovXG5jbGFzcyBQbGF5b3V0RGVsYXkgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGVuYWJsZWQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIG1pbiA9IDI7XG4gICAgICovXG4gICAgdGhpcy5taW4gPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIG1heCA9IDM7XG4gICAgICovXG4gICAgdGhpcy5tYXggPSAwO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQbGF5b3V0RGVsYXkoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQbGF5b3V0RGVsYXkoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQbGF5b3V0RGVsYXkoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFBsYXlvdXREZWxheSwgYSwgYik7XG4gIH1cbn1cblBsYXlvdXREZWxheS5ydW50aW1lID0gcHJvdG8zO1xuUGxheW91dERlbGF5LnR5cGVOYW1lID0gXCJsaXZla2l0LlBsYXlvdXREZWxheVwiO1xuUGxheW91dERlbGF5LmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJlbmFibGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm1pblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJtYXhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5QYXJ0aWNpcGFudFBlcm1pc3Npb25cbiAqL1xuY2xhc3MgUGFydGljaXBhbnRQZXJtaXNzaW9uIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIGFsbG93IHBhcnRpY2lwYW50IHRvIHN1YnNjcmliZSB0byBvdGhlciB0cmFja3MgaW4gdGhlIHJvb21cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBjYW5fc3Vic2NyaWJlID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmNhblN1YnNjcmliZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIGFsbG93IHBhcnRpY2lwYW50IHRvIHB1Ymxpc2ggbmV3IHRyYWNrcyB0byByb29tXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgY2FuX3B1Ymxpc2ggPSAyO1xuICAgICAqL1xuICAgIHRoaXMuY2FuUHVibGlzaCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIGFsbG93IHBhcnRpY2lwYW50IHRvIHB1Ymxpc2ggZGF0YVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGNhbl9wdWJsaXNoX2RhdGEgPSAzO1xuICAgICAqL1xuICAgIHRoaXMuY2FuUHVibGlzaERhdGEgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBzb3VyY2VzIHRoYXQgYXJlIGFsbG93ZWQgdG8gYmUgcHVibGlzaGVkXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuVHJhY2tTb3VyY2UgY2FuX3B1Ymxpc2hfc291cmNlcyA9IDk7XG4gICAgICovXG4gICAgdGhpcy5jYW5QdWJsaXNoU291cmNlcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyB0aGF0IGl0J3MgaGlkZGVuIHRvIG90aGVyc1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGhpZGRlbiA9IDc7XG4gICAgICovXG4gICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaXQncyBhIHJlY29yZGVyIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgcmVjb3JkZXIgPSA4O1xuICAgICAqL1xuICAgIHRoaXMucmVjb3JkZXIgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgdGhhdCBwYXJ0aWNpcGFudCBjYW4gdXBkYXRlIG93biBtZXRhZGF0YVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGNhbl91cGRhdGVfbWV0YWRhdGEgPSAxMDtcbiAgICAgKi9cbiAgICB0aGlzLmNhblVwZGF0ZU1ldGFkYXRhID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIHRoYXQgcGFydGljaXBhbnQgaXMgYW4gYWdlbnRcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBhZ2VudCA9IDExO1xuICAgICAqL1xuICAgIHRoaXMuYWdlbnQgPSBmYWxzZTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRQZXJtaXNzaW9uKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRQZXJtaXNzaW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRQZXJtaXNzaW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhQYXJ0aWNpcGFudFBlcm1pc3Npb24sIGEsIGIpO1xuICB9XG59XG5QYXJ0aWNpcGFudFBlcm1pc3Npb24ucnVudGltZSA9IHByb3RvMztcblBhcnRpY2lwYW50UGVybWlzc2lvbi50eXBlTmFtZSA9IFwibGl2ZWtpdC5QYXJ0aWNpcGFudFBlcm1pc3Npb25cIjtcblBhcnRpY2lwYW50UGVybWlzc2lvbi5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY2FuX3N1YnNjcmliZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJjYW5fcHVibGlzaFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJjYW5fcHVibGlzaF9kYXRhXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcImNhbl9wdWJsaXNoX3NvdXJjZXNcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1NvdXJjZSksXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImhpZGRlblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJyZWNvcmRlclwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwiY2FuX3VwZGF0ZV9tZXRhZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwiYWdlbnRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5QYXJ0aWNpcGFudEluZm9cbiAqL1xuY2xhc3MgUGFydGljaXBhbnRJbmZvIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHNpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5zaWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGlkZW50aXR5ID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLmlkZW50aXR5ID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuUGFydGljaXBhbnRJbmZvLlN0YXRlIHN0YXRlID0gMztcbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlID0gUGFydGljaXBhbnRJbmZvX1N0YXRlLkpPSU5JTkc7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlRyYWNrSW5mbyB0cmFja3MgPSA0O1xuICAgICAqL1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbWV0YWRhdGEgPSA1O1xuICAgICAqL1xuICAgIHRoaXMubWV0YWRhdGEgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIHRpbWVzdGFtcCB3aGVuIHBhcnRpY2lwYW50IGpvaW5lZCByb29tLCBpbiBzZWNvbmRzXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IGpvaW5lZF9hdCA9IDY7XG4gICAgICovXG4gICAgdGhpcy5qb2luZWRBdCA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBuYW1lID0gOTtcbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHZlcnNpb24gPSAxMDtcbiAgICAgKi9cbiAgICB0aGlzLnZlcnNpb24gPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHJlZ2lvbiA9IDEyO1xuICAgICAqL1xuICAgIHRoaXMucmVnaW9uID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgdGhlIHBhcnRpY2lwYW50IGhhcyBhbiBhY3RpdmUgcHVibGlzaGVyIGNvbm5lY3Rpb25cbiAgICAgKiBhbmQgY2FuIHB1Ymxpc2ggdG8gdGhlIHNlcnZlclxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGlzX3B1Ymxpc2hlciA9IDEzO1xuICAgICAqL1xuICAgIHRoaXMuaXNQdWJsaXNoZXIgPSBmYWxzZTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRJbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhQYXJ0aWNpcGFudEluZm8sIGEsIGIpO1xuICB9XG59XG5QYXJ0aWNpcGFudEluZm8ucnVudGltZSA9IHByb3RvMztcblBhcnRpY2lwYW50SW5mby50eXBlTmFtZSA9IFwibGl2ZWtpdC5QYXJ0aWNpcGFudEluZm9cIjtcblBhcnRpY2lwYW50SW5mby5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiaWRlbnRpdHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJzdGF0ZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFBhcnRpY2lwYW50SW5mb19TdGF0ZSlcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwidHJhY2tzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFja0luZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIm1ldGFkYXRhXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiam9pbmVkX2F0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJuYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcInZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcInBlcm1pc3Npb25cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBhcnRpY2lwYW50UGVybWlzc2lvblxufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwicmVnaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcImlzX3B1Ymxpc2hlclwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlBhcnRpY2lwYW50SW5mby5TdGF0ZVxuICovXG52YXIgUGFydGljaXBhbnRJbmZvX1N0YXRlO1xuKGZ1bmN0aW9uIChQYXJ0aWNpcGFudEluZm9fU3RhdGUpIHtcbiAgLyoqXG4gICAqIHdlYnNvY2tldCcgY29ubmVjdGVkLCBidXQgbm90IG9mZmVyZWQgeWV0XG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBKT0lOSU5HID0gMDtcbiAgICovXG4gIFBhcnRpY2lwYW50SW5mb19TdGF0ZVtQYXJ0aWNpcGFudEluZm9fU3RhdGVbXCJKT0lOSU5HXCJdID0gMF0gPSBcIkpPSU5JTkdcIjtcbiAgLyoqXG4gICAqIHNlcnZlciByZWNlaXZlZCBjbGllbnQgb2ZmZXJcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEpPSU5FRCA9IDE7XG4gICAqL1xuICBQYXJ0aWNpcGFudEluZm9fU3RhdGVbUGFydGljaXBhbnRJbmZvX1N0YXRlW1wiSk9JTkVEXCJdID0gMV0gPSBcIkpPSU5FRFwiO1xuICAvKipcbiAgICogSUNFIGNvbm5lY3Rpdml0eSBlc3RhYmxpc2hlZFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQUNUSVZFID0gMjtcbiAgICovXG4gIFBhcnRpY2lwYW50SW5mb19TdGF0ZVtQYXJ0aWNpcGFudEluZm9fU3RhdGVbXCJBQ1RJVkVcIl0gPSAyXSA9IFwiQUNUSVZFXCI7XG4gIC8qKlxuICAgKiBXUyBkaXNjb25uZWN0ZWRcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IERJU0NPTk5FQ1RFRCA9IDM7XG4gICAqL1xuICBQYXJ0aWNpcGFudEluZm9fU3RhdGVbUGFydGljaXBhbnRJbmZvX1N0YXRlW1wiRElTQ09OTkVDVEVEXCJdID0gM10gPSBcIkRJU0NPTk5FQ1RFRFwiO1xufSkoUGFydGljaXBhbnRJbmZvX1N0YXRlIHx8IChQYXJ0aWNpcGFudEluZm9fU3RhdGUgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoUGFydGljaXBhbnRJbmZvX1N0YXRlKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoUGFydGljaXBhbnRJbmZvX1N0YXRlLCBcImxpdmVraXQuUGFydGljaXBhbnRJbmZvLlN0YXRlXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkpPSU5JTkdcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJKT0lORURcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJBQ1RJVkVcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJESVNDT05ORUNURURcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkVuY3J5cHRpb25cbiAqL1xuY2xhc3MgRW5jcnlwdGlvbiBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRW5jcnlwdGlvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEVuY3J5cHRpb24oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBFbmNyeXB0aW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhFbmNyeXB0aW9uLCBhLCBiKTtcbiAgfVxufVxuRW5jcnlwdGlvbi5ydW50aW1lID0gcHJvdG8zO1xuRW5jcnlwdGlvbi50eXBlTmFtZSA9IFwibGl2ZWtpdC5FbmNyeXB0aW9uXCI7XG5FbmNyeXB0aW9uLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuRW5jcnlwdGlvbi5UeXBlXG4gKi9cbnZhciBFbmNyeXB0aW9uX1R5cGU7XG4oZnVuY3Rpb24gKEVuY3J5cHRpb25fVHlwZSkge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IE5PTkUgPSAwO1xuICAgKi9cbiAgRW5jcnlwdGlvbl9UeXBlW0VuY3J5cHRpb25fVHlwZVtcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEdDTSA9IDE7XG4gICAqL1xuICBFbmNyeXB0aW9uX1R5cGVbRW5jcnlwdGlvbl9UeXBlW1wiR0NNXCJdID0gMV0gPSBcIkdDTVwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IENVU1RPTSA9IDI7XG4gICAqL1xuICBFbmNyeXB0aW9uX1R5cGVbRW5jcnlwdGlvbl9UeXBlW1wiQ1VTVE9NXCJdID0gMl0gPSBcIkNVU1RPTVwiO1xufSkoRW5jcnlwdGlvbl9UeXBlIHx8IChFbmNyeXB0aW9uX1R5cGUgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jcnlwdGlvbl9UeXBlKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoRW5jcnlwdGlvbl9UeXBlLCBcImxpdmVraXQuRW5jcnlwdGlvbi5UeXBlXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIk5PTkVcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJHQ01cIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJDVVNUT01cIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlNpbXVsY2FzdENvZGVjSW5mb1xuICovXG5jbGFzcyBTaW11bGNhc3RDb2RlY0luZm8gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbWltZV90eXBlID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLm1pbWVUeXBlID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBtaWQgPSAyO1xuICAgICAqL1xuICAgIHRoaXMubWlkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBjaWQgPSAzO1xuICAgICAqL1xuICAgIHRoaXMuY2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuVmlkZW9MYXllciBsYXllcnMgPSA0O1xuICAgICAqL1xuICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNpbXVsY2FzdENvZGVjSW5mbygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNpbXVsY2FzdENvZGVjSW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNpbXVsY2FzdENvZGVjSW5mbygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU2ltdWxjYXN0Q29kZWNJbmZvLCBhLCBiKTtcbiAgfVxufVxuU2ltdWxjYXN0Q29kZWNJbmZvLnJ1bnRpbWUgPSBwcm90bzM7XG5TaW11bGNhc3RDb2RlY0luZm8udHlwZU5hbWUgPSBcImxpdmVraXQuU2ltdWxjYXN0Q29kZWNJbmZvXCI7XG5TaW11bGNhc3RDb2RlY0luZm8uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcIm1pbWVfdHlwZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm1pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImxheWVyc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVmlkZW9MYXllcixcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5UcmFja0luZm9cbiAqL1xuY2xhc3MgVHJhY2tJbmZvIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHNpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5zaWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5UcmFja1R5cGUgdHlwZSA9IDI7XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gVHJhY2tUeXBlLkFVRElPO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG5hbWUgPSAzO1xuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIG11dGVkID0gNDtcbiAgICAgKi9cbiAgICB0aGlzLm11dGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogb3JpZ2luYWwgd2lkdGggb2YgdmlkZW8gKHVuc2V0IGZvciBhdWRpbylcbiAgICAgKiBjbGllbnRzIG1heSByZWNlaXZlIGEgbG93ZXIgcmVzb2x1dGlvbiB2ZXJzaW9uIHdpdGggc2ltdWxjYXN0XG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiB3aWR0aCA9IDU7XG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgLyoqXG4gICAgICogb3JpZ2luYWwgaGVpZ2h0IG9mIHZpZGVvICh1bnNldCBmb3IgYXVkaW8pXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBoZWlnaHQgPSA2O1xuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRyYWNrIGlzIHNpbXVsY2FzdGVkXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgc2ltdWxjYXN0ID0gNztcbiAgICAgKi9cbiAgICB0aGlzLnNpbXVsY2FzdCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIHRydWUgaWYgRFRYIChEaXNjb250aW51b3VzIFRyYW5zbWlzc2lvbikgaXMgZGlzYWJsZWQgZm9yIGF1ZGlvXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgZGlzYWJsZV9kdHggPSA4O1xuICAgICAqL1xuICAgIHRoaXMuZGlzYWJsZUR0eCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIHNvdXJjZSBvZiBtZWRpYVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlRyYWNrU291cmNlIHNvdXJjZSA9IDk7XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2UgPSBUcmFja1NvdXJjZS5VTktOT1dOO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5WaWRlb0xheWVyIGxheWVycyA9IDEwO1xuICAgICAqL1xuICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgLyoqXG4gICAgICogbWltZSB0eXBlIG9mIGNvZGVjXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBtaW1lX3R5cGUgPSAxMTtcbiAgICAgKi9cbiAgICB0aGlzLm1pbWVUeXBlID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBtaWQgPSAxMjtcbiAgICAgKi9cbiAgICB0aGlzLm1pZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlNpbXVsY2FzdENvZGVjSW5mbyBjb2RlY3MgPSAxMztcbiAgICAgKi9cbiAgICB0aGlzLmNvZGVjcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBzdGVyZW8gPSAxNDtcbiAgICAgKi9cbiAgICB0aGlzLnN0ZXJlbyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIHRydWUgaWYgUkVEIChSZWR1bmRhbnQgRW5jb2RpbmcpIGlzIGRpc2FibGVkIGZvciBhdWRpb1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGRpc2FibGVfcmVkID0gMTU7XG4gICAgICovXG4gICAgdGhpcy5kaXNhYmxlUmVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkVuY3J5cHRpb24uVHlwZSBlbmNyeXB0aW9uID0gMTY7XG4gICAgICovXG4gICAgdGhpcy5lbmNyeXB0aW9uID0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc3RyZWFtID0gMTc7XG4gICAgICovXG4gICAgdGhpcy5zdHJlYW0gPSBcIlwiO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFja0luZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFja0luZm8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFja0luZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFRyYWNrSW5mbywgYSwgYik7XG4gIH1cbn1cblRyYWNrSW5mby5ydW50aW1lID0gcHJvdG8zO1xuVHJhY2tJbmZvLnR5cGVOYW1lID0gXCJsaXZla2l0LlRyYWNrSW5mb1wiO1xuVHJhY2tJbmZvLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0eXBlXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tUeXBlKVxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJuYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwibXV0ZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwid2lkdGhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiaGVpZ2h0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcInNpbXVsY2FzdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJkaXNhYmxlX2R0eFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJzb3VyY2VcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1NvdXJjZSlcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcImxheWVyc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVmlkZW9MYXllcixcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcIm1pbWVfdHlwZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJtaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwiY29kZWNzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTaW11bGNhc3RDb2RlY0luZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAxNCxcbiAgbmFtZTogXCJzdGVyZW9cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDE1LFxuICBuYW1lOiBcImRpc2FibGVfcmVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxNixcbiAgbmFtZTogXCJlbmNyeXB0aW9uXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jcnlwdGlvbl9UeXBlKVxufSwge1xuICBubzogMTcsXG4gIG5hbWU6IFwic3RyZWFtXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbi8qKlxuICogcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCBhdmFpbGFibGUgc3BhdGlhbCBsYXllcnNcbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlZpZGVvTGF5ZXJcbiAqL1xuY2xhc3MgVmlkZW9MYXllciBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBmb3IgdHJhY2tzIHdpdGggYSBzaW5nbGUgbGF5ZXIsIHRoaXMgc2hvdWxkIGJlIEhJR0hcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5WaWRlb1F1YWxpdHkgcXVhbGl0eSA9IDE7XG4gICAgICovXG4gICAgdGhpcy5xdWFsaXR5ID0gVmlkZW9RdWFsaXR5LkxPVztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiB3aWR0aCA9IDI7XG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgaGVpZ2h0ID0gMztcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgLyoqXG4gICAgICogdGFyZ2V0IGJpdHJhdGUgaW4gYml0IHBlciBzZWNvbmQgKGJwcyksIHNlcnZlciB3aWxsIG1lYXN1cmUgYWN0dWFsXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBiaXRyYXRlID0gNDtcbiAgICAgKi9cbiAgICB0aGlzLmJpdHJhdGUgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHNzcmMgPSA1O1xuICAgICAqL1xuICAgIHRoaXMuc3NyYyA9IDA7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFZpZGVvTGF5ZXIoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBWaWRlb0xheWVyKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVmlkZW9MYXllcigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVmlkZW9MYXllciwgYSwgYik7XG4gIH1cbn1cblZpZGVvTGF5ZXIucnVudGltZSA9IHByb3RvMztcblZpZGVvTGF5ZXIudHlwZU5hbWUgPSBcImxpdmVraXQuVmlkZW9MYXllclwiO1xuVmlkZW9MYXllci5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicXVhbGl0eVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSlcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwid2lkdGhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiaGVpZ2h0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImJpdHJhdGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwic3NyY1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufV0pO1xuLyoqXG4gKiBuZXcgRGF0YVBhY2tldCBBUElcbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkRhdGFQYWNrZXRcbiAqL1xuY2xhc3MgRGF0YVBhY2tldCBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuRGF0YVBhY2tldC5LaW5kIGtpbmQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMua2luZCA9IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gb25lb2YgbGl2ZWtpdC5EYXRhUGFja2V0LnZhbHVlXG4gICAgICovXG4gICAgdGhpcy52YWx1ZSA9IHtcbiAgICAgIGNhc2U6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERhdGFQYWNrZXQoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhUGFja2V0KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRGF0YVBhY2tldCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoRGF0YVBhY2tldCwgYSwgYik7XG4gIH1cbn1cbkRhdGFQYWNrZXQucnVudGltZSA9IHByb3RvMztcbkRhdGFQYWNrZXQudHlwZU5hbWUgPSBcImxpdmVraXQuRGF0YVBhY2tldFwiO1xuRGF0YVBhY2tldC5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwia2luZFwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKERhdGFQYWNrZXRfS2luZClcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidXNlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXNlclBhY2tldCxcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJzcGVha2VyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBBY3RpdmVTcGVha2VyVXBkYXRlLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuRGF0YVBhY2tldC5LaW5kXG4gKi9cbnZhciBEYXRhUGFja2V0X0tpbmQ7XG4oZnVuY3Rpb24gKERhdGFQYWNrZXRfS2luZCkge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFJFTElBQkxFID0gMDtcbiAgICovXG4gIERhdGFQYWNrZXRfS2luZFtEYXRhUGFja2V0X0tpbmRbXCJSRUxJQUJMRVwiXSA9IDBdID0gXCJSRUxJQUJMRVwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IExPU1NZID0gMTtcbiAgICovXG4gIERhdGFQYWNrZXRfS2luZFtEYXRhUGFja2V0X0tpbmRbXCJMT1NTWVwiXSA9IDFdID0gXCJMT1NTWVwiO1xufSkoRGF0YVBhY2tldF9LaW5kIHx8IChEYXRhUGFja2V0X0tpbmQgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoRGF0YVBhY2tldF9LaW5kKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoRGF0YVBhY2tldF9LaW5kLCBcImxpdmVraXQuRGF0YVBhY2tldC5LaW5kXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlJFTElBQkxFXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiTE9TU1lcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkFjdGl2ZVNwZWFrZXJVcGRhdGVcbiAqL1xuY2xhc3MgQWN0aXZlU3BlYWtlclVwZGF0ZSBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuU3BlYWtlckluZm8gc3BlYWtlcnMgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuc3BlYWtlcnMgPSBbXTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQWN0aXZlU3BlYWtlclVwZGF0ZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEFjdGl2ZVNwZWFrZXJVcGRhdGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBBY3RpdmVTcGVha2VyVXBkYXRlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhBY3RpdmVTcGVha2VyVXBkYXRlLCBhLCBiKTtcbiAgfVxufVxuQWN0aXZlU3BlYWtlclVwZGF0ZS5ydW50aW1lID0gcHJvdG8zO1xuQWN0aXZlU3BlYWtlclVwZGF0ZS50eXBlTmFtZSA9IFwibGl2ZWtpdC5BY3RpdmVTcGVha2VyVXBkYXRlXCI7XG5BY3RpdmVTcGVha2VyVXBkYXRlLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzcGVha2Vyc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3BlYWtlckluZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3BlYWtlckluZm9cbiAqL1xuY2xhc3MgU3BlYWtlckluZm8gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc2lkID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnNpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogYXVkaW8gbGV2ZWwsIDAtMS4wLCAxIGlzIGxvdWRlc3RcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZmxvYXQgbGV2ZWwgPSAyO1xuICAgICAqL1xuICAgIHRoaXMubGV2ZWwgPSAwO1xuICAgIC8qKlxuICAgICAqIHRydWUgaWYgc3BlYWtlciBpcyBjdXJyZW50bHkgYWN0aXZlXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgYWN0aXZlID0gMztcbiAgICAgKi9cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTcGVha2VySW5mbygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNwZWFrZXJJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3BlYWtlckluZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFNwZWFrZXJJbmZvLCBhLCBiKTtcbiAgfVxufVxuU3BlYWtlckluZm8ucnVudGltZSA9IHByb3RvMztcblNwZWFrZXJJbmZvLnR5cGVOYW1lID0gXCJsaXZla2l0LlNwZWFrZXJJbmZvXCI7XG5TcGVha2VySW5mby5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibGV2ZWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMiAvKiBTY2FsYXJUeXBlLkZMT0FUICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImFjdGl2ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlVzZXJQYWNrZXRcbiAqL1xuY2xhc3MgVXNlclBhY2tldCBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBwYXJ0aWNpcGFudCBJRCBvZiB1c2VyIHRoYXQgc2VudCB0aGUgbWVzc2FnZVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcGFydGljaXBhbnRfc2lkID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnBhcnRpY2lwYW50U2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBwYXJ0aWNpcGFudF9pZGVudGl0eSA9IDU7XG4gICAgICovXG4gICAgdGhpcy5wYXJ0aWNpcGFudElkZW50aXR5ID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiB1c2VyIGRlZmluZWQgcGF5bG9hZFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBieXRlcyBwYXlsb2FkID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnBheWxvYWQgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICAvKipcbiAgICAgKiB0aGUgSUQgb2YgdGhlIHBhcnRpY2lwYW50cyB3aG8gd2lsbCByZWNlaXZlIHRoZSBtZXNzYWdlIChzZW50IHRvIGFsbCBieSBkZWZhdWx0KVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBzdHJpbmcgZGVzdGluYXRpb25fc2lkcyA9IDM7XG4gICAgICovXG4gICAgdGhpcy5kZXN0aW5hdGlvblNpZHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBpZGVudGl0aWVzIG9mIHBhcnRpY2lwYW50cyB3aG8gd2lsbCByZWNlaXZlIHRoZSBtZXNzYWdlIChzZW50IHRvIGFsbCBieSBkZWZhdWx0KVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBzdHJpbmcgZGVzdGluYXRpb25faWRlbnRpdGllcyA9IDY7XG4gICAgICovXG4gICAgdGhpcy5kZXN0aW5hdGlvbklkZW50aXRpZXMgPSBbXTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVXNlclBhY2tldCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVzZXJQYWNrZXQoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBVc2VyUGFja2V0KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhVc2VyUGFja2V0LCBhLCBiKTtcbiAgfVxufVxuVXNlclBhY2tldC5ydW50aW1lID0gcHJvdG8zO1xuVXNlclBhY2tldC50eXBlTmFtZSA9IFwibGl2ZWtpdC5Vc2VyUGFja2V0XCI7XG5Vc2VyUGFja2V0LmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInBheWxvYWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTIgLyogU2NhbGFyVHlwZS5CWVRFUyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJkZXN0aW5hdGlvbl9zaWRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImRlc3RpbmF0aW9uX2lkZW50aXRpZXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwidG9waWNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyxcbiAgb3B0OiB0cnVlXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUGFydGljaXBhbnRUcmFja3NcbiAqL1xuY2xhc3MgUGFydGljaXBhbnRUcmFja3MgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogcGFydGljaXBhbnQgSUQgb2YgcGFydGljaXBhbnQgdG8gd2hvbSB0aGUgdHJhY2tzIGJlbG9uZ1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcGFydGljaXBhbnRfc2lkID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnBhcnRpY2lwYW50U2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIHN0cmluZyB0cmFja19zaWRzID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrU2lkcyA9IFtdO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aWNpcGFudFRyYWNrcygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50VHJhY2tzKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRUcmFja3MoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFBhcnRpY2lwYW50VHJhY2tzLCBhLCBiKTtcbiAgfVxufVxuUGFydGljaXBhbnRUcmFja3MucnVudGltZSA9IHByb3RvMztcblBhcnRpY2lwYW50VHJhY2tzLnR5cGVOYW1lID0gXCJsaXZla2l0LlBhcnRpY2lwYW50VHJhY2tzXCI7XG5QYXJ0aWNpcGFudFRyYWNrcy5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHJhY2tfc2lkc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBkZXRhaWxzIGFib3V0IHRoZSBzZXJ2ZXJcbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlNlcnZlckluZm9cbiAqL1xuY2xhc3MgU2VydmVySW5mbyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuU2VydmVySW5mby5FZGl0aW9uIGVkaXRpb24gPSAxO1xuICAgICAqL1xuICAgIHRoaXMuZWRpdGlvbiA9IFNlcnZlckluZm9fRWRpdGlvbi5TdGFuZGFyZDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB2ZXJzaW9uID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnZlcnNpb24gPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgcHJvdG9jb2wgPSAzO1xuICAgICAqL1xuICAgIHRoaXMucHJvdG9jb2wgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHJlZ2lvbiA9IDQ7XG4gICAgICovXG4gICAgdGhpcy5yZWdpb24gPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG5vZGVfaWQgPSA1O1xuICAgICAqL1xuICAgIHRoaXMubm9kZUlkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBhZGRpdGlvbmFsIGRlYnVnZ2luZyBpbmZvcm1hdGlvbi4gc2VudCBvbmx5IGlmIHNlcnZlciBpcyBpbiBkZXZlbG9wbWVudCBtb2RlXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBkZWJ1Z19pbmZvID0gNjtcbiAgICAgKi9cbiAgICB0aGlzLmRlYnVnSW5mbyA9IFwiXCI7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNlcnZlckluZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTZXJ2ZXJJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2VydmVySW5mbygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU2VydmVySW5mbywgYSwgYik7XG4gIH1cbn1cblNlcnZlckluZm8ucnVudGltZSA9IHByb3RvMztcblNlcnZlckluZm8udHlwZU5hbWUgPSBcImxpdmVraXQuU2VydmVySW5mb1wiO1xuU2VydmVySW5mby5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiZWRpdGlvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFNlcnZlckluZm9fRWRpdGlvbilcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInByb3RvY29sXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJyZWdpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJub2RlX2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiZGVidWdfaW5mb1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuU2VydmVySW5mby5FZGl0aW9uXG4gKi9cbnZhciBTZXJ2ZXJJbmZvX0VkaXRpb247XG4oZnVuY3Rpb24gKFNlcnZlckluZm9fRWRpdGlvbikge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFN0YW5kYXJkID0gMDtcbiAgICovXG4gIFNlcnZlckluZm9fRWRpdGlvbltTZXJ2ZXJJbmZvX0VkaXRpb25bXCJTdGFuZGFyZFwiXSA9IDBdID0gXCJTdGFuZGFyZFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IENsb3VkID0gMTtcbiAgICovXG4gIFNlcnZlckluZm9fRWRpdGlvbltTZXJ2ZXJJbmZvX0VkaXRpb25bXCJDbG91ZFwiXSA9IDFdID0gXCJDbG91ZFwiO1xufSkoU2VydmVySW5mb19FZGl0aW9uIHx8IChTZXJ2ZXJJbmZvX0VkaXRpb24gPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoU2VydmVySW5mb19FZGl0aW9uKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoU2VydmVySW5mb19FZGl0aW9uLCBcImxpdmVraXQuU2VydmVySW5mby5FZGl0aW9uXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlN0YW5kYXJkXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiQ2xvdWRcIlxufV0pO1xuLyoqXG4gKiBkZXRhaWxzIGFib3V0IHRoZSBjbGllbnRcbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkNsaWVudEluZm9cbiAqL1xuY2xhc3MgQ2xpZW50SW5mbyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuQ2xpZW50SW5mby5TREsgc2RrID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnNkayA9IENsaWVudEluZm9fU0RLLlVOS05PV047XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdmVyc2lvbiA9IDI7XG4gICAgICovXG4gICAgdGhpcy52ZXJzaW9uID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDMyIHByb3RvY29sID0gMztcbiAgICAgKi9cbiAgICB0aGlzLnByb3RvY29sID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBvcyA9IDQ7XG4gICAgICovXG4gICAgdGhpcy5vcyA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgb3NfdmVyc2lvbiA9IDU7XG4gICAgICovXG4gICAgdGhpcy5vc1ZlcnNpb24gPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGRldmljZV9tb2RlbCA9IDY7XG4gICAgICovXG4gICAgdGhpcy5kZXZpY2VNb2RlbCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgYnJvd3NlciA9IDc7XG4gICAgICovXG4gICAgdGhpcy5icm93c2VyID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBicm93c2VyX3ZlcnNpb24gPSA4O1xuICAgICAqL1xuICAgIHRoaXMuYnJvd3NlclZlcnNpb24gPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGFkZHJlc3MgPSA5O1xuICAgICAqL1xuICAgIHRoaXMuYWRkcmVzcyA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogd2lmaSwgd2lyZWQsIGNlbGx1bGFyLCB2cG4sIGVtcHR5IGlmIG5vdCBrbm93blxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbmV0d29yayA9IDEwO1xuICAgICAqL1xuICAgIHRoaXMubmV0d29yayA9IFwiXCI7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IENsaWVudEluZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGllbnRJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ2xpZW50SW5mbygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoQ2xpZW50SW5mbywgYSwgYik7XG4gIH1cbn1cbkNsaWVudEluZm8ucnVudGltZSA9IHByb3RvMztcbkNsaWVudEluZm8udHlwZU5hbWUgPSBcImxpdmVraXQuQ2xpZW50SW5mb1wiO1xuQ2xpZW50SW5mby5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic2RrXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50SW5mb19TREspXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJwcm90b2NvbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwib3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJvc192ZXJzaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiZGV2aWNlX21vZGVsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiYnJvd3NlclwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcImJyb3dzZXJfdmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcImFkZHJlc3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwibmV0d29ya1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuQ2xpZW50SW5mby5TREtcbiAqL1xudmFyIENsaWVudEluZm9fU0RLO1xuKGZ1bmN0aW9uIChDbGllbnRJbmZvX1NESykge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFVOS05PV04gPSAwO1xuICAgKi9cbiAgQ2xpZW50SW5mb19TREtbQ2xpZW50SW5mb19TREtbXCJVTktOT1dOXCJdID0gMF0gPSBcIlVOS05PV05cIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBKUyA9IDE7XG4gICAqL1xuICBDbGllbnRJbmZvX1NES1tDbGllbnRJbmZvX1NES1tcIkpTXCJdID0gMV0gPSBcIkpTXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU1dJRlQgPSAyO1xuICAgKi9cbiAgQ2xpZW50SW5mb19TREtbQ2xpZW50SW5mb19TREtbXCJTV0lGVFwiXSA9IDJdID0gXCJTV0lGVFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEFORFJPSUQgPSAzO1xuICAgKi9cbiAgQ2xpZW50SW5mb19TREtbQ2xpZW50SW5mb19TREtbXCJBTkRST0lEXCJdID0gM10gPSBcIkFORFJPSURcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBGTFVUVEVSID0gNDtcbiAgICovXG4gIENsaWVudEluZm9fU0RLW0NsaWVudEluZm9fU0RLW1wiRkxVVFRFUlwiXSA9IDRdID0gXCJGTFVUVEVSXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogR08gPSA1O1xuICAgKi9cbiAgQ2xpZW50SW5mb19TREtbQ2xpZW50SW5mb19TREtbXCJHT1wiXSA9IDVdID0gXCJHT1wiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFVOSVRZID0gNjtcbiAgICovXG4gIENsaWVudEluZm9fU0RLW0NsaWVudEluZm9fU0RLW1wiVU5JVFlcIl0gPSA2XSA9IFwiVU5JVFlcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSRUFDVF9OQVRJVkUgPSA3O1xuICAgKi9cbiAgQ2xpZW50SW5mb19TREtbQ2xpZW50SW5mb19TREtbXCJSRUFDVF9OQVRJVkVcIl0gPSA3XSA9IFwiUkVBQ1RfTkFUSVZFXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUlVTVCA9IDg7XG4gICAqL1xuICBDbGllbnRJbmZvX1NES1tDbGllbnRJbmZvX1NES1tcIlJVU1RcIl0gPSA4XSA9IFwiUlVTVFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFBZVEhPTiA9IDk7XG4gICAqL1xuICBDbGllbnRJbmZvX1NES1tDbGllbnRJbmZvX1NES1tcIlBZVEhPTlwiXSA9IDldID0gXCJQWVRIT05cIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBDUFAgPSAxMDtcbiAgICovXG4gIENsaWVudEluZm9fU0RLW0NsaWVudEluZm9fU0RLW1wiQ1BQXCJdID0gMTBdID0gXCJDUFBcIjtcbn0pKENsaWVudEluZm9fU0RLIHx8IChDbGllbnRJbmZvX1NESyA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRJbmZvX1NESylcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKENsaWVudEluZm9fU0RLLCBcImxpdmVraXQuQ2xpZW50SW5mby5TREtcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiVU5LTk9XTlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkpTXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiU1dJRlRcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJBTkRST0lEXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiRkxVVFRFUlwiXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIkdPXCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiVU5JVFlcIlxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJSRUFDVF9OQVRJVkVcIlxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJSVVNUXCJcbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwiUFlUSE9OXCJcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcIkNQUFwiXG59XSk7XG4vKipcbiAqIHNlcnZlciBwcm92aWRlZCBjbGllbnQgY29uZmlndXJhdGlvblxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuQ2xpZW50Q29uZmlndXJhdGlvblxuICovXG5jbGFzcyBDbGllbnRDb25maWd1cmF0aW9uIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5DbGllbnRDb25maWdTZXR0aW5nIHJlc3VtZV9jb25uZWN0aW9uID0gMztcbiAgICAgKi9cbiAgICB0aGlzLnJlc3VtZUNvbm5lY3Rpb24gPSBDbGllbnRDb25maWdTZXR0aW5nLlVOU0VUO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5DbGllbnRDb25maWdTZXR0aW5nIGZvcmNlX3JlbGF5ID0gNTtcbiAgICAgKi9cbiAgICB0aGlzLmZvcmNlUmVsYXkgPSBDbGllbnRDb25maWdTZXR0aW5nLlVOU0VUO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGllbnRDb25maWd1cmF0aW9uKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ2xpZW50Q29uZmlndXJhdGlvbigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IENsaWVudENvbmZpZ3VyYXRpb24oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKENsaWVudENvbmZpZ3VyYXRpb24sIGEsIGIpO1xuICB9XG59XG5DbGllbnRDb25maWd1cmF0aW9uLnJ1bnRpbWUgPSBwcm90bzM7XG5DbGllbnRDb25maWd1cmF0aW9uLnR5cGVOYW1lID0gXCJsaXZla2l0LkNsaWVudENvbmZpZ3VyYXRpb25cIjtcbkNsaWVudENvbmZpZ3VyYXRpb24uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInZpZGVvXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBWaWRlb0NvbmZpZ3VyYXRpb25cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwic2NyZWVuXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBWaWRlb0NvbmZpZ3VyYXRpb25cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicmVzdW1lX2Nvbm5lY3Rpb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nKVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJkaXNhYmxlZF9jb2RlY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IERpc2FibGVkQ29kZWNzXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImZvcmNlX3JlbGF5XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZylcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5WaWRlb0NvbmZpZ3VyYXRpb25cbiAqL1xuY2xhc3MgVmlkZW9Db25maWd1cmF0aW9uIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5DbGllbnRDb25maWdTZXR0aW5nIGhhcmR3YXJlX2VuY29kZXIgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuaGFyZHdhcmVFbmNvZGVyID0gQ2xpZW50Q29uZmlnU2V0dGluZy5VTlNFVDtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVmlkZW9Db25maWd1cmF0aW9uKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVmlkZW9Db25maWd1cmF0aW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVmlkZW9Db25maWd1cmF0aW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhWaWRlb0NvbmZpZ3VyYXRpb24sIGEsIGIpO1xuICB9XG59XG5WaWRlb0NvbmZpZ3VyYXRpb24ucnVudGltZSA9IHByb3RvMztcblZpZGVvQ29uZmlndXJhdGlvbi50eXBlTmFtZSA9IFwibGl2ZWtpdC5WaWRlb0NvbmZpZ3VyYXRpb25cIjtcblZpZGVvQ29uZmlndXJhdGlvbi5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiaGFyZHdhcmVfZW5jb2RlclwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudENvbmZpZ1NldHRpbmcpXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuRGlzYWJsZWRDb2RlY3NcbiAqL1xuY2xhc3MgRGlzYWJsZWRDb2RlY3MgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogZGlzYWJsZWQgZm9yIGJvdGggcHVibGlzaCBhbmQgc3Vic2NyaWJlXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuQ29kZWMgY29kZWNzID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmNvZGVjcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIG9ubHkgZGlzYWJsZSBmb3IgcHVibGlzaFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LkNvZGVjIHB1Ymxpc2ggPSAyO1xuICAgICAqL1xuICAgIHRoaXMucHVibGlzaCA9IFtdO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBEaXNhYmxlZENvZGVjcygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERpc2FibGVkQ29kZWNzKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRGlzYWJsZWRDb2RlY3MoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKERpc2FibGVkQ29kZWNzLCBhLCBiKTtcbiAgfVxufVxuRGlzYWJsZWRDb2RlY3MucnVudGltZSA9IHByb3RvMztcbkRpc2FibGVkQ29kZWNzLnR5cGVOYW1lID0gXCJsaXZla2l0LkRpc2FibGVkQ29kZWNzXCI7XG5EaXNhYmxlZENvZGVjcy5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY29kZWNzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDb2RlYyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicHVibGlzaFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ29kZWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUlRQRHJpZnRcbiAqL1xuY2xhc3MgUlRQRHJpZnQgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgZHVyYXRpb24gPSAzO1xuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDY0IHN0YXJ0X3RpbWVzdGFtcCA9IDQ7XG4gICAgICovXG4gICAgdGhpcy5zdGFydFRpbWVzdGFtcCA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQ2NCBlbmRfdGltZXN0YW1wID0gNTtcbiAgICAgKi9cbiAgICB0aGlzLmVuZFRpbWVzdGFtcCA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQ2NCBydHBfY2xvY2tfdGlja3MgPSA2O1xuICAgICAqL1xuICAgIHRoaXMucnRwQ2xvY2tUaWNrcyA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IGRyaWZ0X3NhbXBsZXMgPSA3O1xuICAgICAqL1xuICAgIHRoaXMuZHJpZnRTYW1wbGVzID0gcHJvdG9JbnQ2NC56ZXJvO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGRyaWZ0X21zID0gODtcbiAgICAgKi9cbiAgICB0aGlzLmRyaWZ0TXMgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGNsb2NrX3JhdGUgPSA5O1xuICAgICAqL1xuICAgIHRoaXMuY2xvY2tSYXRlID0gMDtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUlRQRHJpZnQoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSVFBEcmlmdCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJUUERyaWZ0KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhSVFBEcmlmdCwgYSwgYik7XG4gIH1cbn1cblJUUERyaWZ0LnJ1bnRpbWUgPSBwcm90bzM7XG5SVFBEcmlmdC50eXBlTmFtZSA9IFwibGl2ZWtpdC5SVFBEcmlmdFwiO1xuUlRQRHJpZnQuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInN0YXJ0X3RpbWVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRpbWVzdGFtcFxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJlbmRfdGltZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZXN0YW1wXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImR1cmF0aW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwic3RhcnRfdGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiZW5kX3RpbWVzdGFtcFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInJ0cF9jbG9ja190aWNrc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImRyaWZ0X3NhbXBsZXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcImRyaWZ0X21zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwiY2xvY2tfcmF0ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUlRQU3RhdHNcbiAqL1xuY2xhc3MgUlRQU3RhdHMgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgZHVyYXRpb24gPSAzO1xuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHBhY2tldHMgPSA0O1xuICAgICAqL1xuICAgIHRoaXMucGFja2V0cyA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgcGFja2V0X3JhdGUgPSA1O1xuICAgICAqL1xuICAgIHRoaXMucGFja2V0UmF0ZSA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50NjQgYnl0ZXMgPSA2O1xuICAgICAqL1xuICAgIHRoaXMuYnl0ZXMgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50NjQgaGVhZGVyX2J5dGVzID0gMzk7XG4gICAgICovXG4gICAgdGhpcy5oZWFkZXJCeXRlcyA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBiaXRyYXRlID0gNztcbiAgICAgKi9cbiAgICB0aGlzLmJpdHJhdGUgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHBhY2tldHNfbG9zdCA9IDg7XG4gICAgICovXG4gICAgdGhpcy5wYWNrZXRzTG9zdCA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgcGFja2V0X2xvc3NfcmF0ZSA9IDk7XG4gICAgICovXG4gICAgdGhpcy5wYWNrZXRMb3NzUmF0ZSA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBmbG9hdCBwYWNrZXRfbG9zc19wZXJjZW50YWdlID0gMTA7XG4gICAgICovXG4gICAgdGhpcy5wYWNrZXRMb3NzUGVyY2VudGFnZSA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgcGFja2V0c19kdXBsaWNhdGUgPSAxMTtcbiAgICAgKi9cbiAgICB0aGlzLnBhY2tldHNEdXBsaWNhdGUgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIHBhY2tldF9kdXBsaWNhdGVfcmF0ZSA9IDEyO1xuICAgICAqL1xuICAgIHRoaXMucGFja2V0RHVwbGljYXRlUmF0ZSA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50NjQgYnl0ZXNfZHVwbGljYXRlID0gMTM7XG4gICAgICovXG4gICAgdGhpcy5ieXRlc0R1cGxpY2F0ZSA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQ2NCBoZWFkZXJfYnl0ZXNfZHVwbGljYXRlID0gNDA7XG4gICAgICovXG4gICAgdGhpcy5oZWFkZXJCeXRlc0R1cGxpY2F0ZSA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBiaXRyYXRlX2R1cGxpY2F0ZSA9IDE0O1xuICAgICAqL1xuICAgIHRoaXMuYml0cmF0ZUR1cGxpY2F0ZSA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgcGFja2V0c19wYWRkaW5nID0gMTU7XG4gICAgICovXG4gICAgdGhpcy5wYWNrZXRzUGFkZGluZyA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgcGFja2V0X3BhZGRpbmdfcmF0ZSA9IDE2O1xuICAgICAqL1xuICAgIHRoaXMucGFja2V0UGFkZGluZ1JhdGUgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDY0IGJ5dGVzX3BhZGRpbmcgPSAxNztcbiAgICAgKi9cbiAgICB0aGlzLmJ5dGVzUGFkZGluZyA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQ2NCBoZWFkZXJfYnl0ZXNfcGFkZGluZyA9IDQxO1xuICAgICAqL1xuICAgIHRoaXMuaGVhZGVyQnl0ZXNQYWRkaW5nID0gcHJvdG9JbnQ2NC56ZXJvO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGJpdHJhdGVfcGFkZGluZyA9IDE4O1xuICAgICAqL1xuICAgIHRoaXMuYml0cmF0ZVBhZGRpbmcgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHBhY2tldHNfb3V0X29mX29yZGVyID0gMTk7XG4gICAgICovXG4gICAgdGhpcy5wYWNrZXRzT3V0T2ZPcmRlciA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgZnJhbWVzID0gMjA7XG4gICAgICovXG4gICAgdGhpcy5mcmFtZXMgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGZyYW1lX3JhdGUgPSAyMTtcbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lUmF0ZSA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgaml0dGVyX2N1cnJlbnQgPSAyMjtcbiAgICAgKi9cbiAgICB0aGlzLmppdHRlckN1cnJlbnQgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGppdHRlcl9tYXggPSAyMztcbiAgICAgKi9cbiAgICB0aGlzLmppdHRlck1heCA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBtYXA8aW50MzIsIHVpbnQzMj4gZ2FwX2hpc3RvZ3JhbSA9IDI0O1xuICAgICAqL1xuICAgIHRoaXMuZ2FwSGlzdG9ncmFtID0ge307XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgbmFja3MgPSAyNTtcbiAgICAgKi9cbiAgICB0aGlzLm5hY2tzID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBuYWNrX2Fja3MgPSAzNztcbiAgICAgKi9cbiAgICB0aGlzLm5hY2tBY2tzID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBuYWNrX21pc3NlcyA9IDI2O1xuICAgICAqL1xuICAgIHRoaXMubmFja01pc3NlcyA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgbmFja19yZXBlYXRlZCA9IDM4O1xuICAgICAqL1xuICAgIHRoaXMubmFja1JlcGVhdGVkID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBwbGlzID0gMjc7XG4gICAgICovXG4gICAgdGhpcy5wbGlzID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBmaXJzID0gMjk7XG4gICAgICovXG4gICAgdGhpcy5maXJzID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBydHRfY3VycmVudCA9IDMxO1xuICAgICAqL1xuICAgIHRoaXMucnR0Q3VycmVudCA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgcnR0X21heCA9IDMyO1xuICAgICAqL1xuICAgIHRoaXMucnR0TWF4ID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBrZXlfZnJhbWVzID0gMzM7XG4gICAgICovXG4gICAgdGhpcy5rZXlGcmFtZXMgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGxheWVyX2xvY2tfcGxpcyA9IDM1O1xuICAgICAqL1xuICAgIHRoaXMubGF5ZXJMb2NrUGxpcyA9IDA7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJUUFN0YXRzKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUlRQU3RhdHMoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSVFBTdGF0cygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUlRQU3RhdHMsIGEsIGIpO1xuICB9XG59XG5SVFBTdGF0cy5ydW50aW1lID0gcHJvdG8zO1xuUlRQU3RhdHMudHlwZU5hbWUgPSBcImxpdmVraXQuUlRQU3RhdHNcIjtcblJUUFN0YXRzLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzdGFydF90aW1lXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lc3RhbXBcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiZW5kX3RpbWVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRpbWVzdGFtcFxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJkdXJhdGlvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInBhY2tldHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwicGFja2V0X3JhdGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJieXRlc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG59LCB7XG4gIG5vOiAzOSxcbiAgbmFtZTogXCJoZWFkZXJfYnl0ZXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJiaXRyYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwicGFja2V0c19sb3N0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcInBhY2tldF9sb3NzX3JhdGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwicGFja2V0X2xvc3NfcGVyY2VudGFnZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAyIC8qIFNjYWxhclR5cGUuRkxPQVQgKi9cbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcInBhY2tldHNfZHVwbGljYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJwYWNrZXRfZHVwbGljYXRlX3JhdGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwiYnl0ZXNfZHVwbGljYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbn0sIHtcbiAgbm86IDQwLFxuICBuYW1lOiBcImhlYWRlcl9ieXRlc19kdXBsaWNhdGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwiYml0cmF0ZV9kdXBsaWNhdGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xufSwge1xuICBubzogMTUsXG4gIG5hbWU6IFwicGFja2V0c19wYWRkaW5nXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAxNixcbiAgbmFtZTogXCJwYWNrZXRfcGFkZGluZ19yYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn0sIHtcbiAgbm86IDE3LFxuICBuYW1lOiBcImJ5dGVzX3BhZGRpbmdcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xufSwge1xuICBubzogNDEsXG4gIG5hbWU6IFwiaGVhZGVyX2J5dGVzX3BhZGRpbmdcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xufSwge1xuICBubzogMTgsXG4gIG5hbWU6IFwiYml0cmF0ZV9wYWRkaW5nXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn0sIHtcbiAgbm86IDE5LFxuICBuYW1lOiBcInBhY2tldHNfb3V0X29mX29yZGVyXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAyMCxcbiAgbmFtZTogXCJmcmFtZXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDIxLFxuICBuYW1lOiBcImZyYW1lX3JhdGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xufSwge1xuICBubzogMjIsXG4gIG5hbWU6IFwiaml0dGVyX2N1cnJlbnRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xufSwge1xuICBubzogMjMsXG4gIG5hbWU6IFwiaml0dGVyX21heFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovXG59LCB7XG4gIG5vOiAyNCxcbiAgbmFtZTogXCJnYXBfaGlzdG9ncmFtXCIsXG4gIGtpbmQ6IFwibWFwXCIsXG4gIEs6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqLyxcbiAgVjoge1xuICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgfVxufSwge1xuICBubzogMjUsXG4gIG5hbWU6IFwibmFja3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDM3LFxuICBuYW1lOiBcIm5hY2tfYWNrc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMjYsXG4gIG5hbWU6IFwibmFja19taXNzZXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDM4LFxuICBuYW1lOiBcIm5hY2tfcmVwZWF0ZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDI3LFxuICBuYW1lOiBcInBsaXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDI4LFxuICBuYW1lOiBcImxhc3RfcGxpXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lc3RhbXBcbn0sIHtcbiAgbm86IDI5LFxuICBuYW1lOiBcImZpcnNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDMwLFxuICBuYW1lOiBcImxhc3RfZmlyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lc3RhbXBcbn0sIHtcbiAgbm86IDMxLFxuICBuYW1lOiBcInJ0dF9jdXJyZW50XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzMixcbiAgbmFtZTogXCJydHRfbWF4XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzMyxcbiAgbmFtZTogXCJrZXlfZnJhbWVzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzNCxcbiAgbmFtZTogXCJsYXN0X2tleV9mcmFtZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZXN0YW1wXG59LCB7XG4gIG5vOiAzNSxcbiAgbmFtZTogXCJsYXllcl9sb2NrX3BsaXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDM2LFxuICBuYW1lOiBcImxhc3RfbGF5ZXJfbG9ja19wbGlcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRpbWVzdGFtcFxufSwge1xuICBubzogNDQsXG4gIG5hbWU6IFwicGFja2V0X2RyaWZ0XCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSVFBEcmlmdFxufSwge1xuICBubzogNDUsXG4gIG5hbWU6IFwicmVwb3J0X2RyaWZ0XCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSVFBEcmlmdFxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlRpbWVkVmVyc2lvblxuICovXG5jbGFzcyBUaW1lZFZlcnNpb24gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCB1bml4X21pY3JvID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnVuaXhNaWNybyA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDMyIHRpY2tzID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnRpY2tzID0gMDtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVGltZWRWZXJzaW9uKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVGltZWRWZXJzaW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVGltZWRWZXJzaW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhUaW1lZFZlcnNpb24sIGEsIGIpO1xuICB9XG59XG5UaW1lZFZlcnNpb24ucnVudGltZSA9IHByb3RvMztcblRpbWVkVmVyc2lvbi50eXBlTmFtZSA9IFwibGl2ZWtpdC5UaW1lZFZlcnNpb25cIjtcblRpbWVkVmVyc2lvbi5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidW5peF9taWNyb1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidGlja3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59XSk7XG5cbmNvbnN0IG1heFJldHJ5RGVsYXkgPSA3MDAwO1xuY29uc3QgREVGQVVMVF9SRVRSWV9ERUxBWVNfSU5fTVMgPSBbMCwgMzAwLCAyICogMiAqIDMwMCwgMyAqIDMgKiAzMDAsIDQgKiA0ICogMzAwLCBtYXhSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5XTtcbmNsYXNzIERlZmF1bHRSZWNvbm5lY3RQb2xpY3kge1xuICBjb25zdHJ1Y3RvcihyZXRyeURlbGF5cykge1xuICAgIHRoaXMuX3JldHJ5RGVsYXlzID0gcmV0cnlEZWxheXMgIT09IHVuZGVmaW5lZCA/IFsuLi5yZXRyeURlbGF5c10gOiBERUZBVUxUX1JFVFJZX0RFTEFZU19JTl9NUztcbiAgfVxuICBuZXh0UmV0cnlEZWxheUluTXMoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LnJldHJ5Q291bnQgPj0gdGhpcy5fcmV0cnlEZWxheXMubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCByZXRyeURlbGF5ID0gdGhpcy5fcmV0cnlEZWxheXNbY29udGV4dC5yZXRyeUNvdW50XTtcbiAgICBpZiAoY29udGV4dC5yZXRyeUNvdW50IDw9IDEpIHJldHVybiByZXRyeURlbGF5O1xuICAgIHJldHVybiByZXRyeURlbGF5ICsgTWF0aC5yYW5kb20oKSAqIDEwMDA7XG4gIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxudmFyIGV2ZW50cyA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGw7XG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJyA/IFIuYXBwbHkgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG59O1xudmFyIFJlZmxlY3RPd25LZXlzO1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5cztcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxuZXZlbnRzLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5ldmVudHMuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9IHR5cGUgPT09ICdlcnJvcic7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkgZG9FcnJvciA9IGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQ7ZWxzZSBpZiAoIWRvRXJyb3IpIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICsgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbn07XG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7XG4gICAgZmlyZWQ6IGZhbHNlLFxuICAgIHdyYXBGbjogdW5kZWZpbmVkLFxuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIHR5cGU6IHR5cGUsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzO1xuICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7ZWxzZSB7XG4gICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcikgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHBvc2l0aW9uID0gLTE7XG4gICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocG9zaXRpb24gPCAwKSByZXR1cm4gdGhpcztcbiAgICBpZiAocG9zaXRpb24gPT09IDApIGxpc3Quc2hpZnQoKTtlbHNlIHtcbiAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgfVxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcbiAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7ZWxzZSBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICB2YXIga2V5O1xuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG4gIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKSBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7XG4gICAgICBvbmNlOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbnZhciBldmVudHNFeHBvcnRzID0gZXZlbnRzLmV4cG9ydHM7XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5cbmxldCBsb2dEaXNhYmxlZF8gPSB0cnVlO1xubGV0IGRlcHJlY2F0aW9uV2FybmluZ3NfID0gdHJ1ZTtcblxuLyoqXG4gKiBFeHRyYWN0IGJyb3dzZXIgdmVyc2lvbiBvdXQgb2YgdGhlIHByb3ZpZGVkIHVzZXIgYWdlbnQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gdWFzdHJpbmcgdXNlckFnZW50IHN0cmluZy5cbiAqIEBwYXJhbSB7IXN0cmluZ30gZXhwciBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCBhcyBtYXRjaCBjcml0ZXJpYS5cbiAqIEBwYXJhbSB7IW51bWJlcn0gcG9zIHBvc2l0aW9uIGluIHRoZSB2ZXJzaW9uIHN0cmluZyB0byBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IGJyb3dzZXIgdmVyc2lvbi5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFZlcnNpb24odWFzdHJpbmcsIGV4cHIsIHBvcykge1xuICBjb25zdCBtYXRjaCA9IHVhc3RyaW5nLm1hdGNoKGV4cHIpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID49IHBvcyAmJiBwYXJzZUludChtYXRjaFtwb3NdLCAxMCk7XG59XG5cbi8vIFdyYXBzIHRoZSBwZWVyY29ubmVjdGlvbiBldmVudCBldmVudE5hbWVUb1dyYXAgaW4gYSBmdW5jdGlvblxuLy8gd2hpY2ggcmV0dXJucyB0aGUgbW9kaWZpZWQgZXZlbnQgb2JqZWN0IChvciBmYWxzZSB0byBwcmV2ZW50XG4vLyB0aGUgZXZlbnQpLlxuZnVuY3Rpb24gd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCBldmVudE5hbWVUb1dyYXAsIHdyYXBwZXIpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvdG8gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xuICBjb25zdCBuYXRpdmVBZGRFdmVudExpc3RlbmVyID0gcHJvdG8uYWRkRXZlbnRMaXN0ZW5lcjtcbiAgcHJvdG8uYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChuYXRpdmVFdmVudE5hbWUsIGNiKSB7XG4gICAgaWYgKG5hdGl2ZUV2ZW50TmFtZSAhPT0gZXZlbnROYW1lVG9XcmFwKSB7XG4gICAgICByZXR1cm4gbmF0aXZlQWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSBlID0+IHtcbiAgICAgIGNvbnN0IG1vZGlmaWVkRXZlbnQgPSB3cmFwcGVyKGUpO1xuICAgICAgaWYgKG1vZGlmaWVkRXZlbnQpIHtcbiAgICAgICAgaWYgKGNiLmhhbmRsZUV2ZW50KSB7XG4gICAgICAgICAgY2IuaGFuZGxlRXZlbnQobW9kaWZpZWRFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IobW9kaWZpZWRFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX2V2ZW50TWFwID0gdGhpcy5fZXZlbnRNYXAgfHwge307XG4gICAgaWYgKCF0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdKSB7XG4gICAgICB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLnNldChjYiwgd3JhcHBlZENhbGxiYWNrKTtcbiAgICByZXR1cm4gbmF0aXZlQWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbbmF0aXZlRXZlbnROYW1lLCB3cmFwcGVkQ2FsbGJhY2tdKTtcbiAgfTtcbiAgY29uc3QgbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHByb3RvLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gIHByb3RvLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAobmF0aXZlRXZlbnROYW1lLCBjYikge1xuICAgIGlmIChuYXRpdmVFdmVudE5hbWUgIT09IGV2ZW50TmFtZVRvV3JhcCB8fCAhdGhpcy5fZXZlbnRNYXAgfHwgIXRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0pIHtcbiAgICAgIHJldHVybiBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5oYXMoY2IpKSB7XG4gICAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBjb25zdCB1bndyYXBwZWRDYiA9IHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uZ2V0KGNiKTtcbiAgICB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLmRlbGV0ZShjYik7XG4gICAgaWYgKHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uc2l6ZSA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF07XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9ldmVudE1hcCkubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRNYXA7XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIFtuYXRpdmVFdmVudE5hbWUsIHVud3JhcHBlZENiXSk7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ29uJyArIGV2ZW50TmFtZVRvV3JhcCwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXTtcbiAgICB9LFxuICAgIHNldChjYikge1xuICAgICAgaWYgKHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWVUb1dyYXAsIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdKTtcbiAgICAgICAgZGVsZXRlIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdO1xuICAgICAgfVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWVUb1dyYXAsIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdID0gY2IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5mdW5jdGlvbiBkaXNhYmxlTG9nKGJvb2wpIHtcbiAgaWYgKHR5cGVvZiBib29sICE9PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdBcmd1bWVudCB0eXBlOiAnICsgdHlwZW9mIGJvb2wgKyAnLiBQbGVhc2UgdXNlIGEgYm9vbGVhbi4nKTtcbiAgfVxuICBsb2dEaXNhYmxlZF8gPSBib29sO1xuICByZXR1cm4gYm9vbCA/ICdhZGFwdGVyLmpzIGxvZ2dpbmcgZGlzYWJsZWQnIDogJ2FkYXB0ZXIuanMgbG9nZ2luZyBlbmFibGVkJztcbn1cblxuLyoqXG4gKiBEaXNhYmxlIG9yIGVuYWJsZSBkZXByZWNhdGlvbiB3YXJuaW5nc1xuICogQHBhcmFtIHshYm9vbGVhbn0gYm9vbCBzZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIHdhcm5pbmdzLlxuICovXG5mdW5jdGlvbiBkaXNhYmxlV2FybmluZ3MoYm9vbCkge1xuICBpZiAodHlwZW9mIGJvb2wgIT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0FyZ3VtZW50IHR5cGU6ICcgKyB0eXBlb2YgYm9vbCArICcuIFBsZWFzZSB1c2UgYSBib29sZWFuLicpO1xuICB9XG4gIGRlcHJlY2F0aW9uV2FybmluZ3NfID0gIWJvb2w7XG4gIHJldHVybiAnYWRhcHRlci5qcyBkZXByZWNhdGlvbiB3YXJuaW5ncyAnICsgKGJvb2wgPyAnZGlzYWJsZWQnIDogJ2VuYWJsZWQnKTtcbn1cbmZ1bmN0aW9uIGxvZygpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKGxvZ0Rpc2FibGVkXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTaG93cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgc3VnZ2VzdGluZyB0aGUgbW9kZXJuIGFuZCBzcGVjLWNvbXBhdGlibGUgQVBJLlxuICovXG5mdW5jdGlvbiBkZXByZWNhdGVkKG9sZE1ldGhvZCwgbmV3TWV0aG9kKSB7XG4gIGlmICghZGVwcmVjYXRpb25XYXJuaW5nc18pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS53YXJuKG9sZE1ldGhvZCArICcgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSAnICsgbmV3TWV0aG9kICsgJyBpbnN0ZWFkLicpO1xufVxuXG4vKipcbiAqIEJyb3dzZXIgZGV0ZWN0b3IuXG4gKlxuICogQHJldHVybiB7b2JqZWN0fSByZXN1bHQgY29udGFpbmluZyBicm93c2VyIGFuZCB2ZXJzaW9uXG4gKiAgICAgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0QnJvd3Nlcih3aW5kb3cpIHtcbiAgLy8gUmV0dXJuZWQgcmVzdWx0IG9iamVjdC5cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGJyb3dzZXI6IG51bGwsXG4gICAgdmVyc2lvbjogbnVsbFxuICB9O1xuXG4gIC8vIEZhaWwgZWFybHkgaWYgaXQncyBub3QgYSBicm93c2VyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Lm5hdmlnYXRvciB8fCAhd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHtcbiAgICByZXN1bHQuYnJvd3NlciA9ICdOb3QgYSBicm93c2VyLic7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjb25zdCB7XG4gICAgbmF2aWdhdG9yXG4gIH0gPSB3aW5kb3c7XG4gIGlmIChuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhKSB7XG4gICAgLy8gRmlyZWZveC5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdmaXJlZm94JztcbiAgICByZXN1bHQudmVyc2lvbiA9IGV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsIC9GaXJlZm94XFwvKFxcZCspXFwuLywgMSk7XG4gIH0gZWxzZSBpZiAobmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fCB3aW5kb3cuaXNTZWN1cmVDb250ZXh0ID09PSBmYWxzZSAmJiB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAvLyBDaHJvbWUsIENocm9taXVtLCBXZWJ2aWV3LCBPcGVyYS5cbiAgICAvLyBWZXJzaW9uIG1hdGNoZXMgQ2hyb21lL1dlYlJUQyB2ZXJzaW9uLlxuICAgIC8vIENocm9tZSA3NCByZW1vdmVkIHdlYmtpdEdldFVzZXJNZWRpYSBvbiBodHRwIGFzIHdlbGwgc28gd2UgbmVlZCB0aGVcbiAgICAvLyBtb3JlIGNvbXBsaWNhdGVkIGZhbGxiYWNrIHRvIHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ2Nocm9tZSc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvQ2hyb20oZXxpdW0pXFwvKFxcZCspXFwuLywgMik7XG4gIH0gZWxzZSBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvKFxcZCspXFwuLykpIHtcbiAgICAvLyBTYWZhcmkuXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnc2FmYXJpJztcbiAgICByZXN1bHQudmVyc2lvbiA9IGV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsIC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8sIDEpO1xuICAgIHJlc3VsdC5zdXBwb3J0c1VuaWZpZWRQbGFuID0gd2luZG93LlJUQ1J0cFRyYW5zY2VpdmVyICYmICdjdXJyZW50RGlyZWN0aW9uJyBpbiB3aW5kb3cuUlRDUnRwVHJhbnNjZWl2ZXIucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIC8vIERlZmF1bHQgZmFsbHRocm91Z2g6IG5vdCBzdXBwb3J0ZWQuXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnTm90IGEgc3VwcG9ydGVkIGJyb3dzZXIuJztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHNvbWV0aGluZyBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHNvbWV0aGluZyB5b3Ugd2FudCB0byBjaGVjay5cbiAqIEByZXR1cm4gdHJ1ZSBpZiB2YWwgaXMgYW4gb2JqZWN0LCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbGwgZW1wdHkgb2JqZWN0cyBhbmQgdW5kZWZpbmVkIHZhbHVlc1xuICogZnJvbSBhIG5lc3RlZCBvYmplY3QgLS0gYW4gZW5oYW5jZWQgYW5kIHZhbmlsbGEgdmVyc2lvblxuICogb2YgTG9kYXNoJ3MgYGNvbXBhY3RgLlxuICovXG5mdW5jdGlvbiBjb21wYWN0T2JqZWN0KGRhdGEpIHtcbiAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhkYXRhKS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBrZXkpIHtcbiAgICBjb25zdCBpc09iaiA9IGlzT2JqZWN0KGRhdGFba2V5XSk7XG4gICAgY29uc3QgdmFsdWUgPSBpc09iaiA/IGNvbXBhY3RPYmplY3QoZGF0YVtrZXldKSA6IGRhdGFba2V5XTtcbiAgICBjb25zdCBpc0VtcHR5T2JqZWN0ID0gaXNPYmogJiYgIU9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgaXNFbXB0eU9iamVjdCkge1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY2N1bXVsYXRvciwge1xuICAgICAgW2tleV06IHZhbHVlXG4gICAgfSk7XG4gIH0sIHt9KTtcbn1cblxuLyogaXRlcmF0ZXMgdGhlIHN0YXRzIGdyYXBoIHJlY3Vyc2l2ZWx5LiAqL1xuZnVuY3Rpb24gd2Fsa1N0YXRzKHN0YXRzLCBiYXNlLCByZXN1bHRTZXQpIHtcbiAgaWYgKCFiYXNlIHx8IHJlc3VsdFNldC5oYXMoYmFzZS5pZCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVzdWx0U2V0LnNldChiYXNlLmlkLCBiYXNlKTtcbiAgT2JqZWN0LmtleXMoYmFzZSkuZm9yRWFjaChuYW1lID0+IHtcbiAgICBpZiAobmFtZS5lbmRzV2l0aCgnSWQnKSkge1xuICAgICAgd2Fsa1N0YXRzKHN0YXRzLCBzdGF0cy5nZXQoYmFzZVtuYW1lXSksIHJlc3VsdFNldCk7XG4gICAgfSBlbHNlIGlmIChuYW1lLmVuZHNXaXRoKCdJZHMnKSkge1xuICAgICAgYmFzZVtuYW1lXS5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgd2Fsa1N0YXRzKHN0YXRzLCBzdGF0cy5nZXQoaWQpLCByZXN1bHRTZXQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyogZmlsdGVyIGdldFN0YXRzIGZvciBhIHNlbmRlci9yZWNlaXZlciB0cmFjay4gKi9cbmZ1bmN0aW9uIGZpbHRlclN0YXRzKHJlc3VsdCwgdHJhY2ssIG91dGJvdW5kKSB7XG4gIGNvbnN0IHN0cmVhbVN0YXRzVHlwZSA9IG91dGJvdW5kID8gJ291dGJvdW5kLXJ0cCcgOiAnaW5ib3VuZC1ydHAnO1xuICBjb25zdCBmaWx0ZXJlZFJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgaWYgKHRyYWNrID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZpbHRlcmVkUmVzdWx0O1xuICB9XG4gIGNvbnN0IHRyYWNrU3RhdHMgPSBbXTtcbiAgcmVzdWx0LmZvckVhY2godmFsdWUgPT4ge1xuICAgIGlmICh2YWx1ZS50eXBlID09PSAndHJhY2snICYmIHZhbHVlLnRyYWNrSWRlbnRpZmllciA9PT0gdHJhY2suaWQpIHtcbiAgICAgIHRyYWNrU3RhdHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgdHJhY2tTdGF0cy5mb3JFYWNoKHRyYWNrU3RhdCA9PiB7XG4gICAgcmVzdWx0LmZvckVhY2goc3RhdHMgPT4ge1xuICAgICAgaWYgKHN0YXRzLnR5cGUgPT09IHN0cmVhbVN0YXRzVHlwZSAmJiBzdGF0cy50cmFja0lkID09PSB0cmFja1N0YXQuaWQpIHtcbiAgICAgICAgd2Fsa1N0YXRzKHJlc3VsdCwgc3RhdHMsIGZpbHRlcmVkUmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJlZFJlc3VsdDtcbn1cblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbmNvbnN0IGxvZ2dpbmcgPSBsb2c7XG5mdW5jdGlvbiBzaGltR2V0VXNlck1lZGlhJDIod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBjb25zdCBuYXZpZ2F0b3IgPSB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcjtcbiAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbnN0cmFpbnRzVG9DaHJvbWVfID0gZnVuY3Rpb24gKGMpIHtcbiAgICBpZiAodHlwZW9mIGMgIT09ICdvYmplY3QnIHx8IGMubWFuZGF0b3J5IHx8IGMub3B0aW9uYWwpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBjb25zdCBjYyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChrZXkgPT09ICdyZXF1aXJlJyB8fCBrZXkgPT09ICdhZHZhbmNlZCcgfHwga2V5ID09PSAnbWVkaWFTb3VyY2UnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHIgPSB0eXBlb2YgY1trZXldID09PSAnb2JqZWN0JyA/IGNba2V5XSA6IHtcbiAgICAgICAgaWRlYWw6IGNba2V5XVxuICAgICAgfTtcbiAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHIuZXhhY3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHIubWluID0gci5tYXggPSByLmV4YWN0O1xuICAgICAgfVxuICAgICAgY29uc3Qgb2xkbmFtZV8gPSBmdW5jdGlvbiAocHJlZml4LCBuYW1lKSB7XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICsgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWUgPT09ICdkZXZpY2VJZCcgPyAnc291cmNlSWQnIDogbmFtZTtcbiAgICAgIH07XG4gICAgICBpZiAoci5pZGVhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNjLm9wdGlvbmFsID0gY2Mub3B0aW9uYWwgfHwgW107XG4gICAgICAgIGxldCBvYyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHIuaWRlYWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJ21pbicsIGtleSldID0gci5pZGVhbDtcbiAgICAgICAgICBjYy5vcHRpb25hbC5wdXNoKG9jKTtcbiAgICAgICAgICBvYyA9IHt9O1xuICAgICAgICAgIG9jW29sZG5hbWVfKCdtYXgnLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJycsIGtleSldID0gci5pZGVhbDtcbiAgICAgICAgICBjYy5vcHRpb25hbC5wdXNoKG9jKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHIuZXhhY3QgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygci5leGFjdCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgY2MubWFuZGF0b3J5ID0gY2MubWFuZGF0b3J5IHx8IHt9O1xuICAgICAgICBjYy5tYW5kYXRvcnlbb2xkbmFtZV8oJycsIGtleSldID0gci5leGFjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFsnbWluJywgJ21heCddLmZvckVhY2gobWl4ID0+IHtcbiAgICAgICAgICBpZiAoclttaXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNjLm1hbmRhdG9yeSA9IGNjLm1hbmRhdG9yeSB8fCB7fTtcbiAgICAgICAgICAgIGNjLm1hbmRhdG9yeVtvbGRuYW1lXyhtaXgsIGtleSldID0gclttaXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGMuYWR2YW5jZWQpIHtcbiAgICAgIGNjLm9wdGlvbmFsID0gKGNjLm9wdGlvbmFsIHx8IFtdKS5jb25jYXQoYy5hZHZhbmNlZCk7XG4gICAgfVxuICAgIHJldHVybiBjYztcbiAgfTtcbiAgY29uc3Qgc2hpbUNvbnN0cmFpbnRzXyA9IGZ1bmN0aW9uIChjb25zdHJhaW50cywgZnVuYykge1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDYxKSB7XG4gICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gICAgfVxuICAgIGNvbnN0cmFpbnRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIGlmIChjb25zdHJhaW50cyAmJiB0eXBlb2YgY29uc3RyYWludHMuYXVkaW8gPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCByZW1hcCA9IGZ1bmN0aW9uIChvYmosIGEsIGIpIHtcbiAgICAgICAgaWYgKGEgaW4gb2JqICYmICEoYiBpbiBvYmopKSB7XG4gICAgICAgICAgb2JqW2JdID0gb2JqW2FdO1xuICAgICAgICAgIGRlbGV0ZSBvYmpbYV07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdHJhaW50cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICAgIHJlbWFwKGNvbnN0cmFpbnRzLmF1ZGlvLCAnYXV0b0dhaW5Db250cm9sJywgJ2dvb2dBdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgIHJlbWFwKGNvbnN0cmFpbnRzLmF1ZGlvLCAnbm9pc2VTdXBwcmVzc2lvbicsICdnb29nTm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgY29uc3RyYWludHMuYXVkaW8gPSBjb25zdHJhaW50c1RvQ2hyb21lXyhjb25zdHJhaW50cy5hdWRpbyk7XG4gICAgfVxuICAgIGlmIChjb25zdHJhaW50cyAmJiB0eXBlb2YgY29uc3RyYWludHMudmlkZW8gPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBTaGltIGZhY2luZ01vZGUgZm9yIG1vYmlsZSAmIHN1cmZhY2UgcHJvLlxuICAgICAgbGV0IGZhY2UgPSBjb25zdHJhaW50cy52aWRlby5mYWNpbmdNb2RlO1xuICAgICAgZmFjZSA9IGZhY2UgJiYgKHR5cGVvZiBmYWNlID09PSAnb2JqZWN0JyA/IGZhY2UgOiB7XG4gICAgICAgIGlkZWFsOiBmYWNlXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGdldFN1cHBvcnRlZEZhY2luZ01vZGVMaWVzID0gYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDY2O1xuICAgICAgaWYgKGZhY2UgJiYgKGZhY2UuZXhhY3QgPT09ICd1c2VyJyB8fCBmYWNlLmV4YWN0ID09PSAnZW52aXJvbm1lbnQnIHx8IGZhY2UuaWRlYWwgPT09ICd1c2VyJyB8fCBmYWNlLmlkZWFsID09PSAnZW52aXJvbm1lbnQnKSAmJiAhKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cygpLmZhY2luZ01vZGUgJiYgIWdldFN1cHBvcnRlZEZhY2luZ01vZGVMaWVzKSkge1xuICAgICAgICBkZWxldGUgY29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZTtcbiAgICAgICAgbGV0IG1hdGNoZXM7XG4gICAgICAgIGlmIChmYWNlLmV4YWN0ID09PSAnZW52aXJvbm1lbnQnIHx8IGZhY2UuaWRlYWwgPT09ICdlbnZpcm9ubWVudCcpIHtcbiAgICAgICAgICBtYXRjaGVzID0gWydiYWNrJywgJ3JlYXInXTtcbiAgICAgICAgfSBlbHNlIGlmIChmYWNlLmV4YWN0ID09PSAndXNlcicgfHwgZmFjZS5pZGVhbCA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IFsnZnJvbnQnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgIC8vIExvb2sgZm9yIG1hdGNoZXMgaW4gbGFiZWwsIG9yIHVzZSBsYXN0IGNhbSBmb3IgYmFjayAodHlwaWNhbCkuXG4gICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpLnRoZW4oZGV2aWNlcyA9PiB7XG4gICAgICAgICAgICBkZXZpY2VzID0gZGV2aWNlcy5maWx0ZXIoZCA9PiBkLmtpbmQgPT09ICd2aWRlb2lucHV0Jyk7XG4gICAgICAgICAgICBsZXQgZGV2ID0gZGV2aWNlcy5maW5kKGQgPT4gbWF0Y2hlcy5zb21lKG1hdGNoID0+IGQubGFiZWwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhtYXRjaCkpKTtcbiAgICAgICAgICAgIGlmICghZGV2ICYmIGRldmljZXMubGVuZ3RoICYmIG1hdGNoZXMuaW5jbHVkZXMoJ2JhY2snKSkge1xuICAgICAgICAgICAgICBkZXYgPSBkZXZpY2VzW2RldmljZXMubGVuZ3RoIC0gMV07IC8vIG1vcmUgbGlrZWx5IHRoZSBiYWNrIGNhbVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRldikge1xuICAgICAgICAgICAgICBjb25zdHJhaW50cy52aWRlby5kZXZpY2VJZCA9IGZhY2UuZXhhY3QgPyB7XG4gICAgICAgICAgICAgICAgZXhhY3Q6IGRldi5kZXZpY2VJZFxuICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgIGlkZWFsOiBkZXYuZGV2aWNlSWRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMudmlkZW8pO1xuICAgICAgICAgICAgbG9nZ2luZygnY2hyb21lOiAnICsgSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3RyYWludHMudmlkZW8gPSBjb25zdHJhaW50c1RvQ2hyb21lXyhjb25zdHJhaW50cy52aWRlbyk7XG4gICAgfVxuICAgIGxvZ2dpbmcoJ2Nocm9tZTogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgcmV0dXJuIGZ1bmMoY29uc3RyYWludHMpO1xuICB9O1xuICBjb25zdCBzaGltRXJyb3JfID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2NCkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB7XG4gICAgICAgIFBlcm1pc3Npb25EZW5pZWRFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIFBlcm1pc3Npb25EaXNtaXNzZWRFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIEludmFsaWRTdGF0ZUVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgRGV2aWNlc05vdEZvdW5kRXJyb3I6ICdOb3RGb3VuZEVycm9yJyxcbiAgICAgICAgQ29uc3RyYWludE5vdFNhdGlzZmllZEVycm9yOiAnT3ZlcmNvbnN0cmFpbmVkRXJyb3InLFxuICAgICAgICBUcmFja1N0YXJ0RXJyb3I6ICdOb3RSZWFkYWJsZUVycm9yJyxcbiAgICAgICAgTWVkaWFEZXZpY2VGYWlsZWREdWVUb1NodXRkb3duOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgTWVkaWFEZXZpY2VLaWxsU3dpdGNoT246ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBUYWJDYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJyxcbiAgICAgICAgU2NyZWVuQ2FwdHVyZUVycm9yOiAnQWJvcnRFcnJvcicsXG4gICAgICAgIERldmljZUNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InXG4gICAgICB9W2UubmFtZV0gfHwgZS5uYW1lLFxuICAgICAgbWVzc2FnZTogZS5tZXNzYWdlLFxuICAgICAgY29uc3RyYWludDogZS5jb25zdHJhaW50IHx8IGUuY29uc3RyYWludE5hbWUsXG4gICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArICh0aGlzLm1lc3NhZ2UgJiYgJzogJykgKyB0aGlzLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgY29uc3QgZ2V0VXNlck1lZGlhXyA9IGZ1bmN0aW9uIChjb25zdHJhaW50cywgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgc2hpbUNvbnN0cmFpbnRzXyhjb25zdHJhaW50cywgYyA9PiB7XG4gICAgICBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhKGMsIG9uU3VjY2VzcywgZSA9PiB7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihzaGltRXJyb3JfKGUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBnZXRVc2VyTWVkaWFfLmJpbmQobmF2aWdhdG9yKTtcblxuICAvLyBFdmVuIHRob3VnaCBDaHJvbWUgNDUgaGFzIG5hdmlnYXRvci5tZWRpYURldmljZXMgYW5kIGEgZ2V0VXNlck1lZGlhXG4gIC8vIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBQcm9taXNlLCBpdCBkb2VzIG5vdCBhY2NlcHQgc3BlYy1zdHlsZVxuICAvLyBjb25zdHJhaW50cy5cbiAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgY29uc3Qgb3JpZ0dldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLmJpbmQobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiAoY3MpIHtcbiAgICAgIHJldHVybiBzaGltQ29uc3RyYWludHNfKGNzLCBjID0+IG9yaWdHZXRVc2VyTWVkaWEoYykudGhlbihzdHJlYW0gPT4ge1xuICAgICAgICBpZiAoYy5hdWRpbyAmJiAhc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoIHx8IGMudmlkZW8gJiYgIXN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCkge1xuICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCcnLCAnTm90Rm91bmRFcnJvcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LCBlID0+IFByb21pc2UucmVqZWN0KHNoaW1FcnJvcl8oZSkpKSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxOCBUaGUgYWRhcHRlci5qcyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cblxuZnVuY3Rpb24gc2hpbUdldERpc3BsYXlNZWRpYSQxKHdpbmRvdywgZ2V0U291cmNlSWQpIHtcbiAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmICdnZXREaXNwbGF5TWVkaWEnIGluIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZ2V0U291cmNlSWQgaXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlIHJlc29sdmluZyB3aXRoXG4gIC8vIHRoZSBzb3VyY2VJZCBvZiB0aGUgc2NyZWVuL3dpbmRvdy90YWIgdG8gYmUgc2hhcmVkLlxuICBpZiAodHlwZW9mIGdldFNvdXJjZUlkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcignc2hpbUdldERpc3BsYXlNZWRpYTogZ2V0U291cmNlSWQgYXJndW1lbnQgaXMgbm90ICcgKyAnYSBmdW5jdGlvbicpO1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPSBmdW5jdGlvbiBnZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpIHtcbiAgICByZXR1cm4gZ2V0U291cmNlSWQoY29uc3RyYWludHMpLnRoZW4oc291cmNlSWQgPT4ge1xuICAgICAgY29uc3Qgd2lkdGhTcGVjaWZpZWQgPSBjb25zdHJhaW50cy52aWRlbyAmJiBjb25zdHJhaW50cy52aWRlby53aWR0aDtcbiAgICAgIGNvbnN0IGhlaWdodFNwZWNpZmllZCA9IGNvbnN0cmFpbnRzLnZpZGVvICYmIGNvbnN0cmFpbnRzLnZpZGVvLmhlaWdodDtcbiAgICAgIGNvbnN0IGZyYW1lUmF0ZVNwZWNpZmllZCA9IGNvbnN0cmFpbnRzLnZpZGVvICYmIGNvbnN0cmFpbnRzLnZpZGVvLmZyYW1lUmF0ZTtcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0ge1xuICAgICAgICBtYW5kYXRvcnk6IHtcbiAgICAgICAgICBjaHJvbWVNZWRpYVNvdXJjZTogJ2Rlc2t0b3AnLFxuICAgICAgICAgIGNocm9tZU1lZGlhU291cmNlSWQ6IHNvdXJjZUlkLFxuICAgICAgICAgIG1heEZyYW1lUmF0ZTogZnJhbWVSYXRlU3BlY2lmaWVkIHx8IDNcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICh3aWR0aFNwZWNpZmllZCkge1xuICAgICAgICBjb25zdHJhaW50cy52aWRlby5tYW5kYXRvcnkubWF4V2lkdGggPSB3aWR0aFNwZWNpZmllZDtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHRTcGVjaWZpZWQpIHtcbiAgICAgICAgY29uc3RyYWludHMudmlkZW8ubWFuZGF0b3J5Lm1heEhlaWdodCA9IGhlaWdodFNwZWNpZmllZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIH0pO1xuICB9O1xufVxuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuZnVuY3Rpb24gc2hpbU1lZGlhU3RyZWFtKHdpbmRvdykge1xuICB3aW5kb3cuTWVkaWFTdHJlYW0gPSB3aW5kb3cuTWVkaWFTdHJlYW0gfHwgd2luZG93LndlYmtpdE1lZGlhU3RyZWFtO1xufVxuZnVuY3Rpb24gc2hpbU9uVHJhY2skMSh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAhKCdvbnRyYWNrJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnb250cmFjaycsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29udHJhY2s7XG4gICAgICB9LFxuICAgICAgc2V0KGYpIHtcbiAgICAgICAgaWYgKHRoaXMuX29udHJhY2spIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29udHJhY2sgPSBmKTtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX29udHJhY2twb2x5KSB7XG4gICAgICAgIHRoaXMuX29udHJhY2twb2x5ID0gZSA9PiB7XG4gICAgICAgICAgLy8gb25hZGRzdHJlYW0gZG9lcyBub3QgZmlyZSB3aGVuIGEgdHJhY2sgaXMgYWRkZWQgdG8gYW4gZXhpc3RpbmdcbiAgICAgICAgICAvLyBzdHJlYW0uIEJ1dCBzdHJlYW0ub25hZGR0cmFjayBpcyBpbXBsZW1lbnRlZCBzbyB3ZSB1c2UgdGhhdC5cbiAgICAgICAgICBlLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHRlID0+IHtcbiAgICAgICAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycykge1xuICAgICAgICAgICAgICByZWNlaXZlciA9IHRoaXMuZ2V0UmVjZWl2ZXJzKCkuZmluZChyID0+IHIudHJhY2sgJiYgci50cmFjay5pZCA9PT0gdGUudHJhY2suaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB7XG4gICAgICAgICAgICAgICAgdHJhY2s6IHRlLnRyYWNrXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgIGV2ZW50LnRyYWNrID0gdGUudHJhY2s7XG4gICAgICAgICAgICBldmVudC5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgICAgZXZlbnQudHJhbnNjZWl2ZXIgPSB7XG4gICAgICAgICAgICAgIHJlY2VpdmVyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXZlbnQuc3RyZWFtcyA9IFtlLnN0cmVhbV07XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGUuc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICAgICAgbGV0IHJlY2VpdmVyO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzKSB7XG4gICAgICAgICAgICAgIHJlY2VpdmVyID0gdGhpcy5nZXRSZWNlaXZlcnMoKS5maW5kKHIgPT4gci50cmFjayAmJiByLnRyYWNrLmlkID09PSB0cmFjay5pZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNlaXZlciA9IHtcbiAgICAgICAgICAgICAgICB0cmFja1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ3RyYWNrJyk7XG4gICAgICAgICAgICBldmVudC50cmFjayA9IHRyYWNrO1xuICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICAgIGV2ZW50LnRyYW5zY2VpdmVyID0ge1xuICAgICAgICAgICAgICByZWNlaXZlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbXMgPSBbZS5zdHJlYW1dO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbnRyYWNrcG9seSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBldmVuIGlmIFJUQ1J0cFRyYW5zY2VpdmVyIGlzIGluIHdpbmRvdywgaXQgaXMgb25seSB1c2VkIGFuZFxuICAgIC8vIGVtaXR0ZWQgaW4gdW5pZmllZC1wbGFuLiBVbmZvcnR1bmF0ZWx5IHRoaXMgbWVhbnMgd2UgbmVlZFxuICAgIC8vIHRvIHVuY29uZGl0aW9uYWxseSB3cmFwIHRoZSBldmVudC5cbiAgICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGUgPT4ge1xuICAgICAgaWYgKCFlLnRyYW5zY2VpdmVyKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAndHJhbnNjZWl2ZXInLCB7XG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHJlY2VpdmVyOiBlLnJlY2VpdmVyXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzaGltR2V0U2VuZGVyc1dpdGhEdG1mKHdpbmRvdykge1xuICAvLyBPdmVycmlkZXMgYWRkVHJhY2svcmVtb3ZlVHJhY2ssIGRlcGVuZHMgb24gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2suXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgISgnZ2V0U2VuZGVycycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkgJiYgJ2NyZWF0ZURUTUZTZW5kZXInIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICBjb25zdCBzaGltU2VuZGVyV2l0aER0bWYgPSBmdW5jdGlvbiAocGMsIHRyYWNrKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFjayxcbiAgICAgICAgZ2V0IGR0bWYoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2R0bWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZHRtZiA9IHBjLmNyZWF0ZURUTUZTZW5kZXIodHJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fZHRtZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9kdG1mO1xuICAgICAgICB9LFxuICAgICAgICBfcGM6IHBjXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBhdWdtZW50IGFkZFRyYWNrIHdoZW4gZ2V0U2VuZGVycyBpcyBub3QgYXZhaWxhYmxlLlxuICAgIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRlcnMuc2xpY2UoKTsgLy8gcmV0dXJuIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgc3RhdGUuXG4gICAgICB9O1xuICAgICAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgc3RyZWFtKSB7XG4gICAgICAgIGxldCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKCFzZW5kZXIpIHtcbiAgICAgICAgICBzZW5kZXIgPSBzaGltU2VuZGVyV2l0aER0bWYodGhpcywgdHJhY2spO1xuICAgICAgICAgIHRoaXMuX3NlbmRlcnMucHVzaChzZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICB9O1xuICAgICAgY29uc3Qgb3JpZ1JlbW92ZVRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjaztcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICAgICAgb3JpZ1JlbW92ZVRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX3NlbmRlcnMuaW5kZXhPZihzZW5kZXIpO1xuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX3NlbmRlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9yaWdBZGRTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHRoaXMuX3NlbmRlcnMgPSB0aGlzLl9zZW5kZXJzIHx8IFtdO1xuICAgICAgb3JpZ0FkZFN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgIHRoaXMuX3NlbmRlcnMucHVzaChzaGltU2VuZGVyV2l0aER0bWYodGhpcywgdHJhY2spKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgdGhpcy5fc2VuZGVycyA9IHRoaXMuX3NlbmRlcnMgfHwgW107XG4gICAgICBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIFtzdHJlYW1dKTtcbiAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgY29uc3Qgc2VuZGVyID0gdGhpcy5fc2VuZGVycy5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgICAgICBpZiAoc2VuZGVyKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHNlbmRlclxuICAgICAgICAgIHRoaXMuX3NlbmRlcnMuc3BsaWNlKHRoaXMuX3NlbmRlcnMuaW5kZXhPZihzZW5kZXIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgJ2dldFNlbmRlcnMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgJiYgJ2NyZWF0ZURUTUZTZW5kZXInIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgJiYgd2luZG93LlJUQ1J0cFNlbmRlciAmJiAhKCdkdG1mJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgY29uc3Qgc2VuZGVycyA9IG9yaWdHZXRTZW5kZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgIHNlbmRlcnMuZm9yRWFjaChzZW5kZXIgPT4gc2VuZGVyLl9wYyA9IHRoaXMpO1xuICAgICAgcmV0dXJuIHNlbmRlcnM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUsICdkdG1mJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fZHRtZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMudHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgdGhpcy5fZHRtZiA9IHRoaXMuX3BjLmNyZWF0ZURUTUZTZW5kZXIodGhpcy50cmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2R0bWYgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZHRtZjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbUdldFN0YXRzKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnR2V0U3RhdHMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgY29uc3QgW3NlbGVjdG9yLCBvblN1Y2MsIG9uRXJyXSA9IGFyZ3VtZW50cztcblxuICAgIC8vIElmIHNlbGVjdG9yIGlzIGEgZnVuY3Rpb24gdGhlbiB3ZSBhcmUgaW4gdGhlIG9sZCBzdHlsZSBzdGF0cyBzbyBqdXN0XG4gICAgLy8gcGFzcyBiYWNrIHRoZSBvcmlnaW5hbCBnZXRTdGF0cyBmb3JtYXQgdG8gYXZvaWQgYnJlYWtpbmcgb2xkIHVzZXJzLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIHNwZWMtc3R5bGUgZ2V0U3RhdHMgaXMgc3VwcG9ydGVkLCByZXR1cm4gdGhvc2Ugd2hlbiBjYWxsZWQgd2l0aFxuICAgIC8vIGVpdGhlciBubyBhcmd1bWVudHMgb3IgdGhlIHNlbGVjdG9yIGFyZ3VtZW50IGlzIG51bGwuXG4gICAgaWYgKG9yaWdHZXRTdGF0cy5sZW5ndGggPT09IDAgJiYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHNlbGVjdG9yICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgcmV0dXJuIG9yaWdHZXRTdGF0cy5hcHBseSh0aGlzLCBbXSk7XG4gICAgfVxuICAgIGNvbnN0IGZpeENocm9tZVN0YXRzXyA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgY29uc3Qgc3RhbmRhcmRSZXBvcnQgPSB7fTtcbiAgICAgIGNvbnN0IHJlcG9ydHMgPSByZXNwb25zZS5yZXN1bHQoKTtcbiAgICAgIHJlcG9ydHMuZm9yRWFjaChyZXBvcnQgPT4ge1xuICAgICAgICBjb25zdCBzdGFuZGFyZFN0YXRzID0ge1xuICAgICAgICAgIGlkOiByZXBvcnQuaWQsXG4gICAgICAgICAgdGltZXN0YW1wOiByZXBvcnQudGltZXN0YW1wLFxuICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIGxvY2FsY2FuZGlkYXRlOiAnbG9jYWwtY2FuZGlkYXRlJyxcbiAgICAgICAgICAgIHJlbW90ZWNhbmRpZGF0ZTogJ3JlbW90ZS1jYW5kaWRhdGUnXG4gICAgICAgICAgfVtyZXBvcnQudHlwZV0gfHwgcmVwb3J0LnR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgcmVwb3J0Lm5hbWVzKCkuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICBzdGFuZGFyZFN0YXRzW25hbWVdID0gcmVwb3J0LnN0YXQobmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGFuZGFyZFJlcG9ydFtzdGFuZGFyZFN0YXRzLmlkXSA9IHN0YW5kYXJkU3RhdHM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzdGFuZGFyZFJlcG9ydDtcbiAgICB9O1xuXG4gICAgLy8gc2hpbSBnZXRTdGF0cyB3aXRoIG1hcGxpa2Ugc3VwcG9ydFxuICAgIGNvbnN0IG1ha2VNYXBTdGF0cyA9IGZ1bmN0aW9uIChzdGF0cykge1xuICAgICAgcmV0dXJuIG5ldyBNYXAoT2JqZWN0LmtleXMoc3RhdHMpLm1hcChrZXkgPT4gW2tleSwgc3RhdHNba2V5XV0pKTtcbiAgICB9O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIGNvbnN0IHN1Y2Nlc3NDYWxsYmFja1dyYXBwZXJfID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIG9uU3VjYyhtYWtlTWFwU3RhdHMoZml4Q2hyb21lU3RhdHNfKHJlc3BvbnNlKSkpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgW3N1Y2Nlc3NDYWxsYmFja1dyYXBwZXJfLCBzZWxlY3Rvcl0pO1xuICAgIH1cblxuICAgIC8vIHByb21pc2Utc3VwcG9ydFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgW2Z1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICByZXNvbHZlKG1ha2VNYXBTdGF0cyhmaXhDaHJvbWVTdGF0c18ocmVzcG9uc2UpKSk7XG4gICAgICB9LCByZWplY3RdKTtcbiAgICB9KS50aGVuKG9uU3VjYywgb25FcnIpO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyICYmIHdpbmRvdy5SVENSdHBSZWNlaXZlcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzaGltIHNlbmRlciBzdGF0cy5cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgICBpZiAob3JpZ0dldFNlbmRlcnMpIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICAgIGNvbnN0IHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICAgIHNlbmRlcnMuZm9yRWFjaChzZW5kZXIgPT4gc2VuZGVyLl9wYyA9IHRoaXMpO1xuICAgICAgICByZXR1cm4gc2VuZGVycztcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gICAgaWYgKG9yaWdBZGRUcmFjaykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKCkge1xuICAgICAgICBjb25zdCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgc2VuZGVyLl9wYyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICB9O1xuICAgIH1cbiAgICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgICAgY29uc3Qgc2VuZGVyID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpLnRoZW4ocmVzdWx0ID0+XG4gICAgICAvKiBOb3RlOiB0aGlzIHdpbGwgaW5jbHVkZSBzdGF0cyBvZiBhbGwgc2VuZGVycyB0aGF0XG4gICAgICAgKiAgIHNlbmQgYSB0cmFjayB3aXRoIHRoZSBzYW1lIGlkIGFzIHNlbmRlci50cmFjayBhc1xuICAgICAgICogICBpdCBpcyBub3QgcG9zc2libGUgdG8gaWRlbnRpZnkgdGhlIFJUQ1J0cFNlbmRlci5cbiAgICAgICAqL1xuICAgICAgZmlsdGVyU3RhdHMocmVzdWx0LCBzZW5kZXIudHJhY2ssIHRydWUpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gc2hpbSByZWNlaXZlciBzdGF0cy5cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlKSkge1xuICAgIGNvbnN0IG9yaWdHZXRSZWNlaXZlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycztcbiAgICBpZiAob3JpZ0dldFJlY2VpdmVycykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMgPSBmdW5jdGlvbiBnZXRSZWNlaXZlcnMoKSB7XG4gICAgICAgIGNvbnN0IHJlY2VpdmVycyA9IG9yaWdHZXRSZWNlaXZlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgICByZWNlaXZlcnMuZm9yRWFjaChyZWNlaXZlciA9PiByZWNlaXZlci5fcGMgPSB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlY2VpdmVycztcbiAgICAgIH07XG4gICAgfVxuICAgIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ3RyYWNrJywgZSA9PiB7XG4gICAgICBlLnJlY2VpdmVyLl9wYyA9IGUuc3JjRWxlbWVudDtcbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICAgIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICAgIGNvbnN0IHJlY2VpdmVyID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpLnRoZW4ocmVzdWx0ID0+IGZpbHRlclN0YXRzKHJlc3VsdCwgcmVjZWl2ZXIudHJhY2ssIGZhbHNlKSk7XG4gICAgfTtcbiAgfVxuICBpZiAoISgnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlICYmICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzaGltIFJUQ1BlZXJDb25uZWN0aW9uLmdldFN0YXRzKHRyYWNrKS5cbiAgY29uc3Qgb3JpZ0dldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiB3aW5kb3cuTWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgY29uc3QgdHJhY2sgPSBhcmd1bWVudHNbMF07XG4gICAgICBsZXQgc2VuZGVyO1xuICAgICAgbGV0IHJlY2VpdmVyO1xuICAgICAgbGV0IGVycjtcbiAgICAgIHRoaXMuZ2V0U2VuZGVycygpLmZvckVhY2gocyA9PiB7XG4gICAgICAgIGlmIChzLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgIGlmIChzZW5kZXIpIHtcbiAgICAgICAgICAgIGVyciA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRlciA9IHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ2V0UmVjZWl2ZXJzKCkuZm9yRWFjaChyID0+IHtcbiAgICAgICAgaWYgKHIudHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgaWYgKHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBlcnIgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNlaXZlciA9IHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByLnRyYWNrID09PSB0cmFjaztcbiAgICAgIH0pO1xuICAgICAgaWYgKGVyciB8fCBzZW5kZXIgJiYgcmVjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ1RoZXJlIGFyZSBtb3JlIHRoYW4gb25lIHNlbmRlciBvciByZWNlaXZlciBmb3IgdGhlIHRyYWNrLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKSk7XG4gICAgICB9IGVsc2UgaWYgKHNlbmRlcikge1xuICAgICAgICByZXR1cm4gc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgICB9IGVsc2UgaWYgKHJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiByZWNlaXZlci5nZXRTdGF0cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ1RoZXJlIGlzIG5vIHNlbmRlciBvciByZWNlaXZlciBmb3IgdGhlIHRyYWNrLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSh3aW5kb3cpIHtcbiAgLy8gc2hpbSBhZGRUcmFjay9yZW1vdmVUcmFjayB3aXRoIG5hdGl2ZSB2YXJpYW50cyBpbiBvcmRlciB0byBtYWtlXG4gIC8vIHRoZSBpbnRlcmFjdGlvbnMgd2l0aCBsZWdhY3kgZ2V0TG9jYWxTdHJlYW1zIGJlaGF2ZSBhcyBpbiBvdGhlciBicm93c2Vycy5cbiAgLy8gS2VlcHMgYSBtYXBwaW5nIHN0cmVhbS5pZCA9PiBbc3RyZWFtLCBydHBzZW5kZXJzLi4uXVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcyA9IGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcykubWFwKHN0cmVhbUlkID0+IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdWzBdKTtcbiAgfTtcbiAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcbiAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgcmV0dXJuIG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICBjb25zdCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoIXRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXSkge1xuICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdID0gW3N0cmVhbSwgc2VuZGVyXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXS5pbmRleE9mKHNlbmRlcikgPT09IC0xKSB7XG4gICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0ucHVzaChzZW5kZXIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VuZGVyO1xuICB9O1xuICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGV4aXN0aW5nU2VuZGVycyA9IHRoaXMuZ2V0U2VuZGVycygpO1xuICAgIG9yaWdBZGRTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBjb25zdCBuZXdTZW5kZXJzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmlsdGVyKG5ld1NlbmRlciA9PiBleGlzdGluZ1NlbmRlcnMuaW5kZXhPZihuZXdTZW5kZXIpID09PSAtMSk7XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdID0gW3N0cmVhbV0uY29uY2F0KG5ld1NlbmRlcnMpO1xuICB9O1xuICBjb25zdCBvcmlnUmVtb3ZlU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgIGRlbGV0ZSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF07XG4gICAgcmV0dXJuIG9yaWdSZW1vdmVTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgY29uc3Qgb3JpZ1JlbW92ZVRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjaztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgIGlmIChzZW5kZXIpIHtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMpLmZvckVhY2goc3RyZWFtSWQgPT4ge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXS5pbmRleE9mKHNlbmRlcik7XG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF0uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnUmVtb3ZlVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gc2hpbSBhZGRUcmFjayBhbmQgcmVtb3ZlVHJhY2suXG4gIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjUpIHtcbiAgICByZXR1cm4gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlKHdpbmRvdyk7XG4gIH1cblxuICAvLyBhbHNvIHNoaW0gcGMuZ2V0TG9jYWxTdHJlYW1zIHdoZW4gYWRkVHJhY2sgaXMgc2hpbW1lZFxuICAvLyB0byByZXR1cm4gdGhlIG9yaWdpbmFsIHN0cmVhbXMuXG4gIGNvbnN0IG9yaWdHZXRMb2NhbFN0cmVhbXMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXMgPSBmdW5jdGlvbiBnZXRMb2NhbFN0cmVhbXMoKSB7XG4gICAgY29uc3QgbmF0aXZlU3RyZWFtcyA9IG9yaWdHZXRMb2NhbFN0cmVhbXMuYXBwbHkodGhpcyk7XG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcbiAgICByZXR1cm4gbmF0aXZlU3RyZWFtcy5tYXAoc3RyZWFtID0+IHRoaXMuX3JldmVyc2VTdHJlYW1zW3N0cmVhbS5pZF0pO1xuICB9O1xuICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgY29uc3QgYWxyZWFkeUV4aXN0cyA9IHRoaXMuZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUcmFjayBhbHJlYWR5IGV4aXN0cy4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gQWRkIGlkZW50aXR5IG1hcHBpbmcgZm9yIGNvbnNpc3RlbmN5IHdpdGggYWRkVHJhY2suXG4gICAgLy8gVW5sZXNzIHRoaXMgaXMgYmVpbmcgdXNlZCB3aXRoIGEgc3RyZWFtIGZyb20gYWRkVHJhY2suXG4gICAgaWYgKCF0aGlzLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdKSB7XG4gICAgICBjb25zdCBuZXdTdHJlYW0gPSBuZXcgd2luZG93Lk1lZGlhU3RyZWFtKHN0cmVhbS5nZXRUcmFja3MoKSk7XG4gICAgICB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gPSBuZXdTdHJlYW07XG4gICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtc1tuZXdTdHJlYW0uaWRdID0gc3RyZWFtO1xuICAgICAgc3RyZWFtID0gbmV3U3RyZWFtO1xuICAgIH1cbiAgICBvcmlnQWRkU3RyZWFtLmFwcGx5KHRoaXMsIFtzdHJlYW1dKTtcbiAgfTtcbiAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuICAgIG9yaWdSZW1vdmVTdHJlYW0uYXBwbHkodGhpcywgW3RoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSB8fCBzdHJlYW1dKTtcbiAgICBkZWxldGUgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID8gdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdLmlkIDogc3RyZWFtLmlkXTtcbiAgICBkZWxldGUgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdO1xuICB9O1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2ssIHN0cmVhbSkge1xuICAgIGlmICh0aGlzLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhlIFJUQ1BlZXJDb25uZWN0aW9uXFwncyBzaWduYWxpbmdTdGF0ZSBpcyBcXCdjbG9zZWRcXCcuJywgJ0ludmFsaWRTdGF0ZUVycm9yJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0cmVhbXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgaWYgKHN0cmVhbXMubGVuZ3RoICE9PSAxIHx8ICFzdHJlYW1zWzBdLmdldFRyYWNrcygpLmZpbmQodCA9PiB0ID09PSB0cmFjaykpIHtcbiAgICAgIC8vIHRoaXMgaXMgbm90IGZ1bGx5IGNvcnJlY3QgYnV0IGFsbCB3ZSBjYW4gbWFuYWdlIHdpdGhvdXRcbiAgICAgIC8vIFtbYXNzb2NpYXRlZCBNZWRpYVN0cmVhbXNdXSBpbnRlcm5hbCBzbG90LlxuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhlIGFkYXB0ZXIuanMgYWRkVHJhY2sgcG9seWZpbGwgb25seSBzdXBwb3J0cyBhIHNpbmdsZSAnICsgJyBzdHJlYW0gd2hpY2ggaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgdHJhY2suJywgJ05vdFN1cHBvcnRlZEVycm9yJyk7XG4gICAgfVxuICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUcmFjayBhbHJlYWR5IGV4aXN0cy4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgfVxuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG4gICAgY29uc3Qgb2xkU3RyZWFtID0gdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdO1xuICAgIGlmIChvbGRTdHJlYW0pIHtcbiAgICAgIC8vIHRoaXMgaXMgdXNpbmcgb2RkIENocm9tZSBiZWhhdmlvdXIsIHVzZSB3aXRoIGNhdXRpb246XG4gICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NzgxNVxuICAgICAgLy8gTm90ZTogd2UgcmVseSBvbiB0aGUgaGlnaC1sZXZlbCBhZGRUcmFjay9kdG1mIHNoaW0gdG9cbiAgICAgIC8vIGNyZWF0ZSB0aGUgc2VuZGVyIHdpdGggYSBkdG1mIHNlbmRlci5cbiAgICAgIG9sZFN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG5cbiAgICAgIC8vIFRyaWdnZXIgT05OIGFzeW5jLlxuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ25lZ290aWF0aW9ubmVlZGVkJykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5ld1N0cmVhbSA9IG5ldyB3aW5kb3cuTWVkaWFTdHJlYW0oW3RyYWNrXSk7XG4gICAgICB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gPSBuZXdTdHJlYW07XG4gICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtc1tuZXdTdHJlYW0uaWRdID0gc3RyZWFtO1xuICAgICAgdGhpcy5hZGRTdHJlYW0obmV3U3RyZWFtKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gIH07XG5cbiAgLy8gcmVwbGFjZSB0aGUgaW50ZXJuYWwgc3RyZWFtIGlkIHdpdGggdGhlIGV4dGVybmFsIG9uZSBhbmRcbiAgLy8gdmljZSB2ZXJzYS5cbiAgZnVuY3Rpb24gcmVwbGFjZUludGVybmFsU3RyZWFtSWQocGMsIGRlc2NyaXB0aW9uKSB7XG4gICAgbGV0IHNkcCA9IGRlc2NyaXB0aW9uLnNkcDtcbiAgICBPYmplY3Qua2V5cyhwYy5fcmV2ZXJzZVN0cmVhbXMgfHwgW10pLmZvckVhY2goaW50ZXJuYWxJZCA9PiB7XG4gICAgICBjb25zdCBleHRlcm5hbFN0cmVhbSA9IHBjLl9yZXZlcnNlU3RyZWFtc1tpbnRlcm5hbElkXTtcbiAgICAgIGNvbnN0IGludGVybmFsU3RyZWFtID0gcGMuX3N0cmVhbXNbZXh0ZXJuYWxTdHJlYW0uaWRdO1xuICAgICAgc2RwID0gc2RwLnJlcGxhY2UobmV3IFJlZ0V4cChpbnRlcm5hbFN0cmVhbS5pZCwgJ2cnKSwgZXh0ZXJuYWxTdHJlYW0uaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXG4gICAgICBzZHBcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByZXBsYWNlRXh0ZXJuYWxTdHJlYW1JZChwYywgZGVzY3JpcHRpb24pIHtcbiAgICBsZXQgc2RwID0gZGVzY3JpcHRpb24uc2RwO1xuICAgIE9iamVjdC5rZXlzKHBjLl9yZXZlcnNlU3RyZWFtcyB8fCBbXSkuZm9yRWFjaChpbnRlcm5hbElkID0+IHtcbiAgICAgIGNvbnN0IGV4dGVybmFsU3RyZWFtID0gcGMuX3JldmVyc2VTdHJlYW1zW2ludGVybmFsSWRdO1xuICAgICAgY29uc3QgaW50ZXJuYWxTdHJlYW0gPSBwYy5fc3RyZWFtc1tleHRlcm5hbFN0cmVhbS5pZF07XG4gICAgICBzZHAgPSBzZHAucmVwbGFjZShuZXcgUmVnRXhwKGV4dGVybmFsU3RyZWFtLmlkLCAnZycpLCBpbnRlcm5hbFN0cmVhbS5pZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgdHlwZTogZGVzY3JpcHRpb24udHlwZSxcbiAgICAgIHNkcFxuICAgIH0pO1xuICB9XG4gIFsnY3JlYXRlT2ZmZXInLCAnY3JlYXRlQW5zd2VyJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgY29uc3QgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgIGNvbnN0IG1ldGhvZE9iaiA9IHtcbiAgICAgIFttZXRob2RdKCkge1xuICAgICAgICBjb25zdCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBjb25zdCBpc0xlZ2FjeUNhbGwgPSBhcmd1bWVudHMubGVuZ3RoICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbic7XG4gICAgICAgIGlmIChpc0xlZ2FjeUNhbGwpIHtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIFtkZXNjcmlwdGlvbiA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZXNjID0gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgYXJnc1swXS5hcHBseShudWxsLCBbZGVzY10pO1xuICAgICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICBpZiAoYXJnc1sxXSkge1xuICAgICAgICAgICAgICBhcmdzWzFdLmFwcGx5KG51bGwsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgYXJndW1lbnRzWzJdXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4oZGVzY3JpcHRpb24gPT4gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xuICB9KTtcbiAgY29uc3Qgb3JpZ1NldExvY2FsRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldExvY2FsRGVzY3JpcHRpb24oKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoIHx8ICFhcmd1bWVudHNbMF0udHlwZSkge1xuICAgICAgcmV0dXJuIG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGFyZ3VtZW50c1swXSA9IHJlcGxhY2VFeHRlcm5hbFN0cmVhbUlkKHRoaXMsIGFyZ3VtZW50c1swXSk7XG4gICAgcmV0dXJuIG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gVE9ETzogbWFuZ2xlIGdldFN0YXRzOiBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXN0YXRzLyNkb20tcnRjbWVkaWFzdHJlYW1zdGF0cy1zdHJlYW1pZGVudGlmaWVyXG5cbiAgY29uc3Qgb3JpZ0xvY2FsRGVzY3JpcHRpb24gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdsb2NhbERlc2NyaXB0aW9uJyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnbG9jYWxEZXNjcmlwdGlvbicsIHtcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IG9yaWdMb2NhbERlc2NyaXB0aW9uLmdldC5hcHBseSh0aGlzKTtcbiAgICAgIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnJykge1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgfSk7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICBpZiAodGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBSVENQZWVyQ29ubmVjdGlvblxcJ3Mgc2lnbmFsaW5nU3RhdGUgaXMgXFwnY2xvc2VkXFwnLicsICdJbnZhbGlkU3RhdGVFcnJvcicpO1xuICAgIH1cbiAgICAvLyBXZSBjYW4gbm90IHlldCBjaGVjayBmb3Igc2VuZGVyIGluc3RhbmNlb2YgUlRDUnRwU2VuZGVyXG4gICAgLy8gc2luY2Ugd2Ugc2hpbSBSVFBTZW5kZXIuIFNvIHdlIGNoZWNrIGlmIHNlbmRlci5fcGMgaXMgc2V0LlxuICAgIGlmICghc2VuZGVyLl9wYykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignQXJndW1lbnQgMSBvZiBSVENQZWVyQ29ubmVjdGlvbi5yZW1vdmVUcmFjayAnICsgJ2RvZXMgbm90IGltcGxlbWVudCBpbnRlcmZhY2UgUlRDUnRwU2VuZGVyLicsICdUeXBlRXJyb3InKTtcbiAgICB9XG4gICAgY29uc3QgaXNMb2NhbCA9IHNlbmRlci5fcGMgPT09IHRoaXM7XG4gICAgaWYgKCFpc0xvY2FsKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdTZW5kZXIgd2FzIG5vdCBjcmVhdGVkIGJ5IHRoaXMgY29ubmVjdGlvbi4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgfVxuXG4gICAgLy8gU2VhcmNoIGZvciB0aGUgbmF0aXZlIHN0cmVhbSB0aGUgc2VuZGVycyB0cmFjayBiZWxvbmdzIHRvLlxuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgIGxldCBzdHJlYW07XG4gICAgT2JqZWN0LmtleXModGhpcy5fc3RyZWFtcykuZm9yRWFjaChzdHJlYW1pZCA9PiB7XG4gICAgICBjb25zdCBoYXNUcmFjayA9IHRoaXMuX3N0cmVhbXNbc3RyZWFtaWRdLmdldFRyYWNrcygpLmZpbmQodHJhY2sgPT4gc2VuZGVyLnRyYWNrID09PSB0cmFjayk7XG4gICAgICBpZiAoaGFzVHJhY2spIHtcbiAgICAgICAgc3RyZWFtID0gdGhpcy5fc3RyZWFtc1tzdHJlYW1pZF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN0cmVhbSkge1xuICAgICAgaWYgKHN0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCB0cmFjayBvZiB0aGUgc3RyZWFtLCByZW1vdmUgdGhlIHN0cmVhbS4gVGhpc1xuICAgICAgICAvLyB0YWtlcyBjYXJlIG9mIGFueSBzaGltbWVkIF9zZW5kZXJzLlxuICAgICAgICB0aGlzLnJlbW92ZVN0cmVhbSh0aGlzLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlbHlpbmcgb24gdGhlIHNhbWUgb2RkIGNocm9tZSBiZWhhdmlvdXIgYXMgYWJvdmUuXG4gICAgICAgIHN0cmVhbS5yZW1vdmVUcmFjayhzZW5kZXIudHJhY2spO1xuICAgICAgfVxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbmVnb3RpYXRpb25uZWVkZWQnKSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc2hpbVBlZXJDb25uZWN0aW9uJDEod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAvLyB2ZXJ5IGJhc2ljIHN1cHBvcnQgZm9yIG9sZCB2ZXJzaW9ucy5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb247XG4gIH1cbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzaGltIGltcGxpY2l0IGNyZWF0aW9uIG9mIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbi9SVENJY2VDYW5kaWRhdGVcbiAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1Mykge1xuICAgIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZU1ldGhvZCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICAgIGNvbnN0IG1ldGhvZE9iaiA9IHtcbiAgICAgICAgW21ldGhvZF0oKSB7XG4gICAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3IChtZXRob2QgPT09ICdhZGRJY2VDYW5kaWRhdGUnID8gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA6IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24pKGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gbWV0aG9kT2JqW21ldGhvZF07XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gQXR0ZW1wdCB0byBmaXggT05OIGluIHBsYW4tYiBtb2RlLlxuZnVuY3Rpb24gZml4TmVnb3RpYXRpb25OZWVkZWQod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICduZWdvdGlhdGlvbm5lZWRlZCcsIGUgPT4ge1xuICAgIGNvbnN0IHBjID0gZS50YXJnZXQ7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA3MiB8fCBwYy5nZXRDb25maWd1cmF0aW9uICYmIHBjLmdldENvbmZpZ3VyYXRpb24oKS5zZHBTZW1hbnRpY3MgPT09ICdwbGFuLWInKSB7XG4gICAgICBpZiAocGMuc2lnbmFsaW5nU3RhdGUgIT09ICdzdGFibGUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuXG52YXIgY2hyb21lU2hpbSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRmaXhOZWdvdGlhdGlvbk5lZWRlZDogZml4TmVnb3RpYXRpb25OZWVkZWQsXG5cdHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrOiBzaGltQWRkVHJhY2tSZW1vdmVUcmFjayxcblx0c2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlOiBzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmUsXG5cdHNoaW1HZXREaXNwbGF5TWVkaWE6IHNoaW1HZXREaXNwbGF5TWVkaWEkMSxcblx0c2hpbUdldFNlbmRlcnNXaXRoRHRtZjogc2hpbUdldFNlbmRlcnNXaXRoRHRtZixcblx0c2hpbUdldFN0YXRzOiBzaGltR2V0U3RhdHMsXG5cdHNoaW1HZXRVc2VyTWVkaWE6IHNoaW1HZXRVc2VyTWVkaWEkMixcblx0c2hpbU1lZGlhU3RyZWFtOiBzaGltTWVkaWFTdHJlYW0sXG5cdHNoaW1PblRyYWNrOiBzaGltT25UcmFjayQxLFxuXHRzaGltUGVlckNvbm5lY3Rpb246IHNoaW1QZWVyQ29ubmVjdGlvbiQxLFxuXHRzaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0czogc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHNcbn0pO1xuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSQxKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG4gIGNvbnN0IE1lZGlhU3RyZWFtVHJhY2sgPSB3aW5kb3cgJiYgd2luZG93Lk1lZGlhU3RyZWFtVHJhY2s7XG4gIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiAoY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIC8vIFJlcGxhY2UgRmlyZWZveCA0NCsncyBkZXByZWNhdGlvbiB3YXJuaW5nIHdpdGggdW5wcmVmaXhlZCB2ZXJzaW9uLlxuICAgIGRlcHJlY2F0ZWQoJ25hdmlnYXRvci5nZXRVc2VyTWVkaWEnLCAnbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEnKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cykudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICB9O1xuICBpZiAoIShicm93c2VyRGV0YWlscy52ZXJzaW9uID4gNTUgJiYgJ2F1dG9HYWluQ29udHJvbCcgaW4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cygpKSkge1xuICAgIGNvbnN0IHJlbWFwID0gZnVuY3Rpb24gKG9iaiwgYSwgYikge1xuICAgICAgaWYgKGEgaW4gb2JqICYmICEoYiBpbiBvYmopKSB7XG4gICAgICAgIG9ialtiXSA9IG9ialthXTtcbiAgICAgICAgZGVsZXRlIG9ialthXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5hdGl2ZUdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLmJpbmQobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKHR5cGVvZiBjID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYy5hdWRpbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYykpO1xuICAgICAgICByZW1hcChjLmF1ZGlvLCAnYXV0b0dhaW5Db250cm9sJywgJ21vekF1dG9HYWluQ29udHJvbCcpO1xuICAgICAgICByZW1hcChjLmF1ZGlvLCAnbm9pc2VTdXBwcmVzc2lvbicsICdtb3pOb2lzZVN1cHByZXNzaW9uJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlR2V0VXNlck1lZGlhKGMpO1xuICAgIH07XG4gICAgaWYgKE1lZGlhU3RyZWFtVHJhY2sgJiYgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3MpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZUdldFNldHRpbmdzID0gTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3M7XG4gICAgICBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5nZXRTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gbmF0aXZlR2V0U2V0dGluZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmVtYXAob2JqLCAnbW96QXV0b0dhaW5Db250cm9sJywgJ2F1dG9HYWluQ29udHJvbCcpO1xuICAgICAgICByZW1hcChvYmosICdtb3pOb2lzZVN1cHByZXNzaW9uJywgJ25vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChNZWRpYVN0cmVhbVRyYWNrICYmIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHMpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZUFwcGx5Q29uc3RyYWludHMgPSBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzO1xuICAgICAgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuYXBwbHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09ICdhdWRpbycgJiYgdHlwZW9mIGMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgYyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYykpO1xuICAgICAgICAgIHJlbWFwKGMsICdhdXRvR2FpbkNvbnRyb2wnLCAnbW96QXV0b0dhaW5Db250cm9sJyk7XG4gICAgICAgICAgcmVtYXAoYywgJ25vaXNlU3VwcHJlc3Npb24nLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYXRpdmVBcHBseUNvbnN0cmFpbnRzLmFwcGx5KHRoaXMsIFtjXSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxOCBUaGUgYWRhcHRlci5qcyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cblxuZnVuY3Rpb24gc2hpbUdldERpc3BsYXlNZWRpYSh3aW5kb3csIHByZWZlcnJlZE1lZGlhU291cmNlKSB7XG4gIGlmICh3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiAnZ2V0RGlzcGxheU1lZGlhJyBpbiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSA9IGZ1bmN0aW9uIGdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cykge1xuICAgIGlmICghKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLnZpZGVvKSkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IERPTUV4Y2VwdGlvbignZ2V0RGlzcGxheU1lZGlhIHdpdGhvdXQgdmlkZW8gJyArICdjb25zdHJhaW50cyBpcyB1bmRlZmluZWQnKTtcbiAgICAgIGVyci5uYW1lID0gJ05vdEZvdW5kRXJyb3InO1xuICAgICAgLy8gZnJvbSBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtRE9NRXhjZXB0aW9uLWVycm9yLW5hbWVzXG4gICAgICBlcnIuY29kZSA9IDg7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnRzLnZpZGVvID09PSB0cnVlKSB7XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IHtcbiAgICAgICAgbWVkaWFTb3VyY2U6IHByZWZlcnJlZE1lZGlhU291cmNlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJhaW50cy52aWRlby5tZWRpYVNvdXJjZSA9IHByZWZlcnJlZE1lZGlhU291cmNlO1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgfTtcbn1cblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbmZ1bmN0aW9uIHNoaW1PblRyYWNrKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1RyYWNrRXZlbnQgJiYgJ3JlY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUgJiYgISgndHJhbnNjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlLCAndHJhbnNjZWl2ZXInLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVjZWl2ZXI6IHRoaXMucmVjZWl2ZXJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbVBlZXJDb25uZWN0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47IC8vIHByb2JhYmx5IG1lZGlhLnBlZXJjb25uZWN0aW9uLmVuYWJsZWQ9ZmFsc2UgaW4gYWJvdXQ6Y29uZmlnXG4gIH1cbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgLy8gdmVyeSBiYXNpYyBzdXBwb3J0IGZvciBvbGQgdmVyc2lvbnMuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uO1xuICB9XG4gIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTMpIHtcbiAgICAvLyBzaGltIGF3YXkgbmVlZCBmb3Igb2Jzb2xldGUgUlRDSWNlQ2FuZGlkYXRlL1JUQ1Nlc3Npb25EZXNjcmlwdGlvbi5cbiAgICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nLCAnYWRkSWNlQ2FuZGlkYXRlJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBjb25zdCBuYXRpdmVNZXRob2QgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgICBjb25zdCBtZXRob2RPYmogPSB7XG4gICAgICAgIFttZXRob2RdKCkge1xuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyAobWV0aG9kID09PSAnYWRkSWNlQ2FuZGlkYXRlJyA/IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgOiB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShhcmd1bWVudHNbMF0pO1xuICAgICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IG1vZGVyblN0YXRzVHlwZXMgPSB7XG4gICAgaW5ib3VuZHJ0cDogJ2luYm91bmQtcnRwJyxcbiAgICBvdXRib3VuZHJ0cDogJ291dGJvdW5kLXJ0cCcsXG4gICAgY2FuZGlkYXRlcGFpcjogJ2NhbmRpZGF0ZS1wYWlyJyxcbiAgICBsb2NhbGNhbmRpZGF0ZTogJ2xvY2FsLWNhbmRpZGF0ZScsXG4gICAgcmVtb3RlY2FuZGlkYXRlOiAncmVtb3RlLWNhbmRpZGF0ZSdcbiAgfTtcbiAgY29uc3QgbmF0aXZlR2V0U3RhdHMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgY29uc3QgW3NlbGVjdG9yLCBvblN1Y2MsIG9uRXJyXSA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmF0aXZlR2V0U3RhdHMuYXBwbHkodGhpcywgW3NlbGVjdG9yIHx8IG51bGxdKS50aGVuKHN0YXRzID0+IHtcbiAgICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTMgJiYgIW9uU3VjYykge1xuICAgICAgICAvLyBTaGltIG9ubHkgcHJvbWlzZSBnZXRTdGF0cyB3aXRoIHNwZWMtaHlwaGVucyBpbiB0eXBlIG5hbWVzXG4gICAgICAgIC8vIExlYXZlIGNhbGxiYWNrIHZlcnNpb24gYWxvbmU7IG1pc2Mgb2xkIHVzZXMgb2YgZm9yRWFjaCBiZWZvcmUgTWFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhdHMuZm9yRWFjaChzdGF0ID0+IHtcbiAgICAgICAgICAgIHN0YXQudHlwZSA9IG1vZGVyblN0YXRzVHlwZXNbc3RhdC50eXBlXSB8fCBzdGF0LnR5cGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZS5uYW1lICE9PSAnVHlwZUVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQXZvaWQgVHlwZUVycm9yOiBcInR5cGVcIiBpcyByZWFkLW9ubHksIGluIG9sZCB2ZXJzaW9ucy4gMzQtNDNpc2hcbiAgICAgICAgICBzdGF0cy5mb3JFYWNoKChzdGF0LCBpKSA9PiB7XG4gICAgICAgICAgICBzdGF0cy5zZXQoaSwgT2JqZWN0LmFzc2lnbih7fSwgc3RhdCwge1xuICAgICAgICAgICAgICB0eXBlOiBtb2Rlcm5TdGF0c1R5cGVzW3N0YXQudHlwZV0gfHwgc3RhdC50eXBlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0cztcbiAgICB9KS50aGVuKG9uU3VjYywgb25FcnIpO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbVNlbmRlckdldFN0YXRzKHdpbmRvdykge1xuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgaWYgKG9yaWdHZXRTZW5kZXJzKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcbiAgICAgIGNvbnN0IHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICBzZW5kZXJzLmZvckVhY2goc2VuZGVyID0+IHNlbmRlci5fcGMgPSB0aGlzKTtcbiAgICAgIHJldHVybiBzZW5kZXJzO1xuICAgIH07XG4gIH1cbiAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgaWYgKG9yaWdBZGRUcmFjaykge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjaygpIHtcbiAgICAgIGNvbnN0IHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgc2VuZGVyLl9wYyA9IHRoaXM7XG4gICAgICByZXR1cm4gc2VuZGVyO1xuICAgIH07XG4gIH1cbiAgd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFjayA/IHRoaXMuX3BjLmdldFN0YXRzKHRoaXMudHJhY2spIDogUHJvbWlzZS5yZXNvbHZlKG5ldyBNYXAoKSk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltUmVjZWl2ZXJHZXRTdGF0cyh3aW5kb3cpIHtcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh3aW5kb3cuUlRDUnRwU2VuZGVyICYmICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnR2V0UmVjZWl2ZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnM7XG4gIGlmIChvcmlnR2V0UmVjZWl2ZXJzKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMgPSBmdW5jdGlvbiBnZXRSZWNlaXZlcnMoKSB7XG4gICAgICBjb25zdCByZWNlaXZlcnMgPSBvcmlnR2V0UmVjZWl2ZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgIHJlY2VpdmVycy5mb3JFYWNoKHJlY2VpdmVyID0+IHJlY2VpdmVyLl9wYyA9IHRoaXMpO1xuICAgICAgcmV0dXJuIHJlY2VpdmVycztcbiAgICB9O1xuICB9XG4gIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ3RyYWNrJywgZSA9PiB7XG4gICAgZS5yZWNlaXZlci5fcGMgPSBlLnNyY0VsZW1lbnQ7XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xuICB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKHRoaXMudHJhY2spO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbVJlbW92ZVN0cmVhbSh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHwgJ3JlbW92ZVN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICBkZXByZWNhdGVkKCdyZW1vdmVTdHJlYW0nLCAncmVtb3ZlVHJhY2snKTtcbiAgICB0aGlzLmdldFNlbmRlcnMoKS5mb3JFYWNoKHNlbmRlciA9PiB7XG4gICAgICBpZiAoc2VuZGVyLnRyYWNrICYmIHN0cmVhbS5nZXRUcmFja3MoKS5pbmNsdWRlcyhzZW5kZXIudHJhY2spKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1SVENEYXRhQ2hhbm5lbCh3aW5kb3cpIHtcbiAgLy8gcmVuYW1lIERhdGFDaGFubmVsIHRvIFJUQ0RhdGFDaGFubmVsIChuYXRpdmUgZml4IGluIEZGNjApOlxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTczODUxXG4gIGlmICh3aW5kb3cuRGF0YUNoYW5uZWwgJiYgIXdpbmRvdy5SVENEYXRhQ2hhbm5lbCkge1xuICAgIHdpbmRvdy5SVENEYXRhQ2hhbm5lbCA9IHdpbmRvdy5EYXRhQ2hhbm5lbDtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbUFkZFRyYW5zY2VpdmVyKHdpbmRvdykge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicnRjSGFja3MvYWRhcHRlci9pc3N1ZXMvOTk4I2lzc3VlY29tbWVudC01MTY5MjE2NDdcbiAgLy8gRmlyZWZveCBpZ25vcmVzIHRoZSBpbml0IHNlbmRFbmNvZGluZ3Mgb3B0aW9ucyBwYXNzZWQgdG8gYWRkVHJhbnNjZWl2ZXJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM5NjkxOFxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdBZGRUcmFuc2NlaXZlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhbnNjZWl2ZXI7XG4gIGlmIChvcmlnQWRkVHJhbnNjZWl2ZXIpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYW5zY2VpdmVyID0gZnVuY3Rpb24gYWRkVHJhbnNjZWl2ZXIoKSB7XG4gICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgLy8gV2ViSURMIGlucHV0IGNvZXJjaW9uIGFuZCB2YWxpZGF0aW9uXG4gICAgICBsZXQgc2VuZEVuY29kaW5ncyA9IGFyZ3VtZW50c1sxXSAmJiBhcmd1bWVudHNbMV0uc2VuZEVuY29kaW5ncztcbiAgICAgIGlmIChzZW5kRW5jb2RpbmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2VuZEVuY29kaW5ncyA9IFtdO1xuICAgICAgfVxuICAgICAgc2VuZEVuY29kaW5ncyA9IFsuLi5zZW5kRW5jb2RpbmdzXTtcbiAgICAgIGNvbnN0IHNob3VsZFBlcmZvcm1DaGVjayA9IHNlbmRFbmNvZGluZ3MubGVuZ3RoID4gMDtcbiAgICAgIGlmIChzaG91bGRQZXJmb3JtQ2hlY2spIHtcbiAgICAgICAgLy8gSWYgc2VuZEVuY29kaW5ncyBwYXJhbXMgYXJlIHByb3ZpZGVkLCB2YWxpZGF0ZSBncmFtbWFyXG4gICAgICAgIHNlbmRFbmNvZGluZ3MuZm9yRWFjaChlbmNvZGluZ1BhcmFtID0+IHtcbiAgICAgICAgICBpZiAoJ3JpZCcgaW4gZW5jb2RpbmdQYXJhbSkge1xuICAgICAgICAgICAgY29uc3QgcmlkUmVnZXggPSAvXlthLXowLTldezAsMTZ9JC9pO1xuICAgICAgICAgICAgaWYgKCFyaWRSZWdleC50ZXN0KGVuY29kaW5nUGFyYW0ucmlkKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFJJRCB2YWx1ZSBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdzY2FsZVJlc29sdXRpb25Eb3duQnknIGluIGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICAgIGlmICghKHBhcnNlRmxvYXQoZW5jb2RpbmdQYXJhbS5zY2FsZVJlc29sdXRpb25Eb3duQnkpID49IDEuMCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NjYWxlX3Jlc29sdXRpb25fZG93bl9ieSBtdXN0IGJlID49IDEuMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ21heEZyYW1lcmF0ZScgaW4gZW5jb2RpbmdQYXJhbSkge1xuICAgICAgICAgICAgaWYgKCEocGFyc2VGbG9hdChlbmNvZGluZ1BhcmFtLm1heEZyYW1lcmF0ZSkgPj0gMCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21heF9mcmFtZXJhdGUgbXVzdCBiZSA+PSAwLjAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSBvcmlnQWRkVHJhbnNjZWl2ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmIChzaG91bGRQZXJmb3JtQ2hlY2spIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGluaXQgb3B0aW9ucyB3ZXJlIGFwcGxpZWQuIElmIG5vdCB3ZSBkbyB0aGlzIGluIGFuXG4gICAgICAgIC8vIGFzeW5jaHJvbm91cyB3YXkgYW5kIHNhdmUgdGhlIHByb21pc2UgcmVmZXJlbmNlIGluIGEgZ2xvYmFsIG9iamVjdC5cbiAgICAgICAgLy8gVGhpcyBpcyBhbiB1Z2x5IGhhY2ssIGJ1dCBhdCB0aGUgc2FtZSB0aW1lIGlzIHdheSBtb3JlIHJvYnVzdCB0aGFuXG4gICAgICAgIC8vIGNoZWNraW5nIHRoZSBzZW5kZXIgcGFyYW1ldGVycyBiZWZvcmUgYW5kIGFmdGVyIHRoZSBjcmVhdGVPZmZlclxuICAgICAgICAvLyBBbHNvIG5vdGUgdGhhdCBhZnRlciB0aGUgY3JlYXRlb2ZmZXIgd2UgYXJlIG5vdCAxMDAlIHN1cmUgdGhhdFxuICAgICAgICAvLyB0aGUgcGFyYW1zIHdlcmUgYXN5bmNocm9ub3VzbHkgYXBwbGllZCBzbyB3ZSBtaWdodCBtaXNzIHRoZVxuICAgICAgICAvLyBvcHBvcnR1bml0eSB0byByZWNyZWF0ZSBvZmZlci5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNlbmRlclxuICAgICAgICB9ID0gdHJhbnNjZWl2ZXI7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIGlmICghKCdlbmNvZGluZ3MnIGluIHBhcmFtcykgfHxcbiAgICAgICAgLy8gQXZvaWQgYmVpbmcgZm9vbGVkIGJ5IHBhdGNoZWQgZ2V0UGFyYW1ldGVycygpIGJlbG93LlxuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzLmxlbmd0aCA9PT0gMSAmJiBPYmplY3Qua2V5cyhwYXJhbXMuZW5jb2RpbmdzWzBdKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gc2VuZEVuY29kaW5ncztcbiAgICAgICAgICBzZW5kZXIuc2VuZEVuY29kaW5ncyA9IHNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMucHVzaChzZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHNlbmRlci5zZW5kRW5jb2RpbmdzO1xuICAgICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBzZW5kZXIuc2VuZEVuY29kaW5ncztcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2NlaXZlcjtcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBzaGltR2V0UGFyYW1ldGVycyh3aW5kb3cpIHtcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0dldFBhcmFtZXRlcnMgPSB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRQYXJhbWV0ZXJzO1xuICBpZiAob3JpZ0dldFBhcmFtZXRlcnMpIHtcbiAgICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gZ2V0UGFyYW1ldGVycygpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG9yaWdHZXRQYXJhbWV0ZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoISgnZW5jb2RpbmdzJyBpbiBwYXJhbXMpKSB7XG4gICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBbXS5jb25jYXQodGhpcy5zZW5kRW5jb2RpbmdzIHx8IFt7fV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBzaGltQ3JlYXRlT2ZmZXIod2luZG93KSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGNIYWNrcy9hZGFwdGVyL2lzc3Vlcy85OTgjaXNzdWVjb21tZW50LTUxNjkyMTY0N1xuICAvLyBGaXJlZm94IGlnbm9yZXMgdGhlIGluaXQgc2VuZEVuY29kaW5ncyBvcHRpb25zIHBhc3NlZCB0byBhZGRUcmFuc2NlaXZlclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzk2OTE4XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0NyZWF0ZU9mZmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlcjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKCkge1xuICAgIGlmICh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyAmJiB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1DcmVhdGVBbnN3ZXIod2luZG93KSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGNIYWNrcy9hZGFwdGVyL2lzc3Vlcy85OTgjaXNzdWVjb21tZW50LTUxNjkyMTY0N1xuICAvLyBGaXJlZm94IGlnbm9yZXMgdGhlIGluaXQgc2VuZEVuY29kaW5ncyBvcHRpb25zIHBhc3NlZCB0byBhZGRUcmFuc2NlaXZlclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzk2OTE4XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0NyZWF0ZUFuc3dlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQW5zd2VyO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUFuc3dlciA9IGZ1bmN0aW9uIGNyZWF0ZUFuc3dlcigpIHtcbiAgICBpZiAodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgJiYgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gb3JpZ0NyZWF0ZUFuc3dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzID0gW107XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdDcmVhdGVBbnN3ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIGZpcmVmb3hTaGltID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdHNoaW1BZGRUcmFuc2NlaXZlcjogc2hpbUFkZFRyYW5zY2VpdmVyLFxuXHRzaGltQ3JlYXRlQW5zd2VyOiBzaGltQ3JlYXRlQW5zd2VyLFxuXHRzaGltQ3JlYXRlT2ZmZXI6IHNoaW1DcmVhdGVPZmZlcixcblx0c2hpbUdldERpc3BsYXlNZWRpYTogc2hpbUdldERpc3BsYXlNZWRpYSxcblx0c2hpbUdldFBhcmFtZXRlcnM6IHNoaW1HZXRQYXJhbWV0ZXJzLFxuXHRzaGltR2V0VXNlck1lZGlhOiBzaGltR2V0VXNlck1lZGlhJDEsXG5cdHNoaW1PblRyYWNrOiBzaGltT25UcmFjayxcblx0c2hpbVBlZXJDb25uZWN0aW9uOiBzaGltUGVlckNvbm5lY3Rpb24sXG5cdHNoaW1SVENEYXRhQ2hhbm5lbDogc2hpbVJUQ0RhdGFDaGFubmVsLFxuXHRzaGltUmVjZWl2ZXJHZXRTdGF0czogc2hpbVJlY2VpdmVyR2V0U3RhdHMsXG5cdHNoaW1SZW1vdmVTdHJlYW06IHNoaW1SZW1vdmVTdHJlYW0sXG5cdHNoaW1TZW5kZXJHZXRTdGF0czogc2hpbVNlbmRlckdldFN0YXRzXG59KTtcblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG5mdW5jdGlvbiBzaGltTG9jYWxTdHJlYW1zQVBJKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgnZ2V0TG9jYWxTdHJlYW1zJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID0gZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fbG9jYWxTdHJlYW1zO1xuICAgIH07XG4gIH1cbiAgaWYgKCEoJ2FkZFN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBfYWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICB9XG4gICAgICAvLyBUcnkgdG8gZW11bGF0ZSBDaHJvbWUncyBiZWhhdmlvdXIgb2YgYWRkaW5nIGluIGF1ZGlvLXZpZGVvIG9yZGVyLlxuICAgICAgLy8gU2FmYXJpIG9yZGVycyBieSB0cmFjayBpZC5cbiAgICAgIHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmZvckVhY2godHJhY2sgPT4gX2FkZFRyYWNrLmNhbGwodGhpcywgdHJhY2ssIHN0cmVhbSkpO1xuICAgICAgc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiBfYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjaywgc3RyZWFtKSk7XG4gICAgfTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2spIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHJlYW1zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgc3RyZWFtc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtcykge1xuICAgICAgICBzdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW3N0cmVhbV07XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zLmluY2x1ZGVzKHN0cmVhbSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfYWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIGlmICghKCdyZW1vdmVTdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbG9jYWxTdHJlYW1zLmluZGV4T2Yoc3RyZWFtKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICBjb25zdCB0cmFja3MgPSBzdHJlYW0uZ2V0VHJhY2tzKCk7XG4gICAgICB0aGlzLmdldFNlbmRlcnMoKS5mb3JFYWNoKHNlbmRlciA9PiB7XG4gICAgICAgIGlmICh0cmFja3MuaW5jbHVkZXMoc2VuZGVyLnRyYWNrKSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbVJlbW90ZVN0cmVhbXNBUEkod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCAhd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKCdnZXRSZW1vdGVTdHJlYW1zJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVtb3RlU3RyZWFtcyA9IGZ1bmN0aW9uIGdldFJlbW90ZVN0cmVhbXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVtb3RlU3RyZWFtcyA/IHRoaXMuX3JlbW90ZVN0cmVhbXMgOiBbXTtcbiAgICB9O1xuICB9XG4gIGlmICghKCdvbmFkZHN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ29uYWRkc3RyZWFtJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25hZGRzdHJlYW07XG4gICAgICB9LFxuICAgICAgc2V0KGYpIHtcbiAgICAgICAgaWYgKHRoaXMuX29uYWRkc3RyZWFtKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbmFkZHN0cmVhbSk7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbmFkZHN0cmVhbSA9IGYpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb25hZGRzdHJlYW1wb2x5ID0gZSA9PiB7XG4gICAgICAgICAgZS5zdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVtb3RlU3RyZWFtcykge1xuICAgICAgICAgICAgICB0aGlzLl9yZW1vdGVTdHJlYW1zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVtb3RlU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHN0cmVhbScpO1xuICAgICAgICAgICAgZXZlbnQuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgICBjb25zdCBwYyA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuX29uYWRkc3RyZWFtcG9seSkge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb25hZGRzdHJlYW1wb2x5ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlLnN0cmVhbXMuZm9yRWFjaChzdHJlYW0gPT4ge1xuICAgICAgICAgICAgaWYgKCFwYy5fcmVtb3RlU3RyZWFtcykge1xuICAgICAgICAgICAgICBwYy5fcmVtb3RlU3RyZWFtcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBjLl9yZW1vdGVTdHJlYW1zLmluZGV4T2Yoc3RyZWFtKSA+PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBjLl9yZW1vdGVTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdhZGRzdHJlYW0nKTtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgIHBjLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkocGMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbUNhbGxiYWNrc0FQSSh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvdG90eXBlID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgY29uc3Qgb3JpZ0NyZWF0ZU9mZmVyID0gcHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xuICBjb25zdCBvcmlnQ3JlYXRlQW5zd2VyID0gcHJvdG90eXBlLmNyZWF0ZUFuc3dlcjtcbiAgY29uc3Qgc2V0TG9jYWxEZXNjcmlwdGlvbiA9IHByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xuICBjb25zdCBzZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgY29uc3QgYWRkSWNlQ2FuZGlkYXRlID0gcHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZTtcbiAgcHJvdG90eXBlLmNyZWF0ZU9mZmVyID0gZnVuY3Rpb24gY3JlYXRlT2ZmZXIoc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICBjb25zdCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzJdIDogYXJndW1lbnRzWzBdO1xuICAgIGNvbnN0IHByb21pc2UgPSBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBwcm90b3R5cGUuY3JlYXRlQW5zd2VyID0gZnVuY3Rpb24gY3JlYXRlQW5zd2VyKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1syXSA6IGFyZ3VtZW50c1swXTtcbiAgICBjb25zdCBwcm9taXNlID0gb3JpZ0NyZWF0ZUFuc3dlci5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIGxldCB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24sIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NyaXB0aW9uXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPSB3aXRoQ2FsbGJhY2s7XG4gIHdpdGhDYWxsYmFjayA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbiwgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICBjb25zdCBwcm9taXNlID0gc2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NyaXB0aW9uXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gd2l0aENhbGxiYWNrO1xuICB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FuZGlkYXRlLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIGNvbnN0IHByb21pc2UgPSBhZGRJY2VDYW5kaWRhdGUuYXBwbHkodGhpcywgW2NhbmRpZGF0ZV0pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPSB3aXRoQ2FsbGJhY2s7XG59XG5mdW5jdGlvbiBzaGltR2V0VXNlck1lZGlhKHdpbmRvdykge1xuICBjb25zdCBuYXZpZ2F0b3IgPSB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcjtcbiAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICAvLyBzaGltIG5vdCBuZWVkZWQgaW4gU2FmYXJpIDEyLjFcbiAgICBjb25zdCBtZWRpYURldmljZXMgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzO1xuICAgIGNvbnN0IF9nZXRVc2VyTWVkaWEgPSBtZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLmJpbmQobWVkaWFEZXZpY2VzKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGNvbnN0cmFpbnRzID0+IHtcbiAgICAgIHJldHVybiBfZ2V0VXNlck1lZGlhKHNoaW1Db25zdHJhaW50cyhjb25zdHJhaW50cykpO1xuICAgIH07XG4gIH1cbiAgaWYgKCFuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzLCBjYiwgZXJyY2IpIHtcbiAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKS50aGVuKGNiLCBlcnJjYik7XG4gICAgfS5iaW5kKG5hdmlnYXRvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1Db25zdHJhaW50cyhjb25zdHJhaW50cykge1xuICBpZiAoY29uc3RyYWludHMgJiYgY29uc3RyYWludHMudmlkZW8gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb25zdHJhaW50cywge1xuICAgICAgdmlkZW86IGNvbXBhY3RPYmplY3QoY29uc3RyYWludHMudmlkZW8pXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNvbnN0cmFpbnRzO1xufVxuZnVuY3Rpb24gc2hpbVJUQ0ljZVNlcnZlclVybHMod2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIG1pZ3JhdGUgZnJvbSBub24tc3BlYyBSVENJY2VTZXJ2ZXIudXJsIHRvIFJUQ0ljZVNlcnZlci51cmxzXG4gIGNvbnN0IE9yaWdQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gZnVuY3Rpb24gUlRDUGVlckNvbm5lY3Rpb24ocGNDb25maWcsIHBjQ29uc3RyYWludHMpIHtcbiAgICBpZiAocGNDb25maWcgJiYgcGNDb25maWcuaWNlU2VydmVycykge1xuICAgICAgY29uc3QgbmV3SWNlU2VydmVycyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwY0NvbmZpZy5pY2VTZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzZXJ2ZXIgPSBwY0NvbmZpZy5pY2VTZXJ2ZXJzW2ldO1xuICAgICAgICBpZiAoc2VydmVyLnVybHMgPT09IHVuZGVmaW5lZCAmJiBzZXJ2ZXIudXJsKSB7XG4gICAgICAgICAgZGVwcmVjYXRlZCgnUlRDSWNlU2VydmVyLnVybCcsICdSVENJY2VTZXJ2ZXIudXJscycpO1xuICAgICAgICAgIHNlcnZlciA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2VydmVyKSk7XG4gICAgICAgICAgc2VydmVyLnVybHMgPSBzZXJ2ZXIudXJsO1xuICAgICAgICAgIGRlbGV0ZSBzZXJ2ZXIudXJsO1xuICAgICAgICAgIG5ld0ljZVNlcnZlcnMucHVzaChzZXJ2ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0ljZVNlcnZlcnMucHVzaChwY0NvbmZpZy5pY2VTZXJ2ZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGNDb25maWcuaWNlU2VydmVycyA9IG5ld0ljZVNlcnZlcnM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3JpZ1BlZXJDb25uZWN0aW9uKHBjQ29uZmlnLCBwY0NvbnN0cmFpbnRzKTtcbiAgfTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSA9IE9yaWdQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIC8vIHdyYXAgc3RhdGljIG1ldGhvZHMuIEN1cnJlbnRseSBqdXN0IGdlbmVyYXRlQ2VydGlmaWNhdGUuXG4gIGlmICgnZ2VuZXJhdGVDZXJ0aWZpY2F0ZScgaW4gT3JpZ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiwgJ2dlbmVyYXRlQ2VydGlmaWNhdGUnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBPcmlnUGVlckNvbm5lY3Rpb24uZ2VuZXJhdGVDZXJ0aWZpY2F0ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlcih3aW5kb3cpIHtcbiAgLy8gQWRkIGV2ZW50LnRyYW5zY2VpdmVyIG1lbWJlciBvdmVyIGRlcHJlY2F0ZWQgZXZlbnQucmVjZWl2ZXJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENUcmFja0V2ZW50ICYmICdyZWNlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlICYmICEoJ3RyYW5zY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSwgJ3RyYW5zY2VpdmVyJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlY2VpdmVyOiB0aGlzLnJlY2VpdmVyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1DcmVhdGVPZmZlckxlZ2FjeSh3aW5kb3cpIHtcbiAgY29uc3Qgb3JpZ0NyZWF0ZU9mZmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlcjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKG9mZmVyT3B0aW9ucykge1xuICAgIGlmIChvZmZlck9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHN1cHBvcnQgYml0IHZhbHVlc1xuICAgICAgICBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9ICEhb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW87XG4gICAgICB9XG4gICAgICBjb25zdCBhdWRpb1RyYW5zY2VpdmVyID0gdGhpcy5nZXRUcmFuc2NlaXZlcnMoKS5maW5kKHRyYW5zY2VpdmVyID0+IHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09ICdhdWRpbycpO1xuICAgICAgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID09PSBmYWxzZSAmJiBhdWRpb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgIGlmIChhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2Jykge1xuICAgICAgICAgIGlmIChhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ3NlbmRvbmx5Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdyZWN2b25seScpIHtcbiAgICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdpbmFjdGl2ZScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID09PSB0cnVlICYmICFhdWRpb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJywge1xuICAgICAgICAgIGRpcmVjdGlvbjogJ3JlY3Zvbmx5J1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHN1cHBvcnQgYml0IHZhbHVlc1xuICAgICAgICBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9ICEhb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW87XG4gICAgICB9XG4gICAgICBjb25zdCB2aWRlb1RyYW5zY2VpdmVyID0gdGhpcy5nZXRUcmFuc2NlaXZlcnMoKS5maW5kKHRyYW5zY2VpdmVyID0+IHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09ICd2aWRlbycpO1xuICAgICAgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvID09PSBmYWxzZSAmJiB2aWRlb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgIGlmICh2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2Jykge1xuICAgICAgICAgIGlmICh2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ3NlbmRvbmx5Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdyZWN2b25seScpIHtcbiAgICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdpbmFjdGl2ZScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvID09PSB0cnVlICYmICF2aWRlb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJywge1xuICAgICAgICAgIGRpcmVjdGlvbjogJ3JlY3Zvbmx5J1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbUF1ZGlvQ29udGV4dCh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8IHdpbmRvdy5BdWRpb0NvbnRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XG59XG5cbnZhciBzYWZhcmlTaGltID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdHNoaW1BdWRpb0NvbnRleHQ6IHNoaW1BdWRpb0NvbnRleHQsXG5cdHNoaW1DYWxsYmFja3NBUEk6IHNoaW1DYWxsYmFja3NBUEksXG5cdHNoaW1Db25zdHJhaW50czogc2hpbUNvbnN0cmFpbnRzLFxuXHRzaGltQ3JlYXRlT2ZmZXJMZWdhY3k6IHNoaW1DcmVhdGVPZmZlckxlZ2FjeSxcblx0c2hpbUdldFVzZXJNZWRpYTogc2hpbUdldFVzZXJNZWRpYSxcblx0c2hpbUxvY2FsU3RyZWFtc0FQSTogc2hpbUxvY2FsU3RyZWFtc0FQSSxcblx0c2hpbVJUQ0ljZVNlcnZlclVybHM6IHNoaW1SVENJY2VTZXJ2ZXJVcmxzLFxuXHRzaGltUmVtb3RlU3RyZWFtc0FQSTogc2hpbVJlbW90ZVN0cmVhbXNBUEksXG5cdHNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXI6IHNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXJcbn0pO1xuXG52YXIgc2RwJDEgPSB7ZXhwb3J0czoge319O1xuXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbihmdW5jdGlvbiAobW9kdWxlKSB7XG5cbiAgLy8gU0RQIGhlbHBlcnMuXG4gIGNvbnN0IFNEUFV0aWxzID0ge307XG5cbiAgLy8gR2VuZXJhdGUgYW4gYWxwaGFudW1lcmljIGlkZW50aWZpZXIgZm9yIGNuYW1lIG9yIG1pZHMuXG4gIC8vIFRPRE86IHVzZSBVVUlEcyBpbnN0ZWFkPyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qZWQvOTgyODgzXG4gIFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEyKTtcbiAgfTtcblxuICAvLyBUaGUgUlRDUCBDTkFNRSB1c2VkIGJ5IGFsbCBwZWVyY29ubmVjdGlvbnMgZnJvbSB0aGUgc2FtZSBKUy5cbiAgU0RQVXRpbHMubG9jYWxDTmFtZSA9IFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllcigpO1xuXG4gIC8vIFNwbGl0cyBTRFAgaW50byBsaW5lcywgZGVhbGluZyB3aXRoIGJvdGggQ1JMRiBhbmQgTEYuXG4gIFNEUFV0aWxzLnNwbGl0TGluZXMgPSBmdW5jdGlvbiAoYmxvYikge1xuICAgIHJldHVybiBibG9iLnRyaW0oKS5zcGxpdCgnXFxuJykubWFwKGxpbmUgPT4gbGluZS50cmltKCkpO1xuICB9O1xuICAvLyBTcGxpdHMgU0RQIGludG8gc2Vzc2lvbnBhcnQgYW5kIG1lZGlhc2VjdGlvbnMuIEVuc3VyZXMgQ1JMRi5cbiAgU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyA9IGZ1bmN0aW9uIChibG9iKSB7XG4gICAgY29uc3QgcGFydHMgPSBibG9iLnNwbGl0KCdcXG5tPScpO1xuICAgIHJldHVybiBwYXJ0cy5tYXAoKHBhcnQsIGluZGV4KSA9PiAoaW5kZXggPiAwID8gJ209JyArIHBhcnQgOiBwYXJ0KS50cmltKCkgKyAnXFxyXFxuJyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgc2Vzc2lvbiBkZXNjcmlwdGlvbi5cbiAgU0RQVXRpbHMuZ2V0RGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoYmxvYikge1xuICAgIGNvbnN0IHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhibG9iKTtcbiAgICByZXR1cm4gc2VjdGlvbnMgJiYgc2VjdGlvbnNbMF07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgaW5kaXZpZHVhbCBtZWRpYSBzZWN0aW9ucy5cbiAgU0RQVXRpbHMuZ2V0TWVkaWFTZWN0aW9ucyA9IGZ1bmN0aW9uIChibG9iKSB7XG4gICAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICAgIHNlY3Rpb25zLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHNlY3Rpb25zO1xuICB9O1xuXG4gIC8vIFJldHVybnMgbGluZXMgdGhhdCBzdGFydCB3aXRoIGEgY2VydGFpbiBwcmVmaXguXG4gIFNEUFV0aWxzLm1hdGNoUHJlZml4ID0gZnVuY3Rpb24gKGJsb2IsIHByZWZpeCkge1xuICAgIHJldHVybiBTRFBVdGlscy5zcGxpdExpbmVzKGJsb2IpLmZpbHRlcihsaW5lID0+IGxpbmUuaW5kZXhPZihwcmVmaXgpID09PSAwKTtcbiAgfTtcblxuICAvLyBQYXJzZXMgYW4gSUNFIGNhbmRpZGF0ZSBsaW5lLiBTYW1wbGUgaW5wdXQ6XG4gIC8vIGNhbmRpZGF0ZTo3MDI3ODYzNTAgMiB1ZHAgNDE4MTk5MDIgOC44LjguOCA2MDc2OSB0eXAgcmVsYXkgcmFkZHIgOC44LjguOFxuICAvLyBycG9ydCA1NTk5NlwiXG4gIC8vIElucHV0IGNhbiBiZSBwcmVmaXhlZCB3aXRoIGE9LlxuICBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgbGV0IHBhcnRzO1xuICAgIC8vIFBhcnNlIGJvdGggdmFyaWFudHMuXG4gICAgaWYgKGxpbmUuaW5kZXhPZignYT1jYW5kaWRhdGU6JykgPT09IDApIHtcbiAgICAgIHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTIpLnNwbGl0KCcgJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTApLnNwbGl0KCcgJyk7XG4gICAgfVxuICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHtcbiAgICAgIGZvdW5kYXRpb246IHBhcnRzWzBdLFxuICAgICAgY29tcG9uZW50OiB7XG4gICAgICAgIDE6ICdydHAnLFxuICAgICAgICAyOiAncnRjcCdcbiAgICAgIH1bcGFydHNbMV1dIHx8IHBhcnRzWzFdLFxuICAgICAgcHJvdG9jb2w6IHBhcnRzWzJdLnRvTG93ZXJDYXNlKCksXG4gICAgICBwcmlvcml0eTogcGFyc2VJbnQocGFydHNbM10sIDEwKSxcbiAgICAgIGlwOiBwYXJ0c1s0XSxcbiAgICAgIGFkZHJlc3M6IHBhcnRzWzRdLFxuICAgICAgLy8gYWRkcmVzcyBpcyBhbiBhbGlhcyBmb3IgaXAuXG4gICAgICBwb3J0OiBwYXJzZUludChwYXJ0c1s1XSwgMTApLFxuICAgICAgLy8gc2tpcCBwYXJ0c1s2XSA9PSAndHlwJ1xuICAgICAgdHlwZTogcGFydHNbN11cbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSA4OyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHN3aXRjaCAocGFydHNbaV0pIHtcbiAgICAgICAgY2FzZSAncmFkZHInOlxuICAgICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncnBvcnQnOlxuICAgICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCA9IHBhcnNlSW50KHBhcnRzW2kgKyAxXSwgMTApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0Y3B0eXBlJzpcbiAgICAgICAgICBjYW5kaWRhdGUudGNwVHlwZSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndWZyYWcnOlxuICAgICAgICAgIGNhbmRpZGF0ZS51ZnJhZyA9IHBhcnRzW2kgKyAxXTsgLy8gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICAgICAgY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gZXh0ZW5zaW9uIGhhbmRsaW5nLCBpbiBwYXJ0aWN1bGFyIHVmcmFnLiBEb24ndCBvdmVyd3JpdGUuXG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZVtwYXJ0c1tpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2FuZGlkYXRlW3BhcnRzW2ldXSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYW5kaWRhdGU7XG4gIH07XG5cbiAgLy8gVHJhbnNsYXRlcyBhIGNhbmRpZGF0ZSBvYmplY3QgaW50byBTRFAgY2FuZGlkYXRlIGF0dHJpYnV0ZS5cbiAgLy8gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBhPSBwcmVmaXghXG4gIFNEUFV0aWxzLndyaXRlQ2FuZGlkYXRlID0gZnVuY3Rpb24gKGNhbmRpZGF0ZSkge1xuICAgIGNvbnN0IHNkcCA9IFtdO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5mb3VuZGF0aW9uKTtcbiAgICBjb25zdCBjb21wb25lbnQgPSBjYW5kaWRhdGUuY29tcG9uZW50O1xuICAgIGlmIChjb21wb25lbnQgPT09ICdydHAnKSB7XG4gICAgICBzZHAucHVzaCgxKTtcbiAgICB9IGVsc2UgaWYgKGNvbXBvbmVudCA9PT0gJ3J0Y3AnKSB7XG4gICAgICBzZHAucHVzaCgyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2RwLnB1c2goY29tcG9uZW50KTtcbiAgICB9XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnByb3RvY29sLnRvVXBwZXJDYXNlKCkpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5wcmlvcml0eSk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLmFkZHJlc3MgfHwgY2FuZGlkYXRlLmlwKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUucG9ydCk7XG4gICAgY29uc3QgdHlwZSA9IGNhbmRpZGF0ZS50eXBlO1xuICAgIHNkcC5wdXNoKCd0eXAnKTtcbiAgICBzZHAucHVzaCh0eXBlKTtcbiAgICBpZiAodHlwZSAhPT0gJ2hvc3QnICYmIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyAmJiBjYW5kaWRhdGUucmVsYXRlZFBvcnQpIHtcbiAgICAgIHNkcC5wdXNoKCdyYWRkcicpO1xuICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzKTtcbiAgICAgIHNkcC5wdXNoKCdycG9ydCcpO1xuICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KTtcbiAgICB9XG4gICAgaWYgKGNhbmRpZGF0ZS50Y3BUeXBlICYmIGNhbmRpZGF0ZS5wcm90b2NvbC50b0xvd2VyQ2FzZSgpID09PSAndGNwJykge1xuICAgICAgc2RwLnB1c2goJ3RjcHR5cGUnKTtcbiAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS50Y3BUeXBlKTtcbiAgICB9XG4gICAgaWYgKGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50IHx8IGNhbmRpZGF0ZS51ZnJhZykge1xuICAgICAgc2RwLnB1c2goJ3VmcmFnJyk7XG4gICAgICBzZHAucHVzaChjYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudCB8fCBjYW5kaWRhdGUudWZyYWcpO1xuICAgIH1cbiAgICByZXR1cm4gJ2NhbmRpZGF0ZTonICsgc2RwLmpvaW4oJyAnKTtcbiAgfTtcblxuICAvLyBQYXJzZXMgYW4gaWNlLW9wdGlvbnMgbGluZSwgcmV0dXJucyBhbiBhcnJheSBvZiBvcHRpb24gdGFncy5cbiAgLy8gU2FtcGxlIGlucHV0OlxuICAvLyBhPWljZS1vcHRpb25zOmZvbyBiYXJcbiAgU0RQVXRpbHMucGFyc2VJY2VPcHRpb25zID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICByZXR1cm4gbGluZS5zdWJzdHJpbmcoMTQpLnNwbGl0KCcgJyk7XG4gIH07XG5cbiAgLy8gUGFyc2VzIGEgcnRwbWFwIGxpbmUsIHJldHVybnMgUlRDUnRwQ29kZGVjUGFyYW1ldGVycy4gU2FtcGxlIGlucHV0OlxuICAvLyBhPXJ0cG1hcDoxMTEgb3B1cy80ODAwMC8yXG4gIFNEUFV0aWxzLnBhcnNlUnRwTWFwID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBsZXQgcGFydHMgPSBsaW5lLnN1YnN0cmluZyg5KS5zcGxpdCgnICcpO1xuICAgIGNvbnN0IHBhcnNlZCA9IHtcbiAgICAgIHBheWxvYWRUeXBlOiBwYXJzZUludChwYXJ0cy5zaGlmdCgpLCAxMCkgLy8gd2FzOiBpZFxuICAgIH07XG4gICAgcGFydHMgPSBwYXJ0c1swXS5zcGxpdCgnLycpO1xuICAgIHBhcnNlZC5uYW1lID0gcGFydHNbMF07XG4gICAgcGFyc2VkLmNsb2NrUmF0ZSA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7IC8vIHdhczogY2xvY2tyYXRlXG4gICAgcGFyc2VkLmNoYW5uZWxzID0gcGFydHMubGVuZ3RoID09PSAzID8gcGFyc2VJbnQocGFydHNbMl0sIDEwKSA6IDE7XG4gICAgLy8gbGVnYWN5IGFsaWFzLCBnb3QgcmVuYW1lZCBiYWNrIHRvIGNoYW5uZWxzIGluIE9SVEMuXG4gICAgcGFyc2VkLm51bUNoYW5uZWxzID0gcGFyc2VkLmNoYW5uZWxzO1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGVzIGEgcnRwbWFwIGxpbmUgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3JcbiAgLy8gUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuICBTRFBVdGlscy53cml0ZVJ0cE1hcCA9IGZ1bmN0aW9uIChjb2RlYykge1xuICAgIGxldCBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICAgIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICAgIH1cbiAgICBjb25zdCBjaGFubmVscyA9IGNvZGVjLmNoYW5uZWxzIHx8IGNvZGVjLm51bUNoYW5uZWxzIHx8IDE7XG4gICAgcmV0dXJuICdhPXJ0cG1hcDonICsgcHQgKyAnICcgKyBjb2RlYy5uYW1lICsgJy8nICsgY29kZWMuY2xvY2tSYXRlICsgKGNoYW5uZWxzICE9PSAxID8gJy8nICsgY2hhbm5lbHMgOiAnJykgKyAnXFxyXFxuJztcbiAgfTtcblxuICAvLyBQYXJzZXMgYSBleHRtYXAgbGluZSAoaGVhZGVyZXh0ZW5zaW9uIGZyb20gUkZDIDUyODUpLiBTYW1wbGUgaW5wdXQ6XG4gIC8vIGE9ZXh0bWFwOjIgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuICAvLyBhPWV4dG1hcDoyL3NlbmRvbmx5IHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbiAgU0RQVXRpbHMucGFyc2VFeHRtYXAgPSBmdW5jdGlvbiAobGluZSkge1xuICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICBkaXJlY3Rpb246IHBhcnRzWzBdLmluZGV4T2YoJy8nKSA+IDAgPyBwYXJ0c1swXS5zcGxpdCgnLycpWzFdIDogJ3NlbmRyZWN2JyxcbiAgICAgIHVyaTogcGFydHNbMV0sXG4gICAgICBhdHRyaWJ1dGVzOiBwYXJ0cy5zbGljZSgyKS5qb2luKCcgJylcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlcyBhbiBleHRtYXAgbGluZSBmcm9tIFJUQ1J0cEhlYWRlckV4dGVuc2lvblBhcmFtZXRlcnMgb3JcbiAgLy8gUlRDUnRwSGVhZGVyRXh0ZW5zaW9uLlxuICBTRFBVdGlscy53cml0ZUV4dG1hcCA9IGZ1bmN0aW9uIChoZWFkZXJFeHRlbnNpb24pIHtcbiAgICByZXR1cm4gJ2E9ZXh0bWFwOicgKyAoaGVhZGVyRXh0ZW5zaW9uLmlkIHx8IGhlYWRlckV4dGVuc2lvbi5wcmVmZXJyZWRJZCkgKyAoaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiAmJiBoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uICE9PSAnc2VuZHJlY3YnID8gJy8nICsgaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiA6ICcnKSArICcgJyArIGhlYWRlckV4dGVuc2lvbi51cmkgKyAoaGVhZGVyRXh0ZW5zaW9uLmF0dHJpYnV0ZXMgPyAnICcgKyBoZWFkZXJFeHRlbnNpb24uYXR0cmlidXRlcyA6ICcnKSArICdcXHJcXG4nO1xuICB9O1xuXG4gIC8vIFBhcnNlcyBhIGZtdHAgbGluZSwgcmV0dXJucyBkaWN0aW9uYXJ5LiBTYW1wbGUgaW5wdXQ6XG4gIC8vIGE9Zm10cDo5NiB2YnI9b247Y25nPW9uXG4gIC8vIEFsc28gZGVhbHMgd2l0aCB2YnI9b247IGNuZz1vblxuICBTRFBVdGlscy5wYXJzZUZtdHAgPSBmdW5jdGlvbiAobGluZSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHt9O1xuICAgIGxldCBrdjtcbiAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKGxpbmUuaW5kZXhPZignICcpICsgMSkuc3BsaXQoJzsnKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBrdiA9IHBhcnRzW2pdLnRyaW0oKS5zcGxpdCgnPScpO1xuICAgICAgcGFyc2VkW2t2WzBdLnRyaW0oKV0gPSBrdlsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZXMgYSBmbXRwIGxpbmUgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuICBTRFBVdGlscy53cml0ZUZtdHAgPSBmdW5jdGlvbiAoY29kZWMpIHtcbiAgICBsZXQgbGluZSA9ICcnO1xuICAgIGxldCBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICAgIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICAgIH1cbiAgICBpZiAoY29kZWMucGFyYW1ldGVycyAmJiBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgICAgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykuZm9yRWFjaChwYXJhbSA9PiB7XG4gICAgICAgIGlmIChjb2RlYy5wYXJhbWV0ZXJzW3BhcmFtXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0gKyAnPScgKyBjb2RlYy5wYXJhbWV0ZXJzW3BhcmFtXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxpbmUgKz0gJ2E9Zm10cDonICsgcHQgKyAnICcgKyBwYXJhbXMuam9pbignOycpICsgJ1xcclxcbic7XG4gICAgfVxuICAgIHJldHVybiBsaW5lO1xuICB9O1xuXG4gIC8vIFBhcnNlcyBhIHJ0Y3AtZmIgbGluZSwgcmV0dXJucyBSVENQUnRjcEZlZWRiYWNrIG9iamVjdC4gU2FtcGxlIGlucHV0OlxuICAvLyBhPXJ0Y3AtZmI6OTggbmFjayBycHNpXG4gIFNEUFV0aWxzLnBhcnNlUnRjcEZiID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKGxpbmUuaW5kZXhPZignICcpICsgMSkuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogcGFydHMuc2hpZnQoKSxcbiAgICAgIHBhcmFtZXRlcjogcGFydHMuam9pbignICcpXG4gICAgfTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhPXJ0Y3AtZmIgbGluZXMgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuICBTRFBVdGlscy53cml0ZVJ0Y3BGYiA9IGZ1bmN0aW9uIChjb2RlYykge1xuICAgIGxldCBsaW5lcyA9ICcnO1xuICAgIGxldCBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICAgIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICAgIH1cbiAgICBpZiAoY29kZWMucnRjcEZlZWRiYWNrICYmIGNvZGVjLnJ0Y3BGZWVkYmFjay5sZW5ndGgpIHtcbiAgICAgIC8vIEZJWE1FOiBzcGVjaWFsIGhhbmRsaW5nIGZvciB0cnItaW50P1xuICAgICAgY29kZWMucnRjcEZlZWRiYWNrLmZvckVhY2goZmIgPT4ge1xuICAgICAgICBsaW5lcyArPSAnYT1ydGNwLWZiOicgKyBwdCArICcgJyArIGZiLnR5cGUgKyAoZmIucGFyYW1ldGVyICYmIGZiLnBhcmFtZXRlci5sZW5ndGggPyAnICcgKyBmYi5wYXJhbWV0ZXIgOiAnJykgKyAnXFxyXFxuJztcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbGluZXM7XG4gIH07XG5cbiAgLy8gUGFyc2VzIGEgUkZDIDU1NzYgc3NyYyBtZWRpYSBhdHRyaWJ1dGUuIFNhbXBsZSBpbnB1dDpcbiAgLy8gYT1zc3JjOjM3MzU5Mjg1NTkgY25hbWU6c29tZXRoaW5nXG4gIFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBjb25zdCBzcCA9IGxpbmUuaW5kZXhPZignICcpO1xuICAgIGNvbnN0IHBhcnRzID0ge1xuICAgICAgc3NyYzogcGFyc2VJbnQobGluZS5zdWJzdHJpbmcoNywgc3ApLCAxMClcbiAgICB9O1xuICAgIGNvbnN0IGNvbG9uID0gbGluZS5pbmRleE9mKCc6Jywgc3ApO1xuICAgIGlmIChjb2xvbiA+IC0xKSB7XG4gICAgICBwYXJ0cy5hdHRyaWJ1dGUgPSBsaW5lLnN1YnN0cmluZyhzcCArIDEsIGNvbG9uKTtcbiAgICAgIHBhcnRzLnZhbHVlID0gbGluZS5zdWJzdHJpbmcoY29sb24gKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydHMuYXR0cmlidXRlID0gbGluZS5zdWJzdHJpbmcoc3AgKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzO1xuICB9O1xuXG4gIC8vIFBhcnNlIGEgc3NyYy1ncm91cCBsaW5lIChzZWUgUkZDIDU1NzYpLiBTYW1wbGUgaW5wdXQ6XG4gIC8vIGE9c3NyYy1ncm91cDpzZW1hbnRpY3MgMTIgMzRcbiAgU0RQVXRpbHMucGFyc2VTc3JjR3JvdXAgPSBmdW5jdGlvbiAobGluZSkge1xuICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTMpLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbWFudGljczogcGFydHMuc2hpZnQoKSxcbiAgICAgIHNzcmNzOiBwYXJ0cy5tYXAoc3NyYyA9PiBwYXJzZUludChzc3JjLCAxMCkpXG4gICAgfTtcbiAgfTtcblxuICAvLyBFeHRyYWN0cyB0aGUgTUlEIChSRkMgNTg4OCkgZnJvbSBhIG1lZGlhIHNlY3Rpb24uXG4gIC8vIFJldHVybnMgdGhlIE1JRCBvciB1bmRlZmluZWQgaWYgbm8gbWlkIGxpbmUgd2FzIGZvdW5kLlxuICBTRFBVdGlscy5nZXRNaWQgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgY29uc3QgbWlkID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1taWQ6JylbMF07XG4gICAgaWYgKG1pZCkge1xuICAgICAgcmV0dXJuIG1pZC5zdWJzdHJpbmcoNik7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBhcnNlcyBhIGZpbmdlcnByaW50IGxpbmUgZm9yIERUTFMtU1JUUC5cbiAgU0RQVXRpbHMucGFyc2VGaW5nZXJwcmludCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxNCkuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWxnb3JpdGhtOiBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgLy8gYWxnb3JpdGhtIGlzIGNhc2Utc2Vuc2l0aXZlIGluIEVkZ2UuXG4gICAgICB2YWx1ZTogcGFydHNbMV0udG9VcHBlckNhc2UoKSAvLyB0aGUgZGVmaW5pdGlvbiBpcyB1cHBlci1jYXNlIGluIFJGQyA0NTcyLlxuICAgIH07XG4gIH07XG5cbiAgLy8gRXh0cmFjdHMgRFRMUyBwYXJhbWV0ZXJzIGZyb20gU0RQIG1lZGlhIHNlY3Rpb24gb3Igc2Vzc2lvbnBhcnQuXG4gIC8vIEZJWE1FOiBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBmdW5jdGlvbnMgdGhpcyBzaG91bGQgb25seVxuICAvLyAgIGdldCB0aGUgZmluZ2VycHJpbnQgbGluZSBhcyBpbnB1dC4gU2VlIGFsc28gZ2V0SWNlUGFyYW1ldGVycy5cbiAgU0RQVXRpbHMuZ2V0RHRsc1BhcmFtZXRlcnMgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsICdhPWZpbmdlcnByaW50OicpO1xuICAgIC8vIE5vdGU6IGE9c2V0dXAgbGluZSBpcyBpZ25vcmVkIHNpbmNlIHdlIHVzZSB0aGUgJ2F1dG8nIHJvbGUgaW4gRWRnZS5cbiAgICByZXR1cm4ge1xuICAgICAgcm9sZTogJ2F1dG8nLFxuICAgICAgZmluZ2VycHJpbnRzOiBsaW5lcy5tYXAoU0RQVXRpbHMucGFyc2VGaW5nZXJwcmludClcbiAgICB9O1xuICB9O1xuXG4gIC8vIFNlcmlhbGl6ZXMgRFRMUyBwYXJhbWV0ZXJzIHRvIFNEUC5cbiAgU0RQVXRpbHMud3JpdGVEdGxzUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChwYXJhbXMsIHNldHVwVHlwZSkge1xuICAgIGxldCBzZHAgPSAnYT1zZXR1cDonICsgc2V0dXBUeXBlICsgJ1xcclxcbic7XG4gICAgcGFyYW1zLmZpbmdlcnByaW50cy5mb3JFYWNoKGZwID0+IHtcbiAgICAgIHNkcCArPSAnYT1maW5nZXJwcmludDonICsgZnAuYWxnb3JpdGhtICsgJyAnICsgZnAudmFsdWUgKyAnXFxyXFxuJztcbiAgICB9KTtcbiAgICByZXR1cm4gc2RwO1xuICB9O1xuXG4gIC8vIFBhcnNlcyBhPWNyeXB0byBsaW5lcyBpbnRvXG4gIC8vICAgaHR0cHM6Ly9yYXdnaXQuY29tL2Fib2JhL2VkZ2VydGMvbWFzdGVyL21zb3J0Yy1yczQuaHRtbCNkaWN0aW9uYXJ5LXJ0Y3NydHBzZGVzcGFyYW1ldGVycy1tZW1iZXJzXG4gIFNEUFV0aWxzLnBhcnNlQ3J5cHRvTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyg5KS5zcGxpdCgnICcpO1xuICAgIHJldHVybiB7XG4gICAgICB0YWc6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICBjcnlwdG9TdWl0ZTogcGFydHNbMV0sXG4gICAgICBrZXlQYXJhbXM6IHBhcnRzWzJdLFxuICAgICAgc2Vzc2lvblBhcmFtczogcGFydHMuc2xpY2UoMylcbiAgICB9O1xuICB9O1xuICBTRFBVdGlscy53cml0ZUNyeXB0b0xpbmUgPSBmdW5jdGlvbiAocGFyYW1ldGVycykge1xuICAgIHJldHVybiAnYT1jcnlwdG86JyArIHBhcmFtZXRlcnMudGFnICsgJyAnICsgcGFyYW1ldGVycy5jcnlwdG9TdWl0ZSArICcgJyArICh0eXBlb2YgcGFyYW1ldGVycy5rZXlQYXJhbXMgPT09ICdvYmplY3QnID8gU0RQVXRpbHMud3JpdGVDcnlwdG9LZXlQYXJhbXMocGFyYW1ldGVycy5rZXlQYXJhbXMpIDogcGFyYW1ldGVycy5rZXlQYXJhbXMpICsgKHBhcmFtZXRlcnMuc2Vzc2lvblBhcmFtcyA/ICcgJyArIHBhcmFtZXRlcnMuc2Vzc2lvblBhcmFtcy5qb2luKCcgJykgOiAnJykgKyAnXFxyXFxuJztcbiAgfTtcblxuICAvLyBQYXJzZXMgdGhlIGNyeXB0byBrZXkgcGFyYW1ldGVycyBpbnRvXG4gIC8vICAgaHR0cHM6Ly9yYXdnaXQuY29tL2Fib2JhL2VkZ2VydGMvbWFzdGVyL21zb3J0Yy1yczQuaHRtbCNydGNzcnRwa2V5cGFyYW0qXG4gIFNEUFV0aWxzLnBhcnNlQ3J5cHRvS2V5UGFyYW1zID0gZnVuY3Rpb24gKGtleVBhcmFtcykge1xuICAgIGlmIChrZXlQYXJhbXMuaW5kZXhPZignaW5saW5lOicpICE9PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBrZXlQYXJhbXMuc3Vic3RyaW5nKDcpLnNwbGl0KCd8Jyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleU1ldGhvZDogJ2lubGluZScsXG4gICAgICBrZXlTYWx0OiBwYXJ0c1swXSxcbiAgICAgIGxpZmVUaW1lOiBwYXJ0c1sxXSxcbiAgICAgIG1raVZhbHVlOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCc6JylbMF0gOiB1bmRlZmluZWQsXG4gICAgICBta2lMZW5ndGg6IHBhcnRzWzJdID8gcGFydHNbMl0uc3BsaXQoJzonKVsxXSA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH07XG4gIFNEUFV0aWxzLndyaXRlQ3J5cHRvS2V5UGFyYW1zID0gZnVuY3Rpb24gKGtleVBhcmFtcykge1xuICAgIHJldHVybiBrZXlQYXJhbXMua2V5TWV0aG9kICsgJzonICsga2V5UGFyYW1zLmtleVNhbHQgKyAoa2V5UGFyYW1zLmxpZmVUaW1lID8gJ3wnICsga2V5UGFyYW1zLmxpZmVUaW1lIDogJycpICsgKGtleVBhcmFtcy5ta2lWYWx1ZSAmJiBrZXlQYXJhbXMubWtpTGVuZ3RoID8gJ3wnICsga2V5UGFyYW1zLm1raVZhbHVlICsgJzonICsga2V5UGFyYW1zLm1raUxlbmd0aCA6ICcnKTtcbiAgfTtcblxuICAvLyBFeHRyYWN0cyBhbGwgU0RFUyBwYXJhbWV0ZXJzLlxuICBTRFBVdGlscy5nZXRDcnlwdG9QYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LCAnYT1jcnlwdG86Jyk7XG4gICAgcmV0dXJuIGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUNyeXB0b0xpbmUpO1xuICB9O1xuXG4gIC8vIFBhcnNlcyBJQ0UgaW5mb3JtYXRpb24gZnJvbSBTRFAgbWVkaWEgc2VjdGlvbiBvciBzZXNzaW9ucGFydC5cbiAgLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4gIC8vICAgZ2V0IHRoZSBpY2UtdWZyYWcgYW5kIGljZS1wd2QgbGluZXMgYXMgaW5wdXQuXG4gIFNEUFV0aWxzLmdldEljZVBhcmFtZXRlcnMgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICAgIGNvbnN0IHVmcmFnID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsICdhPWljZS11ZnJhZzonKVswXTtcbiAgICBjb25zdCBwd2QgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCwgJ2E9aWNlLXB3ZDonKVswXTtcbiAgICBpZiAoISh1ZnJhZyAmJiBwd2QpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXJuYW1lRnJhZ21lbnQ6IHVmcmFnLnN1YnN0cmluZygxMiksXG4gICAgICBwYXNzd29yZDogcHdkLnN1YnN0cmluZygxMClcbiAgICB9O1xuICB9O1xuXG4gIC8vIFNlcmlhbGl6ZXMgSUNFIHBhcmFtZXRlcnMgdG8gU0RQLlxuICBTRFBVdGlscy53cml0ZUljZVBhcmFtZXRlcnMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgbGV0IHNkcCA9ICdhPWljZS11ZnJhZzonICsgcGFyYW1zLnVzZXJuYW1lRnJhZ21lbnQgKyAnXFxyXFxuJyArICdhPWljZS1wd2Q6JyArIHBhcmFtcy5wYXNzd29yZCArICdcXHJcXG4nO1xuICAgIGlmIChwYXJhbXMuaWNlTGl0ZSkge1xuICAgICAgc2RwICs9ICdhPWljZS1saXRlXFxyXFxuJztcbiAgICB9XG4gICAgcmV0dXJuIHNkcDtcbiAgfTtcblxuICAvLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIFJUQ1J0cFBhcmFtZXRlcnMuXG4gIFNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHtcbiAgICAgIGNvZGVjczogW10sXG4gICAgICBoZWFkZXJFeHRlbnNpb25zOiBbXSxcbiAgICAgIGZlY01lY2hhbmlzbXM6IFtdLFxuICAgICAgcnRjcDogW11cbiAgICB9O1xuICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICAgIGNvbnN0IG1saW5lID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcbiAgICBkZXNjcmlwdGlvbi5wcm9maWxlID0gbWxpbmVbMl07XG4gICAgZm9yIChsZXQgaSA9IDM7IGkgPCBtbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gZmluZCBhbGwgY29kZWNzIGZyb20gbWxpbmVbMy4uXVxuICAgICAgY29uc3QgcHQgPSBtbGluZVtpXTtcbiAgICAgIGNvbnN0IHJ0cG1hcGxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0cG1hcDonICsgcHQgKyAnICcpWzBdO1xuICAgICAgaWYgKHJ0cG1hcGxpbmUpIHtcbiAgICAgICAgY29uc3QgY29kZWMgPSBTRFBVdGlscy5wYXJzZVJ0cE1hcChydHBtYXBsaW5lKTtcbiAgICAgICAgY29uc3QgZm10cHMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPWZtdHA6JyArIHB0ICsgJyAnKTtcbiAgICAgICAgLy8gT25seSB0aGUgZmlyc3QgYT1mbXRwOjxwdD4gaXMgY29uc2lkZXJlZC5cbiAgICAgICAgY29kZWMucGFyYW1ldGVycyA9IGZtdHBzLmxlbmd0aCA/IFNEUFV0aWxzLnBhcnNlRm10cChmbXRwc1swXSkgOiB7fTtcbiAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLWZiOicgKyBwdCArICcgJykubWFwKFNEUFV0aWxzLnBhcnNlUnRjcEZiKTtcbiAgICAgICAgZGVzY3JpcHRpb24uY29kZWNzLnB1c2goY29kZWMpO1xuICAgICAgICAvLyBwYXJzZSBGRUMgbWVjaGFuaXNtcyBmcm9tIHJ0cG1hcCBsaW5lcy5cbiAgICAgICAgc3dpdGNoIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICBjYXNlICdSRUQnOlxuICAgICAgICAgIGNhc2UgJ1VMUEZFQyc6XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLnB1c2goY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9ZXh0bWFwOicpLmZvckVhY2gobGluZSA9PiB7XG4gICAgICBkZXNjcmlwdGlvbi5oZWFkZXJFeHRlbnNpb25zLnB1c2goU0RQVXRpbHMucGFyc2VFeHRtYXAobGluZSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IHdpbGRjYXJkUnRjcEZiID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLWZiOiogJykubWFwKFNEUFV0aWxzLnBhcnNlUnRjcEZiKTtcbiAgICBkZXNjcmlwdGlvbi5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgICB3aWxkY2FyZFJ0Y3BGYi5mb3JFYWNoKGZiID0+IHtcbiAgICAgICAgY29uc3QgZHVwbGljYXRlID0gY29kZWMucnRjcEZlZWRiYWNrLmZpbmQoZXhpc3RpbmdGZWVkYmFjayA9PiB7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nRmVlZGJhY2sudHlwZSA9PT0gZmIudHlwZSAmJiBleGlzdGluZ0ZlZWRiYWNrLnBhcmFtZXRlciA9PT0gZmIucGFyYW1ldGVyO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFkdXBsaWNhdGUpIHtcbiAgICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2sucHVzaChmYik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIEZJWE1FOiBwYXJzZSBydGNwLlxuICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZXMgcGFydHMgb2YgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGRlc2NyaWJpbmcgdGhlIGNhcGFiaWxpdGllcyAvXG4gIC8vIHBhcmFtZXRlcnMuXG4gIFNEUFV0aWxzLndyaXRlUnRwRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoa2luZCwgY2Fwcykge1xuICAgIGxldCBzZHAgPSAnJztcblxuICAgIC8vIEJ1aWxkIHRoZSBtbGluZS5cbiAgICBzZHAgKz0gJ209JyArIGtpbmQgKyAnICc7XG4gICAgc2RwICs9IGNhcHMuY29kZWNzLmxlbmd0aCA+IDAgPyAnOScgOiAnMCc7IC8vIHJlamVjdCBpZiBubyBjb2RlY3MuXG4gICAgc2RwICs9ICcgJyArIChjYXBzLnByb2ZpbGUgfHwgJ1VEUC9UTFMvUlRQL1NBVlBGJykgKyAnICc7XG4gICAgc2RwICs9IGNhcHMuY29kZWNzLm1hcChjb2RlYyA9PiB7XG4gICAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29kZWMucGF5bG9hZFR5cGU7XG4gICAgfSkuam9pbignICcpICsgJ1xcclxcbic7XG4gICAgc2RwICs9ICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJztcbiAgICBzZHAgKz0gJ2E9cnRjcDo5IElOIElQNCAwLjAuMC4wXFxyXFxuJztcblxuICAgIC8vIEFkZCBhPXJ0cG1hcCBsaW5lcyBmb3IgZWFjaCBjb2RlYy4gQWxzbyBmbXRwIGFuZCBydGNwLWZiLlxuICAgIGNhcHMuY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlUnRwTWFwKGNvZGVjKTtcbiAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZUZtdHAoY29kZWMpO1xuICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlUnRjcEZiKGNvZGVjKTtcbiAgICB9KTtcbiAgICBsZXQgbWF4cHRpbWUgPSAwO1xuICAgIGNhcHMuY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgICAgaWYgKGNvZGVjLm1heHB0aW1lID4gbWF4cHRpbWUpIHtcbiAgICAgICAgbWF4cHRpbWUgPSBjb2RlYy5tYXhwdGltZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobWF4cHRpbWUgPiAwKSB7XG4gICAgICBzZHAgKz0gJ2E9bWF4cHRpbWU6JyArIG1heHB0aW1lICsgJ1xcclxcbic7XG4gICAgfVxuICAgIGlmIChjYXBzLmhlYWRlckV4dGVuc2lvbnMpIHtcbiAgICAgIGNhcHMuaGVhZGVyRXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZUV4dG1hcChleHRlbnNpb24pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEZJWE1FOiB3cml0ZSBmZWNNZWNoYW5pc21zLlxuICAgIHJldHVybiBzZHA7XG4gIH07XG5cbiAgLy8gUGFyc2VzIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZlxuICAvLyBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnMuXG4gIFNEUFV0aWxzLnBhcnNlUnRwRW5jb2RpbmdQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgIGNvbnN0IGVuY29kaW5nUGFyYW1ldGVycyA9IFtdO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbik7XG4gICAgY29uc3QgaGFzUmVkID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdSRUQnKSAhPT0gLTE7XG4gICAgY29uc3QgaGFzVWxwZmVjID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdVTFBGRUMnKSAhPT0gLTE7XG5cbiAgICAvLyBmaWx0ZXIgYT1zc3JjOi4uLiBjbmFtZTosIGlnbm9yZSBQbGFuQi1tc2lkXG4gICAgY29uc3Qgc3NyY3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JykubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpLmZpbHRlcihwYXJ0cyA9PiBwYXJ0cy5hdHRyaWJ1dGUgPT09ICdjbmFtZScpO1xuICAgIGNvbnN0IHByaW1hcnlTc3JjID0gc3NyY3MubGVuZ3RoID4gMCAmJiBzc3Jjc1swXS5zc3JjO1xuICAgIGxldCBzZWNvbmRhcnlTc3JjO1xuICAgIGNvbnN0IGZsb3dzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjLWdyb3VwOkZJRCcpLm1hcChsaW5lID0+IHtcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTcpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4gcGFydHMubWFwKHBhcnQgPT4gcGFyc2VJbnQocGFydCwgMTApKTtcbiAgICB9KTtcbiAgICBpZiAoZmxvd3MubGVuZ3RoID4gMCAmJiBmbG93c1swXS5sZW5ndGggPiAxICYmIGZsb3dzWzBdWzBdID09PSBwcmltYXJ5U3NyYykge1xuICAgICAgc2Vjb25kYXJ5U3NyYyA9IGZsb3dzWzBdWzFdO1xuICAgIH1cbiAgICBkZXNjcmlwdGlvbi5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgICBpZiAoY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpID09PSAnUlRYJyAmJiBjb2RlYy5wYXJhbWV0ZXJzLmFwdCkge1xuICAgICAgICBsZXQgZW5jUGFyYW0gPSB7XG4gICAgICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXG4gICAgICAgICAgY29kZWNQYXlsb2FkVHlwZTogcGFyc2VJbnQoY29kZWMucGFyYW1ldGVycy5hcHQsIDEwKVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJpbWFyeVNzcmMgJiYgc2Vjb25kYXJ5U3NyYykge1xuICAgICAgICAgIGVuY1BhcmFtLnJ0eCA9IHtcbiAgICAgICAgICAgIHNzcmM6IHNlY29uZGFyeVNzcmNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKGVuY1BhcmFtKTtcbiAgICAgICAgaWYgKGhhc1JlZCkge1xuICAgICAgICAgIGVuY1BhcmFtID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbmNQYXJhbSkpO1xuICAgICAgICAgIGVuY1BhcmFtLmZlYyA9IHtcbiAgICAgICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgICAgICAgICAgbWVjaGFuaXNtOiBoYXNVbHBmZWMgPyAncmVkK3VscGZlYycgOiAncmVkJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGVuY29kaW5nUGFyYW1ldGVycy5sZW5ndGggPT09IDAgJiYgcHJpbWFyeVNzcmMpIHtcbiAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKHtcbiAgICAgICAgc3NyYzogcHJpbWFyeVNzcmNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHdlIHN1cHBvcnQgYm90aCBiPUFTIGFuZCBiPVRJQVMgYnV0IGludGVycHJldCBBUyBhcyBUSUFTLlxuICAgIGxldCBiYW5kd2lkdGggPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdiPScpO1xuICAgIGlmIChiYW5kd2lkdGgubGVuZ3RoKSB7XG4gICAgICBpZiAoYmFuZHdpZHRoWzBdLmluZGV4T2YoJ2I9VElBUzonKSA9PT0gMCkge1xuICAgICAgICBiYW5kd2lkdGggPSBwYXJzZUludChiYW5kd2lkdGhbMF0uc3Vic3RyaW5nKDcpLCAxMCk7XG4gICAgICB9IGVsc2UgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPUFTOicpID09PSAwKSB7XG4gICAgICAgIC8vIHVzZSBmb3JtdWxhIGZyb20gSlNFUCB0byBjb252ZXJ0IGI9QVMgdG8gVElBUyB2YWx1ZS5cbiAgICAgICAgYmFuZHdpZHRoID0gcGFyc2VJbnQoYmFuZHdpZHRoWzBdLnN1YnN0cmluZyg1KSwgMTApICogMTAwMCAqIDAuOTUgLSA1MCAqIDQwICogODtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhbmR3aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5mb3JFYWNoKHBhcmFtcyA9PiB7XG4gICAgICAgIHBhcmFtcy5tYXhCaXRyYXRlID0gYmFuZHdpZHRoO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGluZ1BhcmFtZXRlcnM7XG4gIH07XG5cbiAgLy8gcGFyc2VzIGh0dHA6Ly9kcmFmdC5vcnRjLm9yZy8jcnRjcnRjcHBhcmFtZXRlcnMqXG4gIFNEUFV0aWxzLnBhcnNlUnRjcFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgY29uc3QgcnRjcFBhcmFtZXRlcnMgPSB7fTtcblxuICAgIC8vIEdldHMgdGhlIGZpcnN0IFNTUkMuIE5vdGUgdGhhdCB3aXRoIFJUWCB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZVxuICAgIC8vIFNTUkNzLlxuICAgIGNvbnN0IHJlbW90ZVNzcmMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JykubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpLmZpbHRlcihvYmogPT4gb2JqLmF0dHJpYnV0ZSA9PT0gJ2NuYW1lJylbMF07XG4gICAgaWYgKHJlbW90ZVNzcmMpIHtcbiAgICAgIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lID0gcmVtb3RlU3NyYy52YWx1ZTtcbiAgICAgIHJ0Y3BQYXJhbWV0ZXJzLnNzcmMgPSByZW1vdGVTc3JjLnNzcmM7XG4gICAgfVxuXG4gICAgLy8gRWRnZSB1c2VzIHRoZSBjb21wb3VuZCBhdHRyaWJ1dGUgaW5zdGVhZCBvZiByZWR1Y2VkU2l6ZVxuICAgIC8vIGNvbXBvdW5kIGlzICFyZWR1Y2VkU2l6ZVxuICAgIGNvbnN0IHJzaXplID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLXJzaXplJyk7XG4gICAgcnRjcFBhcmFtZXRlcnMucmVkdWNlZFNpemUgPSByc2l6ZS5sZW5ndGggPiAwO1xuICAgIHJ0Y3BQYXJhbWV0ZXJzLmNvbXBvdW5kID0gcnNpemUubGVuZ3RoID09PSAwO1xuXG4gICAgLy8gcGFyc2VzIHRoZSBydGNwLW11eCBhdHRy0ZZidXRlLlxuICAgIC8vIE5vdGUgdGhhdCBFZGdlIGRvZXMgbm90IHN1cHBvcnQgdW5tdXhlZCBSVENQLlxuICAgIGNvbnN0IG11eCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1tdXgnKTtcbiAgICBydGNwUGFyYW1ldGVycy5tdXggPSBtdXgubGVuZ3RoID4gMDtcbiAgICByZXR1cm4gcnRjcFBhcmFtZXRlcnM7XG4gIH07XG4gIFNEUFV0aWxzLndyaXRlUnRjcFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAocnRjcFBhcmFtZXRlcnMpIHtcbiAgICBsZXQgc2RwID0gJyc7XG4gICAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLnJlZHVjZWRTaXplKSB7XG4gICAgICBzZHAgKz0gJ2E9cnRjcC1yc2l6ZVxcclxcbic7XG4gICAgfVxuICAgIGlmIChydGNwUGFyYW1ldGVycy5tdXgpIHtcbiAgICAgIHNkcCArPSAnYT1ydGNwLW11eFxcclxcbic7XG4gICAgfVxuICAgIGlmIChydGNwUGFyYW1ldGVycy5zc3JjICE9PSB1bmRlZmluZWQgJiYgcnRjcFBhcmFtZXRlcnMuY25hbWUpIHtcbiAgICAgIHNkcCArPSAnYT1zc3JjOicgKyBydGNwUGFyYW1ldGVycy5zc3JjICsgJyBjbmFtZTonICsgcnRjcFBhcmFtZXRlcnMuY25hbWUgKyAnXFxyXFxuJztcbiAgICB9XG4gICAgcmV0dXJuIHNkcDtcbiAgfTtcblxuICAvLyBwYXJzZXMgZWl0aGVyIGE9bXNpZDogb3IgYT1zc3JjOi4uLiBtc2lkIGxpbmVzIGFuZCByZXR1cm5zXG4gIC8vIHRoZSBpZCBvZiB0aGUgTWVkaWFTdHJlYW0gYW5kIE1lZGlhU3RyZWFtVHJhY2suXG4gIFNEUFV0aWxzLnBhcnNlTXNpZCA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICBsZXQgcGFydHM7XG4gICAgY29uc3Qgc3BlYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bXNpZDonKTtcbiAgICBpZiAoc3BlYy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHBhcnRzID0gc3BlY1swXS5zdWJzdHJpbmcoNykuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbTogcGFydHNbMF0sXG4gICAgICAgIHRyYWNrOiBwYXJ0c1sxXVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcGxhbkIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JykubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpLmZpbHRlcihtc2lkUGFydHMgPT4gbXNpZFBhcnRzLmF0dHJpYnV0ZSA9PT0gJ21zaWQnKTtcbiAgICBpZiAocGxhbkIubGVuZ3RoID4gMCkge1xuICAgICAgcGFydHMgPSBwbGFuQlswXS52YWx1ZS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RyZWFtOiBwYXJ0c1swXSxcbiAgICAgICAgdHJhY2s6IHBhcnRzWzFdXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICAvLyBTQ1RQXG4gIC8vIHBhcnNlcyBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiBmaXJzdCBhbmQgZmFsbHMgYmFja1xuICAvLyB0byBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0wNVxuICBTRFBVdGlscy5wYXJzZVNjdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICBjb25zdCBtbGluZSA9IFNEUFV0aWxzLnBhcnNlTUxpbmUobWVkaWFTZWN0aW9uKTtcbiAgICBjb25zdCBtYXhTaXplTGluZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bWF4LW1lc3NhZ2Utc2l6ZTonKTtcbiAgICBsZXQgbWF4TWVzc2FnZVNpemU7XG4gICAgaWYgKG1heFNpemVMaW5lLmxlbmd0aCA+IDApIHtcbiAgICAgIG1heE1lc3NhZ2VTaXplID0gcGFyc2VJbnQobWF4U2l6ZUxpbmVbMF0uc3Vic3RyaW5nKDE5KSwgMTApO1xuICAgIH1cbiAgICBpZiAoaXNOYU4obWF4TWVzc2FnZVNpemUpKSB7XG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IDY1NTM2O1xuICAgIH1cbiAgICBjb25zdCBzY3RwUG9ydCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c2N0cC1wb3J0OicpO1xuICAgIGlmIChzY3RwUG9ydC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3J0OiBwYXJzZUludChzY3RwUG9ydFswXS5zdWJzdHJpbmcoMTIpLCAxMCksXG4gICAgICAgIHByb3RvY29sOiBtbGluZS5mbXQsXG4gICAgICAgIG1heE1lc3NhZ2VTaXplXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzY3RwTWFwTGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHBtYXA6Jyk7XG4gICAgaWYgKHNjdHBNYXBMaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IHNjdHBNYXBMaW5lc1swXS5zdWJzdHJpbmcoMTApLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3J0OiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgICAgICBwcm90b2NvbDogcGFydHNbMV0sXG4gICAgICAgIG1heE1lc3NhZ2VTaXplXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICAvLyBTQ1RQXG4gIC8vIG91dHB1dHMgdGhlIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2IHZlcnNpb24gdGhhdCBhbGwgYnJvd3NlcnNcbiAgLy8gc3VwcG9ydCBieSBub3cgcmVjZWl2aW5nIGluIHRoaXMgZm9ybWF0LCB1bmxlc3Mgd2Ugb3JpZ2luYWxseSBwYXJzZWRcbiAgLy8gYXMgdGhlIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTA1IGZvcm1hdCAoaW5kaWNhdGVkIGJ5IHRoZSBtLWxpbmVcbiAgLy8gcHJvdG9jb2wgb2YgRFRMUy9TQ1RQIC0tIHdpdGhvdXQgVURQLyBvciBUQ1AvKVxuICBTRFBVdGlscy53cml0ZVNjdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChtZWRpYSwgc2N0cCkge1xuICAgIGxldCBvdXRwdXQgPSBbXTtcbiAgICBpZiAobWVkaWEucHJvdG9jb2wgIT09ICdEVExTL1NDVFAnKSB7XG4gICAgICBvdXRwdXQgPSBbJ209JyArIG1lZGlhLmtpbmQgKyAnIDkgJyArIG1lZGlhLnByb3RvY29sICsgJyAnICsgc2N0cC5wcm90b2NvbCArICdcXHJcXG4nLCAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbicsICdhPXNjdHAtcG9ydDonICsgc2N0cC5wb3J0ICsgJ1xcclxcbiddO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgPSBbJ209JyArIG1lZGlhLmtpbmQgKyAnIDkgJyArIG1lZGlhLnByb3RvY29sICsgJyAnICsgc2N0cC5wb3J0ICsgJ1xcclxcbicsICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJywgJ2E9c2N0cG1hcDonICsgc2N0cC5wb3J0ICsgJyAnICsgc2N0cC5wcm90b2NvbCArICcgNjU1MzVcXHJcXG4nXTtcbiAgICB9XG4gICAgaWYgKHNjdHAubWF4TWVzc2FnZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3V0cHV0LnB1c2goJ2E9bWF4LW1lc3NhZ2Utc2l6ZTonICsgc2N0cC5tYXhNZXNzYWdlU2l6ZSArICdcXHJcXG4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHNlc3Npb24gSUQgZm9yIFNEUC5cbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtcnRjd2ViLWpzZXAtMjAjc2VjdGlvbi01LjIuMVxuICAvLyByZWNvbW1lbmRzIHVzaW5nIGEgY3J5cHRvZ3JhcGhpY2FsbHkgcmFuZG9tICt2ZSA2NC1iaXQgdmFsdWVcbiAgLy8gYnV0IHJpZ2h0IG5vdyB0aGlzIHNob3VsZCBiZSBhY2NlcHRhYmxlIGFuZCB3aXRoaW4gdGhlIHJpZ2h0IHJhbmdlXG4gIFNEUFV0aWxzLmdlbmVyYXRlU2Vzc2lvbklkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc3Vic3RyKDIsIDIyKTtcbiAgfTtcblxuICAvLyBXcml0ZSBib2lsZXIgcGxhdGUgZm9yIHN0YXJ0IG9mIFNEUFxuICAvLyBzZXNzSWQgYXJndW1lbnQgaXMgb3B0aW9uYWwgLSBpZiBub3Qgc3VwcGxpZWQgaXQgd2lsbFxuICAvLyBiZSBnZW5lcmF0ZWQgcmFuZG9tbHlcbiAgLy8gc2Vzc1ZlcnNpb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIDJcbiAgLy8gc2Vzc1VzZXIgaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvICd0aGlzaXNhZGFwdGVyb3J0YydcbiAgU0RQVXRpbHMud3JpdGVTZXNzaW9uQm9pbGVycGxhdGUgPSBmdW5jdGlvbiAoc2Vzc0lkLCBzZXNzVmVyLCBzZXNzVXNlcikge1xuICAgIGxldCBzZXNzaW9uSWQ7XG4gICAgY29uc3QgdmVyc2lvbiA9IHNlc3NWZXIgIT09IHVuZGVmaW5lZCA/IHNlc3NWZXIgOiAyO1xuICAgIGlmIChzZXNzSWQpIHtcbiAgICAgIHNlc3Npb25JZCA9IHNlc3NJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vzc2lvbklkID0gU0RQVXRpbHMuZ2VuZXJhdGVTZXNzaW9uSWQoKTtcbiAgICB9XG4gICAgY29uc3QgdXNlciA9IHNlc3NVc2VyIHx8ICd0aGlzaXNhZGFwdGVyb3J0Yyc7XG4gICAgLy8gRklYTUU6IHNlc3MtaWQgc2hvdWxkIGJlIGFuIE5UUCB0aW1lc3RhbXAuXG4gICAgcmV0dXJuICd2PTBcXHJcXG4nICsgJ289JyArIHVzZXIgKyAnICcgKyBzZXNzaW9uSWQgKyAnICcgKyB2ZXJzaW9uICsgJyBJTiBJUDQgMTI3LjAuMC4xXFxyXFxuJyArICdzPS1cXHJcXG4nICsgJ3Q9MCAwXFxyXFxuJztcbiAgfTtcblxuICAvLyBHZXRzIHRoZSBkaXJlY3Rpb24gZnJvbSB0aGUgbWVkaWFTZWN0aW9uIG9yIHRoZSBzZXNzaW9ucGFydC5cbiAgU0RQVXRpbHMuZ2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgICAvLyBMb29rIGZvciBzZW5kcmVjdiwgc2VuZG9ubHksIHJlY3Zvbmx5LCBpbmFjdGl2ZSwgZGVmYXVsdCB0byBzZW5kcmVjdi5cbiAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzd2l0Y2ggKGxpbmVzW2ldKSB7XG4gICAgICAgIGNhc2UgJ2E9c2VuZHJlY3YnOlxuICAgICAgICBjYXNlICdhPXNlbmRvbmx5JzpcbiAgICAgICAgY2FzZSAnYT1yZWN2b25seSc6XG4gICAgICAgIGNhc2UgJ2E9aW5hY3RpdmUnOlxuICAgICAgICAgIHJldHVybiBsaW5lc1tpXS5zdWJzdHJpbmcoMik7XG4gICAgICAgIC8vIEZJWE1FOiBXaGF0IHNob3VsZCBoYXBwZW4gaGVyZT9cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlc3Npb25wYXJ0KSB7XG4gICAgICByZXR1cm4gU0RQVXRpbHMuZ2V0RGlyZWN0aW9uKHNlc3Npb25wYXJ0KTtcbiAgICB9XG4gICAgcmV0dXJuICdzZW5kcmVjdic7XG4gIH07XG4gIFNEUFV0aWxzLmdldEtpbmQgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gICAgY29uc3QgbWxpbmUgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xuICAgIHJldHVybiBtbGluZVswXS5zdWJzdHJpbmcoMik7XG4gIH07XG4gIFNEUFV0aWxzLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgcmV0dXJuIG1lZGlhU2VjdGlvbi5zcGxpdCgnICcsIDIpWzFdID09PSAnMCc7XG4gIH07XG4gIFNEUFV0aWxzLnBhcnNlTUxpbmUgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gICAgY29uc3QgcGFydHMgPSBsaW5lc1swXS5zdWJzdHJpbmcoMikuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogcGFydHNbMF0sXG4gICAgICBwb3J0OiBwYXJzZUludChwYXJ0c1sxXSwgMTApLFxuICAgICAgcHJvdG9jb2w6IHBhcnRzWzJdLFxuICAgICAgZm10OiBwYXJ0cy5zbGljZSgzKS5qb2luKCcgJylcbiAgICB9O1xuICB9O1xuICBTRFBVdGlscy5wYXJzZU9MaW5lID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgIGNvbnN0IGxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdvPScpWzBdO1xuICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMikuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge1xuICAgICAgdXNlcm5hbWU6IHBhcnRzWzBdLFxuICAgICAgc2Vzc2lvbklkOiBwYXJ0c1sxXSxcbiAgICAgIHNlc3Npb25WZXJzaW9uOiBwYXJzZUludChwYXJ0c1syXSwgMTApLFxuICAgICAgbmV0VHlwZTogcGFydHNbM10sXG4gICAgICBhZGRyZXNzVHlwZTogcGFydHNbNF0sXG4gICAgICBhZGRyZXNzOiBwYXJ0c1s1XVxuICAgIH07XG4gIH07XG5cbiAgLy8gYSB2ZXJ5IG5haXZlIGludGVycHJldGF0aW9uIG9mIGEgdmFsaWQgU0RQLlxuICBTRFBVdGlscy5pc1ZhbGlkU0RQID0gZnVuY3Rpb24gKGJsb2IpIHtcbiAgICBpZiAodHlwZW9mIGJsb2IgIT09ICdzdHJpbmcnIHx8IGJsb2IubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhibG9iKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGluZXNbaV0ubGVuZ3RoIDwgMiB8fCBsaW5lc1tpXS5jaGFyQXQoMSkgIT09ICc9Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBjaGVjayB0aGUgbW9kaWZpZXIgYSBiaXQgbW9yZS5cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzLlxuICB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTRFBVdGlscztcbiAgfVxufSkoc2RwJDEpO1xudmFyIHNkcEV4cG9ydHMgPSBzZHAkMS5leHBvcnRzO1xudmFyIFNEUFV0aWxzID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHNkcEV4cG9ydHMpO1xuXG52YXIgc2RwID0gLyojX19QVVJFX18qL19tZXJnZU5hbWVzcGFjZXMoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGRlZmF1bHQ6IFNEUFV0aWxzXG59LCBbc2RwRXhwb3J0c10pO1xuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNyBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuZnVuY3Rpb24gc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpIHtcbiAgLy8gZm91bmRhdGlvbiBpcyBhcmJpdHJhcmlseSBjaG9zZW4gYXMgYW4gaW5kaWNhdG9yIGZvciBmdWxsIHN1cHBvcnQgZm9yXG4gIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJydGMtcGMvI3J0Y2ljZWNhbmRpZGF0ZS1pbnRlcmZhY2VcbiAgaWYgKCF3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIHx8IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgJiYgJ2ZvdW5kYXRpb24nIGluIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZSA9IHdpbmRvdy5SVENJY2VDYW5kaWRhdGU7XG4gIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbiBSVENJY2VDYW5kaWRhdGUoYXJncykge1xuICAgIC8vIFJlbW92ZSB0aGUgYT0gd2hpY2ggc2hvdWxkbid0IGJlIHBhcnQgb2YgdGhlIGNhbmRpZGF0ZSBzdHJpbmcuXG4gICAgaWYgKHR5cGVvZiBhcmdzID09PSAnb2JqZWN0JyAmJiBhcmdzLmNhbmRpZGF0ZSAmJiBhcmdzLmNhbmRpZGF0ZS5pbmRleE9mKCdhPScpID09PSAwKSB7XG4gICAgICBhcmdzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhcmdzKSk7XG4gICAgICBhcmdzLmNhbmRpZGF0ZSA9IGFyZ3MuY2FuZGlkYXRlLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MuY2FuZGlkYXRlICYmIGFyZ3MuY2FuZGlkYXRlLmxlbmd0aCkge1xuICAgICAgLy8gQXVnbWVudCB0aGUgbmF0aXZlIGNhbmRpZGF0ZSB3aXRoIHRoZSBwYXJzZWQgZmllbGRzLlxuICAgICAgY29uc3QgbmF0aXZlQ2FuZGlkYXRlID0gbmV3IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZShhcmdzKTtcbiAgICAgIGNvbnN0IHBhcnNlZENhbmRpZGF0ZSA9IFNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlKGFyZ3MuY2FuZGlkYXRlKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcnNlZENhbmRpZGF0ZSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gbmF0aXZlQ2FuZGlkYXRlKSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYXRpdmVDYW5kaWRhdGUsIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHBhcnNlZENhbmRpZGF0ZVtrZXldXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3ZlcnJpZGUgc2VyaWFsaXplciB0byBub3Qgc2VyaWFsaXplIHRoZSBleHRyYSBhdHRyaWJ1dGVzLlxuICAgICAgbmF0aXZlQ2FuZGlkYXRlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW5kaWRhdGU6IG5hdGl2ZUNhbmRpZGF0ZS5jYW5kaWRhdGUsXG4gICAgICAgICAgc2RwTWlkOiBuYXRpdmVDYW5kaWRhdGUuc2RwTWlkLFxuICAgICAgICAgIHNkcE1MaW5lSW5kZXg6IG5hdGl2ZUNhbmRpZGF0ZS5zZHBNTGluZUluZGV4LFxuICAgICAgICAgIHVzZXJuYW1lRnJhZ21lbnQ6IG5hdGl2ZUNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG5hdGl2ZUNhbmRpZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOYXRpdmVSVENJY2VDYW5kaWRhdGUoYXJncyk7XG4gIH07XG4gIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUucHJvdG90eXBlID0gTmF0aXZlUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZTtcblxuICAvLyBIb29rIHVwIHRoZSBhdWdtZW50ZWQgY2FuZGlkYXRlIGluIG9uaWNlY2FuZGlkYXRlIGFuZFxuICAvLyBhZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCAuLi4pXG4gIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2ljZWNhbmRpZGF0ZScsIGUgPT4ge1xuICAgIGlmIChlLmNhbmRpZGF0ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICdjYW5kaWRhdGUnLCB7XG4gICAgICAgIHZhbHVlOiBuZXcgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZShlLmNhbmRpZGF0ZSksXG4gICAgICAgIHdyaXRhYmxlOiAnZmFsc2UnXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wod2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fCB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlICYmICdyZWxheVByb3RvY29sJyBpbiB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEhvb2sgdXAgdGhlIGF1Z21lbnRlZCBjYW5kaWRhdGUgaW4gb25pY2VjYW5kaWRhdGUgYW5kXG4gIC8vIGFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIC4uLilcbiAgd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnaWNlY2FuZGlkYXRlJywgZSA9PiB7XG4gICAgaWYgKGUuY2FuZGlkYXRlKSB7XG4gICAgICBjb25zdCBwYXJzZWRDYW5kaWRhdGUgPSBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShlLmNhbmRpZGF0ZS5jYW5kaWRhdGUpO1xuICAgICAgaWYgKHBhcnNlZENhbmRpZGF0ZS50eXBlID09PSAncmVsYXknKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBsaWJ3ZWJydGMtc3BlY2lmaWMgbWFwcGluZyBvZiBsb2NhbCB0eXBlIHByZWZlcmVuY2VcbiAgICAgICAgLy8gdG8gcmVsYXlQcm90b2NvbC5cbiAgICAgICAgZS5jYW5kaWRhdGUucmVsYXlQcm90b2NvbCA9IHtcbiAgICAgICAgICAwOiAndGxzJyxcbiAgICAgICAgICAxOiAndGNwJyxcbiAgICAgICAgICAyOiAndWRwJ1xuICAgICAgICB9W3BhcnNlZENhbmRpZGF0ZS5wcmlvcml0eSA+PiAyNF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKCdzY3RwJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnc2N0cCcsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9zY3RwID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB0aGlzLl9zY3RwO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHNjdHBJbkRlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKCFkZXNjcmlwdGlvbiB8fCAhZGVzY3JpcHRpb24uc2RwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhkZXNjcmlwdGlvbi5zZHApO1xuICAgIHNlY3Rpb25zLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHNlY3Rpb25zLnNvbWUobWVkaWFTZWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IG1MaW5lID0gU0RQVXRpbHMucGFyc2VNTGluZShtZWRpYVNlY3Rpb24pO1xuICAgICAgcmV0dXJuIG1MaW5lICYmIG1MaW5lLmtpbmQgPT09ICdhcHBsaWNhdGlvbicgJiYgbUxpbmUucHJvdG9jb2wuaW5kZXhPZignU0NUUCcpICE9PSAtMTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZ2V0UmVtb3RlRmlyZWZveFZlcnNpb24gPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICAvLyBUT0RPOiBJcyB0aGVyZSBhIGJldHRlciBzb2x1dGlvbiBmb3IgZGV0ZWN0aW5nIEZpcmVmb3g/XG4gICAgY29uc3QgbWF0Y2ggPSBkZXNjcmlwdGlvbi5zZHAubWF0Y2goL21vemlsbGEuLi5USElTX0lTX1NEUEFSVEEtKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsIHx8IG1hdGNoLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgY29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgLy8gVGVzdCBmb3IgTmFOICh5ZXMsIHRoaXMgaXMgdWdseSlcbiAgICByZXR1cm4gdmVyc2lvbiAhPT0gdmVyc2lvbiA/IC0xIDogdmVyc2lvbjtcbiAgfTtcbiAgY29uc3QgZ2V0Q2FuU2VuZE1heE1lc3NhZ2VTaXplID0gZnVuY3Rpb24gKHJlbW90ZUlzRmlyZWZveCkge1xuICAgIC8vIEV2ZXJ5IGltcGxlbWVudGF0aW9uIHdlIGtub3cgY2FuIHNlbmQgYXQgbGVhc3QgNjQgS2lCLlxuICAgIC8vIE5vdGU6IEFsdGhvdWdoIENocm9tZSBpcyB0ZWNobmljYWxseSBhYmxlIHRvIHNlbmQgdXAgdG8gMjU2IEtpQiwgdGhlXG4gICAgLy8gICAgICAgZGF0YSBkb2VzIG5vdCByZWFjaCB0aGUgb3RoZXIgcGVlciByZWxpYWJseS5cbiAgICAvLyAgICAgICBTZWU6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD04NDE5XG4gICAgbGV0IGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDY1NTM2O1xuICAgIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCcpIHtcbiAgICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTcpIHtcbiAgICAgICAgaWYgKHJlbW90ZUlzRmlyZWZveCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBGRiA8IDU3IHdpbGwgc2VuZCBpbiAxNiBLaUIgY2h1bmtzIHVzaW5nIHRoZSBkZXByZWNhdGVkIFBQSURcbiAgICAgICAgICAvLyBmcmFnbWVudGF0aW9uLlxuICAgICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDE2Mzg0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEhvd2V2ZXIsIG90aGVyIEZGIChhbmQgUkFXUlRDKSBjYW4gcmVhc3NlbWJsZSBQUElELWZyYWdtZW50ZWRcbiAgICAgICAgICAvLyBtZXNzYWdlcy4gVGh1cywgc3VwcG9ydGluZyB+MiBHaUIgd2hlbiBzZW5kaW5nLlxuICAgICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDYwKSB7XG4gICAgICAgIC8vIEN1cnJlbnRseSwgYWxsIEZGID49IDU3IHdpbGwgcmVzZXQgdGhlIHJlbW90ZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZVxuICAgICAgICAvLyB0byB0aGUgZGVmYXVsdCB2YWx1ZSB3aGVuIGEgZGF0YSBjaGFubmVsIGlzIGNyZWF0ZWQgYXQgYSBsYXRlclxuICAgICAgICAvLyBzdGFnZS4gOihcbiAgICAgICAgLy8gU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI2ODMxXG4gICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPT09IDU3ID8gNjU1MzUgOiA2NTUzNjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZGID49IDYwIHN1cHBvcnRzIHNlbmRpbmcgfjIgR2lCXG4gICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYW5TZW5kTWF4TWVzc2FnZVNpemU7XG4gIH07XG4gIGNvbnN0IGdldE1heE1lc3NhZ2VTaXplID0gZnVuY3Rpb24gKGRlc2NyaXB0aW9uLCByZW1vdGVJc0ZpcmVmb3gpIHtcbiAgICAvLyBOb3RlOiA2NTUzNiBieXRlcyBpcyB0aGUgZGVmYXVsdCB2YWx1ZSBmcm9tIHRoZSBTRFAgc3BlYy4gQWxzbyxcbiAgICAvLyAgICAgICBldmVyeSBpbXBsZW1lbnRhdGlvbiB3ZSBrbm93IHN1cHBvcnRzIHJlY2VpdmluZyA2NTUzNiBieXRlcy5cbiAgICBsZXQgbWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcblxuICAgIC8vIEZGIDU3IGhhcyBhIHNsaWdodGx5IGluY29ycmVjdCBkZWZhdWx0IHJlbW90ZSBtYXggbWVzc2FnZSBzaXplLCBzb1xuICAgIC8vIHdlIG5lZWQgdG8gYWRqdXN0IGl0IGhlcmUgdG8gYXZvaWQgYSBmYWlsdXJlIHdoZW4gc2VuZGluZy5cbiAgICAvLyBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MjU2OTdcbiAgICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPT09IDU3KSB7XG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IDY1NTM1O1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KGRlc2NyaXB0aW9uLnNkcCwgJ2E9bWF4LW1lc3NhZ2Utc2l6ZTonKTtcbiAgICBpZiAobWF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgbWF4TWVzc2FnZVNpemUgPSBwYXJzZUludChtYXRjaFswXS5zdWJzdHJpbmcoMTkpLCAxMCk7XG4gICAgfSBlbHNlIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCcgJiYgcmVtb3RlSXNGaXJlZm94ICE9PSAtMSkge1xuICAgICAgLy8gSWYgdGhlIG1heGltdW0gbWVzc2FnZSBzaXplIGlzIG5vdCBwcmVzZW50IGluIHRoZSByZW1vdGUgU0RQIGFuZFxuICAgICAgLy8gYm90aCBsb2NhbCBhbmQgcmVtb3RlIGFyZSBGaXJlZm94LCB0aGUgcmVtb3RlIHBlZXIgY2FuIHJlY2VpdmVcbiAgICAgIC8vIH4yIEdpQi5cbiAgICAgIG1heE1lc3NhZ2VTaXplID0gMjE0NzQ4MzYzNztcbiAgICB9XG4gICAgcmV0dXJuIG1heE1lc3NhZ2VTaXplO1xuICB9O1xuICBjb25zdCBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgdGhpcy5fc2N0cCA9IG51bGw7XG4gICAgLy8gQ2hyb21lIGRlY2lkZWQgdG8gbm90IGV4cG9zZSAuc2N0cCBpbiBwbGFuLWIgbW9kZS5cbiAgICAvLyBBcyB1c3VhbCwgYWRhcHRlci5qcyBoYXMgdG8gZG8gYW4gJ3VnbHkgd29yYWthcm91bmQnXG4gICAgLy8gdG8gY292ZXIgdXAgdGhlIG1lc3MuXG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdjaHJvbWUnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNzYpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2RwU2VtYW50aWNzXG4gICAgICB9ID0gdGhpcy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICBpZiAoc2RwU2VtYW50aWNzID09PSAncGxhbi1iJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NjdHAnLCB7XG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9zY3RwID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB0aGlzLl9zY3RwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzY3RwSW5EZXNjcmlwdGlvbihhcmd1bWVudHNbMF0pKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgcmVtb3RlIGlzIEZGLlxuICAgICAgY29uc3QgaXNGaXJlZm94ID0gZ2V0UmVtb3RlRmlyZWZveFZlcnNpb24oYXJndW1lbnRzWzBdKTtcblxuICAgICAgLy8gR2V0IHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSB0aGUgbG9jYWwgcGVlciBpcyBjYXBhYmxlIG9mIHNlbmRpbmdcbiAgICAgIGNvbnN0IGNhblNlbmRNTVMgPSBnZXRDYW5TZW5kTWF4TWVzc2FnZVNpemUoaXNGaXJlZm94KTtcblxuICAgICAgLy8gR2V0IHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSBvZiB0aGUgcmVtb3RlIHBlZXIuXG4gICAgICBjb25zdCByZW1vdGVNTVMgPSBnZXRNYXhNZXNzYWdlU2l6ZShhcmd1bWVudHNbMF0sIGlzRmlyZWZveCk7XG5cbiAgICAgIC8vIERldGVybWluZSBmaW5hbCBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZVxuICAgICAgbGV0IG1heE1lc3NhZ2VTaXplO1xuICAgICAgaWYgKGNhblNlbmRNTVMgPT09IDAgJiYgcmVtb3RlTU1TID09PSAwKSB7XG4gICAgICAgIG1heE1lc3NhZ2VTaXplID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgfSBlbHNlIGlmIChjYW5TZW5kTU1TID09PSAwIHx8IHJlbW90ZU1NUyA9PT0gMCkge1xuICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IE1hdGgubWF4KGNhblNlbmRNTVMsIHJlbW90ZU1NUyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IE1hdGgubWluKGNhblNlbmRNTVMsIHJlbW90ZU1NUyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGR1bW15IFJUQ1NjdHBUcmFuc3BvcnQgb2JqZWN0IGFuZCB0aGUgJ21heE1lc3NhZ2VTaXplJ1xuICAgICAgLy8gYXR0cmlidXRlLlxuICAgICAgY29uc3Qgc2N0cCA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNjdHAsICdtYXhNZXNzYWdlU2l6ZScsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBtYXhNZXNzYWdlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9zY3RwID0gc2N0cDtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpIHtcbiAgaWYgKCEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICdjcmVhdGVEYXRhQ2hhbm5lbCcgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBOb3RlOiBBbHRob3VnaCBGaXJlZm94ID49IDU3IGhhcyBhIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgdGhlIG1heGltdW1cbiAgLy8gICAgICAgbWVzc2FnZSBzaXplIGNhbiBiZSByZXNldCBmb3IgYWxsIGRhdGEgY2hhbm5lbHMgYXQgYSBsYXRlciBzdGFnZS5cbiAgLy8gICAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI2ODMxXG5cbiAgZnVuY3Rpb24gd3JhcERjU2VuZChkYywgcGMpIHtcbiAgICBjb25zdCBvcmlnRGF0YUNoYW5uZWxTZW5kID0gZGMuc2VuZDtcbiAgICBkYy5zZW5kID0gZnVuY3Rpb24gc2VuZCgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhcmd1bWVudHNbMF07XG4gICAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aCB8fCBkYXRhLnNpemUgfHwgZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgaWYgKGRjLnJlYWR5U3RhdGUgPT09ICdvcGVuJyAmJiBwYy5zY3RwICYmIGxlbmd0aCA+IHBjLnNjdHAubWF4TWVzc2FnZVNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWVzc2FnZSB0b28gbGFyZ2UgKGNhbiBzZW5kIGEgbWF4aW11bSBvZiAnICsgcGMuc2N0cC5tYXhNZXNzYWdlU2l6ZSArICcgYnl0ZXMpJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ0RhdGFDaGFubmVsU2VuZC5hcHBseShkYywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIGNvbnN0IG9yaWdDcmVhdGVEYXRhQ2hhbm5lbCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlRGF0YUNoYW5uZWw7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlRGF0YUNoYW5uZWwgPSBmdW5jdGlvbiBjcmVhdGVEYXRhQ2hhbm5lbCgpIHtcbiAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IG9yaWdDcmVhdGVEYXRhQ2hhbm5lbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHdyYXBEY1NlbmQoZGF0YUNoYW5uZWwsIHRoaXMpO1xuICAgIHJldHVybiBkYXRhQ2hhbm5lbDtcbiAgfTtcbiAgd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnZGF0YWNoYW5uZWwnLCBlID0+IHtcbiAgICB3cmFwRGNTZW5kKGUuY2hhbm5lbCwgZS50YXJnZXQpO1xuICAgIHJldHVybiBlO1xuICB9KTtcbn1cblxuLyogc2hpbXMgUlRDQ29ubmVjdGlvblN0YXRlIGJ5IHByZXRlbmRpbmcgaXQgaXMgdGhlIHNhbWUgYXMgaWNlQ29ubmVjdGlvblN0YXRlLlxuICogU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD02MTQ1I2MxMlxuICogZm9yIHdoeSB0aGlzIGlzIGEgdmFsaWQgaGFjayBpbiBDaHJvbWUuIEluIEZpcmVmb3ggaXQgaXMgc2xpZ2h0bHkgaW5jb3JyZWN0XG4gKiBzaW5jZSBEVExTIGZhaWx1cmVzIHdvdWxkIGJlIGhpZGRlbi4gU2VlXG4gKiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjY1ODI3XG4gKiBmb3IgdGhlIEZpcmVmb3ggdHJhY2tpbmcgYnVnLlxuICovXG5mdW5jdGlvbiBzaGltQ29ubmVjdGlvblN0YXRlKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fCAnY29ubmVjdGlvblN0YXRlJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3RvID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnY29ubmVjdGlvblN0YXRlJywge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBsZXRlZDogJ2Nvbm5lY3RlZCcsXG4gICAgICAgIGNoZWNraW5nOiAnY29ubmVjdGluZydcbiAgICAgIH1bdGhpcy5pY2VDb25uZWN0aW9uU3RhdGVdIHx8IHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ29uY29ubmVjdGlvbnN0YXRlY2hhbmdlJywge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSB8fCBudWxsO1xuICAgIH0sXG4gICAgc2V0KGNiKSB7XG4gICAgICBpZiAodGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gY2IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbiddLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICBjb25zdCBvcmlnTWV0aG9kID0gcHJvdG9bbWV0aG9kXTtcbiAgICBwcm90b1ttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5KSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZXBvbHkgPSBlID0+IHtcbiAgICAgICAgICBjb25zdCBwYyA9IGUudGFyZ2V0O1xuICAgICAgICAgIGlmIChwYy5fbGFzdENvbm5lY3Rpb25TdGF0ZSAhPT0gcGMuY29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICBwYy5fbGFzdENvbm5lY3Rpb25TdGF0ZSA9IHBjLmNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0V2ZW50ID0gbmV3IEV2ZW50KCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBlKTtcbiAgICAgICAgICAgIHBjLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZW1vdmVFeHRtYXBBbGxvd01peGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgLyogcmVtb3ZlIGE9ZXh0bWFwLWFsbG93LW1peGVkIGZvciB3ZWJydGMub3JnIDwgTTcxICovXG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDcxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnc2FmYXJpJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDYwNSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuYXRpdmVTUkQgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oZGVzYykge1xuICAgIGlmIChkZXNjICYmIGRlc2Muc2RwICYmIGRlc2Muc2RwLmluZGV4T2YoJ1xcbmE9ZXh0bWFwLWFsbG93LW1peGVkJykgIT09IC0xKSB7XG4gICAgICBjb25zdCBzZHAgPSBkZXNjLnNkcC5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4ge1xuICAgICAgICByZXR1cm4gbGluZS50cmltKCkgIT09ICdhPWV4dG1hcC1hbGxvdy1taXhlZCc7XG4gICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgIC8vIFNhZmFyaSBlbmZvcmNlcyByZWFkLW9ubHktbmVzcyBvZiBSVENTZXNzaW9uRGVzY3JpcHRpb24gZmllbGRzLlxuICAgICAgaWYgKHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24gJiYgZGVzYyBpbnN0YW5jZW9mIHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24pIHtcbiAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICAgIHR5cGU6IGRlc2MudHlwZSxcbiAgICAgICAgICBzZHBcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXNjLnNkcCA9IHNkcDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZVNSRC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5KHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgLy8gU3VwcG9ydCBmb3IgYWRkSWNlQ2FuZGlkYXRlKG51bGwgb3IgdW5kZWZpbmVkKVxuICAvLyBhcyB3ZWxsIGFzIGFkZEljZUNhbmRpZGF0ZSh7Y2FuZGlkYXRlOiBcIlwiLCAuLi59KVxuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05Nzg1ODJcbiAgLy8gTm90ZTogbXVzdCBiZSBjYWxsZWQgYmVmb3JlIG90aGVyIHBvbHlmaWxscyB3aGljaCBjaGFuZ2UgdGhlIHNpZ25hdHVyZS5cbiAgaWYgKCEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG5hdGl2ZUFkZEljZUNhbmRpZGF0ZSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlO1xuICBpZiAoIW5hdGl2ZUFkZEljZUNhbmRpZGF0ZSB8fCBuYXRpdmVBZGRJY2VDYW5kaWRhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gYWRkSWNlQ2FuZGlkYXRlKCkge1xuICAgIGlmICghYXJndW1lbnRzWzBdKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzFdKSB7XG4gICAgICAgIGFyZ3VtZW50c1sxXS5hcHBseShudWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLy8gRmlyZWZveCA2OCsgZW1pdHMgYW5kIHByb2Nlc3NlcyB7Y2FuZGlkYXRlOiBcIlwiLCAuLi59LCBpZ25vcmVcbiAgICAvLyBpbiBvbGRlciB2ZXJzaW9ucy5cbiAgICAvLyBOYXRpdmUgc3VwcG9ydCBmb3IgaWdub3JpbmcgZXhpc3RzIGZvciBDaHJvbWUgTTc3Ky5cbiAgICAvLyBTYWZhcmkgaWdub3JlcyBhcyB3ZWxsLCBleGFjdCB2ZXJzaW9uIHVua25vd24gYnV0IHdvcmtzIGluIHRoZSBzYW1lXG4gICAgLy8gdmVyc2lvbiB0aGF0IGFsc28gaWdub3JlcyBhZGRJY2VDYW5kaWRhdGUobnVsbCkuXG4gICAgaWYgKChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNzggfHwgYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2OCB8fCBicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnc2FmYXJpJykgJiYgYXJndW1lbnRzWzBdICYmIGFyZ3VtZW50c1swXS5jYW5kaWRhdGUgPT09ICcnKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVBZGRJY2VDYW5kaWRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLy8gTm90ZTogTWFrZSBzdXJlIHRvIGNhbGwgdGhpcyBhaGVhZCBvZiBBUElzIHRoYXQgbW9kaWZ5XG4vLyBzZXRMb2NhbERlc2NyaXB0aW9uLmxlbmd0aFxuZnVuY3Rpb24gc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKCEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb247XG4gIGlmICghbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbiB8fCBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRMb2NhbERlc2NyaXB0aW9uKCkge1xuICAgIGxldCBkZXNjID0gYXJndW1lbnRzWzBdIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgZGVzYyAhPT0gJ29iamVjdCcgfHwgZGVzYy50eXBlICYmIGRlc2Muc2RwKSB7XG4gICAgICByZXR1cm4gbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvLyBUaGUgcmVtYWluaW5nIHN0ZXBzIHNob3VsZCB0ZWNobmljYWxseSBoYXBwZW4gd2hlbiBTTEQgY29tZXMgb2ZmIHRoZVxuICAgIC8vIFJUQ1BlZXJDb25uZWN0aW9uJ3Mgb3BlcmF0aW9ucyBjaGFpbiAobm90IGFoZWFkIG9mIGdvaW5nIG9uIGl0KSwgYnV0XG4gICAgLy8gdGhpcyBpcyB0b28gZGlmZmljdWx0IHRvIHNoaW0uIEluc3RlYWQsIHRoaXMgc2hpbSBvbmx5IGNvdmVycyB0aGVcbiAgICAvLyBjb21tb24gY2FzZSB3aGVyZSB0aGUgb3BlcmF0aW9ucyBjaGFpbiBpcyBlbXB0eS4gVGhpcyBpcyBpbXBlcmZlY3QsIGJ1dFxuICAgIC8vIHNob3VsZCBjb3ZlciBtYW55IGNhc2VzLiBSYXRpb25hbGU6IEV2ZW4gaWYgd2UgY2FuJ3QgcmVkdWNlIHRoZSBnbGFyZVxuICAgIC8vIHdpbmRvdyB0byB6ZXJvIG9uIGltcGVyZmVjdCBpbXBsZW1lbnRhdGlvbnMsIHRoZXJlJ3MgdmFsdWUgaW4gdGFwcGluZ1xuICAgIC8vIGludG8gdGhlIHBlcmZlY3QgbmVnb3RpYXRpb24gcGF0dGVybiB0aGF0IHNldmVyYWwgYnJvd3NlcnMgc3VwcG9ydC5cbiAgICBkZXNjID0ge1xuICAgICAgdHlwZTogZGVzYy50eXBlLFxuICAgICAgc2RwOiBkZXNjLnNkcFxuICAgIH07XG4gICAgaWYgKCFkZXNjLnR5cGUpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zaWduYWxpbmdTdGF0ZSkge1xuICAgICAgICBjYXNlICdzdGFibGUnOlxuICAgICAgICBjYXNlICdoYXZlLWxvY2FsLW9mZmVyJzpcbiAgICAgICAgY2FzZSAnaGF2ZS1yZW1vdGUtcHJhbnN3ZXInOlxuICAgICAgICAgIGRlc2MudHlwZSA9ICdvZmZlcic7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZGVzYy50eXBlID0gJ2Fuc3dlcic7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZXNjLnNkcCB8fCBkZXNjLnR5cGUgIT09ICdvZmZlcicgJiYgZGVzYy50eXBlICE9PSAnYW5zd2VyJykge1xuICAgICAgcmV0dXJuIG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NdKTtcbiAgICB9XG4gICAgY29uc3QgZnVuYyA9IGRlc2MudHlwZSA9PT0gJ29mZmVyJyA/IHRoaXMuY3JlYXRlT2ZmZXIgOiB0aGlzLmNyZWF0ZUFuc3dlcjtcbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzKS50aGVuKGQgPT4gbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBbZF0pKTtcbiAgfTtcbn1cblxudmFyIGNvbW1vblNoaW0gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0cmVtb3ZlRXh0bWFwQWxsb3dNaXhlZDogcmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCxcblx0c2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5OiBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHksXG5cdHNoaW1Db25uZWN0aW9uU3RhdGU6IHNoaW1Db25uZWN0aW9uU3RhdGUsXG5cdHNoaW1NYXhNZXNzYWdlU2l6ZTogc2hpbU1heE1lc3NhZ2VTaXplLFxuXHRzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb246IHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbixcblx0c2hpbVJUQ0ljZUNhbmRpZGF0ZTogc2hpbVJUQ0ljZUNhbmRpZGF0ZSxcblx0c2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2w6IHNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sLFxuXHRzaGltU2VuZFRocm93VHlwZUVycm9yOiBzaGltU2VuZFRocm93VHlwZUVycm9yXG59KTtcblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG5cbi8vIFNoaW1taW5nIHN0YXJ0cyBoZXJlLlxuZnVuY3Rpb24gYWRhcHRlckZhY3RvcnkoKSB7XG4gIGxldCB7XG4gICAgd2luZG93XG4gIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgIHNoaW1DaHJvbWU6IHRydWUsXG4gICAgc2hpbUZpcmVmb3g6IHRydWUsXG4gICAgc2hpbVNhZmFyaTogdHJ1ZVxuICB9O1xuICAvLyBVdGlscy5cbiAgY29uc3QgbG9nZ2luZyA9IGxvZztcbiAgY29uc3QgYnJvd3NlckRldGFpbHMgPSBkZXRlY3RCcm93c2VyKHdpbmRvdyk7XG4gIGNvbnN0IGFkYXB0ZXIgPSB7XG4gICAgYnJvd3NlckRldGFpbHMsXG4gICAgY29tbW9uU2hpbSxcbiAgICBleHRyYWN0VmVyc2lvbjogZXh0cmFjdFZlcnNpb24sXG4gICAgZGlzYWJsZUxvZzogZGlzYWJsZUxvZyxcbiAgICBkaXNhYmxlV2FybmluZ3M6IGRpc2FibGVXYXJuaW5ncyxcbiAgICAvLyBFeHBvc2Ugc2RwIGFzIGEgY29udmVuaWVuY2UuIEZvciBwcm9kdWN0aW9uIGFwcHMgaW5jbHVkZSBkaXJlY3RseS5cbiAgICBzZHBcbiAgfTtcblxuICAvLyBTaGltIGJyb3dzZXIgaWYgZm91bmQuXG4gIHN3aXRjaCAoYnJvd3NlckRldGFpbHMuYnJvd3Nlcikge1xuICAgIGNhc2UgJ2Nocm9tZSc6XG4gICAgICBpZiAoIWNocm9tZVNoaW0gfHwgIXNoaW1QZWVyQ29ubmVjdGlvbiQxIHx8ICFvcHRpb25zLnNoaW1DaHJvbWUpIHtcbiAgICAgICAgbG9nZ2luZygnQ2hyb21lIHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSBudWxsKSB7XG4gICAgICAgIGxvZ2dpbmcoJ0Nocm9tZSBzaGltIGNhbiBub3QgZGV0ZXJtaW5lIHZlcnNpb24sIG5vdCBzaGltbWluZy4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIGNocm9tZS4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gY2hyb21lU2hpbTtcblxuICAgICAgLy8gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIHNoaW1QZWVyQ29ubmVjdGlvbi5cbiAgICAgIHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3cpO1xuICAgICAgc2hpbUdldFVzZXJNZWRpYSQyKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbU1lZGlhU3RyZWFtKHdpbmRvdyk7XG4gICAgICBzaGltUGVlckNvbm5lY3Rpb24kMSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1PblRyYWNrJDEod2luZG93KTtcbiAgICAgIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbUdldFNlbmRlcnNXaXRoRHRtZih3aW5kb3cpO1xuICAgICAgc2hpbUdldFN0YXRzKHdpbmRvdyk7XG4gICAgICBzaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0cyh3aW5kb3cpO1xuICAgICAgZml4TmVnb3RpYXRpb25OZWVkZWQod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdyk7XG4gICAgICBzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCh3aW5kb3cpO1xuICAgICAgc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3cpO1xuICAgICAgc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpO1xuICAgICAgcmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ZpcmVmb3gnOlxuICAgICAgaWYgKCFmaXJlZm94U2hpbSB8fCAhc2hpbVBlZXJDb25uZWN0aW9uIHx8ICFvcHRpb25zLnNoaW1GaXJlZm94KSB7XG4gICAgICAgIGxvZ2dpbmcoJ0ZpcmVmb3ggc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBmaXJlZm94LicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIGFkYXB0ZXIuYnJvd3NlclNoaW0gPSBmaXJlZm94U2hpbTtcblxuICAgICAgLy8gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIHNoaW1QZWVyQ29ubmVjdGlvbi5cbiAgICAgIHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3cpO1xuICAgICAgc2hpbUdldFVzZXJNZWRpYSQxKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVBlZXJDb25uZWN0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbU9uVHJhY2sod2luZG93KTtcbiAgICAgIHNoaW1SZW1vdmVTdHJlYW0od2luZG93KTtcbiAgICAgIHNoaW1TZW5kZXJHZXRTdGF0cyh3aW5kb3cpO1xuICAgICAgc2hpbVJlY2VpdmVyR2V0U3RhdHMod2luZG93KTtcbiAgICAgIHNoaW1SVENEYXRhQ2hhbm5lbCh3aW5kb3cpO1xuICAgICAgc2hpbUFkZFRyYW5zY2VpdmVyKHdpbmRvdyk7XG4gICAgICBzaGltR2V0UGFyYW1ldGVycyh3aW5kb3cpO1xuICAgICAgc2hpbUNyZWF0ZU9mZmVyKHdpbmRvdyk7XG4gICAgICBzaGltQ3JlYXRlQW5zd2VyKHdpbmRvdyk7XG4gICAgICBzaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdyk7XG4gICAgICBzaGltQ29ubmVjdGlvblN0YXRlKHdpbmRvdyk7XG4gICAgICBzaGltTWF4TWVzc2FnZVNpemUod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzYWZhcmknOlxuICAgICAgaWYgKCFzYWZhcmlTaGltIHx8ICFvcHRpb25zLnNoaW1TYWZhcmkpIHtcbiAgICAgICAgbG9nZ2luZygnU2FmYXJpIHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgc2FmYXJpLicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIGFkYXB0ZXIuYnJvd3NlclNoaW0gPSBzYWZhcmlTaGltO1xuXG4gICAgICAvLyBNdXN0IGJlIGNhbGxlZCBiZWZvcmUgc2hpbUNhbGxiYWNrQVBJLlxuICAgICAgc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5KHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdyk7XG4gICAgICBzaGltUlRDSWNlU2VydmVyVXJscyh3aW5kb3cpO1xuICAgICAgc2hpbUNyZWF0ZU9mZmVyTGVnYWN5KHdpbmRvdyk7XG4gICAgICBzaGltQ2FsbGJhY2tzQVBJKHdpbmRvdyk7XG4gICAgICBzaGltTG9jYWxTdHJlYW1zQVBJKHdpbmRvdyk7XG4gICAgICBzaGltUmVtb3RlU3RyZWFtc0FQSSh3aW5kb3cpO1xuICAgICAgc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlcih3aW5kb3cpO1xuICAgICAgc2hpbUdldFVzZXJNZWRpYSh3aW5kb3cpO1xuICAgICAgc2hpbUF1ZGlvQ29udGV4dCh3aW5kb3cpO1xuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpO1xuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wod2luZG93KTtcbiAgICAgIHNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KTtcbiAgICAgIHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbG9nZ2luZygnVW5zdXBwb3J0ZWQgYnJvd3NlciEnKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuXG5hZGFwdGVyRmFjdG9yeSh7XG4gIHdpbmRvdzogdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiB3aW5kb3dcbn0pO1xuXG5jb25zdCBFTkNSWVBUSU9OX0FMR09SSVRITSA9ICdBRVMtR0NNJztcbi8vIEhvdyBtYW55IGNvbnNlY3V0aXZlIGZyYW1lcyBjYW4gZmFpbCBkZWNyeXB0aW5nIGJlZm9yZSBhIHBhcnRpY3VsYXIga2V5IGdldHMgbWFya2VkIGFzIGludmFsaWRcbmNvbnN0IERFQ1JZUFRJT05fRkFJTFVSRV9UT0xFUkFOQ0UgPSAxMDtcbi8vIGZsYWcgc2V0IHRvIGluZGljYXRlIHRoYXQgZTJlZSBoYXMgYmVlbiBzZXR1cCBmb3Igc2VuZGVyL3JlY2VpdmVyO1xuY29uc3QgRTJFRV9GTEFHID0gJ2xrX2UyZWUnO1xuY29uc3QgU0FMVCA9ICdMS0ZyYW1lRW5jcnlwdGlvbktleSc7XG5jb25zdCBLRVlfUFJPVklERVJfREVGQVVMVFMgPSB7XG4gIHNoYXJlZEtleTogZmFsc2UsXG4gIHJhdGNoZXRTYWx0OiBTQUxULFxuICByYXRjaGV0V2luZG93U2l6ZTogOCxcbiAgZmFpbHVyZVRvbGVyYW5jZTogREVDUllQVElPTl9GQUlMVVJFX1RPTEVSQU5DRVxufTtcblxudmFyIEtleVByb3ZpZGVyRXZlbnQ7XG4oZnVuY3Rpb24gKEtleVByb3ZpZGVyRXZlbnQpIHtcbiAgS2V5UHJvdmlkZXJFdmVudFtcIlNldEtleVwiXSA9IFwic2V0S2V5XCI7XG4gIEtleVByb3ZpZGVyRXZlbnRbXCJSYXRjaGV0UmVxdWVzdFwiXSA9IFwicmF0Y2hldFJlcXVlc3RcIjtcbiAgS2V5UHJvdmlkZXJFdmVudFtcIktleVJhdGNoZXRlZFwiXSA9IFwia2V5UmF0Y2hldGVkXCI7XG59KShLZXlQcm92aWRlckV2ZW50IHx8IChLZXlQcm92aWRlckV2ZW50ID0ge30pKTtcbnZhciBLZXlIYW5kbGVyRXZlbnQ7XG4oZnVuY3Rpb24gKEtleUhhbmRsZXJFdmVudCkge1xuICBLZXlIYW5kbGVyRXZlbnRbXCJLZXlSYXRjaGV0ZWRcIl0gPSBcImtleVJhdGNoZXRlZFwiO1xufSkoS2V5SGFuZGxlckV2ZW50IHx8IChLZXlIYW5kbGVyRXZlbnQgPSB7fSkpO1xudmFyIEVuY3J5cHRpb25FdmVudDtcbihmdW5jdGlvbiAoRW5jcnlwdGlvbkV2ZW50KSB7XG4gIEVuY3J5cHRpb25FdmVudFtcIlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWRcIjtcbiAgRW5jcnlwdGlvbkV2ZW50W1wiRW5jcnlwdGlvbkVycm9yXCJdID0gXCJlbmNyeXB0aW9uRXJyb3JcIjtcbn0pKEVuY3J5cHRpb25FdmVudCB8fCAoRW5jcnlwdGlvbkV2ZW50ID0ge30pKTtcbnZhciBDcnlwdG9yRXZlbnQ7XG4oZnVuY3Rpb24gKENyeXB0b3JFdmVudCkge1xuICBDcnlwdG9yRXZlbnRbXCJFcnJvclwiXSA9IFwiY3J5cHRvckVycm9yXCI7XG59KShDcnlwdG9yRXZlbnQgfHwgKENyeXB0b3JFdmVudCA9IHt9KSk7XG5cbmZ1bmN0aW9uIGlzRTJFRVN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIGlzSW5zZXJ0YWJsZVN0cmVhbVN1cHBvcnRlZCgpIHx8IGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkKCk7XG59XG5mdW5jdGlvbiBpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCgpIHtcbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gdHlwZW9mIHdpbmRvdy5SVENSdHBTY3JpcHRUcmFuc2Zvcm0gIT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gaXNJbnNlcnRhYmxlU3RyZWFtU3VwcG9ydGVkKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdy5SVENSdHBTZW5kZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIC8vIEB0cy1pZ25vcmVcbiAgdHlwZW9mIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmNyZWF0ZUVuY29kZWRTdHJlYW1zICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzVmlkZW9GcmFtZShmcmFtZSkge1xuICByZXR1cm4gJ3R5cGUnIGluIGZyYW1lO1xufVxuZnVuY3Rpb24gaW1wb3J0S2V5KGtleUJ5dGVzKSB7XG4gIGxldCBhbGdvcml0aG0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICBuYW1lOiBFTkNSWVBUSU9OX0FMR09SSVRITVxuICB9O1xuICBsZXQgdXNhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdlbmNyeXB0JztcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL2ltcG9ydEtleVxuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3Jywga2V5Qnl0ZXMsIGFsZ29yaXRobSwgZmFsc2UsIHVzYWdlID09PSAnZGVyaXZlJyA/IFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXSA6IFsnZW5jcnlwdCcsICdkZWNyeXB0J10pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleU1hdGVyaWFsRnJvbVN0cmluZyhwYXNzd29yZCkge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGxldCBlbmMgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBrZXlNYXRlcmlhbCA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBlbmMuZW5jb2RlKHBhc3N3b3JkKSwge1xuICAgICAgbmFtZTogJ1BCS0RGMidcbiAgICB9LCBmYWxzZSwgWydkZXJpdmVCaXRzJywgJ2Rlcml2ZUtleSddKTtcbiAgICByZXR1cm4ga2V5TWF0ZXJpYWw7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlS2V5TWF0ZXJpYWxGcm9tQnVmZmVyKGNyeXB0b0J1ZmZlcikge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGtleU1hdGVyaWFsID0geWllbGQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGNyeXB0b0J1ZmZlciwgJ0hLREYnLCBmYWxzZSwgWydkZXJpdmVCaXRzJywgJ2Rlcml2ZUtleSddKTtcbiAgICByZXR1cm4ga2V5TWF0ZXJpYWw7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0QWxnb09wdGlvbnMoYWxnb3JpdGhtTmFtZSwgc2FsdCkge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBjb25zdCBlbmNvZGVkU2FsdCA9IHRleHRFbmNvZGVyLmVuY29kZShzYWx0KTtcbiAgc3dpdGNoIChhbGdvcml0aG1OYW1lKSB7XG4gICAgY2FzZSAnSEtERic6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnSEtERicsXG4gICAgICAgIHNhbHQ6IGVuY29kZWRTYWx0LFxuICAgICAgICBoYXNoOiAnU0hBLTI1NicsXG4gICAgICAgIGluZm86IG5ldyBBcnJheUJ1ZmZlcigxMjgpXG4gICAgICB9O1xuICAgIGNhc2UgJ1BCS0RGMic6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogJ1BCS0RGMicsXG4gICAgICAgICAgc2FsdDogZW5jb2RlZFNhbHQsXG4gICAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxuICAgICAgICAgIGl0ZXJhdGlvbnM6IDEwMDAwMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbGdvcml0aG0gXCIuY29uY2F0KGFsZ29yaXRobU5hbWUsIFwiIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZFwiKSk7XG4gIH1cbn1cbi8qKlxuICogRGVyaXZlcyBhIHNldCBvZiBrZXlzIGZyb20gdGhlIG1hc3RlciBrZXkuXG4gKiBTZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LW9tYXJhLXNmcmFtZS0wMCNzZWN0aW9uLTQuMy4xXG4gKi9cbmZ1bmN0aW9uIGRlcml2ZUtleXMobWF0ZXJpYWwsIHNhbHQpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBhbGdvcml0aG1PcHRpb25zID0gZ2V0QWxnb09wdGlvbnMobWF0ZXJpYWwuYWxnb3JpdGhtLm5hbWUsIHNhbHQpO1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdWJ0bGVDcnlwdG8vZGVyaXZlS2V5I0hLREZcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGtkZlBhcmFtc1xuICAgIGNvbnN0IGVuY3J5cHRpb25LZXkgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmRlcml2ZUtleShhbGdvcml0aG1PcHRpb25zLCBtYXRlcmlhbCwge1xuICAgICAgbmFtZTogRU5DUllQVElPTl9BTEdPUklUSE0sXG4gICAgICBsZW5ndGg6IDEyOFxuICAgIH0sIGZhbHNlLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0ZXJpYWwsXG4gICAgICBlbmNyeXB0aW9uS2V5XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFMkVFS2V5KCkge1xuICByZXR1cm4gd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMzIpKTtcbn1cbi8qKlxuICogUmF0Y2hldHMgYSBrZXkuIFNlZVxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LW9tYXJhLXNmcmFtZS0wMCNzZWN0aW9uLTQuMy41LjFcbiAqL1xuZnVuY3Rpb24gcmF0Y2hldChtYXRlcmlhbCwgc2FsdCkge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGFsZ29yaXRobU9wdGlvbnMgPSBnZXRBbGdvT3B0aW9ucyhtYXRlcmlhbC5hbGdvcml0aG0ubmFtZSwgc2FsdCk7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9kZXJpdmVCaXRzXG4gICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZGVyaXZlQml0cyhhbGdvcml0aG1PcHRpb25zLCBtYXRlcmlhbCwgMjU2KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBuZWVkc1Jic3BVbmVzY2FwaW5nKGZyYW1lRGF0YSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lRGF0YS5sZW5ndGggLSAzOyBpKyspIHtcbiAgICBpZiAoZnJhbWVEYXRhW2ldID09IDAgJiYgZnJhbWVEYXRhW2kgKyAxXSA9PSAwICYmIGZyYW1lRGF0YVtpICsgMl0gPT0gMykgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcGFyc2VSYnNwKHN0cmVhbSkge1xuICBjb25zdCBkYXRhT3V0ID0gW107XG4gIHZhciBsZW5ndGggPSBzdHJlYW0ubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmVhbS5sZW5ndGg7KSB7XG4gICAgLy8gQmUgY2FyZWZ1bCBhYm91dCBvdmVyL3VuZGVyZmxvdyBoZXJlLiBieXRlX2xlbmd0aF8gLSAzIGNhbiB1bmRlcmZsb3csIGFuZFxuICAgIC8vIGkgKyAzIGNhbiBvdmVyZmxvdywgYnV0IGJ5dGVfbGVuZ3RoXyAtIGkgY2FuJ3QsIGJlY2F1c2UgaSA8IGJ5dGVfbGVuZ3RoX1xuICAgIC8vIGFib3ZlLCBhbmQgdGhhdCBleHByZXNzaW9uIHdpbGwgcHJvZHVjZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGxlZnQgaW5cbiAgICAvLyB0aGUgc3RyZWFtIGluY2x1ZGluZyB0aGUgYnl0ZSBhdCBpLlxuICAgIGlmIChsZW5ndGggLSBpID49IDMgJiYgIXN0cmVhbVtpXSAmJiAhc3RyZWFtW2kgKyAxXSAmJiBzdHJlYW1baSArIDJdID09IDMpIHtcbiAgICAgIC8vIFR3byByYnNwIGJ5dGVzLlxuICAgICAgZGF0YU91dC5wdXNoKHN0cmVhbVtpKytdKTtcbiAgICAgIGRhdGFPdXQucHVzaChzdHJlYW1baSsrXSk7XG4gICAgICAvLyBTa2lwIHRoZSBlbXVsYXRpb24gYnl0ZS5cbiAgICAgIGkrKztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2luZ2xlIHJic3AgYnl0ZS5cbiAgICAgIGRhdGFPdXQucHVzaChzdHJlYW1baSsrXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhT3V0KTtcbn1cbmNvbnN0IGtaZXJvc0luU3RhcnRTZXF1ZW5jZSA9IDI7XG5jb25zdCBrRW11bGF0aW9uQnl0ZSA9IDM7XG5mdW5jdGlvbiB3cml0ZVJic3AoZGF0YV9pbikge1xuICBjb25zdCBkYXRhT3V0ID0gW107XG4gIHZhciBudW1Db25zZWN1dGl2ZVplcm9zID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhX2luLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ5dGUgPSBkYXRhX2luW2ldO1xuICAgIGlmIChieXRlIDw9IGtFbXVsYXRpb25CeXRlICYmIG51bUNvbnNlY3V0aXZlWmVyb3MgPj0ga1plcm9zSW5TdGFydFNlcXVlbmNlKSB7XG4gICAgICAvLyBOZWVkIHRvIGVzY2FwZS5cbiAgICAgIGRhdGFPdXQucHVzaChrRW11bGF0aW9uQnl0ZSk7XG4gICAgICBudW1Db25zZWN1dGl2ZVplcm9zID0gMDtcbiAgICB9XG4gICAgZGF0YU91dC5wdXNoKGJ5dGUpO1xuICAgIGlmIChieXRlID09IDApIHtcbiAgICAgICsrbnVtQ29uc2VjdXRpdmVaZXJvcztcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtQ29uc2VjdXRpdmVaZXJvcyA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhT3V0KTtcbn1cblxuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmNsYXNzIEJhc2VLZXlQcm92aWRlciBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogY2FsbGJhY2sgYmVpbmcgaW52b2tlZCBhZnRlciBhIHJhdGNoZXQgcmVxdWVzdCBoYXMgYmVlbiBwZXJmb3JtZWQgb24gYSBwYXJ0aWNpcGFudFxuICAgICAqIHRoYXQgc3VyZmFjZXMgdGhlIG5ldyBrZXkgbWF0ZXJpYWwuXG4gICAgICogQHBhcmFtIG1hdGVyaWFsXG4gICAgICogQHBhcmFtIGtleUluZGV4XG4gICAgICovXG4gICAgdGhpcy5vbktleVJhdGNoZXRlZCA9IChtYXRlcmlhbCwga2V5SW5kZXgpID0+IHtcbiAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ2tleSByYXRjaGV0ZWQgZXZlbnQgcmVjZWl2ZWQnLCB7XG4gICAgICAgIG1hdGVyaWFsLFxuICAgICAgICBrZXlJbmRleFxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmtleUluZm9NYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBLRVlfUFJPVklERVJfREVGQVVMVFMpLCBvcHRpb25zKTtcbiAgICB0aGlzLm9uKEtleVByb3ZpZGVyRXZlbnQuS2V5UmF0Y2hldGVkLCB0aGlzLm9uS2V5UmF0Y2hldGVkKTtcbiAgfVxuICAvKipcbiAgICogY2FsbGJhY2sgdG8gaW52b2tlIG9uY2UgYSBrZXkgaGFzIGJlZW4gc2V0IGZvciBhIHBhcnRpY2lwYW50XG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIHBhcnRpY2lwYW50SWRlbnRpdHlcbiAgICogQHBhcmFtIGtleUluZGV4XG4gICAqL1xuICBvblNldEVuY3J5cHRpb25LZXkoa2V5LCBwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlJbmRleCkge1xuICAgIGNvbnN0IGtleUluZm8gPSB7XG4gICAgICBrZXksXG4gICAgICBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAga2V5SW5kZXhcbiAgICB9O1xuICAgIHRoaXMua2V5SW5mb01hcC5zZXQoXCJcIi5jb25jYXQocGFydGljaXBhbnRJZGVudGl0eSAhPT0gbnVsbCAmJiBwYXJ0aWNpcGFudElkZW50aXR5ICE9PSB2b2lkIDAgPyBwYXJ0aWNpcGFudElkZW50aXR5IDogJ3NoYXJlZCcsIFwiLVwiKS5jb25jYXQoa2V5SW5kZXggIT09IG51bGwgJiYga2V5SW5kZXggIT09IHZvaWQgMCA/IGtleUluZGV4IDogMCksIGtleUluZm8pO1xuICAgIHRoaXMuZW1pdChLZXlQcm92aWRlckV2ZW50LlNldEtleSwga2V5SW5mbyk7XG4gIH1cbiAgZ2V0S2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmtleUluZm9NYXAudmFsdWVzKCkpO1xuICB9XG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgfVxuICByYXRjaGV0S2V5KHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4KSB7XG4gICAgdGhpcy5lbWl0KEtleVByb3ZpZGVyRXZlbnQuUmF0Y2hldFJlcXVlc3QsIHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4KTtcbiAgfVxufVxuLyoqXG4gKiBBIGJhc2ljIEtleVByb3ZpZGVyIGltcGxlbWVudGF0aW9uIGludGVuZGVkIGZvciBhIHNpbmdsZSBzaGFyZWRcbiAqIHBhc3NwaHJhc2UgYmV0d2VlbiBhbGwgcGFydGljaXBhbnRzXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmNsYXNzIEV4dGVybmFsRTJFRUtleVByb3ZpZGVyIGV4dGVuZHMgQmFzZUtleVByb3ZpZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7XG4gICAgICBzaGFyZWRLZXk6IHRydWUsXG4gICAgICAvLyBmb3IgYSBzaGFyZWQga2V5IHByb3ZpZGVyIGZhaWxpbmcgdG8gZGVjcnlwdCBmb3IgYSBzcGVjaWZpYyBwYXJ0aWNpcGFudFxuICAgICAgLy8gc2hvdWxkIG5vdCBtYXJrIHRoZSBrZXkgYXMgaW52YWxpZCwgc28gd2UgYWNjZXB0IHdyb25nIGtleXMgZm9yZXZlclxuICAgICAgLy8gYW5kIHdvbid0IHRyeSB0byBhdXRvLXJhdGNoZXRcbiAgICAgIHJhdGNoZXRXaW5kb3dTaXplOiAwLFxuICAgICAgZmFpbHVyZVRvbGVyYW5jZTogLTFcbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxuICAvKipcbiAgICogQWNjZXB0cyBhIHBhc3NwaHJhc2UgdGhhdCdzIHVzZWQgdG8gY3JlYXRlIHRoZSBjcnlwdG8ga2V5cy5cbiAgICogV2hlbiBwYXNzaW5nIGluIGEgc3RyaW5nLCBQQktERjIgaXMgdXNlZC5cbiAgICogV2hlbiBwYXNzaW5nIGluIGFuIEFycmF5IGJ1ZmZlciBvZiBjcnlwdG9ncmFwaGljYWxseSByYW5kb20gbnVtYmVycywgSEtERiBpcyBiZWluZyB1c2VkLiAocmVjb21tZW5kZWQpXG4gICAqIEBwYXJhbSBrZXlcbiAgICovXG4gIHNldEtleShrZXkpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZGVyaXZlZEtleSA9IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8geWllbGQgY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nKGtleSkgOiB5aWVsZCBjcmVhdGVLZXlNYXRlcmlhbEZyb21CdWZmZXIoa2V5KTtcbiAgICAgIHRoaXMub25TZXRFbmNyeXB0aW9uS2V5KGRlcml2ZWRLZXkpO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIExpdmVraXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UgfHwgJ2FuIGVycm9yIGhhcyBvY2N1cmVkJyk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufVxuY2xhc3MgQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcmVhc29uLCBzdGF0dXMpIHtcbiAgICBzdXBlcigxLCBtZXNzYWdlKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgfVxufVxuY2xhc3MgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcigyMSwgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ2RldmljZSBpcyB1bnN1cHBvcnRlZCcpO1xuICB9XG59XG5jbGFzcyBUcmFja0ludmFsaWRFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcigyMCwgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ3RyYWNrIGlzIGludmFsaWQnKTtcbiAgfVxufVxuY2xhc3MgVW5zdXBwb3J0ZWRTZXJ2ZXIgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoMTAsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICd1bnN1cHBvcnRlZCBzZXJ2ZXInKTtcbiAgfVxufVxuY2xhc3MgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcigxMiwgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ3VuZXhwZWN0ZWQgY29ubmVjdGlvbiBzdGF0ZScpO1xuICB9XG59XG5jbGFzcyBOZWdvdGlhdGlvbkVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKDEzLCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAndW5hYmxlIHRvIG5lZ290aWF0ZScpO1xuICB9XG59XG5jbGFzcyBQdWJsaXNoRGF0YUVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKDEzLCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAndW5hYmxlIHRvIHB1Ymxpc2ggZGF0YScpO1xuICB9XG59XG52YXIgTWVkaWFEZXZpY2VGYWlsdXJlO1xuKGZ1bmN0aW9uIChNZWRpYURldmljZUZhaWx1cmUpIHtcbiAgLy8gdXNlciByZWplY3RlZCBwZXJtaXNzaW9uc1xuICBNZWRpYURldmljZUZhaWx1cmVbXCJQZXJtaXNzaW9uRGVuaWVkXCJdID0gXCJQZXJtaXNzaW9uRGVuaWVkXCI7XG4gIC8vIGRldmljZSBpcyBub3QgYXZhaWxhYmxlXG4gIE1lZGlhRGV2aWNlRmFpbHVyZVtcIk5vdEZvdW5kXCJdID0gXCJOb3RGb3VuZFwiO1xuICAvLyBkZXZpY2UgaXMgaW4gdXNlLiBPbiBXaW5kb3dzLCBvbmx5IGEgc2luZ2xlIHRhYiBtYXkgZ2V0IGFjY2VzcyB0byBhIGRldmljZSBhdCBhIHRpbWUuXG4gIE1lZGlhRGV2aWNlRmFpbHVyZVtcIkRldmljZUluVXNlXCJdID0gXCJEZXZpY2VJblVzZVwiO1xuICBNZWRpYURldmljZUZhaWx1cmVbXCJPdGhlclwiXSA9IFwiT3RoZXJcIjtcbn0pKE1lZGlhRGV2aWNlRmFpbHVyZSB8fCAoTWVkaWFEZXZpY2VGYWlsdXJlID0ge30pKTtcbihmdW5jdGlvbiAoTWVkaWFEZXZpY2VGYWlsdXJlKSB7XG4gIGZ1bmN0aW9uIGdldEZhaWx1cmUoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgJiYgJ25hbWUnIGluIGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEZvdW5kRXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdEZXZpY2VzTm90Rm91bmRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5Ob3RGb3VuZDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJyB8fCBlcnJvci5uYW1lID09PSAnUGVybWlzc2lvbkRlbmllZEVycm9yJykge1xuICAgICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLlBlcm1pc3Npb25EZW5pZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdFJlYWRhYmxlRXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdUcmFja1N0YXJ0RXJyb3InKSB7XG4gICAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuRGV2aWNlSW5Vc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLk90aGVyO1xuICAgIH1cbiAgfVxuICBNZWRpYURldmljZUZhaWx1cmUuZ2V0RmFpbHVyZSA9IGdldEZhaWx1cmU7XG59KShNZWRpYURldmljZUZhaWx1cmUgfHwgKE1lZGlhRGV2aWNlRmFpbHVyZSA9IHt9KSk7XG5cbi8qKlxuICogRXZlbnRzIGFyZSB0aGUgcHJpbWFyeSB3YXkgTGl2ZUtpdCBub3RpZmllcyB5b3VyIGFwcGxpY2F0aW9uIG9mIGNoYW5nZXMuXG4gKlxuICogVGhlIGZvbGxvd2luZyBhcmUgZXZlbnRzIGVtaXR0ZWQgYnkgW1tSb29tXV0sIGxpc3RlbiB0byByb29tIGV2ZW50cyBsaWtlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogcm9vbS5vbihSb29tRXZlbnQuVHJhY2tQdWJsaXNoZWQsICh0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KSA9PiB7fSlcbiAqIGBgYFxuICovXG52YXIgUm9vbUV2ZW50O1xuKGZ1bmN0aW9uIChSb29tRXZlbnQpIHtcbiAgLyoqXG4gICAqIFdoZW4gdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciBoYXMgYmVlbiBlc3RhYmxpc2hlZFxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQ29ubmVjdGVkXCJdID0gXCJjb25uZWN0ZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciBoYXMgYmVlbiBpbnRlcnJ1cHRlZCBhbmQgaXQncyBhdHRlbXB0aW5nXG4gICAqIHRvIHJlY29ubmVjdC5cbiAgICovXG4gIFJvb21FdmVudFtcIlJlY29ubmVjdGluZ1wiXSA9IFwicmVjb25uZWN0aW5nXCI7XG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIGEgcmVjb25uZWN0aW9uIGhhcyBiZWVuIHN1Y2Nlc3NmdWwuXG4gICAqL1xuICBSb29tRXZlbnRbXCJSZWNvbm5lY3RlZFwiXSA9IFwicmVjb25uZWN0ZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gZGlzY29ubmVjdGVkIGZyb20gcm9vbS4gVGhpcyBmaXJlcyB3aGVuIHJvb20uZGlzY29ubmVjdCgpIGlzIGNhbGxlZCBvclxuICAgKiB3aGVuIGFuIHVucmVjb3ZlcmFibGUgY29ubmVjdGlvbiBpc3N1ZSBoYWQgb2NjdXJlZFxuICAgKi9cbiAgUm9vbUV2ZW50W1wiRGlzY29ubmVjdGVkXCJdID0gXCJkaXNjb25uZWN0ZWRcIjtcbiAgLyoqXG4gICAqIFdoZW5ldmVyIHRoZSBjb25uZWN0aW9uIHN0YXRlIG9mIHRoZSByb29tIGNoYW5nZXNcbiAgICpcbiAgICogYXJnczogKFtbQ29ubmVjdGlvblN0YXRlXV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJDb25uZWN0aW9uU3RhdGVDaGFuZ2VkXCJdID0gXCJjb25uZWN0aW9uU3RhdGVDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBTdGF0ZUNoYW5nZWQgaGFzIGJlZW4gcmVuYW1lZCB0byBDb25uZWN0aW9uU3RhdGVDaGFuZ2VkXG4gICAqL1xuICBSb29tRXZlbnRbXCJTdGF0ZUNoYW5nZWRcIl0gPSBcImNvbm5lY3Rpb25TdGF0ZUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gaW5wdXQgb3Igb3V0cHV0IGRldmljZXMgb24gdGhlIG1hY2hpbmUgaGF2ZSBjaGFuZ2VkLlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiTWVkaWFEZXZpY2VzQ2hhbmdlZFwiXSA9IFwibWVkaWFEZXZpY2VzQ2hhbmdlZFwiO1xuICAvKipcbiAgICogV2hlbiBhIFtbUmVtb3RlUGFydGljaXBhbnRdXSBqb2lucyAqYWZ0ZXIqIHRoZSBsb2NhbFxuICAgKiBwYXJ0aWNpcGFudC4gSXQgd2lsbCBub3QgZW1pdCBldmVudHMgZm9yIHBhcnRpY2lwYW50cyB0aGF0IGFyZSBhbHJlYWR5XG4gICAqIGluIHRoZSByb29tXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudENvbm5lY3RlZFwiXSA9IFwicGFydGljaXBhbnRDb25uZWN0ZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gYSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gbGVhdmVzICphZnRlciogdGhlIGxvY2FsXG4gICAqIHBhcnRpY2lwYW50IGhhcyBqb2luZWQuXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZFwiXSA9IFwicGFydGljaXBhbnREaXNjb25uZWN0ZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gYSBuZXcgdHJhY2sgaXMgcHVibGlzaGVkIHRvIHJvb20gKmFmdGVyKiB0aGUgbG9jYWxcbiAgICogcGFydGljaXBhbnQgaGFzIGpvaW5lZC4gSXQgd2lsbCBub3QgZmlyZSBmb3IgdHJhY2tzIHRoYXQgYXJlIGFscmVhZHkgcHVibGlzaGVkLlxuICAgKlxuICAgKiBBIHRyYWNrIHB1Ymxpc2hlZCBkb2Vzbid0IG1lYW4gdGhlIHBhcnRpY2lwYW50IGhhcyBzdWJzY3JpYmVkIHRvIGl0LiBJdCdzXG4gICAqIHNpbXBseSByZWZsZWN0aW5nIHRoZSBzdGF0ZSBvZiB0aGUgcm9vbS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja1B1Ymxpc2hlZFwiXSA9IFwidHJhY2tQdWJsaXNoZWRcIjtcbiAgLyoqXG4gICAqIFRoZSBbW0xvY2FsUGFydGljaXBhbnRdXSBoYXMgc3Vic2NyaWJlZCB0byBhIG5ldyB0cmFjay4gVGhpcyBldmVudCB3aWxsICoqYWx3YXlzKipcbiAgICogZmlyZSBhcyBsb25nIGFzIG5ldyB0cmFja3MgYXJlIHJlYWR5IGZvciB1c2UuXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrXV0sIFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja1N1YnNjcmliZWRcIl0gPSBcInRyYWNrU3Vic2NyaWJlZFwiO1xuICAvKipcbiAgICogQ291bGQgbm90IHN1YnNjcmliZSB0byBhIHRyYWNrXG4gICAqXG4gICAqIGFyZ3M6ICh0cmFjayBzaWQsIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvbkZhaWxlZFwiO1xuICAvKipcbiAgICogQSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gaGFzIHVucHVibGlzaGVkIGEgdHJhY2tcbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja1VucHVibGlzaGVkXCJdID0gXCJ0cmFja1VucHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBBIHN1YnNjcmliZWQgdHJhY2sgaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZS4gQ2xpZW50cyBzaG91bGQgbGlzdGVuIHRvIHRoaXNcbiAgICogZXZlbnQgYW5kIGVuc3VyZSB0aGV5IGRldGFjaCB0cmFja3MuXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrXV0sIFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja1Vuc3Vic2NyaWJlZFwiXSA9IFwidHJhY2tVbnN1YnNjcmliZWRcIjtcbiAgLyoqXG4gICAqIEEgdHJhY2sgdGhhdCB3YXMgbXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja011dGVkXCJdID0gXCJ0cmFja011dGVkXCI7XG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIHVubXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja1VubXV0ZWRcIl0gPSBcInRyYWNrVW5tdXRlZFwiO1xuICAvKipcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgcHVibGlzaGVkIHN1Y2Nlc3NmdWxseS4gVGhpcyBldmVudCBpcyBoZWxwZnVsIHRvIGtub3dcbiAgICogd2hlbiB0byB1cGRhdGUgeW91ciBsb2NhbCBVSSB3aXRoIHRoZSBuZXdseSBwdWJsaXNoZWQgdHJhY2suXG4gICAqXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dLCBbW0xvY2FsUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIkxvY2FsVHJhY2tQdWJsaXNoZWRcIl0gPSBcImxvY2FsVHJhY2tQdWJsaXNoZWRcIjtcbiAgLyoqXG4gICAqIEEgbG9jYWwgdHJhY2sgd2FzIHVucHVibGlzaGVkLiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vdyB3aGVuIHRvIHJlbW92ZVxuICAgKiB0aGUgbG9jYWwgdHJhY2sgZnJvbSB5b3VyIFVJLlxuICAgKlxuICAgKiBXaGVuIGEgdXNlciBzdG9wcyBzaGFyaW5nIHRoZWlyIHNjcmVlbiBieSBwcmVzc2luZyBcIkVuZFwiIG9uIHRoZSBicm93c2VyIFVJLFxuICAgKiB0aGlzIGV2ZW50IHdpbGwgYWxzbyBmaXJlLlxuICAgKlxuICAgKiBhcmdzOiAoW1tMb2NhbFRyYWNrUHVibGljYXRpb25dXSwgW1tMb2NhbFBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJMb2NhbFRyYWNrVW5wdWJsaXNoZWRcIl0gPSBcImxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogV2hlbiBhIGxvY2FsIGF1ZGlvIHRyYWNrIGlzIHB1Ymxpc2hlZCB0aGUgU0RLIGNoZWNrcyB3aGV0aGVyIHRoZXJlIGlzIGNvbXBsZXRlIHNpbGVuY2VcbiAgICogb24gdGhhdCB0cmFjayBhbmQgZW1pdHMgdGhlIExvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWQgZXZlbnQgaW4gdGhhdCBjYXNlLlxuICAgKiBUaGlzIGFsbG93cyBmb3IgYXBwbGljYXRpb25zIHRvIHNob3cgVUkgaW5mb3JtaW5nIHVzZXJzIHRoYXQgdGhleSBtaWdodCBoYXZlIHRvXG4gICAqIHJlc2V0IHRoZWlyIGF1ZGlvIGhhcmR3YXJlIG9yIGNoZWNrIGZvciBwcm9wZXIgZGV2aWNlIGNvbm5lY3Rpdml0eS5cbiAgICovXG4gIFJvb21FdmVudFtcIkxvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWRcIl0gPSBcImxvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWRcIjtcbiAgLyoqXG4gICAqIEFjdGl2ZSBzcGVha2VycyBjaGFuZ2VkLiBMaXN0IG9mIHNwZWFrZXJzIGFyZSBvcmRlcmVkIGJ5IHRoZWlyIGF1ZGlvIGxldmVsLlxuICAgKiBsb3VkZXN0IHNwZWFrZXJzIGZpcnN0LiBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgTG9jYWxQYXJ0aWNpcGFudCB0b28uXG4gICAqXG4gICAqIFNwZWFrZXIgdXBkYXRlcyBhcmUgc2VudCBvbmx5IHRvIHRoZSBwdWJsaXNoaW5nIHBhcnRpY2lwYW50IGFuZCB0aGVpciBzdWJzY3JpYmVycy5cbiAgICpcbiAgICogYXJnczogKEFycmF5PFtbUGFydGljaXBhbnRdXT4pXG4gICAqL1xuICBSb29tRXZlbnRbXCJBY3RpdmVTcGVha2Vyc0NoYW5nZWRcIl0gPSBcImFjdGl2ZVNwZWFrZXJzQ2hhbmdlZFwiO1xuICAvKipcbiAgICogUGFydGljaXBhbnQgbWV0YWRhdGEgaXMgYSBzaW1wbGUgd2F5IGZvciBhcHAtc3BlY2lmaWMgc3RhdGUgdG8gYmUgcHVzaGVkIHRvXG4gICAqIGFsbCB1c2Vycy5cbiAgICogV2hlbiBSb29tU2VydmljZS5VcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIGlzIGNhbGxlZCB0byBjaGFuZ2UgYSBwYXJ0aWNpcGFudCdzXG4gICAqIHN0YXRlLCAqYWxsKiAgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgZmlyZSB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBhcmdzOiAocHJldk1ldGFkYXRhOiBzdHJpbmcsIFtbUGFydGljaXBhbnRdXSlcbiAgICpcbiAgICovXG4gIFJvb21FdmVudFtcIlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZFwiO1xuICAvKipcbiAgICogUGFydGljaXBhbnQncyBkaXNwbGF5IG5hbWUgY2hhbmdlZFxuICAgKlxuICAgKiBhcmdzOiAobmFtZTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqXG4gICAqL1xuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudE5hbWVDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBSb29tIG1ldGFkYXRhIGlzIGEgc2ltcGxlIHdheSBmb3IgYXBwLXNwZWNpZmljIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xuICAgKiBhbGwgdXNlcnMuXG4gICAqIFdoZW4gUm9vbVNlcnZpY2UuVXBkYXRlUm9vbU1ldGFkYXRhIGlzIGNhbGxlZCB0byBjaGFuZ2UgYSByb29tJ3Mgc3RhdGUsXG4gICAqICphbGwqICBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCBmaXJlIHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIGFyZ3M6IChzdHJpbmcpXG4gICAqL1xuICBSb29tRXZlbnRbXCJSb29tTWV0YWRhdGFDaGFuZ2VkXCJdID0gXCJyb29tTWV0YWRhdGFDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBEYXRhIHJlY2VpdmVkIGZyb20gYW5vdGhlciBwYXJ0aWNpcGFudC5cbiAgICogRGF0YSBwYWNrZXRzIHByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIHVzZSBMaXZlS2l0IHRvIHNlbmQvcmVjZWl2ZSBhcmJpdHJhcnkgcGF5bG9hZHMuXG4gICAqIEFsbCBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCByZWNlaXZlIHRoZSBtZXNzYWdlcyBzZW50IHRvIHRoZSByb29tLlxuICAgKlxuICAgKiBhcmdzOiAocGF5bG9hZDogVWludDhBcnJheSwgcGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSwga2luZDogW1tEYXRhUGFja2V0X0tpbmRdXSwgdG9waWM/OiBzdHJpbmcpXG4gICAqL1xuICBSb29tRXZlbnRbXCJEYXRhUmVjZWl2ZWRcIl0gPSBcImRhdGFSZWNlaXZlZFwiO1xuICAvKipcbiAgICogQ29ubmVjdGlvbiBxdWFsaXR5IHdhcyBjaGFuZ2VkIGZvciBhIFBhcnRpY2lwYW50LiBJdCdsbCByZWNlaXZlIHVwZGF0ZXNcbiAgICogZnJvbSB0aGUgbG9jYWwgcGFydGljaXBhbnQsIGFzIHdlbGwgYXMgYW55IFtbUmVtb3RlUGFydGljaXBhbnRdXXMgdGhhdCB3ZSBhcmVcbiAgICogc3Vic2NyaWJlZCB0by5cbiAgICpcbiAgICogYXJnczogKGNvbm5lY3Rpb25RdWFsaXR5OiBbW0Nvbm5lY3Rpb25RdWFsaXR5XV0sIHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWRcIl0gPSBcImNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZFwiO1xuICAvKipcbiAgICogU3RyZWFtU3RhdGUgaW5kaWNhdGVzIGlmIGEgc3Vic2NyaWJlZCAocmVtb3RlKSB0cmFjayBoYXMgYmVlbiBwYXVzZWQgYnkgdGhlIFNGVVxuICAgKiAodHlwaWNhbGx5IHRoaXMgaGFwcGVucyBiZWNhdXNlIG9mIHN1YnNjcmliZXIncyBiYW5kd2lkdGggY29uc3RyYWludHMpXG4gICAqXG4gICAqIFdoZW4gYmFuZHdpZHRoIGNvbmRpdGlvbnMgYWxsb3csIHRoZSB0cmFjayB3aWxsIGJlIHJlc3VtZWQgYXV0b21hdGljYWxseS5cbiAgICogVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQgd2lsbCBhbHNvIGJlIGVtaXR0ZWQgd2hlbiB0aGF0IGhhcHBlbnMuXG4gICAqXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBzdHJlYW1TdGF0ZTogW1tUcmFjay5TdHJlYW1TdGF0ZV1dLFxuICAgKiAgICAgICAgcGFydGljaXBhbnQ6IFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkXCJdID0gXCJ0cmFja1N0cmVhbVN0YXRlQ2hhbmdlZFwiO1xuICAvKipcbiAgICogT25lIG9mIHN1YnNjcmliZWQgdHJhY2tzIGhhdmUgY2hhbmdlZCBpdHMgcGVybWlzc2lvbnMgZm9yIHRoZSBjdXJyZW50XG4gICAqIHBhcnRpY2lwYW50LiBJZiBwZXJtaXNzaW9uIHdhcyByZXZva2VkLCB0aGVuIHRoZSB0cmFjayB3aWxsIG5vIGxvbmdlclxuICAgKiBiZSBzdWJzY3JpYmVkLiBJZiBwZXJtaXNzaW9uIHdhcyBncmFudGVkLCBhIFRyYWNrU3Vic2NyaWJlZCBldmVudCB3aWxsXG4gICAqIGJlIGVtaXR0ZWQuXG4gICAqXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLFxuICAgKiAgICAgICAgc3RhdHVzOiBbW1RyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1c11dLFxuICAgKiAgICAgICAgcGFydGljaXBhbnQ6IFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIl0gPSBcInRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIE9uZSBvZiBzdWJzY3JpYmVkIHRyYWNrcyBoYXZlIGNoYW5nZWQgaXRzIHN0YXR1cyBmb3IgdGhlIGN1cnJlbnRcbiAgICogcGFydGljaXBhbnQuXG4gICAqXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLFxuICAgKiAgICAgICAgc3RhdHVzOiBbW1RyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzXV0sXG4gICAqICAgICAgICBwYXJ0aWNpcGFudDogW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIExpdmVLaXQgd2lsbCBhdHRlbXB0IHRvIGF1dG9wbGF5IGFsbCBhdWRpbyB0cmFja3Mgd2hlbiB5b3UgYXR0YWNoIHRoZW0gdG9cbiAgICogYXVkaW8gZWxlbWVudHMuIEhvd2V2ZXIsIGlmIHRoYXQgZmFpbHMsIHdlJ2xsIG5vdGlmeSB5b3UgdmlhIEF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLlxuICAgKiBgUm9vbS5jYW5QbGF5YmFja0F1ZGlvYCB3aWxsIGluZGljYXRlIGlmIGF1ZGlvIHBsYXliYWNrIGlzIHBlcm1pdHRlZC5cbiAgICovXG4gIFJvb21FdmVudFtcIkF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkXCJdID0gXCJhdWRpb1BsYXliYWNrQ2hhbmdlZFwiO1xuICAvKipcbiAgICogTGl2ZUtpdCB3aWxsIGF0dGVtcHQgdG8gYXV0b3BsYXkgYWxsIHZpZGVvIHRyYWNrcyB3aGVuIHlvdSBhdHRhY2ggdGhlbSB0b1xuICAgKiBhIHZpZGVvIGVsZW1lbnQuIEhvd2V2ZXIsIGlmIHRoYXQgZmFpbHMsIHdlJ2xsIG5vdGlmeSB5b3UgdmlhIFZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLlxuICAgKiBDYWxsaW5nIGByb29tLnN0YXJ0VmlkZW8oKWAgaW4gYSB1c2VyIGdlc3R1cmUgZXZlbnQgaGFuZGxlciB3aWxsIHJlc3VtZSB0aGUgdmlkZW8gcGxheWJhY2suXG4gICAqL1xuICBSb29tRXZlbnRbXCJWaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZFwiXSA9IFwidmlkZW9QbGF5YmFja0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gd2UgaGF2ZSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBhdHRlbXB0aW5nIHRvIGNyZWF0ZSBhIHRyYWNrLlxuICAgKiBUaGUgZXJyb3JzIHRha2UgcGxhY2UgaW4gZ2V0VXNlck1lZGlhKCkuXG4gICAqIFVzZSBNZWRpYURldmljZUZhaWx1cmUuZ2V0RmFpbHVyZShlcnJvcikgdG8gZ2V0IHRoZSByZWFzb24gb2YgZmFpbHVyZS5cbiAgICogW1tMb2NhbFBhcnRpY2lwYW50Lmxhc3RDYW1lcmFFcnJvcl1dIGFuZCBbW0xvY2FsUGFydGljaXBhbnQubGFzdE1pY3JvcGhvbmVFcnJvcl1dXG4gICAqIHdpbGwgaW5kaWNhdGUgaWYgaXQgaGFkIGFuIGVycm9yIHdoaWxlIGNyZWF0aW5nIHRoZSBhdWRpbyBvciB2aWRlbyB0cmFjayByZXNwZWN0aXZlbHkuXG4gICAqXG4gICAqIGFyZ3M6IChlcnJvcjogRXJyb3IpXG4gICAqL1xuICBSb29tRXZlbnRbXCJNZWRpYURldmljZXNFcnJvclwiXSA9IFwibWVkaWFEZXZpY2VzRXJyb3JcIjtcbiAgLyoqXG4gICAqIEEgcGFydGljaXBhbnQncyBwZXJtaXNzaW9uIGhhcyBjaGFuZ2VkLiBDdXJyZW50bHkgb25seSBmaXJlZCBvbiBMb2NhbFBhcnRpY2lwYW50LlxuICAgKiBhcmdzOiAocHJldlBlcm1pc3Npb25zOiBbW1BhcnRpY2lwYW50UGVybWlzc2lvbl1dLCBwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBTaWduYWwgY29ubmVjdGVkLCBjYW4gcHVibGlzaCB0cmFja3MuXG4gICAqL1xuICBSb29tRXZlbnRbXCJTaWduYWxDb25uZWN0ZWRcIl0gPSBcInNpZ25hbENvbm5lY3RlZFwiO1xuICAvKipcbiAgICogUmVjb3JkaW5nIG9mIGEgcm9vbSBoYXMgc3RhcnRlZC9zdG9wcGVkLiBSb29tLmlzUmVjb3JkaW5nIHdpbGwgYmUgdXBkYXRlZCB0b28uXG4gICAqIGFyZ3M6IChpc1JlY29yZGluZzogYm9vbGVhbilcbiAgICovXG4gIFJvb21FdmVudFtcIlJlY29yZGluZ1N0YXR1c0NoYW5nZWRcIl0gPSBcInJlY29yZGluZ1N0YXR1c0NoYW5nZWRcIjtcbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZFwiO1xuICBSb29tRXZlbnRbXCJFbmNyeXB0aW9uRXJyb3JcIl0gPSBcImVuY3J5cHRpb25FcnJvclwiO1xuICAvKipcbiAgICogRW1pdHMgd2hlbmV2ZXIgdGhlIGN1cnJlbnQgYnVmZmVyIHN0YXR1cyBvZiBhIGRhdGEgY2hhbm5lbCBjaGFuZ2VzXG4gICAqIGFyZ3M6IChpc0xvdzogYm9vbGVhbiwga2luZDogW1tEYXRhUGFja2V0X0tpbmRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIkRDQnVmZmVyU3RhdHVzQ2hhbmdlZFwiXSA9IFwiZGNCdWZmZXJTdGF0dXNDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgYnkgYSBjYWxsIHRvIHJvb20uc3dpdGNoQWN0aXZlRGV2aWNlXG4gICAqIGFyZ3M6IChraW5kOiBNZWRpYURldmljZUtpbmQsIGRldmljZUlkOiBzdHJpbmcpXG4gICAqL1xuICBSb29tRXZlbnRbXCJBY3RpdmVEZXZpY2VDaGFuZ2VkXCJdID0gXCJhY3RpdmVEZXZpY2VDaGFuZ2VkXCI7XG59KShSb29tRXZlbnQgfHwgKFJvb21FdmVudCA9IHt9KSk7XG52YXIgUGFydGljaXBhbnRFdmVudDtcbihmdW5jdGlvbiAoUGFydGljaXBhbnRFdmVudCkge1xuICAvKipcbiAgICogV2hlbiBhIG5ldyB0cmFjayBpcyBwdWJsaXNoZWQgdG8gcm9vbSAqYWZ0ZXIqIHRoZSBsb2NhbFxuICAgKiBwYXJ0aWNpcGFudCBoYXMgam9pbmVkLiBJdCB3aWxsIG5vdCBmaXJlIGZvciB0cmFja3MgdGhhdCBhcmUgYWxyZWFkeSBwdWJsaXNoZWQuXG4gICAqXG4gICAqIEEgdHJhY2sgcHVibGlzaGVkIGRvZXNuJ3QgbWVhbiB0aGUgcGFydGljaXBhbnQgaGFzIHN1YnNjcmliZWQgdG8gaXQuIEl0J3NcbiAgICogc2ltcGx5IHJlZmxlY3RpbmcgdGhlIHN0YXRlIG9mIHRoZSByb29tLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tQdWJsaXNoZWRcIl0gPSBcInRyYWNrUHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBTdWNjZXNzZnVsbHkgc3Vic2NyaWJlZCB0byB0aGUgW1tSZW1vdGVQYXJ0aWNpcGFudF1dJ3MgdHJhY2suXG4gICAqIFRoaXMgZXZlbnQgd2lsbCAqKmFsd2F5cyoqIGZpcmUgYXMgbG9uZyBhcyBuZXcgdHJhY2tzIGFyZSByZWFkeSBmb3IgdXNlLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1N1YnNjcmliZWRcIl0gPSBcInRyYWNrU3Vic2NyaWJlZFwiO1xuICAvKipcbiAgICogQ291bGQgbm90IHN1YnNjcmliZSB0byBhIHRyYWNrXG4gICAqXG4gICAqIGFyZ3M6ICh0cmFjayBzaWQpXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25GYWlsZWRcIl0gPSBcInRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkXCI7XG4gIC8qKlxuICAgKiBBIFtbUmVtb3RlUGFydGljaXBhbnRdXSBoYXMgdW5wdWJsaXNoZWQgYSB0cmFja1xuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwidHJhY2tVbnB1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogQSBzdWJzY3JpYmVkIHRyYWNrIGlzIG5vIGxvbmdlciBhdmFpbGFibGUuIENsaWVudHMgc2hvdWxkIGxpc3RlbiB0byB0aGlzXG4gICAqIGV2ZW50IGFuZCBlbnN1cmUgdGhleSBkZXRhY2ggdHJhY2tzLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1Vuc3Vic2NyaWJlZFwiXSA9IFwidHJhY2tVbnN1YnNjcmliZWRcIjtcbiAgLyoqXG4gICAqIEEgdHJhY2sgdGhhdCB3YXMgbXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrTXV0ZWRcIl0gPSBcInRyYWNrTXV0ZWRcIjtcbiAgLyoqXG4gICAqIEEgdHJhY2sgdGhhdCB3YXMgdW5tdXRlZCwgZmlyZXMgb24gYm90aCBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIGFuZCBbW0xvY2FsUGFydGljaXBhbnRdXVxuICAgKlxuICAgKiBhcmdzOiAoW1tUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tVbm11dGVkXCJdID0gXCJ0cmFja1VubXV0ZWRcIjtcbiAgLyoqXG4gICAqIEEgbG9jYWwgdHJhY2sgd2FzIHB1Ymxpc2hlZCBzdWNjZXNzZnVsbHkuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93XG4gICAqIHdoZW4gdG8gdXBkYXRlIHlvdXIgbG9jYWwgVUkgd2l0aCB0aGUgbmV3bHkgcHVibGlzaGVkIHRyYWNrLlxuICAgKlxuICAgKiBhcmdzOiAoW1tMb2NhbFRyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJMb2NhbFRyYWNrUHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrUHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyB1bnB1Ymxpc2hlZC4gVGhpcyBldmVudCBpcyBoZWxwZnVsIHRvIGtub3cgd2hlbiB0byByZW1vdmVcbiAgICogdGhlIGxvY2FsIHRyYWNrIGZyb20geW91ciBVSS5cbiAgICpcbiAgICogV2hlbiBhIHVzZXIgc3RvcHMgc2hhcmluZyB0aGVpciBzY3JlZW4gYnkgcHJlc3NpbmcgXCJFbmRcIiBvbiB0aGUgYnJvd3NlciBVSSxcbiAgICogdGhpcyBldmVudCB3aWxsIGFsc28gZmlyZS5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiTG9jYWxUcmFja1VucHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrVW5wdWJsaXNoZWRcIjtcbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50IG1ldGFkYXRhIGlzIGEgc2ltcGxlIHdheSBmb3IgYXBwLXNwZWNpZmljIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xuICAgKiBhbGwgdXNlcnMuXG4gICAqIFdoZW4gUm9vbVNlcnZpY2UuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSBpcyBjYWxsZWQgdG8gY2hhbmdlIGEgcGFydGljaXBhbnQnc1xuICAgKiBzdGF0ZSwgKmFsbCogIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIGZpcmUgdGhpcyBldmVudC5cbiAgICogVG8gYWNjZXNzIHRoZSBjdXJyZW50IG1ldGFkYXRhLCBzZWUgW1tQYXJ0aWNpcGFudC5tZXRhZGF0YV1dLlxuICAgKlxuICAgKiBhcmdzOiAocHJldk1ldGFkYXRhOiBzdHJpbmcpXG4gICAqXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCdzIGRpc3BsYXkgbmFtZSBjaGFuZ2VkXG4gICAqXG4gICAqIGFyZ3M6IChuYW1lOiBzdHJpbmcsIFtbUGFydGljaXBhbnRdXSlcbiAgICpcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudE5hbWVDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBEYXRhIHJlY2VpdmVkIGZyb20gdGhpcyBwYXJ0aWNpcGFudCBhcyBzZW5kZXIuXG4gICAqIERhdGEgcGFja2V0cyBwcm92aWRlcyB0aGUgYWJpbGl0eSB0byB1c2UgTGl2ZUtpdCB0byBzZW5kL3JlY2VpdmUgYXJiaXRyYXJ5IHBheWxvYWRzLlxuICAgKiBBbGwgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgcmVjZWl2ZSB0aGUgbWVzc2FnZXMgc2VudCB0byB0aGUgcm9vbS5cbiAgICpcbiAgICogYXJnczogKHBheWxvYWQ6IFVpbnQ4QXJyYXksIGtpbmQ6IFtbRGF0YVBhY2tldF9LaW5kXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiRGF0YVJlY2VpdmVkXCJdID0gXCJkYXRhUmVjZWl2ZWRcIjtcbiAgLyoqXG4gICAqIEhhcyBzcGVha2luZyBzdGF0dXMgY2hhbmdlZCBmb3IgdGhlIGN1cnJlbnQgcGFydGljaXBhbnRcbiAgICpcbiAgICogYXJnczogKHNwZWFraW5nOiBib29sZWFuKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIklzU3BlYWtpbmdDaGFuZ2VkXCJdID0gXCJpc1NwZWFraW5nQ2hhbmdlZFwiO1xuICAvKipcbiAgICogQ29ubmVjdGlvbiBxdWFsaXR5IHdhcyBjaGFuZ2VkIGZvciBhIFBhcnRpY2lwYW50LiBJdCdsbCByZWNlaXZlIHVwZGF0ZXNcbiAgICogZnJvbSB0aGUgbG9jYWwgcGFydGljaXBhbnQsIGFzIHdlbGwgYXMgYW55IFtbUmVtb3RlUGFydGljaXBhbnRdXXMgdGhhdCB3ZSBhcmVcbiAgICogc3Vic2NyaWJlZCB0by5cbiAgICpcbiAgICogYXJnczogKGNvbm5lY3Rpb25RdWFsaXR5OiBbW0Nvbm5lY3Rpb25RdWFsaXR5XV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkXCJdID0gXCJjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFN0cmVhbVN0YXRlIGluZGljYXRlcyBpZiBhIHN1YnNjcmliZWQgdHJhY2sgaGFzIGJlZW4gcGF1c2VkIGJ5IHRoZSBTRlVcbiAgICogKHR5cGljYWxseSB0aGlzIGhhcHBlbnMgYmVjYXVzZSBvZiBzdWJzY3JpYmVyJ3MgYmFuZHdpZHRoIGNvbnN0cmFpbnRzKVxuICAgKlxuICAgKiBXaGVuIGJhbmR3aWR0aCBjb25kaXRpb25zIGFsbG93LCB0aGUgdHJhY2sgd2lsbCBiZSByZXN1bWVkIGF1dG9tYXRpY2FsbHkuXG4gICAqIFRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkIHdpbGwgYWxzbyBiZSBlbWl0dGVkIHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgc3RyZWFtU3RhdGU6IFtbVHJhY2suU3RyZWFtU3RhdGVdXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZFwiXSA9IFwidHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIE9uZSBvZiBzdWJzY3JpYmVkIHRyYWNrcyBoYXZlIGNoYW5nZWQgaXRzIHBlcm1pc3Npb25zIGZvciB0aGUgY3VycmVudFxuICAgKiBwYXJ0aWNpcGFudC4gSWYgcGVybWlzc2lvbiB3YXMgcmV2b2tlZCwgdGhlbiB0aGUgdHJhY2sgd2lsbCBubyBsb25nZXJcbiAgICogYmUgc3Vic2NyaWJlZC4gSWYgcGVybWlzc2lvbiB3YXMgZ3JhbnRlZCwgYSBUcmFja1N1YnNjcmliZWQgZXZlbnQgd2lsbFxuICAgKiBiZSBlbWl0dGVkLlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSxcbiAgICogICAgICAgIHN0YXR1czogW1tUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1c11dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIl0gPSBcInRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIE9uZSBvZiB0aGUgcmVtb3RlIHBhcnRpY2lwYW50cyBwdWJsaWNhdGlvbnMgaGFzIGNoYW5nZWQgaXRzIHN1YnNjcmlwdGlvbiBzdGF0dXMuXG4gICAqXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcIjtcbiAgLy8gZmlyZWQgb25seSBvbiBMb2NhbFBhcnRpY2lwYW50XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIk1lZGlhRGV2aWNlc0Vycm9yXCJdID0gXCJtZWRpYURldmljZXNFcnJvclwiO1xuICAvLyBmaXJlZCBvbmx5IG9uIExvY2FsUGFydGljaXBhbnRcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiQXVkaW9TdHJlYW1BY3F1aXJlZFwiXSA9IFwiYXVkaW9TdHJlYW1BY3F1aXJlZFwiO1xuICAvKipcbiAgICogQSBwYXJ0aWNpcGFudCdzIHBlcm1pc3Npb24gaGFzIGNoYW5nZWQuIEN1cnJlbnRseSBvbmx5IGZpcmVkIG9uIExvY2FsUGFydGljaXBhbnQuXG4gICAqIGFyZ3M6IChwcmV2UGVybWlzc2lvbnM6IFtbUGFydGljaXBhbnRQZXJtaXNzaW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlBDVHJhY2tBZGRlZFwiXSA9IFwicGNUcmFja0FkZGVkXCI7XG59KShQYXJ0aWNpcGFudEV2ZW50IHx8IChQYXJ0aWNpcGFudEV2ZW50ID0ge30pKTtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBFbmdpbmVFdmVudDtcbihmdW5jdGlvbiAoRW5naW5lRXZlbnQpIHtcbiAgRW5naW5lRXZlbnRbXCJUcmFuc3BvcnRzQ3JlYXRlZFwiXSA9IFwidHJhbnNwb3J0c0NyZWF0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJDb25uZWN0ZWRcIl0gPSBcImNvbm5lY3RlZFwiO1xuICBFbmdpbmVFdmVudFtcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiUmVzdW1pbmdcIl0gPSBcInJlc3VtaW5nXCI7XG4gIEVuZ2luZUV2ZW50W1wiUmVzdW1lZFwiXSA9IFwicmVzdW1lZFwiO1xuICBFbmdpbmVFdmVudFtcIlJlc3RhcnRpbmdcIl0gPSBcInJlc3RhcnRpbmdcIjtcbiAgRW5naW5lRXZlbnRbXCJSZXN0YXJ0ZWRcIl0gPSBcInJlc3RhcnRlZFwiO1xuICBFbmdpbmVFdmVudFtcIlNpZ25hbFJlc3VtZWRcIl0gPSBcInNpZ25hbFJlc3VtZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJTaWduYWxSZXN0YXJ0ZWRcIl0gPSBcInNpZ25hbFJlc3RhcnRlZFwiO1xuICBFbmdpbmVFdmVudFtcIkNsb3NpbmdcIl0gPSBcImNsb3NpbmdcIjtcbiAgRW5naW5lRXZlbnRbXCJNZWRpYVRyYWNrQWRkZWRcIl0gPSBcIm1lZGlhVHJhY2tBZGRlZFwiO1xuICBFbmdpbmVFdmVudFtcIkFjdGl2ZVNwZWFrZXJzVXBkYXRlXCJdID0gXCJhY3RpdmVTcGVha2Vyc1VwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIkRhdGFQYWNrZXRSZWNlaXZlZFwiXSA9IFwiZGF0YVBhY2tldFJlY2VpdmVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiUlRQVmlkZW9NYXBVcGRhdGVcIl0gPSBcInJ0cFZpZGVvTWFwVXBkYXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiRENCdWZmZXJTdGF0dXNDaGFuZ2VkXCJdID0gXCJkY0J1ZmZlclN0YXR1c0NoYW5nZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJQYXJ0aWNpcGFudFVwZGF0ZVwiXSA9IFwicGFydGljaXBhbnRVcGRhdGVcIjtcbiAgRW5naW5lRXZlbnRbXCJSb29tVXBkYXRlXCJdID0gXCJyb29tVXBkYXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiU3BlYWtlcnNDaGFuZ2VkXCJdID0gXCJzcGVha2Vyc0NoYW5nZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJTdHJlYW1TdGF0ZUNoYW5nZWRcIl0gPSBcInN0cmVhbVN0YXRlQ2hhbmdlZFwiO1xuICBFbmdpbmVFdmVudFtcIkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlXCJdID0gXCJjb25uZWN0aW9uUXVhbGl0eVVwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIlN1YnNjcmlwdGlvbkVycm9yXCJdID0gXCJzdWJzY3JpcHRpb25FcnJvclwiO1xuICBFbmdpbmVFdmVudFtcIlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGVcIl0gPSBcInN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGVcIjtcbiAgRW5naW5lRXZlbnRbXCJSZW1vdGVNdXRlXCJdID0gXCJyZW1vdGVNdXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGVcIl0gPSBcInN1YnNjcmliZWRRdWFsaXR5VXBkYXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiTG9jYWxUcmFja1VucHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrVW5wdWJsaXNoZWRcIjtcbn0pKEVuZ2luZUV2ZW50IHx8IChFbmdpbmVFdmVudCA9IHt9KSk7XG52YXIgVHJhY2tFdmVudDtcbihmdW5jdGlvbiAoVHJhY2tFdmVudCkge1xuICBUcmFja0V2ZW50W1wiTWVzc2FnZVwiXSA9IFwibWVzc2FnZVwiO1xuICBUcmFja0V2ZW50W1wiTXV0ZWRcIl0gPSBcIm11dGVkXCI7XG4gIFRyYWNrRXZlbnRbXCJVbm11dGVkXCJdID0gXCJ1bm11dGVkXCI7XG4gIC8qKlxuICAgKiBPbmx5IGZpcmVzIG9uIExvY2FsVHJhY2tzXG4gICAqL1xuICBUcmFja0V2ZW50W1wiUmVzdGFydGVkXCJdID0gXCJyZXN0YXJ0ZWRcIjtcbiAgVHJhY2tFdmVudFtcIkVuZGVkXCJdID0gXCJlbmRlZFwiO1xuICBUcmFja0V2ZW50W1wiU3Vic2NyaWJlZFwiXSA9IFwic3Vic2NyaWJlZFwiO1xuICBUcmFja0V2ZW50W1wiVW5zdWJzY3JpYmVkXCJdID0gXCJ1bnN1YnNjcmliZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiVXBkYXRlU2V0dGluZ3NcIl0gPSBcInVwZGF0ZVNldHRpbmdzXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIlVwZGF0ZVN1YnNjcmlwdGlvblwiXSA9IFwidXBkYXRlU3Vic2NyaXB0aW9uXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIkF1ZGlvUGxheWJhY2tTdGFydGVkXCJdID0gXCJhdWRpb1BsYXliYWNrU3RhcnRlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJBdWRpb1BsYXliYWNrRmFpbGVkXCJdID0gXCJhdWRpb1BsYXliYWNrRmFpbGVkXCI7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogT25seSBmaXJlcyBvbiBMb2NhbEF1ZGlvVHJhY2sgaW5zdGFuY2VzXG4gICAqL1xuICBUcmFja0V2ZW50W1wiQXVkaW9TaWxlbmNlRGV0ZWN0ZWRcIl0gPSBcImF1ZGlvU2lsZW5jZURldGVjdGVkXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIlZpc2liaWxpdHlDaGFuZ2VkXCJdID0gXCJ2aXNpYmlsaXR5Q2hhbmdlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJWaWRlb0RpbWVuc2lvbnNDaGFuZ2VkXCJdID0gXCJ2aWRlb0RpbWVuc2lvbnNDaGFuZ2VkXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIlZpZGVvUGxheWJhY2tTdGFydGVkXCJdID0gXCJ2aWRlb1BsYXliYWNrU3RhcnRlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJWaWRlb1BsYXliYWNrRmFpbGVkXCJdID0gXCJ2aWRlb1BsYXliYWNrRmFpbGVkXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIkVsZW1lbnRBdHRhY2hlZFwiXSA9IFwiZWxlbWVudEF0dGFjaGVkXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIkVsZW1lbnREZXRhY2hlZFwiXSA9IFwiZWxlbWVudERldGFjaGVkXCI7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogT25seSBmaXJlcyBvbiBMb2NhbFRyYWNrc1xuICAgKi9cbiAgVHJhY2tFdmVudFtcIlVwc3RyZWFtUGF1c2VkXCJdID0gXCJ1cHN0cmVhbVBhdXNlZFwiO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxUcmFja3NcbiAgICovXG4gIFRyYWNrRXZlbnRbXCJVcHN0cmVhbVJlc3VtZWRcIl0gPSBcInVwc3RyZWFtUmVzdW1lZFwiO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEZpcmVzIG9uIFJlbW90ZVRyYWNrUHVibGljYXRpb25cbiAgICovXG4gIFRyYWNrRXZlbnRbXCJTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZFwiXSA9IFwic3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIEZpcmVzIG9uIFJlbW90ZVRyYWNrUHVibGljYXRpb25cbiAgICovXG4gIFRyYWNrRXZlbnRbXCJTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJzdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBGaXJlcyBvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXG4gICAqL1xuICBUcmFja0V2ZW50W1wiU3Vic2NyaXB0aW9uRmFpbGVkXCJdID0gXCJzdWJzY3JpcHRpb25GYWlsZWRcIjtcbn0pKFRyYWNrRXZlbnQgfHwgKFRyYWNrRXZlbnQgPSB7fSkpO1xuXG5mdW5jdGlvbiByKHIsIGUsIG4pIHtcbiAgdmFyIGksIHQsIG87XG4gIHZvaWQgMCA9PT0gZSAmJiAoZSA9IDUwKSwgdm9pZCAwID09PSBuICYmIChuID0ge30pO1xuICB2YXIgYSA9IG51bGwgIT0gKGkgPSBuLmlzSW1tZWRpYXRlKSAmJiBpLFxuICAgIHUgPSBudWxsICE9ICh0ID0gbi5jYWxsYmFjaykgJiYgdCxcbiAgICBjID0gbi5tYXhXYWl0LFxuICAgIHYgPSBEYXRlLm5vdygpLFxuICAgIGwgPSBbXTtcbiAgZnVuY3Rpb24gZigpIHtcbiAgICBpZiAodm9pZCAwICE9PSBjKSB7XG4gICAgICB2YXIgciA9IERhdGUubm93KCkgLSB2O1xuICAgICAgaWYgKHIgKyBlID49IGMpIHJldHVybiBjIC0gcjtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgdmFyIGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGUgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICBuID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGksIHQpIHtcbiAgICAgIHZhciBjID0gYSAmJiB2b2lkIDAgPT09IG87XG4gICAgICBpZiAodm9pZCAwICE9PSBvICYmIGNsZWFyVGltZW91dChvKSwgbyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobyA9IHZvaWQgMCwgdiA9IERhdGUubm93KCksICFhKSB7XG4gICAgICAgICAgdmFyIGkgPSByLmFwcGx5KG4sIGUpO1xuICAgICAgICAgIHUgJiYgdShpKSwgbC5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHIucmVzb2x2ZSkoaSk7XG4gICAgICAgICAgfSksIGwgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfSwgZigpKSwgYykge1xuICAgICAgICB2YXIgZCA9IHIuYXBwbHkobiwgZSk7XG4gICAgICAgIHJldHVybiB1ICYmIHUoZCksIGkoZCk7XG4gICAgICB9XG4gICAgICBsLnB1c2goe1xuICAgICAgICByZXNvbHZlOiBpLFxuICAgICAgICByZWplY3Q6IHRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gZC5jYW5jZWwgPSBmdW5jdGlvbiAocikge1xuICAgIHZvaWQgMCAhPT0gbyAmJiBjbGVhclRpbWVvdXQobyksIGwuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuICgwLCBlLnJlamVjdCkocik7XG4gICAgfSksIGwgPSBbXTtcbiAgfSwgZDtcbn1cblxuLy8gdGlueSwgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9sYW5jZWRpa3Nvbi9ib3dzZXIvYmxvYi9tYXN0ZXIvc3JjL3BhcnNlci1icm93c2Vycy5qc1xuLy8gcmVkdWNlZCB0byBvbmx5IGRpZmZlcmVudGlhdGUgQ2hyb21lKGl1bSkgYmFzZWQgYnJvd3NlcnMgLyBGaXJlZm94IC8gU2FmYXJpXG5jb25zdCBjb21tb25WZXJzaW9uSWRlbnRpZmllciA9IC92ZXJzaW9uXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pO1xubGV0IGJyb3dzZXJEZXRhaWxzO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0QnJvd3Nlcih1c2VyQWdlbnQpIHtcbiAgbGV0IGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICBpZiAodHlwZW9mIHVzZXJBZ2VudCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdWEgPSAodXNlckFnZW50ICE9PSBudWxsICYmIHVzZXJBZ2VudCAhPT0gdm9pZCAwID8gdXNlckFnZW50IDogbmF2aWdhdG9yLnVzZXJBZ2VudCkudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGJyb3dzZXJEZXRhaWxzID09PSB1bmRlZmluZWQgfHwgZm9yY2UpIHtcbiAgICBjb25zdCBicm93c2VyID0gYnJvd3NlcnNMaXN0LmZpbmQoX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICB0ZXN0XG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHJldHVybiB0ZXN0LnRlc3QodWEpO1xuICAgIH0pO1xuICAgIGJyb3dzZXJEZXRhaWxzID0gYnJvd3NlciA9PT0gbnVsbCB8fCBicm93c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBicm93c2VyLmRlc2NyaWJlKHVhKTtcbiAgfVxuICByZXR1cm4gYnJvd3NlckRldGFpbHM7XG59XG5jb25zdCBicm93c2Vyc0xpc3QgPSBbe1xuICB0ZXN0OiAvZmlyZWZveHxpY2V3ZWFzZWx8Znhpb3MvaSxcbiAgZGVzY3JpYmUodWEpIHtcbiAgICBjb25zdCBicm93c2VyID0ge1xuICAgICAgbmFtZTogJ0ZpcmVmb3gnLFxuICAgICAgdmVyc2lvbjogZ2V0TWF0Y2goLyg/OmZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSwgdWEpLFxuICAgICAgb3M6IHVhLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2Z4aW9zJykgPyAnaU9TJyA6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgcmV0dXJuIGJyb3dzZXI7XG4gIH1cbn0sIHtcbiAgdGVzdDogL2Nocm9tfGNyaW9zfGNybW8vaSxcbiAgZGVzY3JpYmUodWEpIHtcbiAgICBjb25zdCBicm93c2VyID0ge1xuICAgICAgbmFtZTogJ0Nocm9tZScsXG4gICAgICB2ZXJzaW9uOiBnZXRNYXRjaCgvKD86Y2hyb21lfGNocm9taXVtfGNyaW9zfGNybW8pXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLCB1YSksXG4gICAgICBvczogdWEudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnY3Jpb3MnKSA/ICdpT1MnIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICByZXR1cm4gYnJvd3NlcjtcbiAgfVxufSwgLyogU2FmYXJpICovXG57XG4gIHRlc3Q6IC9zYWZhcml8YXBwbGV3ZWJraXQvaSxcbiAgZGVzY3JpYmUodWEpIHtcbiAgICBjb25zdCBicm93c2VyID0ge1xuICAgICAgbmFtZTogJ1NhZmFyaScsXG4gICAgICB2ZXJzaW9uOiBnZXRNYXRjaChjb21tb25WZXJzaW9uSWRlbnRpZmllciwgdWEpLFxuICAgICAgb3M6IHVhLmluY2x1ZGVzKCdtb2JpbGUvJykgPyAnaU9TJyA6ICdtYWNPUydcbiAgICB9O1xuICAgIHJldHVybiBicm93c2VyO1xuICB9XG59XTtcbmZ1bmN0aW9uIGdldE1hdGNoKGV4cCwgdWEpIHtcbiAgbGV0IGlkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICBjb25zdCBtYXRjaCA9IHVhLm1hdGNoKGV4cCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPj0gaWQgJiYgbWF0Y2hbaWRdIHx8ICcnO1xufVxuXG52YXIgdmVyc2lvbiQxID0gXCIxLjE1LjEwXCI7XG5cbmNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uJDE7XG5jb25zdCBwcm90b2NvbFZlcnNpb24gPSAxMTtcblxuLyoqXG4gKiBUaW1lcnMgdGhhdCBjYW4gYmUgb3ZlcnJpZGRlbiB3aXRoIHBsYXRmb3JtIHNwZWNpZmljIGltcGxlbWVudGF0aW9uc1xuICogdGhhdCBlbnN1cmUgdGhhdCB0aGV5IGFyZSBmaXJlZC4gVGhlc2Ugc2hvdWxkIGJlIHVzZWQgd2hlbiBpdCBpcyBjcml0aWNhbFxuICogdGhhdCB0aGUgdGltZXIgZmlyZXMgb24gdGltZS5cbiAqL1xuY2xhc3MgQ3JpdGljYWxUaW1lcnMge31cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8taW1wbGllZC1ldmFsXG5Dcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gc2V0VGltZW91dCguLi5hcmd1bWVudHMpO1xufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8taW1wbGllZC1ldmFsXG5Dcml0aWNhbFRpbWVycy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHNldEludGVydmFsKC4uLmFyZ3VtZW50cyk7XG59O1xuQ3JpdGljYWxUaW1lcnMuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2xlYXJUaW1lb3V0KC4uLmFyZ3VtZW50cyk7XG59O1xuQ3JpdGljYWxUaW1lcnMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNsZWFySW50ZXJ2YWwoLi4uYXJndW1lbnRzKTtcbn07XG5cbmNsYXNzIFZpZGVvUHJlc2V0IHtcbiAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgbWF4Qml0cmF0ZSwgbWF4RnJhbWVyYXRlLCBwcmlvcml0eSkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmVuY29kaW5nID0ge1xuICAgICAgbWF4Qml0cmF0ZSxcbiAgICAgIG1heEZyYW1lcmF0ZSxcbiAgICAgIHByaW9yaXR5XG4gICAgfTtcbiAgfVxuICBnZXQgcmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgZnJhbWVSYXRlOiB0aGlzLmVuY29kaW5nLm1heEZyYW1lcmF0ZSxcbiAgICAgIGFzcGVjdFJhdGlvOiB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHRcbiAgICB9O1xuICB9XG59XG5jb25zdCBiYWNrdXBDb2RlY3MgPSBbJ3ZwOCcsICdoMjY0J107XG5jb25zdCB2aWRlb0NvZGVjcyA9IFsndnA4JywgJ2gyNjQnLCAndnA5JywgJ2F2MSddO1xuZnVuY3Rpb24gaXNCYWNrdXBDb2RlYyhjb2RlYykge1xuICByZXR1cm4gISFiYWNrdXBDb2RlY3MuZmluZChiYWNrdXAgPT4gYmFja3VwID09PSBjb2RlYyk7XG59XG52YXIgQXVkaW9QcmVzZXRzO1xuKGZ1bmN0aW9uIChBdWRpb1ByZXNldHMpIHtcbiAgQXVkaW9QcmVzZXRzLnRlbGVwaG9uZSA9IHtcbiAgICBtYXhCaXRyYXRlOiAxMjAwMFxuICB9O1xuICBBdWRpb1ByZXNldHMuc3BlZWNoID0ge1xuICAgIG1heEJpdHJhdGU6IDIwMDAwXG4gIH07XG4gIEF1ZGlvUHJlc2V0cy5tdXNpYyA9IHtcbiAgICBtYXhCaXRyYXRlOiAzMjAwMFxuICB9O1xuICBBdWRpb1ByZXNldHMubXVzaWNTdGVyZW8gPSB7XG4gICAgbWF4Qml0cmF0ZTogNDgwMDBcbiAgfTtcbiAgQXVkaW9QcmVzZXRzLm11c2ljSGlnaFF1YWxpdHkgPSB7XG4gICAgbWF4Qml0cmF0ZTogNjQwMDBcbiAgfTtcbiAgQXVkaW9QcmVzZXRzLm11c2ljSGlnaFF1YWxpdHlTdGVyZW8gPSB7XG4gICAgbWF4Qml0cmF0ZTogOTYwMDBcbiAgfTtcbn0pKEF1ZGlvUHJlc2V0cyB8fCAoQXVkaW9QcmVzZXRzID0ge30pKTtcbi8qKlxuICogU2FuZSBwcmVzZXRzIGZvciB2aWRlbyByZXNvbHV0aW9uL2VuY29kaW5nXG4gKi9cbmNvbnN0IFZpZGVvUHJlc2V0cyA9IHtcbiAgaDkwOiBuZXcgVmlkZW9QcmVzZXQoMTYwLCA5MCwgOTAwMDAsIDIwKSxcbiAgaDE4MDogbmV3IFZpZGVvUHJlc2V0KDMyMCwgMTgwLCAxNjAwMDAsIDIwKSxcbiAgaDIxNjogbmV3IFZpZGVvUHJlc2V0KDM4NCwgMjE2LCAxODAwMDAsIDIwKSxcbiAgaDM2MDogbmV3IFZpZGVvUHJlc2V0KDY0MCwgMzYwLCA0NTAwMDAsIDIwKSxcbiAgaDU0MDogbmV3IFZpZGVvUHJlc2V0KDk2MCwgNTQwLCA4MDAwMDAsIDI1KSxcbiAgaDcyMDogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgMTcwMDAwMCwgMzApLFxuICBoMTA4MDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDEwODAsIDMwMDAwMDAsIDMwKSxcbiAgaDE0NDA6IG5ldyBWaWRlb1ByZXNldCgyNTYwLCAxNDQwLCA1MDAwMDAwLCAzMCksXG4gIGgyMTYwOiBuZXcgVmlkZW9QcmVzZXQoMzg0MCwgMjE2MCwgODAwMDAwMCwgMzApXG59O1xuLyoqXG4gKiBGb3VyIGJ5IHRocmVlIHByZXNldHNcbiAqL1xuY29uc3QgVmlkZW9QcmVzZXRzNDMgPSB7XG4gIGgxMjA6IG5ldyBWaWRlb1ByZXNldCgxNjAsIDEyMCwgNzAwMDAsIDIwKSxcbiAgaDE4MDogbmV3IFZpZGVvUHJlc2V0KDI0MCwgMTgwLCAxMjUwMDAsIDIwKSxcbiAgaDI0MDogbmV3IFZpZGVvUHJlc2V0KDMyMCwgMjQwLCAxNDAwMDAsIDIwKSxcbiAgaDM2MDogbmV3IFZpZGVvUHJlc2V0KDQ4MCwgMzYwLCAzMzAwMDAsIDIwKSxcbiAgaDQ4MDogbmV3IFZpZGVvUHJlc2V0KDY0MCwgNDgwLCA1MDAwMDAsIDIwKSxcbiAgaDU0MDogbmV3IFZpZGVvUHJlc2V0KDcyMCwgNTQwLCA2MDAwMDAsIDI1KSxcbiAgaDcyMDogbmV3IFZpZGVvUHJlc2V0KDk2MCwgNzIwLCAxMzAwMDAwLCAzMCksXG4gIGgxMDgwOiBuZXcgVmlkZW9QcmVzZXQoMTQ0MCwgMTA4MCwgMjMwMDAwMCwgMzApLFxuICBoMTQ0MDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDE0NDAsIDM4MDAwMDAsIDMwKVxufTtcbmNvbnN0IFNjcmVlblNoYXJlUHJlc2V0cyA9IHtcbiAgaDM2MGZwczM6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDM2MCwgMjAwMDAwLCAzLCAnbWVkaXVtJyksXG4gIGgzNjBmcHMxNTogbmV3IFZpZGVvUHJlc2V0KDY0MCwgMzYwLCA0MDAwMDAsIDE1LCAnbWVkaXVtJyksXG4gIGg3MjBmcHM1OiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCA4MDAwMDAsIDUsICdtZWRpdW0nKSxcbiAgaDcyMGZwczE1OiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCAxNTAwMDAwLCAxNSwgJ21lZGl1bScpLFxuICBoNzIwZnBzMzA6IG5ldyBWaWRlb1ByZXNldCgxMjgwLCA3MjAsIDIwMDAwMDAsIDMwLCAnbWVkaXVtJyksXG4gIGgxMDgwZnBzMTU6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxMDgwLCAyNTAwMDAwLCAxNSwgJ21lZGl1bScpLFxuICBoMTA4MGZwczMwOiBuZXcgVmlkZW9QcmVzZXQoMTkyMCwgMTA4MCwgNTAwMDAwMCwgMzAsICdtZWRpdW0nKSxcbiAgLy8gb3JpZ2luYWwgcmVzb2x1dGlvbiwgd2l0aG91dCByZXNpemluZ1xuICBvcmlnaW5hbDogbmV3IFZpZGVvUHJlc2V0KDAsIDAsIDcwMDAwMDAsIDMwLCAnbWVkaXVtJylcbn07XG5cbi8vIENvcHlyaWdodCAyMDIzIExpdmVLaXQsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuU2lnbmFsVGFyZ2V0XG4gKi9cbnZhciBTaWduYWxUYXJnZXQ7XG4oZnVuY3Rpb24gKFNpZ25hbFRhcmdldCkge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFBVQkxJU0hFUiA9IDA7XG4gICAqL1xuICBTaWduYWxUYXJnZXRbU2lnbmFsVGFyZ2V0W1wiUFVCTElTSEVSXCJdID0gMF0gPSBcIlBVQkxJU0hFUlwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNVQlNDUklCRVIgPSAxO1xuICAgKi9cbiAgU2lnbmFsVGFyZ2V0W1NpZ25hbFRhcmdldFtcIlNVQlNDUklCRVJcIl0gPSAxXSA9IFwiU1VCU0NSSUJFUlwiO1xufSkoU2lnbmFsVGFyZ2V0IHx8IChTaWduYWxUYXJnZXQgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoU2lnbmFsVGFyZ2V0KVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoU2lnbmFsVGFyZ2V0LCBcImxpdmVraXQuU2lnbmFsVGFyZ2V0XCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlBVQkxJU0hFUlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlNVQlNDUklCRVJcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlN0cmVhbVN0YXRlXG4gKi9cbnZhciBTdHJlYW1TdGF0ZTtcbihmdW5jdGlvbiAoU3RyZWFtU3RhdGUpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBBQ1RJVkUgPSAwO1xuICAgKi9cbiAgU3RyZWFtU3RhdGVbU3RyZWFtU3RhdGVbXCJBQ1RJVkVcIl0gPSAwXSA9IFwiQUNUSVZFXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUEFVU0VEID0gMTtcbiAgICovXG4gIFN0cmVhbVN0YXRlW1N0cmVhbVN0YXRlW1wiUEFVU0VEXCJdID0gMV0gPSBcIlBBVVNFRFwiO1xufSkoU3RyZWFtU3RhdGUgfHwgKFN0cmVhbVN0YXRlID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFN0cmVhbVN0YXRlKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoU3RyZWFtU3RhdGUsIFwibGl2ZWtpdC5TdHJlYW1TdGF0ZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJBQ1RJVkVcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJQQVVTRURcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkNhbmRpZGF0ZVByb3RvY29sXG4gKi9cbnZhciBDYW5kaWRhdGVQcm90b2NvbDtcbihmdW5jdGlvbiAoQ2FuZGlkYXRlUHJvdG9jb2wpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBVRFAgPSAwO1xuICAgKi9cbiAgQ2FuZGlkYXRlUHJvdG9jb2xbQ2FuZGlkYXRlUHJvdG9jb2xbXCJVRFBcIl0gPSAwXSA9IFwiVURQXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVENQID0gMTtcbiAgICovXG4gIENhbmRpZGF0ZVByb3RvY29sW0NhbmRpZGF0ZVByb3RvY29sW1wiVENQXCJdID0gMV0gPSBcIlRDUFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFRMUyA9IDI7XG4gICAqL1xuICBDYW5kaWRhdGVQcm90b2NvbFtDYW5kaWRhdGVQcm90b2NvbFtcIlRMU1wiXSA9IDJdID0gXCJUTFNcIjtcbn0pKENhbmRpZGF0ZVByb3RvY29sIHx8IChDYW5kaWRhdGVQcm90b2NvbCA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShDYW5kaWRhdGVQcm90b2NvbClcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKENhbmRpZGF0ZVByb3RvY29sLCBcImxpdmVraXQuQ2FuZGlkYXRlUHJvdG9jb2xcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiVURQXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiVENQXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiVExTXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TaWduYWxSZXF1ZXN0XG4gKi9cbmNsYXNzIFNpZ25hbFJlcXVlc3QgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIG9uZW9mIGxpdmVraXQuU2lnbmFsUmVxdWVzdC5tZXNzYWdlXG4gICAgICovXG4gICAgdGhpcy5tZXNzYWdlID0ge1xuICAgICAgY2FzZTogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2lnbmFsUmVxdWVzdCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNpZ25hbFJlcXVlc3QoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaWduYWxSZXF1ZXN0KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTaWduYWxSZXF1ZXN0LCBhLCBiKTtcbiAgfVxufVxuU2lnbmFsUmVxdWVzdC5ydW50aW1lID0gcHJvdG8zO1xuU2lnbmFsUmVxdWVzdC50eXBlTmFtZSA9IFwibGl2ZWtpdC5TaWduYWxSZXF1ZXN0XCI7XG5TaWduYWxSZXF1ZXN0LmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJvZmZlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiYW5zd2VyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb24sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJ0cmlja2xlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmlja2xlUmVxdWVzdCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImFkZF90cmFja1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQWRkVHJhY2tSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwibXV0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogTXV0ZVRyYWNrUmVxdWVzdCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInN1YnNjcmlwdGlvblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXBkYXRlU3Vic2NyaXB0aW9uLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwidHJhY2tfc2V0dGluZ1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXBkYXRlVHJhY2tTZXR0aW5ncyxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcImxlYXZlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBMZWF2ZVJlcXVlc3QsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwidXBkYXRlX2xheWVyc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXBkYXRlVmlkZW9MYXllcnMsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwic3Vic2NyaXB0aW9uX3Blcm1pc3Npb25cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmlwdGlvblBlcm1pc3Npb24sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwic3luY19zdGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3luY1N0YXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcInNpbXVsYXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTaW11bGF0ZVNjZW5hcmlvLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcInBpbmdcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE1LFxuICBuYW1lOiBcInVwZGF0ZV9tZXRhZGF0YVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNixcbiAgbmFtZTogXCJwaW5nX3JlcVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUGluZyxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU2lnbmFsUmVzcG9uc2VcbiAqL1xuY2xhc3MgU2lnbmFsUmVzcG9uc2UgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIG9uZW9mIGxpdmVraXQuU2lnbmFsUmVzcG9uc2UubWVzc2FnZVxuICAgICAqL1xuICAgIHRoaXMubWVzc2FnZSA9IHtcbiAgICAgIGNhc2U6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNpZ25hbFJlc3BvbnNlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2lnbmFsUmVzcG9uc2UoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaWduYWxSZXNwb25zZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU2lnbmFsUmVzcG9uc2UsIGEsIGIpO1xuICB9XG59XG5TaWduYWxSZXNwb25zZS5ydW50aW1lID0gcHJvdG8zO1xuU2lnbmFsUmVzcG9uc2UudHlwZU5hbWUgPSBcImxpdmVraXQuU2lnbmFsUmVzcG9uc2VcIjtcblNpZ25hbFJlc3BvbnNlLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJqb2luXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBKb2luUmVzcG9uc2UsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJhbnN3ZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvbixcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIm9mZmVyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb24sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJ0cmlja2xlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmlja2xlUmVxdWVzdCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInVwZGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUGFydGljaXBhbnRVcGRhdGUsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJ0cmFja19wdWJsaXNoZWRcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJsZWF2ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogTGVhdmVSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwibXV0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogTXV0ZVRyYWNrUmVxdWVzdCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJzcGVha2Vyc19jaGFuZ2VkXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTcGVha2Vyc0NoYW5nZWQsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwicm9vbV91cGRhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJvb21VcGRhdGUsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwiY29ubmVjdGlvbl9xdWFsaXR5XCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJzdHJlYW1fc3RhdGVfdXBkYXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdHJlYW1TdGF0ZVVwZGF0ZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNCxcbiAgbmFtZTogXCJzdWJzY3JpYmVkX3F1YWxpdHlfdXBkYXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJzdWJzY3JpcHRpb25fcGVybWlzc2lvbl91cGRhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTYsXG4gIG5hbWU6IFwicmVmcmVzaF90b2tlblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE3LFxuICBuYW1lOiBcInRyYWNrX3VucHVibGlzaGVkXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFja1VucHVibGlzaGVkUmVzcG9uc2UsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTgsXG4gIG5hbWU6IFwicG9uZ1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi8sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTksXG4gIG5hbWU6IFwicmVjb25uZWN0XCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSZWNvbm5lY3RSZXNwb25zZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAyMCxcbiAgbmFtZTogXCJwb25nX3Jlc3BcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBvbmcsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMjEsXG4gIG5hbWU6IFwic3Vic2NyaXB0aW9uX3Jlc3BvbnNlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdWJzY3JpcHRpb25SZXNwb25zZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU2ltdWxjYXN0Q29kZWNcbiAqL1xuY2xhc3MgU2ltdWxjYXN0Q29kZWMgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgY29kZWMgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuY29kZWMgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGNpZCA9IDI7XG4gICAgICovXG4gICAgdGhpcy5jaWQgPSBcIlwiO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGNhc3RDb2RlYygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNpbXVsY2FzdENvZGVjKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2ltdWxjYXN0Q29kZWMoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFNpbXVsY2FzdENvZGVjLCBhLCBiKTtcbiAgfVxufVxuU2ltdWxjYXN0Q29kZWMucnVudGltZSA9IHByb3RvMztcblNpbXVsY2FzdENvZGVjLnR5cGVOYW1lID0gXCJsaXZla2l0LlNpbXVsY2FzdENvZGVjXCI7XG5TaW11bGNhc3RDb2RlYy5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY29kZWNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJjaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkFkZFRyYWNrUmVxdWVzdFxuICovXG5jbGFzcyBBZGRUcmFja1JlcXVlc3QgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogY2xpZW50IElEIG9mIHRyYWNrLCB0byBtYXRjaCBpdCB3aGVuIFJUQyB0cmFjayBpcyByZWNlaXZlZFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgY2lkID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmNpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbmFtZSA9IDI7XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVHJhY2tUeXBlIHR5cGUgPSAzO1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IFRyYWNrVHlwZS5BVURJTztcbiAgICAvKipcbiAgICAgKiB0byBiZSBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGxheWVyc1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgd2lkdGggPSA0O1xuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGhlaWdodCA9IDU7XG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIC8qKlxuICAgICAqIHRydWUgdG8gYWRkIHRyYWNrIGFuZCBpbml0aWFsaXplIHRvIG11dGVkXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgbXV0ZWQgPSA2O1xuICAgICAqL1xuICAgIHRoaXMubXV0ZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIERUWCAoRGlzY29udGludW91cyBUcmFuc21pc3Npb24pIGlzIGRpc2FibGVkIGZvciBhdWRpb1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGRpc2FibGVfZHR4ID0gNztcbiAgICAgKi9cbiAgICB0aGlzLmRpc2FibGVEdHggPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVHJhY2tTb3VyY2Ugc291cmNlID0gODtcbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZSA9IFRyYWNrU291cmNlLlVOS05PV047XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlZpZGVvTGF5ZXIgbGF5ZXJzID0gOTtcbiAgICAgKi9cbiAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5TaW11bGNhc3RDb2RlYyBzaW11bGNhc3RfY29kZWNzID0gMTA7XG4gICAgICovXG4gICAgdGhpcy5zaW11bGNhc3RDb2RlY3MgPSBbXTtcbiAgICAvKipcbiAgICAgKiBzZXJ2ZXIgSUQgb2YgdHJhY2ssIHB1Ymxpc2ggbmV3IGNvZGVjIHRvIGV4aXN0IHRyYWNrXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzaWQgPSAxMTtcbiAgICAgKi9cbiAgICB0aGlzLnNpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIHN0ZXJlbyA9IDEyO1xuICAgICAqL1xuICAgIHRoaXMuc3RlcmVvID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiBSRUQgKFJlZHVuZGFudCBFbmNvZGluZykgaXMgZGlzYWJsZWQgZm9yIGF1ZGlvXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgZGlzYWJsZV9yZWQgPSAxMztcbiAgICAgKi9cbiAgICB0aGlzLmRpc2FibGVSZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuRW5jcnlwdGlvbi5UeXBlIGVuY3J5cHRpb24gPSAxNDtcbiAgICAgKi9cbiAgICB0aGlzLmVuY3J5cHRpb24gPSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcbiAgICAvKipcbiAgICAgKiB3aGljaCBzdHJlYW0gdGhlIHRyYWNrIGJlbG9uZ3MgdG8sIHVzZWQgdG8gZ3JvdXAgdHJhY2tzIHRvZ2V0aGVyLlxuICAgICAqIGlmIG5vdCBzcGVjaWZpZWQsIHNlcnZlciB3aWxsIGluZmVyIGl0IGZyb20gdHJhY2sgc291cmNlIHRvIGJ1bmRsZSBjYW1lcmEvbWljcm9waG9uZSwgc2NyZWVuc2hhcmUvYXVkaW8gdG9nZXRoZXJcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHN0cmVhbSA9IDE1O1xuICAgICAqL1xuICAgIHRoaXMuc3RyZWFtID0gXCJcIjtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQWRkVHJhY2tSZXF1ZXN0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQWRkVHJhY2tSZXF1ZXN0KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQWRkVHJhY2tSZXF1ZXN0KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhBZGRUcmFja1JlcXVlc3QsIGEsIGIpO1xuICB9XG59XG5BZGRUcmFja1JlcXVlc3QucnVudGltZSA9IHByb3RvMztcbkFkZFRyYWNrUmVxdWVzdC50eXBlTmFtZSA9IFwibGl2ZWtpdC5BZGRUcmFja1JlcXVlc3RcIjtcbkFkZFRyYWNrUmVxdWVzdC5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInR5cGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1R5cGUpXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIndpZHRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImhlaWdodFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJtdXRlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJkaXNhYmxlX2R0eFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJzb3VyY2VcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1NvdXJjZSlcbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwibGF5ZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBWaWRlb0xheWVyLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwic2ltdWxjYXN0X2NvZGVjc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2ltdWxjYXN0Q29kZWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJzaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwic3RlcmVvXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJkaXNhYmxlX3JlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwiZW5jcnlwdGlvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEVuY3J5cHRpb25fVHlwZSlcbn0sIHtcbiAgbm86IDE1LFxuICBuYW1lOiBcInN0cmVhbVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVHJpY2tsZVJlcXVlc3RcbiAqL1xuY2xhc3MgVHJpY2tsZVJlcXVlc3QgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgY2FuZGlkYXRlSW5pdCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5jYW5kaWRhdGVJbml0ID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuU2lnbmFsVGFyZ2V0IHRhcmdldCA9IDI7XG4gICAgICovXG4gICAgdGhpcy50YXJnZXQgPSBTaWduYWxUYXJnZXQuUFVCTElTSEVSO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmlja2xlUmVxdWVzdCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRyaWNrbGVSZXF1ZXN0KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJpY2tsZVJlcXVlc3QoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFRyaWNrbGVSZXF1ZXN0LCBhLCBiKTtcbiAgfVxufVxuVHJpY2tsZVJlcXVlc3QucnVudGltZSA9IHByb3RvMztcblRyaWNrbGVSZXF1ZXN0LnR5cGVOYW1lID0gXCJsaXZla2l0LlRyaWNrbGVSZXF1ZXN0XCI7XG5Ucmlja2xlUmVxdWVzdC5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY2FuZGlkYXRlSW5pdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRhcmdldFwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFNpZ25hbFRhcmdldClcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5NdXRlVHJhY2tSZXF1ZXN0XG4gKi9cbmNsYXNzIE11dGVUcmFja1JlcXVlc3QgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc2lkID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnNpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIG11dGVkID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLm11dGVkID0gZmFsc2U7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE11dGVUcmFja1JlcXVlc3QoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBNdXRlVHJhY2tSZXF1ZXN0KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTXV0ZVRyYWNrUmVxdWVzdCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoTXV0ZVRyYWNrUmVxdWVzdCwgYSwgYik7XG4gIH1cbn1cbk11dGVUcmFja1JlcXVlc3QucnVudGltZSA9IHByb3RvMztcbk11dGVUcmFja1JlcXVlc3QudHlwZU5hbWUgPSBcImxpdmVraXQuTXV0ZVRyYWNrUmVxdWVzdFwiO1xuTXV0ZVRyYWNrUmVxdWVzdC5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibXV0ZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5Kb2luUmVzcG9uc2VcbiAqL1xuY2xhc3MgSm9pblJlc3BvbnNlIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5QYXJ0aWNpcGFudEluZm8gb3RoZXJfcGFydGljaXBhbnRzID0gMztcbiAgICAgKi9cbiAgICB0aGlzLm90aGVyUGFydGljaXBhbnRzID0gW107XG4gICAgLyoqXG4gICAgICogZGVwcmVjYXRlZC4gdXNlIHNlcnZlcl9pbmZvLnZlcnNpb24gaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHNlcnZlcl92ZXJzaW9uID0gNDtcbiAgICAgKi9cbiAgICB0aGlzLnNlcnZlclZlcnNpb24gPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5JQ0VTZXJ2ZXIgaWNlX3NlcnZlcnMgPSA1O1xuICAgICAqL1xuICAgIHRoaXMuaWNlU2VydmVycyA9IFtdO1xuICAgIC8qKlxuICAgICAqIHVzZSBzdWJzY3JpYmVyIGFzIHRoZSBwcmltYXJ5IFBlZXJDb25uZWN0aW9uXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgc3Vic2NyaWJlcl9wcmltYXJ5ID0gNjtcbiAgICAgKi9cbiAgICB0aGlzLnN1YnNjcmliZXJQcmltYXJ5ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogd2hlbiB0aGUgY3VycmVudCBzZXJ2ZXIgaXNuJ3QgYXZhaWxhYmxlLCByZXR1cm4gYWx0ZXJuYXRlIHVybCB0byByZXRyeSBjb25uZWN0aW9uXG4gICAgICogd2hlbiB0aGlzIGlzIHNldCwgdGhlIG90aGVyIGZpZWxkcyB3aWxsIGJlIGxhcmdlbHkgZW1wdHlcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGFsdGVybmF0aXZlX3VybCA9IDc7XG4gICAgICovXG4gICAgdGhpcy5hbHRlcm5hdGl2ZVVybCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogZGVwcmVjYXRlZC4gdXNlIHNlcnZlcl9pbmZvLnJlZ2lvbiBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc2VydmVyX3JlZ2lvbiA9IDk7XG4gICAgICovXG4gICAgdGhpcy5zZXJ2ZXJSZWdpb24gPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgcGluZ190aW1lb3V0ID0gMTA7XG4gICAgICovXG4gICAgdGhpcy5waW5nVGltZW91dCA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQzMiBwaW5nX2ludGVydmFsID0gMTE7XG4gICAgICovXG4gICAgdGhpcy5waW5nSW50ZXJ2YWwgPSAwO1xuICAgIC8qKlxuICAgICAqIFNlcnZlci1JbmplY3RlZC1GcmFtZSBieXRlIHRyYWlsZXIsIHVzZWQgdG8gaWRlbnRpZnkgdW5lbmNyeXB0ZWQgZnJhbWVzIHdoZW4gZTJlZSBpcyBlbmFibGVkXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJ5dGVzIHNpZl90cmFpbGVyID0gMTM7XG4gICAgICovXG4gICAgdGhpcy5zaWZUcmFpbGVyID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEpvaW5SZXNwb25zZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEpvaW5SZXNwb25zZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEpvaW5SZXNwb25zZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoSm9pblJlc3BvbnNlLCBhLCBiKTtcbiAgfVxufVxuSm9pblJlc3BvbnNlLnJ1bnRpbWUgPSBwcm90bzM7XG5Kb2luUmVzcG9uc2UudHlwZU5hbWUgPSBcImxpdmVraXQuSm9pblJlc3BvbnNlXCI7XG5Kb2luUmVzcG9uc2UuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInJvb21cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJvb20kMVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJwYXJ0aWNpcGFudFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUGFydGljaXBhbnRJbmZvXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIm90aGVyX3BhcnRpY2lwYW50c1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUGFydGljaXBhbnRJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJzZXJ2ZXJfdmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImljZV9zZXJ2ZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBJQ0VTZXJ2ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInN1YnNjcmliZXJfcHJpbWFyeVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJhbHRlcm5hdGl2ZV91cmxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJjbGllbnRfY29uZmlndXJhdGlvblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ2xpZW50Q29uZmlndXJhdGlvblxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJzZXJ2ZXJfcmVnaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcInBpbmdfdGltZW91dFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcInBpbmdfaW50ZXJ2YWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJzZXJ2ZXJfaW5mb1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2VydmVySW5mb1xufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwic2lmX3RyYWlsZXJcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTIgLyogU2NhbGFyVHlwZS5CWVRFUyAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJlY29ubmVjdFJlc3BvbnNlXG4gKi9cbmNsYXNzIFJlY29ubmVjdFJlc3BvbnNlIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5JQ0VTZXJ2ZXIgaWNlX3NlcnZlcnMgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuaWNlU2VydmVycyA9IFtdO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSZWNvbm5lY3RSZXNwb25zZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJlY29ubmVjdFJlc3BvbnNlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUmVjb25uZWN0UmVzcG9uc2UoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFJlY29ubmVjdFJlc3BvbnNlLCBhLCBiKTtcbiAgfVxufVxuUmVjb25uZWN0UmVzcG9uc2UucnVudGltZSA9IHByb3RvMztcblJlY29ubmVjdFJlc3BvbnNlLnR5cGVOYW1lID0gXCJsaXZla2l0LlJlY29ubmVjdFJlc3BvbnNlXCI7XG5SZWNvbm5lY3RSZXNwb25zZS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiaWNlX3NlcnZlcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IElDRVNlcnZlcixcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiY2xpZW50X2NvbmZpZ3VyYXRpb25cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENsaWVudENvbmZpZ3VyYXRpb25cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5UcmFja1B1Ymxpc2hlZFJlc3BvbnNlXG4gKi9cbmNsYXNzIFRyYWNrUHVibGlzaGVkUmVzcG9uc2UgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgY2lkID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmNpZCA9IFwiXCI7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJhY2tQdWJsaXNoZWRSZXNwb25zZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVHJhY2tQdWJsaXNoZWRSZXNwb25zZSwgYSwgYik7XG4gIH1cbn1cblRyYWNrUHVibGlzaGVkUmVzcG9uc2UucnVudGltZSA9IHByb3RvMztcblRyYWNrUHVibGlzaGVkUmVzcG9uc2UudHlwZU5hbWUgPSBcImxpdmVraXQuVHJhY2tQdWJsaXNoZWRSZXNwb25zZVwiO1xuVHJhY2tQdWJsaXNoZWRSZXNwb25zZS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHJhY2tcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyYWNrSW5mb1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZVxuICovXG5jbGFzcyBUcmFja1VucHVibGlzaGVkUmVzcG9uc2UgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdHJhY2tfc2lkID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrU2lkID0gXCJcIjtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhUcmFja1VucHVibGlzaGVkUmVzcG9uc2UsIGEsIGIpO1xuICB9XG59XG5UcmFja1VucHVibGlzaGVkUmVzcG9uc2UucnVudGltZSA9IHByb3RvMztcblRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZS50eXBlTmFtZSA9IFwibGl2ZWtpdC5UcmFja1VucHVibGlzaGVkUmVzcG9uc2VcIjtcblRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TZXNzaW9uRGVzY3JpcHRpb25cbiAqL1xuY2xhc3MgU2Vzc2lvbkRlc2NyaXB0aW9uIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIFwiYW5zd2VyXCIgfCBcIm9mZmVyXCIgfCBcInByYW5zd2VyXCIgfCBcInJvbGxiYWNrXCJcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHR5cGUgPSAxO1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc2RwID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnNkcCA9IFwiXCI7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNlc3Npb25EZXNjcmlwdGlvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNlc3Npb25EZXNjcmlwdGlvbigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNlc3Npb25EZXNjcmlwdGlvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU2Vzc2lvbkRlc2NyaXB0aW9uLCBhLCBiKTtcbiAgfVxufVxuU2Vzc2lvbkRlc2NyaXB0aW9uLnJ1bnRpbWUgPSBwcm90bzM7XG5TZXNzaW9uRGVzY3JpcHRpb24udHlwZU5hbWUgPSBcImxpdmVraXQuU2Vzc2lvbkRlc2NyaXB0aW9uXCI7XG5TZXNzaW9uRGVzY3JpcHRpb24uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInR5cGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJzZHBcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlBhcnRpY2lwYW50VXBkYXRlXG4gKi9cbmNsYXNzIFBhcnRpY2lwYW50VXBkYXRlIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5QYXJ0aWNpcGFudEluZm8gcGFydGljaXBhbnRzID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnBhcnRpY2lwYW50cyA9IFtdO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aWNpcGFudFVwZGF0ZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50VXBkYXRlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRVcGRhdGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFBhcnRpY2lwYW50VXBkYXRlLCBhLCBiKTtcbiAgfVxufVxuUGFydGljaXBhbnRVcGRhdGUucnVudGltZSA9IHByb3RvMztcblBhcnRpY2lwYW50VXBkYXRlLnR5cGVOYW1lID0gXCJsaXZla2l0LlBhcnRpY2lwYW50VXBkYXRlXCI7XG5QYXJ0aWNpcGFudFVwZGF0ZS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQYXJ0aWNpcGFudEluZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVXBkYXRlU3Vic2NyaXB0aW9uXG4gKi9cbmNsYXNzIFVwZGF0ZVN1YnNjcmlwdGlvbiBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIHN0cmluZyB0cmFja19zaWRzID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrU2lkcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBzdWJzY3JpYmUgPSAyO1xuICAgICAqL1xuICAgIHRoaXMuc3Vic2NyaWJlID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlBhcnRpY2lwYW50VHJhY2tzIHBhcnRpY2lwYW50X3RyYWNrcyA9IDM7XG4gICAgICovXG4gICAgdGhpcy5wYXJ0aWNpcGFudFRyYWNrcyA9IFtdO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVTdWJzY3JpcHRpb24oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVTdWJzY3JpcHRpb24oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVTdWJzY3JpcHRpb24oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFVwZGF0ZVN1YnNjcmlwdGlvbiwgYSwgYik7XG4gIH1cbn1cblVwZGF0ZVN1YnNjcmlwdGlvbi5ydW50aW1lID0gcHJvdG8zO1xuVXBkYXRlU3Vic2NyaXB0aW9uLnR5cGVOYW1lID0gXCJsaXZla2l0LlVwZGF0ZVN1YnNjcmlwdGlvblwiO1xuVXBkYXRlU3Vic2NyaXB0aW9uLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInN1YnNjcmliZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF90cmFja3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBhcnRpY2lwYW50VHJhY2tzLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlVwZGF0ZVRyYWNrU2V0dGluZ3NcbiAqL1xuY2xhc3MgVXBkYXRlVHJhY2tTZXR0aW5ncyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIHN0cmluZyB0cmFja19zaWRzID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrU2lkcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIHdoZW4gdHJ1ZSwgdGhlIHRyYWNrIGlzIHBsYWNlZCBpbiBhIHBhdXNlZCBzdGF0ZSwgd2l0aCBubyBuZXcgZGF0YSByZXR1cm5lZFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGRpc2FibGVkID0gMztcbiAgICAgKi9cbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogZGVwcmVjYXRlZCBpbiBmYXZvciBvZiB3aWR0aCAmIGhlaWdodFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlZpZGVvUXVhbGl0eSBxdWFsaXR5ID0gNDtcbiAgICAgKi9cbiAgICB0aGlzLnF1YWxpdHkgPSBWaWRlb1F1YWxpdHkuTE9XO1xuICAgIC8qKlxuICAgICAqIGZvciB2aWRlbywgd2lkdGggdG8gcmVjZWl2ZVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgd2lkdGggPSA1O1xuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIC8qKlxuICAgICAqIGZvciB2aWRlbywgaGVpZ2h0IHRvIHJlY2VpdmVcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGhlaWdodCA9IDY7XG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGZwcyA9IDc7XG4gICAgICovXG4gICAgdGhpcy5mcHMgPSAwO1xuICAgIC8qKlxuICAgICAqIHN1YnNjcmlwdGlvbiBwcmlvcml0eS4gMSBiZWluZyB0aGUgaGlnaGVzdCAoMCBpcyB1bnNldClcbiAgICAgKiB3aGVuIHVuc2V0LCBzZXJ2ZXIgc2lsbCBhc3NpZ24gcHJpb3JpdHkgYmFzZWQgb24gdGhlIG9yZGVyIG9mIHN1YnNjcmlwdGlvblxuICAgICAqIHNlcnZlciB3aWxsIHVzZSBwcmlvcml0eSBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gICAgICogMS4gd2hlbiBzdWJzY3JpYmVkIHRyYWNrcyBleGNlZWQgcGVyLXBhcnRpY2lwYW50IHN1YnNjcmlwdGlvbiBsaW1pdCwgc2VydmVyIHdpbGxcbiAgICAgKiAgICBwYXVzZSB0aGUgbG93ZXN0IHByaW9yaXR5IHRyYWNrc1xuICAgICAqIDIuIHdoZW4gdGhlIG5ldHdvcmsgaXMgY29uZ2VzdGVkLCBzZXJ2ZXIgd2lsbCBhc3NpZ24gYXZhaWxhYmxlIGJhbmR3aWR0aCB0b1xuICAgICAqICAgIGhpZ2hlciBwcmlvcml0eSB0cmFja3MgZmlyc3QuIGxvd2VzdCBwcmlvcml0eSB0cmFja3MgY2FuIGJlIHBhdXNlZFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgcHJpb3JpdHkgPSA4O1xuICAgICAqL1xuICAgIHRoaXMucHJpb3JpdHkgPSAwO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVUcmFja1NldHRpbmdzKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVXBkYXRlVHJhY2tTZXR0aW5ncygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVRyYWNrU2V0dGluZ3MoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFVwZGF0ZVRyYWNrU2V0dGluZ3MsIGEsIGIpO1xuICB9XG59XG5VcGRhdGVUcmFja1NldHRpbmdzLnJ1bnRpbWUgPSBwcm90bzM7XG5VcGRhdGVUcmFja1NldHRpbmdzLnR5cGVOYW1lID0gXCJsaXZla2l0LlVwZGF0ZVRyYWNrU2V0dGluZ3NcIjtcblVwZGF0ZVRyYWNrU2V0dGluZ3MuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInRyYWNrX3NpZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZGlzYWJsZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwicXVhbGl0eVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSlcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwid2lkdGhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiaGVpZ2h0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImZwc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJwcmlvcml0eVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkxlYXZlUmVxdWVzdFxuICovXG5jbGFzcyBMZWF2ZVJlcXVlc3QgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogc2VudCB3aGVuIHNlcnZlciBpbml0aWF0ZXMgdGhlIGRpc2Nvbm5lY3QgZHVlIHRvIHNlcnZlci1yZXN0YXJ0XG4gICAgICogaW5kaWNhdGVzIGNsaWVudHMgc2hvdWxkIGF0dGVtcHQgZnVsbC1yZWNvbm5lY3Qgc2VxdWVuY2VcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBjYW5fcmVjb25uZWN0ID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmNhblJlY29ubmVjdCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5EaXNjb25uZWN0UmVhc29uIHJlYXNvbiA9IDI7XG4gICAgICovXG4gICAgdGhpcy5yZWFzb24gPSBEaXNjb25uZWN0UmVhc29uLlVOS05PV05fUkVBU09OO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBMZWF2ZVJlcXVlc3QoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBMZWF2ZVJlcXVlc3QoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBMZWF2ZVJlcXVlc3QoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKExlYXZlUmVxdWVzdCwgYSwgYik7XG4gIH1cbn1cbkxlYXZlUmVxdWVzdC5ydW50aW1lID0gcHJvdG8zO1xuTGVhdmVSZXF1ZXN0LnR5cGVOYW1lID0gXCJsaXZla2l0LkxlYXZlUmVxdWVzdFwiO1xuTGVhdmVSZXF1ZXN0LmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjYW5fcmVjb25uZWN0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInJlYXNvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKERpc2Nvbm5lY3RSZWFzb24pXG59XSk7XG4vKipcbiAqIG1lc3NhZ2UgdG8gaW5kaWNhdGUgcHVibGlzaGVkIHZpZGVvIHRyYWNrIGRpbWVuc2lvbnMgYXJlIGNoYW5naW5nXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5VcGRhdGVWaWRlb0xheWVyc1xuICovXG5jbGFzcyBVcGRhdGVWaWRlb0xheWVycyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB0cmFja19zaWQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMudHJhY2tTaWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5WaWRlb0xheWVyIGxheWVycyA9IDI7XG4gICAgICovXG4gICAgdGhpcy5sYXllcnMgPSBbXTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVXBkYXRlVmlkZW9MYXllcnMoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVWaWRlb0xheWVycygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVZpZGVvTGF5ZXJzKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhVcGRhdGVWaWRlb0xheWVycywgYSwgYik7XG4gIH1cbn1cblVwZGF0ZVZpZGVvTGF5ZXJzLnJ1bnRpbWUgPSBwcm90bzM7XG5VcGRhdGVWaWRlb0xheWVycy50eXBlTmFtZSA9IFwibGl2ZWtpdC5VcGRhdGVWaWRlb0xheWVyc1wiO1xuVXBkYXRlVmlkZW9MYXllcnMuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImxheWVyc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVmlkZW9MYXllcixcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5VcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhXG4gKi9cbmNsYXNzIFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbWV0YWRhdGEgPSAxO1xuICAgICAqL1xuICAgIHRoaXMubWV0YWRhdGEgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG5hbWUgPSAyO1xuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSwgYSwgYik7XG4gIH1cbn1cblVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEucnVudGltZSA9IHByb3RvMztcblVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEudHlwZU5hbWUgPSBcImxpdmVraXQuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YVwiO1xuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwibWV0YWRhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJuYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5JQ0VTZXJ2ZXJcbiAqL1xuY2xhc3MgSUNFU2VydmVyIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgc3RyaW5nIHVybHMgPSAxO1xuICAgICAqL1xuICAgIHRoaXMudXJscyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHVzZXJuYW1lID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnVzZXJuYW1lID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBjcmVkZW50aWFsID0gMztcbiAgICAgKi9cbiAgICB0aGlzLmNyZWRlbnRpYWwgPSBcIlwiO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBJQ0VTZXJ2ZXIoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBJQ0VTZXJ2ZXIoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBJQ0VTZXJ2ZXIoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKElDRVNlcnZlciwgYSwgYik7XG4gIH1cbn1cbklDRVNlcnZlci5ydW50aW1lID0gcHJvdG8zO1xuSUNFU2VydmVyLnR5cGVOYW1lID0gXCJsaXZla2l0LklDRVNlcnZlclwiO1xuSUNFU2VydmVyLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ1cmxzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInVzZXJuYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiY3JlZGVudGlhbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3BlYWtlcnNDaGFuZ2VkXG4gKi9cbmNsYXNzIFNwZWFrZXJzQ2hhbmdlZCBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuU3BlYWtlckluZm8gc3BlYWtlcnMgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuc3BlYWtlcnMgPSBbXTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3BlYWtlcnNDaGFuZ2VkKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3BlYWtlcnNDaGFuZ2VkKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3BlYWtlcnNDaGFuZ2VkKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTcGVha2Vyc0NoYW5nZWQsIGEsIGIpO1xuICB9XG59XG5TcGVha2Vyc0NoYW5nZWQucnVudGltZSA9IHByb3RvMztcblNwZWFrZXJzQ2hhbmdlZC50eXBlTmFtZSA9IFwibGl2ZWtpdC5TcGVha2Vyc0NoYW5nZWRcIjtcblNwZWFrZXJzQ2hhbmdlZC5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3BlYWtlcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNwZWFrZXJJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJvb21VcGRhdGVcbiAqL1xuY2xhc3MgUm9vbVVwZGF0ZSBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUm9vbVVwZGF0ZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJvb21VcGRhdGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSb29tVXBkYXRlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhSb29tVXBkYXRlLCBhLCBiKTtcbiAgfVxufVxuUm9vbVVwZGF0ZS5ydW50aW1lID0gcHJvdG8zO1xuUm9vbVVwZGF0ZS50eXBlTmFtZSA9IFwibGl2ZWtpdC5Sb29tVXBkYXRlXCI7XG5Sb29tVXBkYXRlLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJyb29tXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSb29tJDFcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eUluZm9cbiAqL1xuY2xhc3MgQ29ubmVjdGlvblF1YWxpdHlJbmZvIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHBhcnRpY2lwYW50X3NpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5wYXJ0aWNpcGFudFNpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5IHF1YWxpdHkgPSAyO1xuICAgICAqL1xuICAgIHRoaXMucXVhbGl0eSA9IENvbm5lY3Rpb25RdWFsaXR5JDEuUE9PUjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGZsb2F0IHNjb3JlID0gMztcbiAgICAgKi9cbiAgICB0aGlzLnNjb3JlID0gMDtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvblF1YWxpdHlJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvblF1YWxpdHlJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvblF1YWxpdHlJbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhDb25uZWN0aW9uUXVhbGl0eUluZm8sIGEsIGIpO1xuICB9XG59XG5Db25uZWN0aW9uUXVhbGl0eUluZm8ucnVudGltZSA9IHByb3RvMztcbkNvbm5lY3Rpb25RdWFsaXR5SW5mby50eXBlTmFtZSA9IFwibGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eUluZm9cIjtcbkNvbm5lY3Rpb25RdWFsaXR5SW5mby5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicXVhbGl0eVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENvbm5lY3Rpb25RdWFsaXR5JDEpXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInNjb3JlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDIgLyogU2NhbGFyVHlwZS5GTE9BVCAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlXG4gKi9cbmNsYXNzIENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eUluZm8gdXBkYXRlcyA9IDE7XG4gICAgICovXG4gICAgdGhpcy51cGRhdGVzID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsIGEsIGIpO1xuICB9XG59XG5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZS5ydW50aW1lID0gcHJvdG8zO1xuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUudHlwZU5hbWUgPSBcImxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGVcIjtcbkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ1cGRhdGVzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDb25uZWN0aW9uUXVhbGl0eUluZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3RyZWFtU3RhdGVJbmZvXG4gKi9cbmNsYXNzIFN0cmVhbVN0YXRlSW5mbyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBwYXJ0aWNpcGFudF9zaWQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMucGFydGljaXBhbnRTaWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHRyYWNrX3NpZCA9IDI7XG4gICAgICovXG4gICAgdGhpcy50cmFja1NpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlN0cmVhbVN0YXRlIHN0YXRlID0gMztcbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlID0gU3RyZWFtU3RhdGUuQUNUSVZFO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1TdGF0ZUluZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1TdGF0ZUluZm8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1TdGF0ZUluZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFN0cmVhbVN0YXRlSW5mbywgYSwgYik7XG4gIH1cbn1cblN0cmVhbVN0YXRlSW5mby5ydW50aW1lID0gcHJvdG8zO1xuU3RyZWFtU3RhdGVJbmZvLnR5cGVOYW1lID0gXCJsaXZla2l0LlN0cmVhbVN0YXRlSW5mb1wiO1xuU3RyZWFtU3RhdGVJbmZvLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJzdGF0ZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFN0cmVhbVN0YXRlKVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN0cmVhbVN0YXRlVXBkYXRlXG4gKi9cbmNsYXNzIFN0cmVhbVN0YXRlVXBkYXRlIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5TdHJlYW1TdGF0ZUluZm8gc3RyZWFtX3N0YXRlcyA9IDE7XG4gICAgICovXG4gICAgdGhpcy5zdHJlYW1TdGF0ZXMgPSBbXTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtU3RhdGVVcGRhdGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1TdGF0ZVVwZGF0ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVN0YXRlVXBkYXRlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTdHJlYW1TdGF0ZVVwZGF0ZSwgYSwgYik7XG4gIH1cbn1cblN0cmVhbVN0YXRlVXBkYXRlLnJ1bnRpbWUgPSBwcm90bzM7XG5TdHJlYW1TdGF0ZVVwZGF0ZS50eXBlTmFtZSA9IFwibGl2ZWtpdC5TdHJlYW1TdGF0ZVVwZGF0ZVwiO1xuU3RyZWFtU3RhdGVVcGRhdGUuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInN0cmVhbV9zdGF0ZXNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN0cmVhbVN0YXRlSW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eVxuICovXG5jbGFzcyBTdWJzY3JpYmVkUXVhbGl0eSBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVmlkZW9RdWFsaXR5IHF1YWxpdHkgPSAxO1xuICAgICAqL1xuICAgIHRoaXMucXVhbGl0eSA9IFZpZGVvUXVhbGl0eS5MT1c7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGVuYWJsZWQgPSAyO1xuICAgICAqL1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVkUXVhbGl0eSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZWRRdWFsaXR5KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlZFF1YWxpdHkoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFN1YnNjcmliZWRRdWFsaXR5LCBhLCBiKTtcbiAgfVxufVxuU3Vic2NyaWJlZFF1YWxpdHkucnVudGltZSA9IHByb3RvMztcblN1YnNjcmliZWRRdWFsaXR5LnR5cGVOYW1lID0gXCJsaXZla2l0LlN1YnNjcmliZWRRdWFsaXR5XCI7XG5TdWJzY3JpYmVkUXVhbGl0eS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicXVhbGl0eVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSlcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiZW5hYmxlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN1YnNjcmliZWRDb2RlY1xuICovXG5jbGFzcyBTdWJzY3JpYmVkQ29kZWMgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgY29kZWMgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuY29kZWMgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eSBxdWFsaXRpZXMgPSAyO1xuICAgICAqL1xuICAgIHRoaXMucXVhbGl0aWVzID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZWRDb2RlYygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZWRDb2RlYygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZWRDb2RlYygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3Vic2NyaWJlZENvZGVjLCBhLCBiKTtcbiAgfVxufVxuU3Vic2NyaWJlZENvZGVjLnJ1bnRpbWUgPSBwcm90bzM7XG5TdWJzY3JpYmVkQ29kZWMudHlwZU5hbWUgPSBcImxpdmVraXQuU3Vic2NyaWJlZENvZGVjXCI7XG5TdWJzY3JpYmVkQ29kZWMuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNvZGVjXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicXVhbGl0aWVzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdWJzY3JpYmVkUXVhbGl0eSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZVxuICovXG5jbGFzcyBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB0cmFja19zaWQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMudHJhY2tTaWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eSBzdWJzY3JpYmVkX3F1YWxpdGllcyA9IDI7XG4gICAgICovXG4gICAgdGhpcy5zdWJzY3JpYmVkUXVhbGl0aWVzID0gW107XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlN1YnNjcmliZWRDb2RlYyBzdWJzY3JpYmVkX2NvZGVjcyA9IDM7XG4gICAgICovXG4gICAgdGhpcy5zdWJzY3JpYmVkQ29kZWNzID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUsIGEsIGIpO1xuICB9XG59XG5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZS5ydW50aW1lID0gcHJvdG8zO1xuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUudHlwZU5hbWUgPSBcImxpdmVraXQuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGVcIjtcblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJzdWJzY3JpYmVkX3F1YWxpdGllc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaWJlZFF1YWxpdHksXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInN1YnNjcmliZWRfY29kZWNzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdWJzY3JpYmVkQ29kZWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVHJhY2tQZXJtaXNzaW9uXG4gKi9cbmNsYXNzIFRyYWNrUGVybWlzc2lvbiBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBwZXJtaXNzaW9uIGNvdWxkIGJlIGdyYW50ZWQgZWl0aGVyIGJ5IHBhcnRpY2lwYW50IHNpZCBvciBpZGVudGl0eVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcGFydGljaXBhbnRfc2lkID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnBhcnRpY2lwYW50U2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgYWxsX3RyYWNrcyA9IDI7XG4gICAgICovXG4gICAgdGhpcy5hbGxUcmFja3MgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIHN0cmluZyB0cmFja19zaWRzID0gMztcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrU2lkcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHBhcnRpY2lwYW50X2lkZW50aXR5ID0gNDtcbiAgICAgKi9cbiAgICB0aGlzLnBhcnRpY2lwYW50SWRlbnRpdHkgPSBcIlwiO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFja1Blcm1pc3Npb24oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFja1Blcm1pc3Npb24oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFja1Blcm1pc3Npb24oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFRyYWNrUGVybWlzc2lvbiwgYSwgYik7XG4gIH1cbn1cblRyYWNrUGVybWlzc2lvbi5ydW50aW1lID0gcHJvdG8zO1xuVHJhY2tQZXJtaXNzaW9uLnR5cGVOYW1lID0gXCJsaXZla2l0LlRyYWNrUGVybWlzc2lvblwiO1xuVHJhY2tQZXJtaXNzaW9uLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJhbGxfdHJhY2tzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInRyYWNrX3NpZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN1YnNjcmlwdGlvblBlcm1pc3Npb25cbiAqL1xuY2xhc3MgU3Vic2NyaXB0aW9uUGVybWlzc2lvbiBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgYWxsX3BhcnRpY2lwYW50cyA9IDE7XG4gICAgICovXG4gICAgdGhpcy5hbGxQYXJ0aWNpcGFudHMgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuVHJhY2tQZXJtaXNzaW9uIHRyYWNrX3Blcm1pc3Npb25zID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrUGVybWlzc2lvbnMgPSBbXTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uUGVybWlzc2lvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvblBlcm1pc3Npb24oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25QZXJtaXNzaW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTdWJzY3JpcHRpb25QZXJtaXNzaW9uLCBhLCBiKTtcbiAgfVxufVxuU3Vic2NyaXB0aW9uUGVybWlzc2lvbi5ydW50aW1lID0gcHJvdG8zO1xuU3Vic2NyaXB0aW9uUGVybWlzc2lvbi50eXBlTmFtZSA9IFwibGl2ZWtpdC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uXCI7XG5TdWJzY3JpcHRpb25QZXJtaXNzaW9uLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJhbGxfcGFydGljaXBhbnRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRyYWNrX3Blcm1pc3Npb25zXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFja1Blcm1pc3Npb24sXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZVxuICovXG5jbGFzcyBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHBhcnRpY2lwYW50X3NpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5wYXJ0aWNpcGFudFNpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdHJhY2tfc2lkID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrU2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgYWxsb3dlZCA9IDM7XG4gICAgICovXG4gICAgdGhpcy5hbGxvd2VkID0gZmFsc2U7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSwgYSwgYik7XG4gIH1cbn1cblN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUucnVudGltZSA9IHByb3RvMztcblN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUudHlwZU5hbWUgPSBcImxpdmVraXQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZVwiO1xuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiYWxsb3dlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN5bmNTdGF0ZVxuICovXG5jbGFzcyBTeW5jU3RhdGUgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlRyYWNrUHVibGlzaGVkUmVzcG9uc2UgcHVibGlzaF90cmFja3MgPSAzO1xuICAgICAqL1xuICAgIHRoaXMucHVibGlzaFRyYWNrcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5EYXRhQ2hhbm5lbEluZm8gZGF0YV9jaGFubmVscyA9IDQ7XG4gICAgICovXG4gICAgdGhpcy5kYXRhQ2hhbm5lbHMgPSBbXTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3luY1N0YXRlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3luY1N0YXRlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3luY1N0YXRlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTeW5jU3RhdGUsIGEsIGIpO1xuICB9XG59XG5TeW5jU3RhdGUucnVudGltZSA9IHByb3RvMztcblN5bmNTdGF0ZS50eXBlTmFtZSA9IFwibGl2ZWtpdC5TeW5jU3RhdGVcIjtcblN5bmNTdGF0ZS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiYW5zd2VyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb25cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwic3Vic2NyaXB0aW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVTdWJzY3JpcHRpb25cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicHVibGlzaF90cmFja3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImRhdGFfY2hhbm5lbHNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IERhdGFDaGFubmVsSW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwib2ZmZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvblxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkRhdGFDaGFubmVsSW5mb1xuICovXG5jbGFzcyBEYXRhQ2hhbm5lbEluZm8gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbGFiZWwgPSAxO1xuICAgICAqL1xuICAgIHRoaXMubGFiZWwgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGlkID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLmlkID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuU2lnbmFsVGFyZ2V0IHRhcmdldCA9IDM7XG4gICAgICovXG4gICAgdGhpcy50YXJnZXQgPSBTaWduYWxUYXJnZXQuUFVCTElTSEVSO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhQ2hhbm5lbEluZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhQ2hhbm5lbEluZm8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhQ2hhbm5lbEluZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKERhdGFDaGFubmVsSW5mbywgYSwgYik7XG4gIH1cbn1cbkRhdGFDaGFubmVsSW5mby5ydW50aW1lID0gcHJvdG8zO1xuRGF0YUNoYW5uZWxJbmZvLnR5cGVOYW1lID0gXCJsaXZla2l0LkRhdGFDaGFubmVsSW5mb1wiO1xuRGF0YUNoYW5uZWxJbmZvLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJsYWJlbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImlkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInRhcmdldFwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFNpZ25hbFRhcmdldClcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TaW11bGF0ZVNjZW5hcmlvXG4gKi9cbmNsYXNzIFNpbXVsYXRlU2NlbmFyaW8gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIG9uZW9mIGxpdmVraXQuU2ltdWxhdGVTY2VuYXJpby5zY2VuYXJpb1xuICAgICAqL1xuICAgIHRoaXMuc2NlbmFyaW8gPSB7XG4gICAgICBjYXNlOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGF0ZVNjZW5hcmlvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2ltdWxhdGVTY2VuYXJpbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNpbXVsYXRlU2NlbmFyaW8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFNpbXVsYXRlU2NlbmFyaW8sIGEsIGIpO1xuICB9XG59XG5TaW11bGF0ZVNjZW5hcmlvLnJ1bnRpbWUgPSBwcm90bzM7XG5TaW11bGF0ZVNjZW5hcmlvLnR5cGVOYW1lID0gXCJsaXZla2l0LlNpbXVsYXRlU2NlbmFyaW9cIjtcblNpbXVsYXRlU2NlbmFyaW8uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNwZWFrZXJfdXBkYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqLyxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJub2RlX2ZhaWx1cmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwibWlncmF0aW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInNlcnZlcl9sZWF2ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJzd2l0Y2hfY2FuZGlkYXRlX3Byb3RvY29sXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2FuZGlkYXRlUHJvdG9jb2wpLFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInN1YnNjcmliZXJfYmFuZHdpZHRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJkaXNjb25uZWN0X3NpZ25hbF9vbl9yZXN1bWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiZGlzY29ubmVjdF9zaWduYWxfb25fcmVzdW1lX25vX21lc3NhZ2VzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUGluZ1xuICovXG5jbGFzcyBQaW5nIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgdGltZXN0YW1wID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnRpbWVzdGFtcCA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBydHQgaW4gbWlsbGlzZWNvbmRzIGNhbGN1bGF0ZWQgYnkgY2xpZW50XG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IHJ0dCA9IDI7XG4gICAgICovXG4gICAgdGhpcy5ydHQgPSBwcm90b0ludDY0Lnplcm87XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBpbmcoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQaW5nKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGluZygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUGluZywgYSwgYik7XG4gIH1cbn1cblBpbmcucnVudGltZSA9IHByb3RvMztcblBpbmcudHlwZU5hbWUgPSBcImxpdmVraXQuUGluZ1wiO1xuUGluZy5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJydHRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUG9uZ1xuICovXG5jbGFzcyBQb25nIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIHRpbWVzdGFtcCBmaWVsZCBvZiBsYXN0IHJlY2VpdmVkIHBpbmcgcmVxdWVzdFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBsYXN0X3BpbmdfdGltZXN0YW1wID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmxhc3RQaW5nVGltZXN0YW1wID0gcHJvdG9JbnQ2NC56ZXJvO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgdGltZXN0YW1wID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnRpbWVzdGFtcCA9IHByb3RvSW50NjQuemVybztcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUG9uZygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBvbmcoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQb25nKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhQb25nLCBhLCBiKTtcbiAgfVxufVxuUG9uZy5ydW50aW1lID0gcHJvdG8zO1xuUG9uZy50eXBlTmFtZSA9IFwibGl2ZWtpdC5Qb25nXCI7XG5Qb25nLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJsYXN0X3BpbmdfdGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0aW1lc3RhbXBcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUmVnaW9uU2V0dGluZ3NcbiAqL1xuY2xhc3MgUmVnaW9uU2V0dGluZ3MgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlJlZ2lvbkluZm8gcmVnaW9ucyA9IDE7XG4gICAgICovXG4gICAgdGhpcy5yZWdpb25zID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ2lvblNldHRpbmdzKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUmVnaW9uU2V0dGluZ3MoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdpb25TZXR0aW5ncygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUmVnaW9uU2V0dGluZ3MsIGEsIGIpO1xuICB9XG59XG5SZWdpb25TZXR0aW5ncy5ydW50aW1lID0gcHJvdG8zO1xuUmVnaW9uU2V0dGluZ3MudHlwZU5hbWUgPSBcImxpdmVraXQuUmVnaW9uU2V0dGluZ3NcIjtcblJlZ2lvblNldHRpbmdzLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJyZWdpb25zXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSZWdpb25JbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJlZ2lvbkluZm9cbiAqL1xuY2xhc3MgUmVnaW9uSW5mbyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyByZWdpb24gPSAxO1xuICAgICAqL1xuICAgIHRoaXMucmVnaW9uID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB1cmwgPSAyO1xuICAgICAqL1xuICAgIHRoaXMudXJsID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IGRpc3RhbmNlID0gMztcbiAgICAgKi9cbiAgICB0aGlzLmRpc3RhbmNlID0gcHJvdG9JbnQ2NC56ZXJvO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdpb25JbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUmVnaW9uSW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ2lvbkluZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFJlZ2lvbkluZm8sIGEsIGIpO1xuICB9XG59XG5SZWdpb25JbmZvLnJ1bnRpbWUgPSBwcm90bzM7XG5SZWdpb25JbmZvLnR5cGVOYW1lID0gXCJsaXZla2l0LlJlZ2lvbkluZm9cIjtcblJlZ2lvbkluZm8uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInJlZ2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInVybFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImRpc3RhbmNlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN1YnNjcmlwdGlvblJlc3BvbnNlXG4gKi9cbmNsYXNzIFN1YnNjcmlwdGlvblJlc3BvbnNlIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHRyYWNrX3NpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy50cmFja1NpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlN1YnNjcmlwdGlvbkVycm9yIGVyciA9IDI7XG4gICAgICovXG4gICAgdGhpcy5lcnIgPSBTdWJzY3JpcHRpb25FcnJvci5TRV9VTktOT1dOO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25SZXNwb25zZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvblJlc3BvbnNlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uUmVzcG9uc2UoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFN1YnNjcmlwdGlvblJlc3BvbnNlLCBhLCBiKTtcbiAgfVxufVxuU3Vic2NyaXB0aW9uUmVzcG9uc2UucnVudGltZSA9IHByb3RvMztcblN1YnNjcmlwdGlvblJlc3BvbnNlLnR5cGVOYW1lID0gXCJsaXZla2l0LlN1YnNjcmlwdGlvblJlc3BvbnNlXCI7XG5TdWJzY3JpcHRpb25SZXNwb25zZS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiZXJyXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU3Vic2NyaXB0aW9uRXJyb3IpXG59XSk7XG5cbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIHN0cnVjdHVyZWRDbG9uZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gIH1cbn1cblxuY29uc3QgQkFDS0dST1VORF9SRUFDVElPTl9ERUxBWSA9IDUwMDA7XG4vLyBrZWVwIG9sZCBhdWRpbyBlbGVtZW50cyB3aGVuIGRldGFjaGVkLCB3ZSB3b3VsZCByZS11c2UgdGhlbSBzaW5jZSBvbiBpT1Ncbi8vIFNhZmFyaSB0cmFja3Mgd2hpY2ggYXVkaW8gZWxlbWVudHMgaGF2ZSBiZWVuIFwiYmxlc3NlZFwiIGJ5IHRoZSB1c2VyLlxuY29uc3QgcmVjeWNsZWRFbGVtZW50cyA9IFtdO1xuY2xhc3MgVHJhY2sgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIGtpbmQpIHtcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzID0gW107XG4gICAgdGhpcy5pc011dGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGN1cnJlbnQgc3RhdGUgb2Ygc3RyZWFtLCBpdCdsbCBpbmRpY2F0ZSBgcGF1c2VkYCBpZiB0aGUgdHJhY2tcbiAgICAgKiBoYXMgYmVlbiBwYXVzZWQgYnkgY29uZ2VzdGlvbiBjb250cm9sbGVyXG4gICAgICovXG4gICAgdGhpcy5zdHJlYW1TdGF0ZSA9IFRyYWNrLlN0cmVhbVN0YXRlLkFjdGl2ZTtcbiAgICB0aGlzLmlzSW5CYWNrZ3JvdW5kID0gZmFsc2U7XG4gICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLmFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5iYWNrZ3JvdW5kVGltZW91dCk7XG4gICAgICB9XG4gICAgICAvLyBkZWxheSBhcHAgdmlzaWJpbGl0eSB1cGRhdGUgaWYgaXQgZ29lcyB0byBoaWRkZW5cbiAgICAgIC8vIHVwZGF0ZSBpbW1lZGlhdGVseSBpZiBpdCBjb21lcyBiYWNrIHRvIGZvY3VzXG4gICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJykge1xuICAgICAgICB0aGlzLmJhY2tncm91bmRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCksIEJBQ0tHUk9VTkRfUkVBQ1RJT05fREVMQVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5UcmFjayk7XG4gICAgdGhpcy5sb2dnZXJDb250ZXh0Q2IgPSBsb2dnZXJPcHRpb25zLmxvZ2dlckNvbnRleHRDYjtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjayA9IG1lZGlhVHJhY2s7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1JRCA9IG1lZGlhVHJhY2suaWQ7XG4gICAgdGhpcy5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuVW5rbm93bjtcbiAgfVxuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKF9hID0gdGhpcy5sb2dnZXJDb250ZXh0Q2IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpKSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0aGlzKSk7XG4gIH1cbiAgLyoqIGN1cnJlbnQgcmVjZWl2ZSBiaXRzIHBlciBzZWNvbmQgKi9cbiAgZ2V0IGN1cnJlbnRCaXRyYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50Qml0cmF0ZTtcbiAgfVxuICBnZXQgbWVkaWFTdHJlYW1UcmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjaztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIHVzZWQgZm9yIGtlZXAgbWVkaWFTdHJlYW0ncyBmaXJzdCBpZCwgc2luY2UgaXQncyBpZCBtaWdodCBjaGFuZ2VcbiAgICogaWYgd2UgZGlzYWJsZS9lbmFibGUgYSB0cmFja1xuICAgKi9cbiAgZ2V0IG1lZGlhU3RyZWFtSUQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtSUQ7XG4gIH1cbiAgYXR0YWNoKGVsZW1lbnQpIHtcbiAgICBsZXQgZWxlbWVudFR5cGUgPSAnYXVkaW8nO1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgIGVsZW1lbnRUeXBlID0gJ3ZpZGVvJztcbiAgICB9XG4gICAgaWYgKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPT09IDAgJiYgVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgdGhpcy5hZGRBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKTtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudFR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgcmVjeWNsZWRFbGVtZW50cy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICAgIGlmIChlLnBhcmVudEVsZW1lbnQgPT09IG51bGwgJiYgIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIGl0IGZyb20gcG9vbFxuICAgICAgICAgIHJlY3ljbGVkRWxlbWVudHMuc3BsaWNlKHJlY3ljbGVkRWxlbWVudHMuaW5kZXhPZihlbGVtZW50KSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmluY2x1ZGVzKGVsZW1lbnQpKSB7XG4gICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICB9XG4gICAgLy8gZXZlbiBpZiB3ZSBiZWxpZXZlIGl0J3MgYWxyZWFkeSBhdHRhY2hlZCB0byB0aGUgZWxlbWVudCwgaXQncyBwb3NzaWJsZVxuICAgIC8vIHRoZSBlbGVtZW50J3Mgc3JjT2JqZWN0IHdhcyBzZXQgdG8gc29tZXRoaW5nIGVsc2Ugb3V0IG9mIGJhbmQuXG4gICAgLy8gd2UnbGwgd2FudCB0byByZS1hdHRhY2ggaXQgaW4gdGhhdCBjYXNlXG4gICAgYXR0YWNoVG9FbGVtZW50KHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG4gICAgLy8gaGFuZGxlIGF1dG8gcGxheWJhY2sgZmFpbHVyZXNcbiAgICBjb25zdCBhbGxNZWRpYVN0cmVhbVRyYWNrcyA9IGVsZW1lbnQuc3JjT2JqZWN0LmdldFRyYWNrcygpO1xuICAgIGNvbnN0IGhhc0F1ZGlvID0gYWxsTWVkaWFTdHJlYW1UcmFja3Muc29tZSh0ciA9PiB0ci5raW5kID09PSAnYXVkaW8nKTtcbiAgICAvLyBtYW51YWxseSBwbGF5IG1lZGlhIHRvIGRldGVjdCBhdXRvIHBsYXliYWNrIHN0YXR1c1xuICAgIGVsZW1lbnQucGxheSgpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KGhhc0F1ZGlvID8gVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrU3RhcnRlZCA6IFRyYWNrRXZlbnQuVmlkZW9QbGF5YmFja1N0YXJ0ZWQpO1xuICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgaWYgKGUubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgdGhpcy5lbWl0KGhhc0F1ZGlvID8gVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkIDogVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrRmFpbGVkLCBlKTtcbiAgICAgIH0gZWxzZSBpZiAoZS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgLy8gY29tbW9ubHkgdHJpZ2dlcmVkIGJ5IGFub3RoZXIgYHBsYXlgIHJlcXVlc3QsIG9ubHkgbG9nIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcIlwiLmNvbmNhdChoYXNBdWRpbyA/ICdhdWRpbycgOiAndmlkZW8nLCBcIiBwbGF5YmFjayBhYm9ydGVkLCBsaWtlbHkgZHVlIHRvIG5ldyBwbGF5IHJlcXVlc3RcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKFwiY291bGQgbm90IHBsYXliYWNrIFwiLmNvbmNhdChoYXNBdWRpbyA/ICdhdWRpbycgOiAndmlkZW8nKSwgZSk7XG4gICAgICB9XG4gICAgICAvLyBJZiBhdWRpbyBwbGF5YmFjayBpc24ndCBhbGxvd2VkIG1ha2Ugc3VyZSB3ZSBzdGlsbCBwbGF5IGJhY2sgdGhlIHZpZGVvXG4gICAgICBpZiAoaGFzQXVkaW8gJiYgZWxlbWVudCAmJiBhbGxNZWRpYVN0cmVhbVRyYWNrcy5zb21lKHRyID0+IHRyLmtpbmQgPT09ICd2aWRlbycpICYmIGUubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgZWxlbWVudC5tdXRlZCA9IHRydWU7XG4gICAgICAgIGVsZW1lbnQucGxheSgpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAvLyBjYXRjaCBmb3IgU2FmYXJpLCBleGNlZWRlZCBvcHRpb25zIGF0IHRoaXMgcG9pbnQgdG8gYXV0b21hdGljYWxseSBwbGF5IHRoZSBtZWRpYSBlbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVsZW1lbnRBdHRhY2hlZCwgZWxlbWVudCk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgZGV0YWNoKGVsZW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgLy8gZGV0YWNoIGZyb20gYSBzaW5nbGUgZWxlbWVudFxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbGVtZW50KTtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICB0aGlzLnJlY3ljbGVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVsZW1lbnREZXRhY2hlZCwgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXRhY2hlZCA9IFtdO1xuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWxtID0+IHtcbiAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbG0pO1xuICAgICAgICBkZXRhY2hlZC5wdXNoKGVsbSk7XG4gICAgICAgIHRoaXMucmVjeWNsZUVsZW1lbnQoZWxtKTtcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRWxlbWVudERldGFjaGVkLCBlbG0pO1xuICAgICAgfSk7XG4gICAgICAvLyByZW1vdmUgYWxsIHRyYWNrc1xuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzID0gW107XG4gICAgICByZXR1cm4gZGV0YWNoZWQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXBwVmlzaWJpbGl0eUxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5zdG9wTW9uaXRvcigpO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICB9XG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSB0cnVlO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gZmFsc2U7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHN0b3BNb25pdG9yKCkge1xuICAgIGlmICh0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLm1vbml0b3JJbnRlcnZhbCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlTG9nZ2VyT3B0aW9ucyhsb2dnZXJPcHRpb25zKSB7XG4gICAgaWYgKGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkge1xuICAgICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIobG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKTtcbiAgICB9XG4gICAgaWYgKGxvZ2dlck9wdGlvbnMubG9nZ2VyQ29udGV4dENiKSB7XG4gICAgICB0aGlzLmxvZ2dlckNvbnRleHRDYiA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyQ29udGV4dENiO1xuICAgIH1cbiAgfVxuICByZWN5Y2xlRWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQXVkaW9FbGVtZW50KSB7XG4gICAgICAvLyB3ZSBvbmx5IG5lZWQgdG8gcmUtdXNlIGEgc2luZ2xlIGVsZW1lbnRcbiAgICAgIGxldCBzaG91bGRDYWNoZSA9IHRydWU7XG4gICAgICBlbGVtZW50LnBhdXNlKCk7XG4gICAgICByZWN5Y2xlZEVsZW1lbnRzLmZvckVhY2goZSA9PiB7XG4gICAgICAgIGlmICghZS5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgc2hvdWxkQ2FjaGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoc2hvdWxkQ2FjaGUpIHtcbiAgICAgICAgcmVjeWNsZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbic7XG4gICAgfSk7XG4gIH1cbiAgYWRkQXBwVmlzaWJpbGl0eUxpc3RlbmVyKCkge1xuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICB0aGlzLmlzSW5CYWNrZ3JvdW5kID0gZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJztcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLmFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlzSW5CYWNrZ3JvdW5kID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJlbW92ZUFwcFZpc2liaWxpdHlMaXN0ZW5lcigpIHtcbiAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMuYXBwVmlzaWJpbGl0eUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhdHRhY2hUb0VsZW1lbnQodHJhY2ssIGVsZW1lbnQpIHtcbiAgbGV0IG1lZGlhU3RyZWFtO1xuICBpZiAoZWxlbWVudC5zcmNPYmplY3QgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbSkge1xuICAgIG1lZGlhU3RyZWFtID0gZWxlbWVudC5zcmNPYmplY3Q7XG4gIH0gZWxzZSB7XG4gICAgbWVkaWFTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgfVxuICAvLyBjaGVjayBpZiB0cmFjayBtYXRjaGVzIGV4aXN0aW5nIHRyYWNrXG4gIGxldCBleGlzdGluZ1RyYWNrcztcbiAgaWYgKHRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICBleGlzdGluZ1RyYWNrcyA9IG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCk7XG4gIH0gZWxzZSB7XG4gICAgZXhpc3RpbmdUcmFja3MgPSBtZWRpYVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpO1xuICB9XG4gIGlmICghZXhpc3RpbmdUcmFja3MuaW5jbHVkZXModHJhY2spKSB7XG4gICAgZXhpc3RpbmdUcmFja3MuZm9yRWFjaChldCA9PiB7XG4gICAgICBtZWRpYVN0cmVhbS5yZW1vdmVUcmFjayhldCk7XG4gICAgfSk7XG4gICAgbWVkaWFTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuICB9XG4gIGlmICghaXNTYWZhcmkoKSB8fCAhKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSkge1xuICAgIC8vIHdoZW4gaW4gbG93IHBvd2VyIG1vZGUgKGFwcGxpZXMgdG8gYm90aCBtYWNPUyBhbmQgaU9TKSwgU2FmYXJpIHdpbGwgc2hvdyBhIHBsYXkvcGF1c2Ugb3ZlcmxheVxuICAgIC8vIHdoZW4gYSB2aWRlbyBzdGFydHMgdGhhdCBoYXMgdGhlIGBhdXRvcGxheWAgYXR0cmlidXRlIGlzIHNldC5cbiAgICAvLyB3ZSB3b3JrIGFyb3VuZCB0aGlzIGJ5IF9ub3RfIHNldHRpbmcgdGhlIGF1dG9wbGF5IGF0dHJpYnV0ZSBvbiBzYWZhcmkgYW5kIGluc3RlYWQgY2FsbCBgc2V0VGltZW91dCgoKSA9PiBlbC5wbGF5KCksMClgIGZ1cnRoZXIgZG93blxuICAgIGVsZW1lbnQuYXV0b3BsYXkgPSB0cnVlO1xuICB9XG4gIC8vIEluIGNhc2UgdGhlcmUgYXJlIG5vIGF1ZGlvIHRyYWNrcyBwcmVzZW50IG9uIHRoZSBtZWRpYXN0cmVhbSwgd2Ugc2V0IHRoZSBlbGVtZW50IGFzIG11dGVkIHRvIGVuc3VyZSBhdXRvcGxheSB3b3Jrc1xuICBlbGVtZW50Lm11dGVkID0gbWVkaWFTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPT09IDA7XG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgIGVsZW1lbnQucGxheXNJbmxpbmUgPSB0cnVlO1xuICB9XG4gIC8vIGF2b2lkIGZsaWNrZXJcbiAgaWYgKGVsZW1lbnQuc3JjT2JqZWN0ICE9PSBtZWRpYVN0cmVhbSkge1xuICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XG4gICAgaWYgKChpc1NhZmFyaSgpIHx8IGlzRmlyZUZveCgpKSAmJiBlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgLy8gRmlyZWZveCBhbHNvIGhhcyBhIHRpbWluZyBpc3N1ZSB3aGVyZSB2aWRlbyBkb2Vzbid0IGFjdHVhbGx5IGdldCBhdHRhY2hlZCB1bmxlc3NcbiAgICAgIC8vIHBlcmZvcm1lZCBvdXQtb2YtYmFuZFxuICAgICAgLy8gU2FmYXJpIDE1IGhhcyBhIGJ1ZyB3aGVyZSBpbiBjZXJ0YWluIGxheW91dHMsIHZpZGVvIGVsZW1lbnQgcmVuZGVyc1xuICAgICAgLy8gYmxhY2sgdW50aWwgdGhlIHBhZ2UgaXMgcmVzaXplZCBvciBvdGhlciBjaGFuZ2VzIHRha2UgcGxhY2UuXG4gICAgICAvLyBSZXNldHRpbmcgdGhlIHNyYyB0cmlnZ2VycyBpdCB0byByZW5kZXIuXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9ydW1zL3RocmVhZC82OTA1MjNcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBlbGVtZW50LnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xuICAgICAgICAvLyBTYWZhcmkgMTUgc29tZXRpbWVzIGZhaWxzIHRvIHN0YXJ0IGEgdmlkZW9cbiAgICAgICAgLy8gd2hlbiB0aGUgd2luZG93IGlzIGJhY2tncm91bmRlZCBiZWZvcmUgdGhlIGZpcnN0IGZyYW1lIGlzIGRyYXduXG4gICAgICAgIC8vIG1hbnVhbGx5IGNhbGxpbmcgcGxheSBoZXJlIHNlZW1zIHRvIGZpeCB0aGF0XG4gICAgICAgIGVsZW1lbnQucGxheSgpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAvKiogZG8gbm90aGluZyAqL1xuICAgICAgICB9KTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gZGV0YWNoVHJhY2sodHJhY2ssIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQuc3JjT2JqZWN0IGluc3RhbmNlb2YgTWVkaWFTdHJlYW0pIHtcbiAgICBjb25zdCBtZWRpYVN0cmVhbSA9IGVsZW1lbnQuc3JjT2JqZWN0O1xuICAgIG1lZGlhU3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICBpZiAobWVkaWFTdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuKGZ1bmN0aW9uIChUcmFjaykge1xuICBsZXQgS2luZDtcbiAgKGZ1bmN0aW9uIChLaW5kKSB7XG4gICAgS2luZFtcIkF1ZGlvXCJdID0gXCJhdWRpb1wiO1xuICAgIEtpbmRbXCJWaWRlb1wiXSA9IFwidmlkZW9cIjtcbiAgICBLaW5kW1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xuICB9KShLaW5kID0gVHJhY2suS2luZCB8fCAoVHJhY2suS2luZCA9IHt9KSk7XG4gIGxldCBTb3VyY2U7XG4gIChmdW5jdGlvbiAoU291cmNlKSB7XG4gICAgU291cmNlW1wiQ2FtZXJhXCJdID0gXCJjYW1lcmFcIjtcbiAgICBTb3VyY2VbXCJNaWNyb3Bob25lXCJdID0gXCJtaWNyb3Bob25lXCI7XG4gICAgU291cmNlW1wiU2NyZWVuU2hhcmVcIl0gPSBcInNjcmVlbl9zaGFyZVwiO1xuICAgIFNvdXJjZVtcIlNjcmVlblNoYXJlQXVkaW9cIl0gPSBcInNjcmVlbl9zaGFyZV9hdWRpb1wiO1xuICAgIFNvdXJjZVtcIlVua25vd25cIl0gPSBcInVua25vd25cIjtcbiAgfSkoU291cmNlID0gVHJhY2suU291cmNlIHx8IChUcmFjay5Tb3VyY2UgPSB7fSkpO1xuICBsZXQgU3RyZWFtU3RhdGUkMTtcbiAgKGZ1bmN0aW9uIChTdHJlYW1TdGF0ZSkge1xuICAgIFN0cmVhbVN0YXRlW1wiQWN0aXZlXCJdID0gXCJhY3RpdmVcIjtcbiAgICBTdHJlYW1TdGF0ZVtcIlBhdXNlZFwiXSA9IFwicGF1c2VkXCI7XG4gICAgU3RyZWFtU3RhdGVbXCJVbmtub3duXCJdID0gXCJ1bmtub3duXCI7XG4gIH0pKFN0cmVhbVN0YXRlJDEgPSBUcmFjay5TdHJlYW1TdGF0ZSB8fCAoVHJhY2suU3RyZWFtU3RhdGUgPSB7fSkpO1xuICAvKiogQGludGVybmFsICovXG4gIGZ1bmN0aW9uIGtpbmRUb1Byb3RvKGspIHtcbiAgICBzd2l0Y2ggKGspIHtcbiAgICAgIGNhc2UgS2luZC5BdWRpbzpcbiAgICAgICAgcmV0dXJuIFRyYWNrVHlwZS5BVURJTztcbiAgICAgIGNhc2UgS2luZC5WaWRlbzpcbiAgICAgICAgcmV0dXJuIFRyYWNrVHlwZS5WSURFTztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEZJWE1FIHRoaXMgd2FzIFVOUkVDT0dOSVpFRCBiZWZvcmVcbiAgICAgICAgcmV0dXJuIFRyYWNrVHlwZS5EQVRBO1xuICAgIH1cbiAgfVxuICBUcmFjay5raW5kVG9Qcm90byA9IGtpbmRUb1Byb3RvO1xuICAvKiogQGludGVybmFsICovXG4gIGZ1bmN0aW9uIGtpbmRGcm9tUHJvdG8odCkge1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSBUcmFja1R5cGUuQVVESU86XG4gICAgICAgIHJldHVybiBLaW5kLkF1ZGlvO1xuICAgICAgY2FzZSBUcmFja1R5cGUuVklERU86XG4gICAgICAgIHJldHVybiBLaW5kLlZpZGVvO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIEtpbmQuVW5rbm93bjtcbiAgICB9XG4gIH1cbiAgVHJhY2sua2luZEZyb21Qcm90byA9IGtpbmRGcm9tUHJvdG87XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZnVuY3Rpb24gc291cmNlVG9Qcm90byhzKSB7XG4gICAgc3dpdGNoIChzKSB7XG4gICAgICBjYXNlIFNvdXJjZS5DYW1lcmE6XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5DQU1FUkE7XG4gICAgICBjYXNlIFNvdXJjZS5NaWNyb3Bob25lOlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuTUlDUk9QSE9ORTtcbiAgICAgIGNhc2UgU291cmNlLlNjcmVlblNoYXJlOlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFO1xuICAgICAgY2FzZSBTb3VyY2UuU2NyZWVuU2hhcmVBdWRpbzpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRV9BVURJTztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5VTktOT1dOO1xuICAgIH1cbiAgfVxuICBUcmFjay5zb3VyY2VUb1Byb3RvID0gc291cmNlVG9Qcm90bztcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBmdW5jdGlvbiBzb3VyY2VGcm9tUHJvdG8ocykge1xuICAgIHN3aXRjaCAocykge1xuICAgICAgY2FzZSBUcmFja1NvdXJjZS5DQU1FUkE6XG4gICAgICAgIHJldHVybiBTb3VyY2UuQ2FtZXJhO1xuICAgICAgY2FzZSBUcmFja1NvdXJjZS5NSUNST1BIT05FOlxuICAgICAgICByZXR1cm4gU291cmNlLk1pY3JvcGhvbmU7XG4gICAgICBjYXNlIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRTpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5TY3JlZW5TaGFyZTtcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFX0FVRElPOlxuICAgICAgICByZXR1cm4gU291cmNlLlNjcmVlblNoYXJlQXVkaW87XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gU291cmNlLlVua25vd247XG4gICAgfVxuICB9XG4gIFRyYWNrLnNvdXJjZUZyb21Qcm90byA9IHNvdXJjZUZyb21Qcm90bztcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBmdW5jdGlvbiBzdHJlYW1TdGF0ZUZyb21Qcm90byhzKSB7XG4gICAgc3dpdGNoIChzKSB7XG4gICAgICBjYXNlIFN0cmVhbVN0YXRlLkFDVElWRTpcbiAgICAgICAgcmV0dXJuIFN0cmVhbVN0YXRlJDEuQWN0aXZlO1xuICAgICAgY2FzZSBTdHJlYW1TdGF0ZS5QQVVTRUQ6XG4gICAgICAgIHJldHVybiBTdHJlYW1TdGF0ZSQxLlBhdXNlZDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBTdHJlYW1TdGF0ZSQxLlVua25vd247XG4gICAgfVxuICB9XG4gIFRyYWNrLnN0cmVhbVN0YXRlRnJvbVByb3RvID0gc3RyZWFtU3RhdGVGcm9tUHJvdG87XG59KShUcmFjayB8fCAoVHJhY2sgPSB7fSkpO1xuXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIGF1ZGlvRGVmYXVsdHMsIHZpZGVvRGVmYXVsdHMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBvcHRzID0gKF9hID0gY2xvbmVEZWVwKG9wdGlvbnMpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgaWYgKG9wdHMuYXVkaW8gPT09IHRydWUpIG9wdHMuYXVkaW8gPSB7fTtcbiAgaWYgKG9wdHMudmlkZW8gPT09IHRydWUpIG9wdHMudmlkZW8gPSB7fTtcbiAgLy8gdXNlIGRlZmF1bHRzXG4gIGlmIChvcHRzLmF1ZGlvKSB7XG4gICAgbWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmcob3B0cy5hdWRpbywgYXVkaW9EZWZhdWx0cyk7XG4gIH1cbiAgaWYgKG9wdHMudmlkZW8pIHtcbiAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhvcHRzLnZpZGVvLCB2aWRlb0RlZmF1bHRzKTtcbiAgfVxuICByZXR1cm4gb3B0cztcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nKG1haW5PYmplY3QsIG9iamVjdFRvTWVyZ2UpIHtcbiAgT2JqZWN0LmtleXMob2JqZWN0VG9NZXJnZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmIChtYWluT2JqZWN0W2tleV0gPT09IHVuZGVmaW5lZCkgbWFpbk9iamVjdFtrZXldID0gb2JqZWN0VG9NZXJnZVtrZXldO1xuICB9KTtcbiAgcmV0dXJuIG1haW5PYmplY3Q7XG59XG5mdW5jdGlvbiBjb25zdHJhaW50c0Zvck9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCBjb25zdHJhaW50cyA9IHt9O1xuICBpZiAob3B0aW9ucy52aWRlbykge1xuICAgIC8vIGRlZmF1bHQgdmlkZW8gb3B0aW9uc1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy52aWRlbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IHZpZGVvT3B0aW9ucyA9IHt9O1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdmlkZW9PcHRpb25zO1xuICAgICAgY29uc3Qgc291cmNlID0gb3B0aW9ucy52aWRlbztcbiAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgJ3Jlc29sdXRpb24nOlxuICAgICAgICAgICAgLy8gZmxhdHRlbiBWaWRlb1Jlc29sdXRpb24gZmllbGRzXG4gICAgICAgICAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyh0YXJnZXQsIHNvdXJjZS5yZXNvbHV0aW9uKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gdmlkZW9PcHRpb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IG9wdGlvbnMudmlkZW87XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gZmFsc2U7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYXVkaW8pIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYXVkaW8gPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdHJhaW50cy5hdWRpbyA9IG9wdGlvbnMuYXVkaW87XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3RyYWludHMuYXVkaW8gPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gY29uc3RyYWludHM7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyBzaWxlbmNlIG9uIGEgZ2l2ZW4gW1tUcmFja11dIGluc3RhbmNlLlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFjayBzZWVtcyB0byBiZSBlbnRpcmVseSBzaWxlbnQuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdFNpbGVuY2UodHJhY2spIHtcbiAgbGV0IHRpbWVPZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDIwMDtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBjdHggPSBnZXROZXdBdWRpb0NvbnRleHQoKTtcbiAgICBpZiAoY3R4KSB7XG4gICAgICBjb25zdCBhbmFseXNlciA9IGN0eC5jcmVhdGVBbmFseXNlcigpO1xuICAgICAgYW5hbHlzZXIuZmZ0U2l6ZSA9IDIwNDg7XG4gICAgICBjb25zdCBidWZmZXJMZW5ndGggPSBhbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudDtcbiAgICAgIGNvbnN0IGRhdGFBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlckxlbmd0aCk7XG4gICAgICBjb25zdCBzb3VyY2UgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UobmV3IE1lZGlhU3RyZWFtKFt0cmFjay5tZWRpYVN0cmVhbVRyYWNrXSkpO1xuICAgICAgc291cmNlLmNvbm5lY3QoYW5hbHlzZXIpO1xuICAgICAgeWllbGQgc2xlZXAodGltZU9mZnNldCk7XG4gICAgICBhbmFseXNlci5nZXRCeXRlVGltZURvbWFpbkRhdGEoZGF0YUFycmF5KTtcbiAgICAgIGNvbnN0IHNvbWVOb2lzZSA9IGRhdGFBcnJheS5zb21lKHNhbXBsZSA9PiBzYW1wbGUgIT09IDEyOCAmJiBzYW1wbGUgIT09IDApO1xuICAgICAgY3R4LmNsb3NlKCk7XG4gICAgICByZXR1cm4gIXNvbWVOb2lzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldE5ld0F1ZGlvQ29udGV4dCgpIHtcbiAgY29uc3QgQXVkaW9Db250ZXh0ID1cbiAgLy8gQHRzLWlnbm9yZVxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KTtcbiAgaWYgKEF1ZGlvQ29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQXVkaW9Db250ZXh0KHtcbiAgICAgIGxhdGVuY3lIaW50OiAnaW50ZXJhY3RpdmUnXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHNvdXJjZVRvS2luZChzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUpIHtcbiAgICByZXR1cm4gJ2F1ZGlvaW5wdXQnO1xuICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSkge1xuICAgIHJldHVybiAndmlkZW9pbnB1dCc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gc2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBfYSwgX2I7XG4gIGxldCB2aWRlb0NvbnN0cmFpbnRzID0gKF9hID0gb3B0aW9ucy52aWRlbykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcbiAgLy8gdHJlYXQgMCBhcyB1bmNhcHBlZFxuICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uICYmIG9wdGlvbnMucmVzb2x1dGlvbi53aWR0aCA+IDAgJiYgb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodCA+IDApIHtcbiAgICB2aWRlb0NvbnN0cmFpbnRzID0gdHlwZW9mIHZpZGVvQ29uc3RyYWludHMgPT09ICdib29sZWFuJyA/IHt9IDogdmlkZW9Db25zdHJhaW50cztcbiAgICBpZiAoaXNTYWZhcmkoKSkge1xuICAgICAgdmlkZW9Db25zdHJhaW50cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmlkZW9Db25zdHJhaW50cyksIHtcbiAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICBtYXg6IG9wdGlvbnMucmVzb2x1dGlvbi53aWR0aFxuICAgICAgICB9LFxuICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICBtYXg6IG9wdGlvbnMucmVzb2x1dGlvbi5oZWlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgZnJhbWVSYXRlOiBvcHRpb25zLnJlc29sdXRpb24uZnJhbWVSYXRlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlkZW9Db25zdHJhaW50cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmlkZW9Db25zdHJhaW50cyksIHtcbiAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICBpZGVhbDogb3B0aW9ucy5yZXNvbHV0aW9uLndpZHRoXG4gICAgICAgIH0sXG4gICAgICAgIGhlaWdodDoge1xuICAgICAgICAgIGlkZWFsOiBvcHRpb25zLnJlc29sdXRpb24uaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIGZyYW1lUmF0ZTogb3B0aW9ucy5yZXNvbHV0aW9uLmZyYW1lUmF0ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgYXVkaW86IChfYiA9IG9wdGlvbnMuYXVkaW8pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlLFxuICAgIHZpZGVvOiB2aWRlb0NvbnN0cmFpbnRzLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc3VwcG9ydCBmb3IgZXhwZXJpbWVudGFsIGRpc3BsYXkgbWVkaWEgZmVhdHVyZXNcbiAgICBjb250cm9sbGVyOiBvcHRpb25zLmNvbnRyb2xsZXIsXG4gICAgc2VsZkJyb3dzZXJTdXJmYWNlOiBvcHRpb25zLnNlbGZCcm93c2VyU3VyZmFjZSxcbiAgICBzdXJmYWNlU3dpdGNoaW5nOiBvcHRpb25zLnN1cmZhY2VTd2l0Y2hpbmcsXG4gICAgc3lzdGVtQXVkaW86IG9wdGlvbnMuc3lzdGVtQXVkaW9cbiAgfTtcbn1cbmZ1bmN0aW9uIG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKG1pbWVUeXBlKSB7XG4gIGNvbnN0IGNvZGVjID0gbWltZVR5cGUuc3BsaXQoJy8nKVsxXS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIXZpZGVvQ29kZWNzLmluY2x1ZGVzKGNvZGVjKSkge1xuICAgIHRocm93IEVycm9yKFwiVmlkZW8gY29kZWMgbm90IHN1cHBvcnRlZDogXCIuY29uY2F0KGNvZGVjKSk7XG4gIH1cbiAgcmV0dXJuIGNvZGVjO1xufVxuZnVuY3Rpb24gZ2V0VHJhY2tQdWJsaWNhdGlvbkluZm8odHJhY2tzKSB7XG4gIGNvbnN0IGluZm9zID0gW107XG4gIHRyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICBpZiAodHJhY2sudHJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5mb3MucHVzaChuZXcgVHJhY2tQdWJsaXNoZWRSZXNwb25zZSh7XG4gICAgICAgIGNpZDogdHJhY2sudHJhY2subWVkaWFTdHJlYW1JRCxcbiAgICAgICAgdHJhY2s6IHRyYWNrLnRyYWNrSW5mb1xuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbmZvcztcbn1cbmZ1bmN0aW9uIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spIHtcbiAgaWYgKHRyYWNrIGluc3RhbmNlb2YgVHJhY2spIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhY2tTaWQ6IHRyYWNrLnNpZCxcbiAgICAgIHRyYWNrU291cmNlOiB0cmFjay5zb3VyY2UsXG4gICAgICB0cmFja011dGVkOiB0cmFjay5pc011dGVkLFxuICAgICAgdHJhY2tFbmFibGVkOiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQsXG4gICAgICB0cmFja0tpbmQ6IHRyYWNrLmtpbmRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFja1NpZDogdHJhY2sudHJhY2tTaWQsXG4gICAgICB0cmFja05hbWU6IHRyYWNrLnRyYWNrTmFtZSxcbiAgICAgIHRyYWNrOiB0cmFjay50cmFjayA/IGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2sudHJhY2spIDogdW5kZWZpbmVkLFxuICAgICAgdHJhY2tFbmFibGVkOiB0cmFjay5pc0VuYWJsZWQsXG4gICAgICB0cmFja0VuY3J5cHRlZDogdHJhY2suaXNFbmNyeXB0ZWQsXG4gICAgICB0cmFja01pbWVUeXBlOiB0cmFjay5taW1lVHlwZVxuICAgIH07XG4gIH1cbn1cblxuY29uc3Qgc2VwYXJhdG9yID0gJ3wnO1xuY29uc3QgZGRFeHRlbnNpb25VUkkgPSAnaHR0cHM6Ly9hb21lZGlhY29kZWMuZ2l0aHViLmlvL2F2MS1ydHAtc3BlYy8jZGVwZW5kZW5jeS1kZXNjcmlwdG9yLXJ0cC1oZWFkZXItZXh0ZW5zaW9uJztcbmZ1bmN0aW9uIHVucGFja1N0cmVhbUlkKHBhY2tlZCkge1xuICBjb25zdCBwYXJ0cyA9IHBhY2tlZC5zcGxpdChzZXBhcmF0b3IpO1xuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBbcGFydHNbMF0sIHBhY2tlZC5zdWJzdHIocGFydHNbMF0ubGVuZ3RoICsgMSldO1xuICB9XG4gIHJldHVybiBbcGFja2VkLCAnJ107XG59XG5mdW5jdGlvbiBzbGVlcChkdXJhdGlvbikge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pKTtcbiAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBzdXBwb3J0c1RyYW5zY2VpdmVyKCkge1xuICByZXR1cm4gJ2FkZFRyYW5zY2VpdmVyJyBpbiBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBzdXBwb3J0c0FkZFRyYWNrKCkge1xuICByZXR1cm4gJ2FkZFRyYWNrJyBpbiBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG59XG5mdW5jdGlvbiBzdXBwb3J0c0FkYXB0aXZlU3RyZWFtKCkge1xuICByZXR1cm4gdHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBzdXBwb3J0c0R5bmFjYXN0KCkge1xuICByZXR1cm4gc3VwcG9ydHNUcmFuc2NlaXZlcigpO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNBVjEoKSB7XG4gIGlmICghKCdnZXRDYXBhYmlsaXRpZXMnIGluIFJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICAvLyBTYWZhcmkgMTcgb24gaVBob25lMTQgcmVwb3J0cyBBVjEgY2FwYWJpbGl0eSwgYnV0IGRvZXMgbm90IGFjdHVhbGx5IHN1cHBvcnQgaXRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgY2FwYWJpbGl0aWVzID0gUlRDUnRwU2VuZGVyLmdldENhcGFiaWxpdGllcygndmlkZW8nKTtcbiAgbGV0IGhhc0FWMSA9IGZhbHNlO1xuICBpZiAoY2FwYWJpbGl0aWVzKSB7XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBjYXBhYmlsaXRpZXMuY29kZWNzKSB7XG4gICAgICBpZiAoY29kZWMubWltZVR5cGUgPT09ICd2aWRlby9BVjEnKSB7XG4gICAgICAgIGhhc0FWMSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzQVYxO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNWUDkoKSB7XG4gIGlmICghKCdnZXRDYXBhYmlsaXRpZXMnIGluIFJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRmlyZUZveCgpKSB7XG4gICAgLy8gdGVjaG5pY2FsbHkgc3BlYWtpbmcgRmlyZUZveCBzdXBwb3J0cyBWUDksIGJ1dCBTVkMgcHVibGlzaGluZyBpcyBicm9rZW5cbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNjMzODc2XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgICBpZiAoKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci52ZXJzaW9uKSAmJiBjb21wYXJlVmVyc2lvbnMoYnJvd3Nlci52ZXJzaW9uLCAnMTYnKSA8IDApIHtcbiAgICAgIC8vIFNhZmFyaSAxNiBhbmQgYmVsb3cgZG9lcyBub3Qgc3VwcG9ydCBWUDlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY2FwYWJpbGl0aWVzID0gUlRDUnRwU2VuZGVyLmdldENhcGFiaWxpdGllcygndmlkZW8nKTtcbiAgbGV0IGhhc1ZQOSA9IGZhbHNlO1xuICBpZiAoY2FwYWJpbGl0aWVzKSB7XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBjYXBhYmlsaXRpZXMuY29kZWNzKSB7XG4gICAgICBpZiAoY29kZWMubWltZVR5cGUgPT09ICd2aWRlby9WUDknKSB7XG4gICAgICAgIGhhc1ZQOSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzVlA5O1xufVxuZnVuY3Rpb24gaXNTVkNDb2RlYyhjb2RlYykge1xuICByZXR1cm4gY29kZWMgPT09ICdhdjEnIHx8IGNvZGVjID09PSAndnA5Jztcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzU2V0U2lua0lkKGVsbSkge1xuICBpZiAoIWRvY3VtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghZWxtKSB7XG4gICAgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcbiAgfVxuICByZXR1cm4gJ3NldFNpbmtJZCcgaW4gZWxtO1xufVxuY29uc3Qgc2V0Q29kZWNQcmVmZXJlbmNlc1ZlcnNpb25zID0ge1xuICBDaHJvbWU6ICcxMDAnLFxuICBTYWZhcmk6ICcxNScsXG4gIEZpcmVmb3g6ICcxMDAnXG59O1xuZnVuY3Rpb24gc3VwcG9ydHNTZXRDb2RlY1ByZWZlcmVuY2VzKHRyYW5zY2VpdmVyKSB7XG4gIGlmICghaXNXZWIoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoISgnc2V0Q29kZWNQcmVmZXJlbmNlcycgaW4gdHJhbnNjZWl2ZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gIGlmICghKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5uYW1lKSB8fCAhYnJvd3Nlci52ZXJzaW9uKSB7XG4gICAgLy8gdmVyc2lvbiBpcyByZXF1aXJlZFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB2ID0gc2V0Q29kZWNQcmVmZXJlbmNlc1ZlcnNpb25zW2Jyb3dzZXIubmFtZV07XG4gIGlmICh2KSB7XG4gICAgcmV0dXJuIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyLnZlcnNpb24sIHYpID49IDA7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNCcm93c2VyU3VwcG9ydGVkKCkge1xuICByZXR1cm4gc3VwcG9ydHNUcmFuc2NlaXZlcigpIHx8IHN1cHBvcnRzQWRkVHJhY2soKTtcbn1cbmZ1bmN0aW9uIGlzRmlyZUZveCgpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKChfYSA9IGdldEJyb3dzZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09PSAnRmlyZWZveCc7XG59XG5mdW5jdGlvbiBpc0Nocm9taXVtQmFzZWQoKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuICgoX2EgPSBnZXRCcm93c2VyKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSA9PT0gJ0Nocm9tZSc7XG59XG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKChfYSA9IGdldEJyb3dzZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09PSAnU2FmYXJpJztcbn1cbmZ1bmN0aW9uIGlzU2FmYXJpMTcoKSB7XG4gIGNvbnN0IGIgPSBnZXRCcm93c2VyKCk7XG4gIHJldHVybiAoYiA9PT0gbnVsbCB8fCBiID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiLm5hbWUpID09PSAnU2FmYXJpJyAmJiBiLnZlcnNpb24uc3RhcnRzV2l0aCgnMTcuJyk7XG59XG5mdW5jdGlvbiBpc01vYmlsZSgpIHtcbiAgaWYgKCFpc1dlYigpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAvVGFibGV0fGlQYWR8TW9iaWxlfEFuZHJvaWR8QmxhY2tCZXJyeS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cbmZ1bmN0aW9uIGlzV2ViKCkge1xuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKSB7XG4gIC8vIG5hdmlnYXRvci5wcm9kdWN0IGlzIGRlcHJlY2F0ZWQgb24gYnJvd3NlcnMsIGJ1dCB3aWxsIGJlIHNldCBhcHByb3ByaWF0ZWx5IGZvciByZWFjdC1uYXRpdmUuXG4gIHJldHVybiBuYXZpZ2F0b3IucHJvZHVjdCA9PSAnUmVhY3ROYXRpdmUnO1xufVxuZnVuY3Rpb24gaXNDbG91ZChzZXJ2ZXJVcmwpIHtcbiAgcmV0dXJuIHNlcnZlclVybC5ob3N0bmFtZS5lbmRzV2l0aCgnLmxpdmVraXQuY2xvdWQnKSB8fCBzZXJ2ZXJVcmwuaG9zdG5hbWUuZW5kc1dpdGgoJy5saXZla2l0LnJ1bicpO1xufVxuZnVuY3Rpb24gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKSB7XG4gIC8vIGdsb2JhbCBkZWZpbmVkIG9ubHkgZm9yIFJlYWN0TmF0aXZlLlxuICAvLyBAdHMtaWdub3JlXG4gIGlmIChnbG9iYWwgJiYgZ2xvYmFsLkxpdmVLaXRSZWFjdE5hdGl2ZUdsb2JhbCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gZ2xvYmFsLkxpdmVLaXRSZWFjdE5hdGl2ZUdsb2JhbDtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0UmVhY3ROYXRpdmVPcygpIHtcbiAgaWYgKCFpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGxldCBpbmZvID0gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKTtcbiAgaWYgKGluZm8pIHtcbiAgICByZXR1cm4gaW5mby5wbGF0Zm9ybTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgaWYgKGlzV2ViKCkpIHtcbiAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIH1cbiAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgIGxldCBpbmZvID0gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKTtcbiAgICBpZiAoaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDE7XG59XG5mdW5jdGlvbiBjb21wYXJlVmVyc2lvbnModjEsIHYyKSB7XG4gIGNvbnN0IHBhcnRzMSA9IHYxLnNwbGl0KCcuJyk7XG4gIGNvbnN0IHBhcnRzMiA9IHYyLnNwbGl0KCcuJyk7XG4gIGNvbnN0IGsgPSBNYXRoLm1pbihwYXJ0czEubGVuZ3RoLCBwYXJ0czIubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrOyArK2kpIHtcbiAgICBjb25zdCBwMSA9IHBhcnNlSW50KHBhcnRzMVtpXSwgMTApO1xuICAgIGNvbnN0IHAyID0gcGFyc2VJbnQocGFydHMyW2ldLCAxMCk7XG4gICAgaWYgKHAxID4gcDIpIHJldHVybiAxO1xuICAgIGlmIChwMSA8IHAyKSByZXR1cm4gLTE7XG4gICAgaWYgKGkgPT09IGsgLSAxICYmIHAxID09PSBwMikgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHYxID09PSAnJyAmJiB2MiAhPT0gJycpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAodjIgPT09ICcnKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIHBhcnRzMS5sZW5ndGggPT0gcGFydHMyLmxlbmd0aCA/IDAgOiBwYXJ0czEubGVuZ3RoIDwgcGFydHMyLmxlbmd0aCA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIHJvRGlzcGF0Y2hDYWxsYmFjayhlbnRyaWVzKSB7XG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgIGVudHJ5LnRhcmdldC5oYW5kbGVSZXNpemUoZW50cnkpO1xuICB9XG59XG5mdW5jdGlvbiBpb0Rpc3BhdGNoQ2FsbGJhY2soZW50cmllcykge1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICBlbnRyeS50YXJnZXQuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQoZW50cnkpO1xuICB9XG59XG5sZXQgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuY29uc3QgZ2V0UmVzaXplT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIGlmICghcmVzaXplT2JzZXJ2ZXIpIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHJvRGlzcGF0Y2hDYWxsYmFjayk7XG4gIHJldHVybiByZXNpemVPYnNlcnZlcjtcbn07XG5sZXQgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBudWxsO1xuY29uc3QgZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIGlmICghaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICBpbnRlcnNlY3Rpb25PYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihpb0Rpc3BhdGNoQ2FsbGJhY2ssIHtcbiAgICAgIHJvb3Q6IG51bGwsXG4gICAgICByb290TWFyZ2luOiAnMHB4J1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBpbnRlcnNlY3Rpb25PYnNlcnZlcjtcbn07XG5mdW5jdGlvbiBnZXRDbGllbnRJbmZvKCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGluZm8gPSBuZXcgQ2xpZW50SW5mbyh7XG4gICAgc2RrOiBDbGllbnRJbmZvX1NESy5KUyxcbiAgICBwcm90b2NvbDogcHJvdG9jb2xWZXJzaW9uLFxuICAgIHZlcnNpb25cbiAgfSk7XG4gIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICBpbmZvLm9zID0gKF9hID0gZ2V0UmVhY3ROYXRpdmVPcygpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgfVxuICByZXR1cm4gaW5mbztcbn1cbmxldCBlbXB0eVZpZGVvU3RyZWFtVHJhY2s7XG5mdW5jdGlvbiBnZXRFbXB0eVZpZGVvU3RyZWFtVHJhY2soKSB7XG4gIGlmICghZW1wdHlWaWRlb1N0cmVhbVRyYWNrKSB7XG4gICAgZW1wdHlWaWRlb1N0cmVhbVRyYWNrID0gY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKCk7XG4gIH1cbiAgcmV0dXJuIGVtcHR5VmlkZW9TdHJlYW1UcmFjay5jbG9uZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKCkge1xuICBsZXQgd2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE2O1xuICBsZXQgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxNjtcbiAgbGV0IGVuYWJsZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICBsZXQgcGFpbnRDb250ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIC8vIHRoZSBjYW52YXMgc2l6ZSBpcyBzZXQgdG8gMTYgYnkgZGVmYXVsdCwgYmVjYXVzZSBlbGVjdHJvbiBhcHBzIHNlZW0gdG8gZmFpbCB3aXRoIHNtYWxsZXIgdmFsdWVzXG4gIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGlmIChwYWludENvbnRlbnQgJiYgY3R4KSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMod2lkdGggLyAyLCBoZWlnaHQgLyAyLCA1MCwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ2dyZXknO1xuICAgIGN0eC5maWxsKCk7XG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBkdW1teVN0cmVhbSA9IGNhbnZhcy5jYXB0dXJlU3RyZWFtKCk7XG4gIGNvbnN0IFtkdW1teVRyYWNrXSA9IGR1bW15U3RyZWFtLmdldFRyYWNrcygpO1xuICBpZiAoIWR1bW15VHJhY2spIHtcbiAgICB0aHJvdyBFcnJvcignQ291bGQgbm90IGdldCBlbXB0eSBtZWRpYSBzdHJlYW0gdmlkZW8gdHJhY2snKTtcbiAgfVxuICBkdW1teVRyYWNrLmVuYWJsZWQgPSBlbmFibGVkO1xuICByZXR1cm4gZHVtbXlUcmFjaztcbn1cbmxldCBlbXB0eUF1ZGlvU3RyZWFtVHJhY2s7XG5mdW5jdGlvbiBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKSB7XG4gIGlmICghZW1wdHlBdWRpb1N0cmVhbVRyYWNrKSB7XG4gICAgLy8gaW1wbGVtZW50YXRpb24gYWRhcHRlZCBmcm9tIGh0dHBzOi8vYmxvZy5tb3ppbGxhLm9yZy93ZWJydGMvd2FybS11cC13aXRoLXJlcGxhY2V0cmFjay9cbiAgICBjb25zdCBjdHggPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gICAgY29uc3Qgb3NjaWxsYXRvciA9IGN0eC5jcmVhdGVPc2NpbGxhdG9yKCk7XG4gICAgY29uc3QgZ2FpbiA9IGN0eC5jcmVhdGVHYWluKCk7XG4gICAgZ2Fpbi5nYWluLnNldFZhbHVlQXRUaW1lKDAsIDApO1xuICAgIGNvbnN0IGRzdCA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKCk7XG4gICAgb3NjaWxsYXRvci5jb25uZWN0KGdhaW4pO1xuICAgIGdhaW4uY29ubmVjdChkc3QpO1xuICAgIG9zY2lsbGF0b3Iuc3RhcnQoKTtcbiAgICBbZW1wdHlBdWRpb1N0cmVhbVRyYWNrXSA9IGRzdC5zdHJlYW0uZ2V0QXVkaW9UcmFja3MoKTtcbiAgICBpZiAoIWVtcHR5QXVkaW9TdHJlYW1UcmFjaykge1xuICAgICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgZW1wdHkgbWVkaWEgc3RyZWFtIGF1ZGlvIHRyYWNrJyk7XG4gICAgfVxuICAgIGVtcHR5QXVkaW9TdHJlYW1UcmFjay5lbmFibGVkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGVtcHR5QXVkaW9TdHJlYW1UcmFjay5jbG9uZSgpO1xufVxuY2xhc3MgRnV0dXJlIHtcbiAgY29uc3RydWN0b3IoZnV0dXJlQmFzZSwgb25GaW5hbGx5KSB7XG4gICAgdGhpcy5vbkZpbmFsbHkgPSBvbkZpbmFsbHk7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgaWYgKGZ1dHVyZUJhc2UpIHtcbiAgICAgICAgeWllbGQgZnV0dXJlQmFzZShyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoX2EgPSB0aGlzLm9uRmluYWxseSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBhbmFseXNlciB3ZWIgYXVkaW8gbm9kZSB0aGF0IGlzIGF0dGFjaGVkIHRvIHRoZSBwcm92aWRlZCB0cmFjay5cbiAqIEFkZGl0aW9uYWxseSByZXR1cm5zIGEgY29udmVuaWVuY2UgbWV0aG9kIGBjYWxjdWxhdGVWb2x1bWVgIHRvIHBlcmZvcm0gaW5zdGFudCB2b2x1bWUgcmVhZGluZ3Mgb24gdGhhdCB0cmFjay5cbiAqIENhbGwgdGhlIHJldHVybmVkIGBjbGVhbnVwYCBmdW5jdGlvbiB0byBjbG9zZSB0aGUgYXVkaW9Db250ZXh0IHRoYXQgaGFzIGJlZW4gY3JlYXRlZCBmb3IgdGhlIGluc3RhbmNlIG9mIHRoaXMgaGVscGVyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUF1ZGlvQW5hbHlzZXIodHJhY2ssIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIGNsb25lVHJhY2s6IGZhbHNlLFxuICAgIGZmdFNpemU6IDIwNDgsXG4gICAgc21vb3RoaW5nVGltZUNvbnN0YW50OiAwLjgsXG4gICAgbWluRGVjaWJlbHM6IC0xMDAsXG4gICAgbWF4RGVjaWJlbHM6IC04MFxuICB9LCBvcHRpb25zKTtcbiAgY29uc3QgYXVkaW9Db250ZXh0ID0gZ2V0TmV3QXVkaW9Db250ZXh0KCk7XG4gIGlmICghYXVkaW9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdWRpbyBDb250ZXh0IG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyJyk7XG4gIH1cbiAgY29uc3Qgc3RyZWFtVHJhY2sgPSBvcHRzLmNsb25lVHJhY2sgPyB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmNsb25lKCkgOiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrO1xuICBjb25zdCBtZWRpYVN0cmVhbVNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShuZXcgTWVkaWFTdHJlYW0oW3N0cmVhbVRyYWNrXSkpO1xuICBjb25zdCBhbmFseXNlciA9IGF1ZGlvQ29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuICBhbmFseXNlci5taW5EZWNpYmVscyA9IG9wdHMubWluRGVjaWJlbHM7XG4gIGFuYWx5c2VyLm1heERlY2liZWxzID0gb3B0cy5tYXhEZWNpYmVscztcbiAgYW5hbHlzZXIuZmZ0U2l6ZSA9IG9wdHMuZmZ0U2l6ZTtcbiAgYW5hbHlzZXIuc21vb3RoaW5nVGltZUNvbnN0YW50ID0gb3B0cy5zbW9vdGhpbmdUaW1lQ29uc3RhbnQ7XG4gIG1lZGlhU3RyZWFtU291cmNlLmNvbm5lY3QoYW5hbHlzZXIpO1xuICBjb25zdCBkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShhbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCk7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBjdXJyZW50IHZvbHVtZSBvZiB0aGUgdHJhY2sgaW4gdGhlIHJhbmdlIGZyb20gMCB0byAxXG4gICAqL1xuICBjb25zdCBjYWxjdWxhdGVWb2x1bWUgPSAoKSA9PiB7XG4gICAgYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoZGF0YUFycmF5KTtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGNvbnN0IGFtcGxpdHVkZSBvZiBkYXRhQXJyYXkpIHtcbiAgICAgIHN1bSArPSBNYXRoLnBvdyhhbXBsaXR1ZGUgLyAyNTUsIDIpO1xuICAgIH1cbiAgICBjb25zdCB2b2x1bWUgPSBNYXRoLnNxcnQoc3VtIC8gZGF0YUFycmF5Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHZvbHVtZTtcbiAgfTtcbiAgY29uc3QgY2xlYW51cCA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICB5aWVsZCBhdWRpb0NvbnRleHQuY2xvc2UoKTtcbiAgICBpZiAob3B0cy5jbG9uZVRyYWNrKSB7XG4gICAgICBzdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjYWxjdWxhdGVWb2x1bWUsXG4gICAgYW5hbHlzZXIsXG4gICAgY2xlYW51cFxuICB9O1xufVxuY2xhc3MgTXV0ZXgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9sb2NraW5nID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdGhpcy5fbG9ja3MgPSAwO1xuICB9XG4gIGlzTG9ja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NrcyA+IDA7XG4gIH1cbiAgbG9jaygpIHtcbiAgICB0aGlzLl9sb2NrcyArPSAxO1xuICAgIGxldCB1bmxvY2tOZXh0O1xuICAgIGNvbnN0IHdpbGxMb2NrID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB1bmxvY2tOZXh0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5fbG9ja3MgLT0gMTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgICBjb25zdCB3aWxsVW5sb2NrID0gdGhpcy5fbG9ja2luZy50aGVuKCgpID0+IHVubG9ja05leHQpO1xuICAgIHRoaXMuX2xvY2tpbmcgPSB0aGlzLl9sb2NraW5nLnRoZW4oKCkgPT4gd2lsbExvY2spO1xuICAgIHJldHVybiB3aWxsVW5sb2NrO1xuICB9XG59XG5mdW5jdGlvbiBpc1ZpZGVvQ29kZWMobWF5YmVDb2RlYykge1xuICByZXR1cm4gdmlkZW9Db2RlY3MuaW5jbHVkZXMobWF5YmVDb2RlYyk7XG59XG5mdW5jdGlvbiB1bndyYXBDb25zdHJhaW50KGNvbnN0cmFpbnQpIHtcbiAgaWYgKHR5cGVvZiBjb25zdHJhaW50ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjb25zdHJhaW50O1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbnN0cmFpbnQpKSB7XG4gICAgcmV0dXJuIGNvbnN0cmFpbnRbMF07XG4gIH1cbiAgaWYgKGNvbnN0cmFpbnQuZXhhY3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25zdHJhaW50LmV4YWN0KSkge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbnQuZXhhY3RbMF07XG4gICAgfVxuICAgIHJldHVybiBjb25zdHJhaW50LmV4YWN0O1xuICB9XG4gIGlmIChjb25zdHJhaW50LmlkZWFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uc3RyYWludC5pZGVhbCkpIHtcbiAgICAgIHJldHVybiBjb25zdHJhaW50LmlkZWFsWzBdO1xuICAgIH1cbiAgICByZXR1cm4gY29uc3RyYWludC5pZGVhbDtcbiAgfVxuICB0aHJvdyBFcnJvcignY291bGQgbm90IHVud3JhcCBjb25zdHJhaW50Jyk7XG59XG5mdW5jdGlvbiB0b1dlYnNvY2tldFVybCh1cmwpIHtcbiAgaWYgKHVybC5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoL14oaHR0cCkvLCAnd3MnKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gdG9IdHRwVXJsKHVybCkge1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoJ3dzJykpIHtcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoL14od3MpLywgJ2h0dHAnKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG5jb25zdCBkZWZhdWx0SWQgPSAnZGVmYXVsdCc7XG5jbGFzcyBEZXZpY2VNYW5hZ2VyIHtcbiAgc3RhdGljIGdldEluc3RhbmNlKCkge1xuICAgIGlmICh0aGlzLmluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgRGV2aWNlTWFuYWdlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgfVxuICBnZXREZXZpY2VzKGtpbmQpIHtcbiAgICBsZXQgcmVxdWVzdFBlcm1pc3Npb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCgoX2EgPSBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaXplKSA+IDApIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygnYXdhaXRpbmcgZ2V0VXNlck1lZGlhIHByb21pc2UnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoa2luZCkge1xuICAgICAgICAgICAgeWllbGQgRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLmdldChraW5kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLnZhbHVlcygpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ2Vycm9yIHdhaXRpbmcgZm9yIG1lZGlhIHBlcm1pc3NvbnMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGRldmljZXMgPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICAgIGlmIChyZXF1ZXN0UGVybWlzc2lvbnMgJiZcbiAgICAgIC8vIGZvciBzYWZhcmkgd2UgbmVlZCB0byBza2lwIHRoaXMgY2hlY2ssIGFzIG90aGVyd2lzZSBpdCB3aWxsIHJlLWFjcXVpcmUgdXNlciBtZWRpYSBhbmQgZmFpbCBvbiBpT1MgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE3OTM2M1xuICAgICAgIShpc1NhZmFyaSgpICYmIHRoaXMuaGFzRGV2aWNlSW5Vc2Uoa2luZCkpKSB7XG4gICAgICAgIGNvbnN0IGlzRHVtbXlEZXZpY2VPckVtcHR5ID0gZGV2aWNlcy5sZW5ndGggPT09IDAgfHwgZGV2aWNlcy5zb21lKGRldmljZSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9MYWJlbCA9IGRldmljZS5sYWJlbCA9PT0gJyc7XG4gICAgICAgICAgY29uc3QgaXNSZWxldmFudCA9IGtpbmQgPyBkZXZpY2Uua2luZCA9PT0ga2luZCA6IHRydWU7XG4gICAgICAgICAgcmV0dXJuIG5vTGFiZWwgJiYgaXNSZWxldmFudDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0R1bW15RGV2aWNlT3JFbXB0eSkge1xuICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb25zVG9BY3F1aXJlID0ge1xuICAgICAgICAgICAgdmlkZW86IGtpbmQgIT09ICdhdWRpb2lucHV0JyAmJiBraW5kICE9PSAnYXVkaW9vdXRwdXQnLFxuICAgICAgICAgICAgYXVkaW86IGtpbmQgIT09ICd2aWRlb2lucHV0J1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3Qgc3RyZWFtID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEocGVybWlzc2lvbnNUb0FjcXVpcmUpO1xuICAgICAgICAgIGRldmljZXMgPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChraW5kKSB7XG4gICAgICAgIGRldmljZXMgPSBkZXZpY2VzLmZpbHRlcihkZXZpY2UgPT4gZGV2aWNlLmtpbmQgPT09IGtpbmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRldmljZXM7XG4gICAgfSk7XG4gIH1cbiAgbm9ybWFsaXplRGV2aWNlSWQoa2luZCwgZGV2aWNlSWQsIGdyb3VwSWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKGRldmljZUlkICE9PSBkZWZhdWx0SWQpIHtcbiAgICAgICAgcmV0dXJuIGRldmljZUlkO1xuICAgICAgfVxuICAgICAgLy8gcmVzb2x2ZSBhY3R1YWwgZGV2aWNlIGlkIGlmIGl0J3MgJ2RlZmF1bHQnOiBDaHJvbWUgcmV0dXJucyBpdCB3aGVuIG5vXG4gICAgICAvLyBkZXZpY2UgaGFzIGJlZW4gY2hvc2VuXG4gICAgICBjb25zdCBkZXZpY2VzID0geWllbGQgdGhpcy5nZXREZXZpY2VzKGtpbmQpO1xuICAgICAgY29uc3QgZGV2aWNlID0gZGV2aWNlcy5maW5kKGQgPT4gZC5ncm91cElkID09PSBncm91cElkICYmIGQuZGV2aWNlSWQgIT09IGRlZmF1bHRJZCk7XG4gICAgICByZXR1cm4gZGV2aWNlID09PSBudWxsIHx8IGRldmljZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGV2aWNlLmRldmljZUlkO1xuICAgIH0pO1xuICB9XG4gIGhhc0RldmljZUluVXNlKGtpbmQpIHtcbiAgICByZXR1cm4ga2luZCA/IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5oYXMoa2luZCkgOiBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2l6ZSA+IDA7XG4gIH1cbn1cbkRldmljZU1hbmFnZXIubWVkaWFEZXZpY2VLaW5kcyA9IFsnYXVkaW9pbnB1dCcsICdhdWRpb291dHB1dCcsICd2aWRlb2lucHV0J107XG5EZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAgPSBuZXcgTWFwKCk7XG5cbmNvbnN0IGRlZmF1bHREaW1lbnNpb25zVGltZW91dCA9IDEwMDA7XG5jbGFzcyBMb2NhbFRyYWNrIGV4dGVuZHMgVHJhY2sge1xuICBnZXQgY29uc3RyYWludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cmFpbnRzO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gbWVkaWFUcmFja1xuICAgKiBAcGFyYW0ga2luZFxuICAgKiBAcGFyYW0gY29uc3RyYWludHMgTWVkaWFUcmFja0NvbnN0cmFpbnRzIHRoYXQgYXJlIGJlaW5nIHVzZWQgd2hlbiByZXN0YXJ0aW5nIG9yIHJlYWNxdWlyaW5nIHRyYWNrc1xuICAgKiBAcGFyYW0gdXNlclByb3ZpZGVkVHJhY2sgU2lnbmFscyB0byB0aGUgU0RLIHdoZXRoZXIgb3Igbm90IHRoZSBtZWRpYVRyYWNrIHNob3VsZCBiZSBtYW5hZ2VkIChpLmUuIHJlbGVhc2VkIGFuZCByZWFjcXVpcmVkKSBpbnRlcm5hbGx5IGJ5IHRoZSBTREtcbiAgICovXG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIGtpbmQsIGNvbnN0cmFpbnRzKSB7XG4gICAgbGV0IHVzZXJQcm92aWRlZFRyYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIGtpbmQsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50ID0gKCkgPT4gdGhpcy5kZWJvdW5jZWRUcmFja011dGVIYW5kbGVyKCkuY2F0Y2goKCkgPT4gdGhpcy5sb2cuZGVidWcoJ3RyYWNrIG11dGUgYm91bmNlIGdvdCBjYW5jZWxsZWQgYnkgYW4gdW5tdXRlIGV2ZW50JywgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgdGhpcy5kZWJvdW5jZWRUcmFja011dGVIYW5kbGVyID0gcigoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCB0aGlzLnBhdXNlVXBzdHJlYW0oKTtcbiAgICB9KSwgNTAwMCk7XG4gICAgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50ID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5kZWJvdW5jZWRUcmFja011dGVIYW5kbGVyLmNhbmNlbCgndW5tdXRlJyk7XG4gICAgICB5aWVsZCB0aGlzLnJlc3VtZVVwc3RyZWFtKCk7XG4gICAgfSk7XG4gICAgdGhpcy5oYW5kbGVFbmRlZCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzSW5CYWNrZ3JvdW5kKSB7XG4gICAgICAgIHRoaXMucmVhY3F1aXJlVHJhY2sgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tVbm11dGVFdmVudCk7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbmRlZCwgdGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLnJlYWNxdWlyZVRyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5wcm92aWRlZEJ5VXNlciA9IHVzZXJQcm92aWRlZFRyYWNrO1xuICAgIHRoaXMubXV0ZUxvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLnBhdXNlVXBzdHJlYW1Mb2NrID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5wcm9jZXNzb3JMb2NrID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5zZXRNZWRpYVN0cmVhbVRyYWNrKG1lZGlhVHJhY2ssIHRydWUpO1xuICAgIC8vIGFkZGVkIHRvIHNhdGlzZnkgVFMgY29tcGlsZXIsIGNvbnN0cmFpbnRzIGFyZSBzeW5jZWQgd2l0aCBNZWRpYVN0cmVhbVRyYWNrXG4gICAgdGhpcy5fY29uc3RyYWludHMgPSBtZWRpYVRyYWNrLmdldENvbnN0cmFpbnRzKCk7XG4gICAgaWYgKGNvbnN0cmFpbnRzKSB7XG4gICAgICB0aGlzLl9jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xuICAgIH1cbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suaWQ7XG4gIH1cbiAgZ2V0IGRpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMua2luZCAhPT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpO1xuICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0IGlzVXBzdHJlYW1QYXVzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQ7XG4gIH1cbiAgZ2V0IGlzVXNlclByb3ZpZGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVkQnlVc2VyO1xuICB9XG4gIGdldCBtZWRpYVN0cmVhbVRyYWNrKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucHJvY2Vzc29yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvY2Vzc2VkVHJhY2spICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuX21lZGlhU3RyZWFtVHJhY2s7XG4gIH1cbiAgc2V0TWVkaWFTdHJlYW1UcmFjayhuZXdUcmFjaywgZm9yY2UpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKG5ld1RyYWNrID09PSB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrICYmICFmb3JjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICAvLyBkZXRhY2hcbiAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGRldGFjaFRyYWNrKHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIGVsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlci5jYW5jZWwoJ25ldy10cmFjaycpO1xuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignbXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tNdXRlRXZlbnQpO1xuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tVbm11dGVFdmVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1lZGlhU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKFtuZXdUcmFja10pO1xuICAgICAgaWYgKG5ld1RyYWNrKSB7XG4gICAgICAgIG5ld1RyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgICAgIC8vIHdoZW4gdW5kZXJseWluZyB0cmFjayBlbWl0cyBtdXRlLCBpdCBpbmRpY2F0ZXMgdGhhdCB0aGUgZGV2aWNlIGlzIHVuYWJsZVxuICAgICAgICAvLyB0byBwcm9kdWNlIG1lZGlhLiBJbiB0aGlzIGNhc2Ugd2UnbGwgbmVlZCB0byBzaWduYWwgd2l0aCByZW1vdGUgdGhhdFxuICAgICAgICAvLyB0aGUgdHJhY2sgaXMgXCJtdXRlZFwiXG4gICAgICAgIC8vIG5vdGUgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBMb2NhbFRyYWNrLm11dGUgYmVjYXVzZSB3ZSBkbyBub3Qgd2FudCB0b1xuICAgICAgICAvLyB0b3VjaCBNZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWRcbiAgICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tNdXRlRXZlbnQpO1xuICAgICAgICBuZXdUcmFjay5hZGRFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50cyA9IG5ld1RyYWNrLmdldENvbnN0cmFpbnRzKCk7XG4gICAgICB9XG4gICAgICBsZXQgcHJvY2Vzc2VkVHJhY2s7XG4gICAgICBpZiAodGhpcy5wcm9jZXNzb3IgJiYgbmV3VHJhY2sgJiYgdGhpcy5wcm9jZXNzb3JFbGVtZW50KSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZXN0YXJ0aW5nIHByb2Nlc3NvcicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09ICd1bmtub3duJykge1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignY2Fubm90IHNldCBwcm9jZXNzb3Igb24gdHJhY2sgb2YgdW5rbm93biBraW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0YWNoVG9FbGVtZW50KG5ld1RyYWNrLCB0aGlzLnByb2Nlc3NvckVsZW1lbnQpO1xuICAgICAgICAvLyBlbnN1cmUgdGhlIHByb2Nlc3NvckVsZW1lbnQgaXRzZWxmIHN0YXlzIG11dGVkXG4gICAgICAgIHRoaXMucHJvY2Vzc29yRWxlbWVudC5tdXRlZCA9IHRydWU7XG4gICAgICAgIHlpZWxkIHRoaXMucHJvY2Vzc29yLnJlc3RhcnQoe1xuICAgICAgICAgIHRyYWNrOiBuZXdUcmFjayxcbiAgICAgICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICAgICAgZWxlbWVudDogdGhpcy5wcm9jZXNzb3JFbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9jZXNzZWRUcmFjayA9IHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VuZGVyKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuc2VuZGVyLnJlcGxhY2VUcmFjayhwcm9jZXNzZWRUcmFjayAhPT0gbnVsbCAmJiBwcm9jZXNzZWRUcmFjayAhPT0gdm9pZCAwID8gcHJvY2Vzc2VkVHJhY2sgOiBuZXdUcmFjayk7XG4gICAgICB9XG4gICAgICAvLyBpZiBgbmV3VHJhY2tgIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBleGlzdGluZyB0cmFjaywgc3RvcCB0aGVcbiAgICAgIC8vIG9sZGVyIHRyYWNrIGp1c3QgYmVmb3JlIHJlcGxhY2luZyBpdFxuICAgICAgaWYgKCF0aGlzLnByb3ZpZGVkQnlVc2VyICYmIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgIT09IG5ld1RyYWNrKSB7XG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjayA9IG5ld1RyYWNrO1xuICAgICAgaWYgKG5ld1RyYWNrKSB7XG4gICAgICAgIC8vIHN5bmMgbXV0ZWQgc3RhdGUgd2l0aCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbmV3bHkgcHJvdmlkZWQgdHJhY2tcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gIXRoaXMuaXNNdXRlZDtcbiAgICAgICAgLy8gd2hlbiBhIHZhbGlkIHRyYWNrIGlzIHJlcGxhY2UsIHdlJ2Qgd2FudCB0byBzdGFydCBwcm9kdWNpbmdcbiAgICAgICAgeWllbGQgdGhpcy5yZXN1bWVVcHN0cmVhbSgpO1xuICAgICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgYXR0YWNoVG9FbGVtZW50KHByb2Nlc3NlZFRyYWNrICE9PSBudWxsICYmIHByb2Nlc3NlZFRyYWNrICE9PSB2b2lkIDAgPyBwcm9jZXNzZWRUcmFjayA6IG5ld1RyYWNrLCBlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHdhaXRGb3JEaW1lbnNpb25zKCkge1xuICAgIGxldCB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBkZWZhdWx0RGltZW5zaW9uc1RpbWVvdXQ7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdldCBkaW1lbnNpb25zIGZvciBhdWRpbyB0cmFja3MnKTtcbiAgICAgIH1cbiAgICAgIGlmICgoKF9hID0gZ2V0QnJvd3NlcigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3MpID09PSAnaU9TJykge1xuICAgICAgICAvLyBicm93c2VycyByZXBvcnQgd3JvbmcgaW5pdGlhbCByZXNvbHV0aW9uIG9uIGlPUy5cbiAgICAgICAgLy8gd2hlbiBzbGlnaHRseSBkZWxheWluZyB0aGUgY2FsbCB0byAuZ2V0U2V0dGluZ3MoKSwgdGhlIGNvcnJlY3QgcmVzb2x1dGlvbiBpcyBiZWluZyByZXBvcnRlZFxuICAgICAgICB5aWVsZCBzbGVlcCgxMCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydGVkID0gRGF0ZS5ub3coKTtcbiAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRlZCA8IHRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgZGltcyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICAgICAgaWYgKGRpbXMpIHtcbiAgICAgICAgICByZXR1cm4gZGltcztcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBzbGVlcCg1MCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ3VuYWJsZSB0byBnZXQgdHJhY2sgZGltZW5zaW9ucyBhZnRlciB0aW1lb3V0Jyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIERldmljZUlEIG9mIHRoZSBkZXZpY2UgdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgdXNlZCBmb3IgdGhpcyB0cmFja1xuICAgKi9cbiAgZ2V0RGV2aWNlSWQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIHNjcmVlbiBzaGFyZSBkb2Vzbid0IGhhdmUgYSB1c2FibGUgZGV2aWNlIGlkXG4gICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRldmljZUlkLFxuICAgICAgICBncm91cElkXG4gICAgICB9ID0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpO1xuICAgICAgY29uc3Qga2luZCA9IHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbyA/ICdhdWRpb2lucHV0JyA6ICd2aWRlb2lucHV0JztcbiAgICAgIHJldHVybiBEZXZpY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkubm9ybWFsaXplRGV2aWNlSWQoa2luZCwgZGV2aWNlSWQsIGdyb3VwSWQpO1xuICAgIH0pO1xuICB9XG4gIG11dGUoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuc2V0VHJhY2tNdXRlZCh0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9XG4gIHVubXV0ZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5zZXRUcmFja011dGVkKGZhbHNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9XG4gIHJlcGxhY2VUcmFjayh0cmFjaykge1xuICAgIGxldCB1c2VyUHJvdmlkZWRUcmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xuICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ3VuYWJsZSB0byByZXBsYWNlIGFuIHVucHVibGlzaGVkIHRyYWNrJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygncmVwbGFjZSBNZWRpYVN0cmVhbVRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHlpZWxkIHRoaXMuc2V0TWVkaWFTdHJlYW1UcmFjayh0cmFjayk7XG4gICAgICAvLyB0aGlzIG11c3QgYmUgc3luY2VkICphZnRlciogc2V0dGluZyBtZWRpYVN0cmVhbVRyYWNrIGFib3ZlLCBzaW5jZSBpdCByZWxpZXNcbiAgICAgIC8vIG9uIHRoZSBwcmV2aW91cyBzdGF0ZSBpbiBvcmRlciB0byBjbGVhbnVwXG4gICAgICB0aGlzLnByb3ZpZGVkQnlVc2VyID0gdXNlclByb3ZpZGVkVHJhY2s7XG4gICAgICBpZiAodGhpcy5wcm9jZXNzb3IpIHtcbiAgICAgICAgeWllbGQgdGhpcy5zdG9wUHJvY2Vzc29yKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxuICByZXN0YXJ0KGNvbnN0cmFpbnRzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghY29uc3RyYWludHMpIHtcbiAgICAgICAgY29uc3RyYWludHMgPSB0aGlzLl9jb25zdHJhaW50cztcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZXN0YXJ0aW5nIHRyYWNrIHdpdGggY29uc3RyYWludHMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgY29uc3RyYWludHNcbiAgICAgIH0pKTtcbiAgICAgIGNvbnN0IHN0cmVhbUNvbnN0cmFpbnRzID0ge1xuICAgICAgICBhdWRpbzogZmFsc2UsXG4gICAgICAgIHZpZGVvOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgc3RyZWFtQ29uc3RyYWludHMudmlkZW8gPSBjb25zdHJhaW50cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbUNvbnN0cmFpbnRzLmF1ZGlvID0gY29uc3RyYWludHM7XG4gICAgICB9XG4gICAgICAvLyB0aGVzZSBzdGVwcyBhcmUgZHVwbGljYXRlZCBmcm9tIHNldE1lZGlhU3RyZWFtVHJhY2sgYmVjYXVzZSB3ZSBtdXN0IHN0b3BcbiAgICAgIC8vIHRoZSBwcmV2aW91cyB0cmFja3MgYmVmb3JlIG5ldyB0cmFja3MgY2FuIGJlIGFjcXVpcmVkXG4gICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGRldGFjaFRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWwpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgICAvLyBvbiBTYWZhcmksIHRoZSBvbGQgYXVkaW8gdHJhY2sgbXVzdCBiZSBzdG9wcGVkIGJlZm9yZSBhdHRlbXB0aW5nIHRvIGFjcXVpcmVcbiAgICAgIC8vIHRoZSBuZXcgdHJhY2ssIG90aGVyd2lzZSB0aGUgbmV3IHRyYWNrIHdpbGwgc3RvcCB3aXRoXG4gICAgICAvLyAnQSBNZWRpYVN0cmVhbVRyYWNrIGVuZGVkIGR1ZSB0byBhIGNhcHR1cmUgZmFpbHVyZWBcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgICAgLy8gY3JlYXRlIG5ldyB0cmFjayBhbmQgYXR0YWNoXG4gICAgICBjb25zdCBtZWRpYVN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHN0cmVhbUNvbnN0cmFpbnRzKTtcbiAgICAgIGNvbnN0IG5ld1RyYWNrID0gbWVkaWFTdHJlYW0uZ2V0VHJhY2tzKClbMF07XG4gICAgICBuZXdUcmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlLWFjcXVpcmVkIE1lZGlhU3RyZWFtVHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgeWllbGQgdGhpcy5zZXRNZWRpYVN0cmVhbVRyYWNrKG5ld1RyYWNrKTtcbiAgICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5SZXN0YXJ0ZWQsIHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gIH1cbiAgc2V0VHJhY2tNdXRlZChtdXRlZCkge1xuICAgIHRoaXMubG9nLmRlYnVnKFwic2V0dGluZyBcIi5jb25jYXQodGhpcy5raW5kLCBcIiB0cmFjayBcIikuY29uY2F0KG11dGVkID8gJ211dGVkJyA6ICd1bm11dGVkJyksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgaWYgKHRoaXMuaXNNdXRlZCA9PT0gbXV0ZWQgJiYgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkICE9PSBtdXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzTXV0ZWQgPSBtdXRlZDtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSAhbXV0ZWQ7XG4gICAgdGhpcy5lbWl0KG11dGVkID8gVHJhY2tFdmVudC5NdXRlZCA6IFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcyk7XG4gIH1cbiAgZ2V0IG5lZWRzUmVBY3F1aXNpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZWFkeVN0YXRlICE9PSAnbGl2ZScgfHwgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5tdXRlZCB8fCAhdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkIHx8IHRoaXMucmVhY3F1aXJlVHJhY2s7XG4gIH1cbiAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZDoge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIF9zdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZC5jYWxsKHRoaXMpO1xuICAgICAgaWYgKCFpc01vYmlsZSgpKSByZXR1cm47XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInZpc2liaWxpdHkgY2hhbmdlZCwgaXMgaW4gQmFja2dyb3VuZDogXCIuY29uY2F0KHRoaXMuaXNJbkJhY2tncm91bmQpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgaWYgKCF0aGlzLmlzSW5CYWNrZ3JvdW5kICYmIHRoaXMubmVlZHNSZUFjcXVpc2l0aW9uICYmICF0aGlzLmlzVXNlclByb3ZpZGVkICYmICF0aGlzLmlzTXV0ZWQpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJ0cmFjayBuZWVkcyB0byBiZSByZWFjcXVpcmVkLCByZXN0YXJ0aW5nIFwiLmNvbmNhdCh0aGlzLnNvdXJjZSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHlpZWxkIHRoaXMucmVzdGFydCgpO1xuICAgICAgICB0aGlzLnJlYWNxdWlyZVRyYWNrID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB2YXIgX2E7XG4gICAgc3VwZXIuc3RvcCgpO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tVbm11dGVFdmVudCk7XG4gICAgKF9hID0gdGhpcy5wcm9jZXNzb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgdGhpcy5wcm9jZXNzb3IgPSB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXG4gICAqIHBhdXNlcyBwdWJsaXNoaW5nIHRvIHRoZSBzZXJ2ZXIgd2l0aG91dCBkaXNhYmxpbmcgdGhlIGxvY2FsIE1lZGlhU3RyZWFtVHJhY2tcbiAgICogdGhpcyBpcyB1c2VkIHRvIGRpc3BsYXkgYSB1c2VyJ3Mgb3duIHZpZGVvIGxvY2FsbHkgd2hpbGUgcGF1c2luZyBwdWJsaXNoaW5nIHRvXG4gICAqIHRoZSBzZXJ2ZXIuXG4gICAqIHRoaXMgQVBJIGlzIHVuc3VwcG9ydGVkIG9uIFNhZmFyaSA8IDEyIGR1ZSB0byBhIGJ1Z1xuICAgKiovXG4gIHBhdXNlVXBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMucGF1c2VVcHN0cmVhbUxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ3VuYWJsZSB0byBwYXVzZSB1cHN0cmVhbSBmb3IgYW4gdW5wdWJsaXNoZWQgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBzdHJlYW1QYXVzZWQsIHRoaXMpO1xuICAgICAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgICAgICBpZiAoKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5uYW1lKSA9PT0gJ1NhZmFyaScgJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIudmVyc2lvbiwgJzEyLjAnKSA8IDApIHtcbiAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTg0OTExXG4gICAgICAgICAgdGhyb3cgbmV3IERldmljZVVuc3VwcG9ydGVkRXJyb3IoJ3BhdXNlVXBzdHJlYW0gaXMgbm90IHN1cHBvcnRlZCBvbiBTYWZhcmkgPCAxMi4nKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB0aGlzLnNlbmRlci5yZXBsYWNlVHJhY2sobnVsbCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXN1bWVVcHN0cmVhbSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5wYXVzZVVwc3RyZWFtTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ3VuYWJsZSB0byByZXN1bWUgdXBzdHJlYW0gZm9yIGFuIHVucHVibGlzaGVkIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5VcHN0cmVhbVJlc3VtZWQsIHRoaXMpO1xuICAgICAgICAvLyB0aGlzIG9wZXJhdGlvbiBpcyBub29wIGlmIG1lZGlhc3RyZWFtdHJhY2sgaXMgYWxyZWFkeSBiZWluZyBzZW50XG4gICAgICAgIHlpZWxkIHRoaXMuc2VuZGVyLnJlcGxhY2VUcmFjayh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBSVENTdGF0c1JlcG9ydCBmb3IgdGhlIExvY2FsVHJhY2sncyB1bmRlcmx5aW5nIFJUQ1J0cFNlbmRlclxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1N0YXRzUmVwb3J0XG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2U8UlRDU3RhdHNSZXBvcnQ+IHwgdW5kZWZpbmVkXG4gICAqL1xuICBnZXRSVENTdGF0c1JlcG9ydCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghKChfYSA9IHRoaXMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzUmVwb3J0ID0geWllbGQgdGhpcy5zZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICAgIHJldHVybiBzdGF0c1JlcG9ydDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhIHByb2Nlc3NvciBvbiB0aGlzIHRyYWNrLlxuICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2xpdmVraXQvdHJhY2stcHJvY2Vzc29ycy1qcyBmb3IgZXhhbXBsZSB1c2FnZVxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqXG4gICAqIEBwYXJhbSBwcm9jZXNzb3JcbiAgICogQHBhcmFtIHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBzZXRQcm9jZXNzb3IocHJvY2Vzc29yKSB7XG4gICAgbGV0IHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMucHJvY2Vzc29yTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1Zygnc2V0dGluZyB1cCBwcm9jZXNzb3InLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3IpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnN0b3BQcm9jZXNzb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5raW5kID09PSAndW5rbm93bicpIHtcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgcHJvY2Vzc29yIG9uIHRyYWNrIG9mIHVua25vd24ga2luZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvY2Vzc29yRWxlbWVudCA9IChfYSA9IHRoaXMucHJvY2Vzc29yRWxlbWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmtpbmQpO1xuICAgICAgICBhdHRhY2hUb0VsZW1lbnQodGhpcy5fbWVkaWFTdHJlYW1UcmFjaywgdGhpcy5wcm9jZXNzb3JFbGVtZW50KTtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3JFbGVtZW50Lm11dGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3JFbGVtZW50LnBsYXkoKS5jYXRjaChlcnJvciA9PiB0aGlzLmxvZy5lcnJvcignZmFpbGVkIHRvIHBsYXkgcHJvY2Vzc29yIGVsZW1lbnQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlcnJvclxuICAgICAgICB9KSkpO1xuICAgICAgICBjb25zdCBwcm9jZXNzb3JPcHRpb25zID0ge1xuICAgICAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgICAgICB0cmFjazogdGhpcy5fbWVkaWFTdHJlYW1UcmFjayxcbiAgICAgICAgICBlbGVtZW50OiB0aGlzLnByb2Nlc3NvckVsZW1lbnRcbiAgICAgICAgfTtcbiAgICAgICAgeWllbGQgcHJvY2Vzc29yLmluaXQocHJvY2Vzc29yT3B0aW9ucyk7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMuYXR0YWNoZWRFbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKGVsICE9PSB0aGlzLnByb2Nlc3NvckVsZW1lbnQgJiYgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkpIHtcbiAgICAgICAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5fbWVkaWFTdHJlYW1UcmFjaywgZWwpO1xuICAgICAgICAgICAgICBhdHRhY2hUb0VsZW1lbnQodGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2ssIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgeWllbGQgKF9iID0gdGhpcy5zZW5kZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZXBsYWNlVHJhY2sodGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRQcm9jZXNzb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc29yO1xuICB9XG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgdHJhY2sgcHJvY2Vzc29yXG4gICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWtpdC90cmFjay1wcm9jZXNzb3JzLWpzIGZvciBleGFtcGxlIHVzYWdlXG4gICAqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICogQHJldHVybnNcbiAgICovXG4gIHN0b3BQcm9jZXNzb3IoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnByb2Nlc3NvcikgcmV0dXJuO1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3N0b3BwaW5nIHByb2Nlc3NvcicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAoX2EgPSB0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3AoKTtcbiAgICAgIHlpZWxkIHRoaXMucHJvY2Vzc29yLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMucHJvY2Vzc29yID0gdW5kZWZpbmVkO1xuICAgICAgKF9iID0gdGhpcy5wcm9jZXNzb3JFbGVtZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVtb3ZlKCk7XG4gICAgICB0aGlzLnByb2Nlc3NvckVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuY2xhc3MgRTJFRU1hbmFnZXIgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub25Xb3JrZXJNZXNzYWdlID0gZXYgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2luZCxcbiAgICAgICAgZGF0YVxuICAgICAgfSA9IGV2LmRhdGE7XG4gICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgIGxpdmVraXRMb2dnZXIuZXJyb3IoZGF0YS5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLmVtaXQoRW5jcnlwdGlvbkV2ZW50LkVuY3J5cHRpb25FcnJvciwgZGF0YS5lcnJvcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luaXRBY2snOlxuICAgICAgICAgIGlmIChkYXRhLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMua2V5UHJvdmlkZXIuZ2V0S2V5cygpLmZvckVhY2goa2V5SW5mbyA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucG9zdEtleShrZXlJbmZvKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZW5hYmxlJzpcbiAgICAgICAgICBpZiAodGhpcy5lbmNyeXB0aW9uRW5hYmxlZCAhPT0gZGF0YS5lbmFibGVkICYmIGRhdGEucGFydGljaXBhbnRJZGVudGl0eSA9PT0gKChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoRW5jcnlwdGlvbkV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsIGRhdGEuZW5hYmxlZCwgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQpO1xuICAgICAgICAgICAgdGhpcy5lbmNyeXB0aW9uRW5hYmxlZCA9IGRhdGEuZW5hYmxlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEucGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgICAgICAgICAgY29uc3QgcGFydGljaXBhbnQgPSAoX2IgPSB0aGlzLnJvb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRQYXJ0aWNpcGFudEJ5SWRlbnRpdHkoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgICAgICAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiY291bGRuJ3Qgc2V0IGVuY3J5cHRpb24gc3RhdHVzLCBwYXJ0aWNpcGFudCBub3QgZm91bmRcIi5jb25jYXQoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoRW5jcnlwdGlvbkV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsIGRhdGEuZW5hYmxlZCwgcGFydGljaXBhbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5lbmNyeXB0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5rZXlQcm92aWRlci5nZXRLZXlzKCkuZm9yRWFjaChrZXlJbmZvID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5wb3N0S2V5KGtleUluZm8pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyYXRjaGV0S2V5JzpcbiAgICAgICAgICB0aGlzLmtleVByb3ZpZGVyLmVtaXQoS2V5UHJvdmlkZXJFdmVudC5LZXlSYXRjaGV0ZWQsIGRhdGEubWF0ZXJpYWwsIGRhdGEua2V5SW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vbldvcmtlckVycm9yID0gZXYgPT4ge1xuICAgICAgbGl2ZWtpdExvZ2dlci5lcnJvcignZTJlZSB3b3JrZXIgZW5jb3VudGVyZWQgYW4gZXJyb3I6Jywge1xuICAgICAgICBlcnJvcjogZXYuZXJyb3JcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0KEVuY3J5cHRpb25FdmVudC5FbmNyeXB0aW9uRXJyb3IsIGV2LmVycm9yKTtcbiAgICB9O1xuICAgIHRoaXMua2V5UHJvdmlkZXIgPSBvcHRpb25zLmtleVByb3ZpZGVyO1xuICAgIHRoaXMud29ya2VyID0gb3B0aW9ucy53b3JrZXI7XG4gICAgdGhpcy5lbmNyeXB0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldHVwKHJvb20pIHtcbiAgICBpZiAoIWlzRTJFRVN1cHBvcnRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcigndHJpZWQgdG8gc2V0dXAgZW5kLXRvLWVuZCBlbmNyeXB0aW9uIG9uIGFuIHVuc3VwcG9ydGVkIGJyb3dzZXInKTtcbiAgICB9XG4gICAgbGl2ZWtpdExvZ2dlci5pbmZvKCdzZXR0aW5nIHVwIGUyZWUnKTtcbiAgICBpZiAocm9vbSAhPT0gdGhpcy5yb29tKSB7XG4gICAgICB0aGlzLnJvb20gPSByb29tO1xuICAgICAgdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKHJvb20sIHRoaXMua2V5UHJvdmlkZXIpO1xuICAgICAgLy8gdGhpcy53b3JrZXIgPSBuZXcgV29ya2VyKCcnKTtcbiAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAga2luZDogJ2luaXQnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAga2V5UHJvdmlkZXJPcHRpb25zOiB0aGlzLmtleVByb3ZpZGVyLmdldE9wdGlvbnMoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMud29ya2VyKSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIuaW5mbyhcImluaXRpYWxpemluZyB3b3JrZXJcIiwge1xuICAgICAgICAgIHdvcmtlcjogdGhpcy53b3JrZXJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud29ya2VyLm9ubWVzc2FnZSA9IHRoaXMub25Xb3JrZXJNZXNzYWdlO1xuICAgICAgICB0aGlzLndvcmtlci5vbmVycm9yID0gdGhpcy5vbldvcmtlckVycm9yO1xuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKGVuYWJsZWQsIHBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwic2V0IGUyZWUgdG8gXCIuY29uY2F0KGVuYWJsZWQsIFwiIGZvciBwYXJ0aWNpcGFudCBcIikuY29uY2F0KHBhcnRpY2lwYW50SWRlbnRpdHkpKTtcbiAgICB0aGlzLnBvc3RFbmFibGUoZW5hYmxlZCwgcGFydGljaXBhbnRJZGVudGl0eSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0U2lmVHJhaWxlcih0cmFpbGVyKSB7XG4gICAgaWYgKCF0cmFpbGVyIHx8IHRyYWlsZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICBsaXZla2l0TG9nZ2VyLndhcm4oXCJpZ25vcmluZyBzZXJ2ZXIgc2VudCB0cmFpbGVyIGFzIGl0J3MgZW1wdHlcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucG9zdFNpZlRyYWlsZXIodHJhaWxlcik7XG4gICAgfVxuICB9XG4gIHNldHVwRW5naW5lKGVuZ2luZSkge1xuICAgIGVuZ2luZS5vbihFbmdpbmVFdmVudC5SVFBWaWRlb01hcFVwZGF0ZSwgcnRwTWFwID0+IHtcbiAgICAgIHRoaXMucG9zdFJUUE1hcChydHBNYXApO1xuICAgIH0pO1xuICB9XG4gIHNldHVwRXZlbnRMaXN0ZW5lcnMocm9vbSwga2V5UHJvdmlkZXIpIHtcbiAgICByb29tLm9uKFJvb21FdmVudC5UcmFja1B1Ymxpc2hlZCwgKHB1YiwgcGFydGljaXBhbnQpID0+IHRoaXMuc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChwdWIudHJhY2tJbmZvLmVuY3J5cHRpb24gIT09IEVuY3J5cHRpb25fVHlwZS5OT05FLCBwYXJ0aWNpcGFudC5pZGVudGl0eSkpO1xuICAgIHJvb20ub24oUm9vbUV2ZW50LkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsIHN0YXRlID0+IHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICByb29tLnBhcnRpY2lwYW50cy5mb3JFYWNoKHBhcnRpY2lwYW50ID0+IHtcbiAgICAgICAgICBwYXJ0aWNpcGFudC50cmFja3MuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKHB1Yi50cmFja0luZm8uZW5jcnlwdGlvbiAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUsIHBhcnRpY2lwYW50LmlkZW50aXR5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkub24oUm9vbUV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCAodHJhY2ssIF8sIHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgIGtpbmQ6ICdyZW1vdmVUcmFuc2Zvcm0nLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICAgICAgdHJhY2tJZDogdHJhY2subWVkaWFTdHJlYW1JRFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgKF9hID0gdGhpcy53b3JrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3N0TWVzc2FnZShtc2cpO1xuICAgIH0pLm9uKFJvb21FdmVudC5UcmFja1N1YnNjcmliZWQsICh0cmFjaywgcHViLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgdGhpcy5zZXR1cEUyRUVSZWNlaXZlcih0cmFjaywgcGFydGljaXBhbnQuaWRlbnRpdHksIHB1Yi50cmFja0luZm8pO1xuICAgIH0pLm9uKFJvb21FdmVudC5TaWduYWxDb25uZWN0ZWQsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5yb29tKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RlZCByb29tIHRvIGJlIHByZXNlbnQgb24gc2lnbmFsIGNvbm5lY3RcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQodGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaXNFMkVFRW5hYmxlZCwgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpO1xuICAgICAga2V5UHJvdmlkZXIuZ2V0S2V5cygpLmZvckVhY2goa2V5SW5mbyA9PiB7XG4gICAgICAgIHRoaXMucG9zdEtleShrZXlJbmZvKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJvb20ubG9jYWxQYXJ0aWNpcGFudC5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIHB1YmxpY2F0aW9uID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuc2V0dXBFMkVFU2VuZGVyKHB1YmxpY2F0aW9uLnRyYWNrLCBwdWJsaWNhdGlvbi50cmFjay5zZW5kZXIpO1xuICAgIH0pKTtcbiAgICBrZXlQcm92aWRlci5vbihLZXlQcm92aWRlckV2ZW50LlNldEtleSwga2V5SW5mbyA9PiB0aGlzLnBvc3RLZXkoa2V5SW5mbykpLm9uKEtleVByb3ZpZGVyRXZlbnQuUmF0Y2hldFJlcXVlc3QsIChwYXJ0aWNpcGFudElkLCBrZXlJbmRleCkgPT4gdGhpcy5wb3N0UmF0Y2hldFJlcXVlc3QocGFydGljaXBhbnRJZCwga2V5SW5kZXgpKTtcbiAgfVxuICBwb3N0UmF0Y2hldFJlcXVlc3QocGFydGljaXBhbnRJZGVudGl0eSwga2V5SW5kZXgpIHtcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICB0aHJvdyBFcnJvcignY291bGQgbm90IHJhdGNoZXQga2V5LCB3b3JrZXIgaXMgbWlzc2luZycpO1xuICAgIH1cbiAgICBjb25zdCBtc2cgPSB7XG4gICAgICBraW5kOiAncmF0Y2hldFJlcXVlc3QnLFxuICAgICAgZGF0YToge1xuICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICBrZXlJbmRleFxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgfVxuICBwb3N0S2V5KF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAga2V5LFxuICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgIGtleUluZGV4XG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIF9hO1xuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHRocm93IEVycm9yKCdjb3VsZCBub3Qgc2V0IGtleSwgd29ya2VyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnID0ge1xuICAgICAga2luZDogJ3NldEtleScsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgIGlzUHVibGlzaGVyOiBwYXJ0aWNpcGFudElkZW50aXR5ID09PSAoKF9hID0gdGhpcy5yb29tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSksXG4gICAgICAgIGtleSxcbiAgICAgICAga2V5SW5kZXhcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gIH1cbiAgcG9zdEVuYWJsZShlbmFibGVkLCBwYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgaWYgKHRoaXMud29ya2VyKSB7XG4gICAgICBjb25zdCBlbmFibGVNc2cgPSB7XG4gICAgICAgIGtpbmQ6ICdlbmFibGUnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZW5hYmxlZCxcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShlbmFibGVNc2cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ2ZhaWxlZCB0byBlbmFibGUgZTJlZSwgd29ya2VyIGlzIG5vdCByZWFkeScpO1xuICAgIH1cbiAgfVxuICBwb3N0UlRQTWFwKG1hcCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2NvdWxkIG5vdCBwb3N0IHJ0cCBtYXAsIHdvcmtlciBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGlmICghKChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2NvdWxkIG5vdCBwb3N0IHJ0cCBtYXAsIGxvY2FsIHBhcnRpY2lwYW50IGlkZW50aXR5IGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnID0ge1xuICAgICAga2luZDogJ3NldFJUUE1hcCcsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1hcCxcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHlcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gIH1cbiAgcG9zdFNpZlRyYWlsZXIodHJhaWxlcikge1xuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHRocm93IEVycm9yKCdjb3VsZCBub3QgcG9zdCBTSUYgdHJhaWxlciwgd29ya2VyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnID0ge1xuICAgICAga2luZDogJ3NldFNpZlRyYWlsZXInLFxuICAgICAgZGF0YToge1xuICAgICAgICB0cmFpbGVyXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICB9XG4gIHNldHVwRTJFRVJlY2VpdmVyKHRyYWNrLCByZW1vdGVJZCwgdHJhY2tJbmZvKSB7XG4gICAgaWYgKCF0cmFjay5yZWNlaXZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh0cmFja0luZm8gPT09IG51bGwgfHwgdHJhY2tJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFja0luZm8ubWltZVR5cGUpIHx8IHRyYWNrSW5mby5taW1lVHlwZSA9PT0gJycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pbWVUeXBlIG1pc3NpbmcgZnJvbSB0cmFja0luZm8sIGNhbm5vdCBzZXQgdXAgRTJFRSBjcnlwdG9yJyk7XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlUmVjZWl2ZXIodHJhY2sucmVjZWl2ZXIsIHRyYWNrLm1lZGlhU3RyZWFtSUQsIHJlbW90ZUlkLCB0cmFjay5raW5kID09PSAndmlkZW8nID8gbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcodHJhY2tJbmZvLm1pbWVUeXBlKSA6IHVuZGVmaW5lZCk7XG4gIH1cbiAgc2V0dXBFMkVFU2VuZGVyKHRyYWNrLCBzZW5kZXIpIHtcbiAgICBpZiAoISh0cmFjayBpbnN0YW5jZW9mIExvY2FsVHJhY2spIHx8ICFzZW5kZXIpIHtcbiAgICAgIGlmICghc2VuZGVyKSBsaXZla2l0TG9nZ2VyLndhcm4oJ2Vhcmx5IHJldHVybiBiZWNhdXNlIHNlbmRlciBpcyBub3QgcmVhZHknKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVTZW5kZXIoc2VuZGVyLCB0cmFjay5tZWRpYVN0cmVhbUlELCB1bmRlZmluZWQpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBnaXZlbiB7QGNvZGUgUlRDUnRwUmVjZWl2ZXJ9IGJ5IGNyZWF0aW5nIGEge0Bjb2RlIFRyYW5zZm9ybVN0cmVhbX0gd2hpY2ggd2lsbCBpbmplY3RcbiAgICogYSBmcmFtZSBkZWNvZGVyLlxuICAgKlxuICAgKi9cbiAgaGFuZGxlUmVjZWl2ZXIocmVjZWl2ZXIsIHRyYWNrSWQsIHBhcnRpY2lwYW50SWRlbnRpdHksIGNvZGVjKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBraW5kOiAnZGVjb2RlJyxcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICAgIHRyYWNrSWQsXG4gICAgICAgICAgY29kZWNcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZWNlaXZlci50cmFuc2Zvcm0gPSBuZXcgUlRDUnRwU2NyaXB0VHJhbnNmb3JtKHRoaXMud29ya2VyLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChFMkVFX0ZMQUcgaW4gcmVjZWl2ZXIgJiYgY29kZWMpIHtcbiAgICAgICAgICAvLyBvbmx5IHVwZGF0ZSBjb2RlY1xuICAgICAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAgICAgIGtpbmQ6ICd1cGRhdGVDb2RlYycsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHRyYWNrSWQsXG4gICAgICAgICAgICAgIGNvZGVjLFxuICAgICAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCB3cml0YWJsZSA9IHJlY2VpdmVyLndyaXRhYmxlU3RyZWFtO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCByZWFkYWJsZSA9IHJlY2VpdmVyLnJlYWRhYmxlU3RyZWFtO1xuICAgICAgICBpZiAoIXdyaXRhYmxlIHx8ICFyZWFkYWJsZSkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjb25zdCByZWNlaXZlclN0cmVhbXMgPSByZWNlaXZlci5jcmVhdGVFbmNvZGVkU3RyZWFtcygpO1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICByZWNlaXZlci53cml0YWJsZVN0cmVhbSA9IHJlY2VpdmVyU3RyZWFtcy53cml0YWJsZTtcbiAgICAgICAgICB3cml0YWJsZSA9IHJlY2VpdmVyU3RyZWFtcy53cml0YWJsZTtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgcmVjZWl2ZXIucmVhZGFibGVTdHJlYW0gPSByZWNlaXZlclN0cmVhbXMucmVhZGFibGU7XG4gICAgICAgICAgcmVhZGFibGUgPSByZWNlaXZlclN0cmVhbXMucmVhZGFibGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICAgIGtpbmQ6ICdkZWNvZGUnLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHJlYWRhYmxlU3RyZWFtOiByZWFkYWJsZSxcbiAgICAgICAgICAgIHdyaXRhYmxlU3RyZWFtOiB3cml0YWJsZSxcbiAgICAgICAgICAgIHRyYWNrSWQ6IHRyYWNrSWQsXG4gICAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHlcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZywgW3JlYWRhYmxlLCB3cml0YWJsZV0pO1xuICAgICAgfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmVjZWl2ZXJbRTJFRV9GTEFHXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGdpdmVuIHtAY29kZSBSVENSdHBTZW5kZXJ9IGJ5IGNyZWF0aW5nIGEge0Bjb2RlIFRyYW5zZm9ybVN0cmVhbX0gd2hpY2ggd2lsbCBpbmplY3RcbiAgICogYSBmcmFtZSBlbmNvZGVyLlxuICAgKlxuICAgKi9cbiAgaGFuZGxlU2VuZGVyKHNlbmRlciwgdHJhY2tJZCwgY29kZWMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKEUyRUVfRkxBRyBpbiBzZW5kZXIgfHwgIXRoaXMud29ya2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpIHx8IHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID09PSAnJykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdsb2NhbCBpZGVudGl0eSBuZWVkcyB0byBiZSBrbm93biBpbiBvcmRlciB0byBzZXQgdXAgZW5jcnlwdGVkIHNlbmRlcicpO1xuICAgIH1cbiAgICBpZiAoaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKSkge1xuICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKCdpbml0aWFsaXplIHNjcmlwdCB0cmFuc2Zvcm0nKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGtpbmQ6ICdlbmNvZGUnLFxuICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSxcbiAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgY29kZWNcbiAgICAgIH07XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBzZW5kZXIudHJhbnNmb3JtID0gbmV3IFJUQ1J0cFNjcmlwdFRyYW5zZm9ybSh0aGlzLndvcmtlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpdmVraXRMb2dnZXIuaW5mbygnaW5pdGlhbGl6ZSBlbmNvZGVkIHN0cmVhbXMnKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IHNlbmRlclN0cmVhbXMgPSBzZW5kZXIuY3JlYXRlRW5jb2RlZFN0cmVhbXMoKTtcbiAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAga2luZDogJ2VuY29kZScsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICByZWFkYWJsZVN0cmVhbTogc2VuZGVyU3RyZWFtcy5yZWFkYWJsZSxcbiAgICAgICAgICB3cml0YWJsZVN0cmVhbTogc2VuZGVyU3RyZWFtcy53cml0YWJsZSxcbiAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2csIFtzZW5kZXJTdHJlYW1zLnJlYWRhYmxlLCBzZW5kZXJTdHJlYW1zLndyaXRhYmxlXSk7XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBzZW5kZXJbRTJFRV9GTEFHXSA9IHRydWU7XG4gIH1cbn1cblxudmFyIFF1ZXVlVGFza1N0YXR1cztcbihmdW5jdGlvbiAoUXVldWVUYXNrU3RhdHVzKSB7XG4gIFF1ZXVlVGFza1N0YXR1c1tRdWV1ZVRhc2tTdGF0dXNbXCJXQUlUSU5HXCJdID0gMF0gPSBcIldBSVRJTkdcIjtcbiAgUXVldWVUYXNrU3RhdHVzW1F1ZXVlVGFza1N0YXR1c1tcIlJVTk5JTkdcIl0gPSAxXSA9IFwiUlVOTklOR1wiO1xuICBRdWV1ZVRhc2tTdGF0dXNbUXVldWVUYXNrU3RhdHVzW1wiQ09NUExFVEVEXCJdID0gMl0gPSBcIkNPTVBMRVRFRFwiO1xufSkoUXVldWVUYXNrU3RhdHVzIHx8IChRdWV1ZVRhc2tTdGF0dXMgPSB7fSkpO1xuY2xhc3MgQXN5bmNRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucGVuZGluZ1Rhc2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudGFza011dGV4ID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5uZXh0VGFza0luZGV4ID0gMDtcbiAgfVxuICBydW4odGFzaykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB0YXNrSW5mbyA9IHtcbiAgICAgICAgaWQ6IHRoaXMubmV4dFRhc2tJbmRleCsrLFxuICAgICAgICBlbnF1ZXVlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICBzdGF0dXM6IFF1ZXVlVGFza1N0YXR1cy5XQUlUSU5HXG4gICAgICB9O1xuICAgICAgdGhpcy5wZW5kaW5nVGFza3Muc2V0KHRhc2tJbmZvLmlkLCB0YXNrSW5mbyk7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnRhc2tNdXRleC5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICB0YXNrSW5mby5leGVjdXRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGFza0luZm8uc3RhdHVzID0gUXVldWVUYXNrU3RhdHVzLlJVTk5JTkc7XG4gICAgICAgIHJldHVybiB5aWVsZCB0YXNrKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0YXNrSW5mby5zdGF0dXMgPSBRdWV1ZVRhc2tTdGF0dXMuQ09NUExFVEVEO1xuICAgICAgICB0aGlzLnBlbmRpbmdUYXNrcy5kZWxldGUodGFza0luZm8uaWQpO1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMucnVuKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHt9KSk7XG4gICAgfSk7XG4gIH1cbiAgc25hcHNob3QoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wZW5kaW5nVGFza3MudmFsdWVzKCkpO1xuICB9XG59XG5cbmNvbnN0IHBhc3NUaHJvdWdoUXVldWVTaWduYWxzID0gWydzeW5jU3RhdGUnLCAndHJpY2tsZScsICdvZmZlcicsICdhbnN3ZXInLCAnc2ltdWxhdGUnLCAnbGVhdmUnXTtcbmZ1bmN0aW9uIGNhblBhc3NUaHJvdWdoUXVldWUocmVxKSB7XG4gIGNvbnN0IGNhblBhc3MgPSBwYXNzVGhyb3VnaFF1ZXVlU2lnbmFscy5pbmRleE9mKHJlcS5jYXNlKSA+PSAwO1xuICBsaXZla2l0TG9nZ2VyLnRyYWNlKCdyZXF1ZXN0IGFsbG93ZWQgdG8gYnlwYXNzIHF1ZXVlOicsIHtcbiAgICBjYW5QYXNzLFxuICAgIHJlcVxuICB9KTtcbiAgcmV0dXJuIGNhblBhc3M7XG59XG52YXIgU2lnbmFsQ29ubmVjdGlvblN0YXRlO1xuKGZ1bmN0aW9uIChTaWduYWxDb25uZWN0aW9uU3RhdGUpIHtcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlW1NpZ25hbENvbm5lY3Rpb25TdGF0ZVtcIkNPTk5FQ1RJTkdcIl0gPSAwXSA9IFwiQ09OTkVDVElOR1wiO1xuICBTaWduYWxDb25uZWN0aW9uU3RhdGVbU2lnbmFsQ29ubmVjdGlvblN0YXRlW1wiQ09OTkVDVEVEXCJdID0gMV0gPSBcIkNPTk5FQ1RFRFwiO1xuICBTaWduYWxDb25uZWN0aW9uU3RhdGVbU2lnbmFsQ29ubmVjdGlvblN0YXRlW1wiUkVDT05ORUNUSU5HXCJdID0gMl0gPSBcIlJFQ09OTkVDVElOR1wiO1xuICBTaWduYWxDb25uZWN0aW9uU3RhdGVbU2lnbmFsQ29ubmVjdGlvblN0YXRlW1wiRElTQ09OTkVDVElOR1wiXSA9IDNdID0gXCJESVNDT05ORUNUSU5HXCI7XG4gIFNpZ25hbENvbm5lY3Rpb25TdGF0ZVtTaWduYWxDb25uZWN0aW9uU3RhdGVbXCJESVNDT05ORUNURURcIl0gPSA0XSA9IFwiRElTQ09OTkVDVEVEXCI7XG59KShTaWduYWxDb25uZWN0aW9uU3RhdGUgfHwgKFNpZ25hbENvbm5lY3Rpb25TdGF0ZSA9IHt9KSk7XG4vKiogQGludGVybmFsICovXG5jbGFzcyBTaWduYWxDbGllbnQge1xuICBnZXQgY3VycmVudFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICB9XG4gIGdldCBpc0Rpc2Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcbiAgfVxuICBnZXQgaXNFc3RhYmxpc2hpbmdDb25uZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVElORyB8fCB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HO1xuICB9XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCB1c2VKU09OID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9hO1xuICAgIC8qKiBzaWduYWwgcnR0IGluIG1pbGxpc2Vjb25kcyAqL1xuICAgIHRoaXMucnR0ID0gMDtcbiAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMucmVzZXRDYWxsYmFja3MgPSAoKSA9PiB7XG4gICAgICB0aGlzLm9uQW5zd2VyID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vbkxlYXZlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vbk5lZ290aWF0ZVJlcXVlc3RlZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25PZmZlciA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25SZW1vdGVNdXRlQ2hhbmdlZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25Ub2tlblJlZnJlc2ggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uVHJpY2tsZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25DbG9zZSA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuU2lnbmFsKTtcbiAgICB0aGlzLmxvZ2dlckNvbnRleHRDYiA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyQ29udGV4dENiO1xuICAgIHRoaXMudXNlSlNPTiA9IHVzZUpTT047XG4gICAgdGhpcy5yZXF1ZXN0UXVldWUgPSBuZXcgQXN5bmNRdWV1ZSgpO1xuICAgIHRoaXMucXVldWVkUmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLmNsb3NpbmdMb2NrID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5jb25uZWN0aW9uTG9jayA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuICB9XG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMubG9nZ2VyQ29udGV4dENiKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XG4gIH1cbiAgam9pbih1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBkdXJpbmcgYSBmdWxsIHJlY29ubmVjdCwgd2UnZCB3YW50IHRvIHN0YXJ0IHRoZSBzZXF1ZW5jZSBldmVuIGlmIGN1cnJlbnRseVxuICAgICAgLy8gY29ubmVjdGVkXG4gICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RJTkc7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRzO1xuICAgICAgY29uc3QgcmVzID0geWllbGQgdGhpcy5jb25uZWN0KHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gIH1cbiAgcmVjb25uZWN0KHVybCwgdG9rZW4sIHNpZCwgcmVhc29uKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2F0dGVtcHRlZCB0byByZWNvbm5lY3Qgd2l0aG91dCBzaWduYWwgb3B0aW9ucyBiZWluZyBzZXQsIGlnbm9yaW5nJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkc7XG4gICAgICAvLyBjbGVhciBwaW5nIGludGVydmFsIGFuZCByZXN0YXJ0IGl0IG9uY2UgcmVjb25uZWN0ZWRcbiAgICAgIHRoaXMuY2xlYXJQaW5nSW50ZXJ2YWwoKTtcbiAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIHRoaXMuY29ubmVjdCh1cmwsIHRva2VuLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIHtcbiAgICAgICAgcmVjb25uZWN0OiB0cnVlLFxuICAgICAgICBzaWQsXG4gICAgICAgIHJlY29ubmVjdFJlYXNvbjogcmVhc29uXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICB9XG4gIGNvbm5lY3QodXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpIHtcbiAgICB0aGlzLmNvbm5lY3RPcHRpb25zID0gb3B0cztcbiAgICB1cmwgPSB0b1dlYnNvY2tldFVybCh1cmwpO1xuICAgIC8vIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgdXJsID0gdXJsLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgdXJsICs9ICcvcnRjJztcbiAgICBjb25zdCBjbGllbnRJbmZvID0gZ2V0Q2xpZW50SW5mbygpO1xuICAgIGNvbnN0IHBhcmFtcyA9IGNyZWF0ZUNvbm5lY3Rpb25QYXJhbXModG9rZW4sIGNsaWVudEluZm8sIG9wdHMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb25Mb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHdzVGltZW91dCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ3Jvb20gY29ubmVjdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQgKHNpZ25hbCknKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB3c1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ3Jvb20gY29ubmVjdGlvbiBoYXMgdGltZWQgb3V0IChzaWduYWwpJykpO1xuICAgICAgICB9LCBvcHRzLndlYnNvY2tldFRpbWVvdXQpO1xuICAgICAgICBpZiAoYWJvcnRTaWduYWwgPT09IG51bGwgfHwgYWJvcnRTaWduYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICBhYm9ydEhhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBhYm9ydFNpZ25hbCA9PT0gbnVsbCB8fCBhYm9ydFNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcImNvbm5lY3RpbmcgdG8gXCIuY29uY2F0KHVybCArIHBhcmFtcyksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLndzKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHVybCArIHBhcmFtcyk7XG4gICAgICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIHRoaXMud3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh3c1RpbWVvdXQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndzLm9uZXJyb3IgPSBldiA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh3c1RpbWVvdXQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHlpZWxkIGZldGNoKFwiaHR0cFwiLmNvbmNhdCh1cmwuc3Vic3RyaW5nKDIpLCBcIi92YWxpZGF0ZVwiKS5jb25jYXQocGFyYW1zKSk7XG4gICAgICAgICAgICAgIGlmIChyZXNwLnN0YXR1cy50b0ZpeGVkKDApLnN0YXJ0c1dpdGgoJzQnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IHlpZWxkIHJlc3AudGV4dCgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKG1zZywgMCAvKiBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCAqLywgcmVzcC5zdGF0dXMpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcignSW50ZXJuYWwgZXJyb3InLCAyIC8qIENvbm5lY3Rpb25FcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yICovLCByZXNwLnN0YXR1cykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdzZXJ2ZXIgd2FzIG5vdCByZWFjaGFibGUnLCAxIC8qIENvbm5lY3Rpb25FcnJvclJlYXNvbi5TZXJ2ZXJVbnJlYWNoYWJsZSAqLykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBvdGhlciBlcnJvcnMsIGhhbmRsZVxuICAgICAgICAgIHRoaXMuaGFuZGxlV1NFcnJvcihldik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IGV2ID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgLy8gbm90IGNvbnNpZGVyZWQgY29ubmVjdGVkIHVudGlsIEpvaW5SZXNwb25zZSBpcyByZWNlaXZlZFxuICAgICAgICAgIGxldCByZXNwO1xuICAgICAgICAgIGlmICh0eXBlb2YgZXYuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGV2LmRhdGEpO1xuICAgICAgICAgICAgcmVzcCA9IFNpZ25hbFJlc3BvbnNlLmZyb21Kc29uKGpzb24pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXYuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICByZXNwID0gU2lnbmFsUmVzcG9uc2UuZnJvbUJpbmFyeShuZXcgVWludDhBcnJheShldi5kYXRhKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKFwiY291bGQgbm90IGRlY29kZSB3ZWJzb2NrZXQgbWVzc2FnZTogXCIuY29uY2F0KHR5cGVvZiBldi5kYXRhKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgICAgIGxldCBzaG91bGRQcm9jZXNzTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gaGFuZGxlIGpvaW4gbWVzc2FnZSBvbmx5XG4gICAgICAgICAgICBpZiAoKChfYSA9IHJlc3AubWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhc2UpID09PSAnam9pbicpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQ7XG4gICAgICAgICAgICAgIGFib3J0U2lnbmFsID09PSBudWxsIHx8IGFib3J0U2lnbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydFNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICAgIHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiA9IHJlc3AubWVzc2FnZS52YWx1ZS5waW5nVGltZW91dDtcbiAgICAgICAgICAgICAgdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvbiA9IHJlc3AubWVzc2FnZS52YWx1ZS5waW5nSW50ZXJ2YWw7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gJiYgdGhpcy5waW5nVGltZW91dER1cmF0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdwaW5nIGNvbmZpZycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy5waW5nVGltZW91dER1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgaW50ZXJ2YWw6IHRoaXMucGluZ0ludGVydmFsRHVyYXRpb25cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFBpbmdJbnRlcnZhbCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzcC5tZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORyAmJiByZXNwLm1lc3NhZ2UuY2FzZSAhPT0gJ2xlYXZlJykge1xuICAgICAgICAgICAgICAvLyBpbiByZWNvbm5lY3RpbmcsIGFueSBtZXNzYWdlIHJlY2VpdmVkIG1lYW5zIHNpZ25hbCByZWNvbm5lY3RlZFxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRDtcbiAgICAgICAgICAgICAgYWJvcnRTaWduYWwgPT09IG51bGwgfHwgYWJvcnRTaWduYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGFydFBpbmdJbnRlcnZhbCgpO1xuICAgICAgICAgICAgICBpZiAoKChfYiA9IHJlc3AubWVzc2FnZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhc2UpID09PSAncmVjb25uZWN0Jykge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKF9jID0gcmVzcC5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBzaG91bGRQcm9jZXNzTWVzc2FnZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0VzdGFibGlzaGluZ0Nvbm5lY3Rpb24gJiYgcmVzcC5tZXNzYWdlLmNhc2UgPT09ICdsZWF2ZScpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ1JlY2VpdmVkIGxlYXZlIHJlcXVlc3Qgd2hpbGUgdHJ5aW5nIHRvIChyZSljb25uZWN0JywgNCAvKiBDb25uZWN0aW9uRXJyb3JSZWFzb24uTGVhdmVSZXF1ZXN0ICovKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvcHRzLnJlY29ubmVjdCkge1xuICAgICAgICAgICAgICAvLyBub24tcmVjb25uZWN0IGNhc2UsIHNob3VsZCByZWNlaXZlIGpvaW4gcmVzcG9uc2UgZmlyc3RcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoXCJkaWQgbm90IHJlY2VpdmUgam9pbiByZXNwb25zZSwgZ290IFwiLmNvbmNhdCgoX2QgPSByZXNwLm1lc3NhZ2UpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYXNlLCBcIiBpbnN0ZWFkXCIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNob3VsZFByb2Nlc3NNZXNzYWdlKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuc2lnbmFsTGF0ZW5jeSkge1xuICAgICAgICAgICAgeWllbGQgc2xlZXAodGhpcy5zaWduYWxMYXRlbmN5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYW5kbGVTaWduYWxSZXNwb25zZShyZXNwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud3Mub25jbG9zZSA9IGV2ID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5pc0VzdGFibGlzaGluZ0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdXZWJzb2NrZXQgZ290IGNsb3NlZCBkdXJpbmcgYSAocmUpY29ubmVjdGlvbiBhdHRlbXB0JykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxvZy53YXJuKFwid2Vic29ja2V0IGNsb3NlZFwiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIHJlYXNvbjogZXYucmVhc29uLFxuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGVcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgdGhpcy5oYW5kbGVPbkNsb3NlKGV2LnJlYXNvbik7XG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMuY2xvc2luZ0xvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNUSU5HO1xuICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLndzLm9ub3BlbiA9IG51bGw7XG4gICAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgICAvLyBjYWxsaW5nIGB3cy5jbG9zZSgpYCBvbmx5IHN0YXJ0cyB0aGUgY2xvc2luZyBoYW5kc2hha2UgKENMT1NJTkcgc3RhdGUpLCBwcmVmZXIgdG8gd2FpdCB1bnRpbCBzdGF0ZSBpcyBhY3R1YWxseSBDTE9TRURcbiAgICAgICAgICBjb25zdCBjbG9zZVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLndzKSB7XG4gICAgICAgICAgICAgIHRoaXMud3Mub25jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHRoaXMud3MucmVhZHlTdGF0ZSA8IHRoaXMud3MuQ0xPU0lORykge1xuICAgICAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgICAgICAgICAgLy8gMjUwbXMgZ3JhY2UgcGVyaW9kIGZvciB3cyB0byBjbG9zZSBncmFjZWZ1bGx5XG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLnJhY2UoW2Nsb3NlUHJvbWlzZSwgc2xlZXAoMjUwKV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLndzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcbiAgICAgICAgdGhpcy5jbGVhclBpbmdJbnRlcnZhbCgpO1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvLyBpbml0aWFsIG9mZmVyIGFmdGVyIGpvaW5pbmdcbiAgc2VuZE9mZmVyKG9mZmVyKSB7XG4gICAgdGhpcy5sb2cuZGVidWcoJ3NlbmRpbmcgb2ZmZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgIG9mZmVyU2RwOiBvZmZlci5zZHBcbiAgICB9KSk7XG4gICAgdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnb2ZmZXInLFxuICAgICAgdmFsdWU6IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24ob2ZmZXIpXG4gICAgfSk7XG4gIH1cbiAgLy8gYW5zd2VyIGEgc2VydmVyLWluaXRpYXRlZCBvZmZlclxuICBzZW5kQW5zd2VyKGFuc3dlcikge1xuICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kaW5nIGFuc3dlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgYW5zd2VyU2RwOiBhbnN3ZXIuc2RwXG4gICAgfSkpO1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdhbnN3ZXInLFxuICAgICAgdmFsdWU6IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oYW5zd2VyKVxuICAgIH0pO1xuICB9XG4gIHNlbmRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlLCB0YXJnZXQpIHtcbiAgICB0aGlzLmxvZy50cmFjZSgnc2VuZGluZyBpY2UgY2FuZGlkYXRlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICBjYW5kaWRhdGVcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3RyaWNrbGUnLFxuICAgICAgdmFsdWU6IG5ldyBUcmlja2xlUmVxdWVzdCh7XG4gICAgICAgIGNhbmRpZGF0ZUluaXQ6IEpTT04uc3RyaW5naWZ5KGNhbmRpZGF0ZSksXG4gICAgICAgIHRhcmdldFxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBzZW5kTXV0ZVRyYWNrKHRyYWNrU2lkLCBtdXRlZCkge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdtdXRlJyxcbiAgICAgIHZhbHVlOiBuZXcgTXV0ZVRyYWNrUmVxdWVzdCh7XG4gICAgICAgIHNpZDogdHJhY2tTaWQsXG4gICAgICAgIG11dGVkXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHNlbmRBZGRUcmFjayhyZXEpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnYWRkVHJhY2snLFxuICAgICAgdmFsdWU6IHJlcVxuICAgIH0pO1xuICB9XG4gIHNlbmRVcGRhdGVMb2NhbE1ldGFkYXRhKG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3VwZGF0ZU1ldGFkYXRhJyxcbiAgICAgIHZhbHVlOiBuZXcgVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSh7XG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBuYW1lXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHNlbmRVcGRhdGVUcmFja1NldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAndHJhY2tTZXR0aW5nJyxcbiAgICAgIHZhbHVlOiBzZXR0aW5nc1xuICAgIH0pO1xuICB9XG4gIHNlbmRVcGRhdGVTdWJzY3JpcHRpb24oc3ViKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3N1YnNjcmlwdGlvbicsXG4gICAgICB2YWx1ZTogc3ViXG4gICAgfSk7XG4gIH1cbiAgc2VuZFN5bmNTdGF0ZShzeW5jKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3N5bmNTdGF0ZScsXG4gICAgICB2YWx1ZTogc3luY1xuICAgIH0pO1xuICB9XG4gIHNlbmRVcGRhdGVWaWRlb0xheWVycyh0cmFja1NpZCwgbGF5ZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3VwZGF0ZUxheWVycycsXG4gICAgICB2YWx1ZTogbmV3IFVwZGF0ZVZpZGVvTGF5ZXJzKHtcbiAgICAgICAgdHJhY2tTaWQsXG4gICAgICAgIGxheWVyc1xuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBzZW5kVXBkYXRlU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMoYWxsUGFydGljaXBhbnRzLCB0cmFja1Blcm1pc3Npb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3N1YnNjcmlwdGlvblBlcm1pc3Npb24nLFxuICAgICAgdmFsdWU6IG5ldyBTdWJzY3JpcHRpb25QZXJtaXNzaW9uKHtcbiAgICAgICAgYWxsUGFydGljaXBhbnRzLFxuICAgICAgICB0cmFja1Blcm1pc3Npb25zXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHNlbmRTaW11bGF0ZVNjZW5hcmlvKHNjZW5hcmlvKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3NpbXVsYXRlJyxcbiAgICAgIHZhbHVlOiBzY2VuYXJpb1xuICAgIH0pO1xuICB9XG4gIHNlbmRQaW5nKCkge1xuICAgIC8qKiBzZW5kIGJvdGggb2YgcGluZyBhbmQgcGluZ1JlcSBmb3IgY29tcGF0aWJpbGl0eSB0byBvbGQgYW5kIG5ldyBzZXJ2ZXIgKi9cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3RoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3BpbmcnLFxuICAgICAgdmFsdWU6IHByb3RvSW50NjQucGFyc2UoRGF0ZS5ub3coKSlcbiAgICB9KSwgdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAncGluZ1JlcScsXG4gICAgICB2YWx1ZTogbmV3IFBpbmcoe1xuICAgICAgICB0aW1lc3RhbXA6IHByb3RvSW50NjQucGFyc2UoRGF0ZS5ub3coKSksXG4gICAgICAgIHJ0dDogcHJvdG9JbnQ2NC5wYXJzZSh0aGlzLnJ0dClcbiAgICAgIH0pXG4gICAgfSldKTtcbiAgfVxuICBzZW5kTGVhdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ2xlYXZlJyxcbiAgICAgIHZhbHVlOiBuZXcgTGVhdmVSZXF1ZXN0KHtcbiAgICAgICAgY2FuUmVjb25uZWN0OiBmYWxzZSxcbiAgICAgICAgcmVhc29uOiBEaXNjb25uZWN0UmVhc29uLkNMSUVOVF9JTklUSUFURURcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgc2VuZFJlcXVlc3QobWVzc2FnZSkge1xuICAgIGxldCBmcm9tUXVldWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBjYXB0dXJlIGFsbCByZXF1ZXN0cyB3aGlsZSByZWNvbm5lY3RpbmcgYW5kIHB1dCB0aGVtIGluIGEgcXVldWVcbiAgICAgIC8vIHVubGVzcyB0aGUgcmVxdWVzdCBvcmlnaW5hdGVzIGZyb20gdGhlIHF1ZXVlLCB0aGVuIGRvbid0IGVucXVldWUgYWdhaW5cbiAgICAgIGNvbnN0IGNhblF1ZXVlID0gIWZyb21RdWV1ZSAmJiAhY2FuUGFzc1Rocm91Z2hRdWV1ZShtZXNzYWdlKTtcbiAgICAgIGlmIChjYW5RdWV1ZSAmJiB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HKSB7XG4gICAgICAgIHRoaXMucXVldWVkUmVxdWVzdHMucHVzaCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5zZW5kUmVxdWVzdChtZXNzYWdlLCB0cnVlKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBtYWtlIHN1cmUgcHJldmlvdXNseSBxdWV1ZWQgcmVxdWVzdHMgYXJlIGJlaW5nIHNlbnQgZmlyc3RcbiAgICAgIGlmICghZnJvbVF1ZXVlKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucmVxdWVzdFF1ZXVlLmZsdXNoKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaWduYWxMYXRlbmN5KSB7XG4gICAgICAgIHlpZWxkIHNsZWVwKHRoaXMuc2lnbmFsTGF0ZW5jeSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMud3MgfHwgdGhpcy53cy5yZWFkeVN0YXRlICE9PSB0aGlzLndzLk9QRU4pIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoXCJjYW5ub3Qgc2VuZCBzaWduYWwgcmVxdWVzdCBiZWZvcmUgY29ubmVjdGVkLCB0eXBlOiBcIi5jb25jYXQobWVzc2FnZSA9PT0gbnVsbCB8fCBtZXNzYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXNzYWdlLmNhc2UpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZXEgPSBuZXcgU2lnbmFsUmVxdWVzdCh7XG4gICAgICAgIG1lc3NhZ2VcbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMudXNlSlNPTikge1xuICAgICAgICAgIHRoaXMud3Muc2VuZChyZXEudG9Kc29uU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMud3Muc2VuZChyZXEudG9CaW5hcnkoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2Vycm9yIHNlbmRpbmcgc2lnbmFsIG1lc3NhZ2UnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlcnJvcjogZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlU2lnbmFsUmVzcG9uc2UocmVzKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBtc2cgPSByZXMubWVzc2FnZTtcbiAgICBpZiAobXNnID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHVuc3VwcG9ydGVkIG1lc3NhZ2UnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcGluZ0hhbmRsZWQgPSBmYWxzZTtcbiAgICBpZiAobXNnLmNhc2UgPT09ICdhbnN3ZXInKSB7XG4gICAgICBjb25zdCBzZCA9IGZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihtc2cudmFsdWUpO1xuICAgICAgaWYgKHRoaXMub25BbnN3ZXIpIHtcbiAgICAgICAgdGhpcy5vbkFuc3dlcihzZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ29mZmVyJykge1xuICAgICAgY29uc3Qgc2QgPSBmcm9tUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24obXNnLnZhbHVlKTtcbiAgICAgIGlmICh0aGlzLm9uT2ZmZXIpIHtcbiAgICAgICAgdGhpcy5vbk9mZmVyKHNkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAndHJpY2tsZScpIHtcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IEpTT04ucGFyc2UobXNnLnZhbHVlLmNhbmRpZGF0ZUluaXQpO1xuICAgICAgaWYgKHRoaXMub25Ucmlja2xlKSB7XG4gICAgICAgIHRoaXMub25Ucmlja2xlKGNhbmRpZGF0ZSwgbXNnLnZhbHVlLnRhcmdldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3VwZGF0ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uUGFydGljaXBhbnRVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5vblBhcnRpY2lwYW50VXBkYXRlKChfYSA9IG1zZy52YWx1ZS5wYXJ0aWNpcGFudHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAndHJhY2tQdWJsaXNoZWQnKSB7XG4gICAgICBpZiAodGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQpIHtcbiAgICAgICAgdGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3BlYWtlcnNDaGFuZ2VkJykge1xuICAgICAgaWYgKHRoaXMub25TcGVha2Vyc0NoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5vblNwZWFrZXJzQ2hhbmdlZCgoX2IgPSBtc2cudmFsdWUuc3BlYWtlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnbGVhdmUnKSB7XG4gICAgICBpZiAodGhpcy5vbkxlYXZlKSB7XG4gICAgICAgIHRoaXMub25MZWF2ZShtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdtdXRlJykge1xuICAgICAgaWYgKHRoaXMub25SZW1vdGVNdXRlQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLm9uUmVtb3RlTXV0ZUNoYW5nZWQobXNnLnZhbHVlLnNpZCwgbXNnLnZhbHVlLm11dGVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAncm9vbVVwZGF0ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uUm9vbVVwZGF0ZSAmJiBtc2cudmFsdWUucm9vbSkge1xuICAgICAgICB0aGlzLm9uUm9vbVVwZGF0ZShtc2cudmFsdWUucm9vbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ2Nvbm5lY3Rpb25RdWFsaXR5Jykge1xuICAgICAgaWYgKHRoaXMub25Db25uZWN0aW9uUXVhbGl0eSkge1xuICAgICAgICB0aGlzLm9uQ29ubmVjdGlvblF1YWxpdHkobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3RyZWFtU3RhdGVVcGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblN0cmVhbVN0YXRlVXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25TdHJlYW1TdGF0ZVVwZGF0ZShtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdzdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3N1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUpIHtcbiAgICAgICAgdGhpcy5vblN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAncmVmcmVzaFRva2VuJykge1xuICAgICAgaWYgKHRoaXMub25Ub2tlblJlZnJlc2gpIHtcbiAgICAgICAgdGhpcy5vblRva2VuUmVmcmVzaChtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICd0cmFja1VucHVibGlzaGVkJykge1xuICAgICAgaWYgKHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQpIHtcbiAgICAgICAgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZChtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdzdWJzY3JpcHRpb25SZXNwb25zZScpIHtcbiAgICAgIGlmICh0aGlzLm9uU3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgdGhpcy5vblN1YnNjcmlwdGlvbkVycm9yKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3BvbmcnKSA7IGVsc2UgaWYgKG1zZy5jYXNlID09PSAncG9uZ1Jlc3AnKSB7XG4gICAgICB0aGlzLnJ0dCA9IERhdGUubm93KCkgLSBOdW1iZXIucGFyc2VJbnQobXNnLnZhbHVlLmxhc3RQaW5nVGltZXN0YW1wLnRvU3RyaW5nKCkpO1xuICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgICBwaW5nSGFuZGxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1bnN1cHBvcnRlZCBtZXNzYWdlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIG1zZ0Nhc2U6IG1zZy5jYXNlXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmICghcGluZ0hhbmRsZWQpIHtcbiAgICAgIHRoaXMucmVzZXRQaW5nVGltZW91dCgpO1xuICAgIH1cbiAgfVxuICBzZXRSZWNvbm5lY3RlZCgpIHtcbiAgICB3aGlsZSAodGhpcy5xdWV1ZWRSZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXEgPSB0aGlzLnF1ZXVlZFJlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICBpZiAocmVxKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLnJ1bihyZXEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYW5kbGVPbkNsb3NlKHJlYXNvbikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRCkgcmV0dXJuO1xuICAgICAgY29uc3Qgb25DbG9zZUNhbGxiYWNrID0gdGhpcy5vbkNsb3NlO1xuICAgICAgeWllbGQgdGhpcy5jbG9zZSgpO1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJ3ZWJzb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQ6IFwiLmNvbmNhdChyZWFzb24pLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgcmVhc29uXG4gICAgICB9KSk7XG4gICAgICBpZiAob25DbG9zZUNhbGxiYWNrKSB7XG4gICAgICAgIG9uQ2xvc2VDYWxsYmFjayhyZWFzb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGhhbmRsZVdTRXJyb3IoZXYpIHtcbiAgICB0aGlzLmxvZy5lcnJvcignd2Vic29ja2V0IGVycm9yJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICBlcnJvcjogZXZcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgcGluZyB0aW1lb3V0IGFuZCBzdGFydHMgYSBuZXcgdGltZW91dC5cbiAgICogQ2FsbCB0aGlzIGFmdGVyIHJlY2VpdmluZyBhIHBvbmcgbWVzc2FnZVxuICAgKi9cbiAgcmVzZXRQaW5nVGltZW91dCgpIHtcbiAgICB0aGlzLmNsZWFyUGluZ1RpbWVvdXQoKTtcbiAgICBpZiAoIXRoaXMucGluZ1RpbWVvdXREdXJhdGlvbikge1xuICAgICAgdGhpcy5sb2cud2FybigncGluZyB0aW1lb3V0IGR1cmF0aW9uIG5vdCBzZXQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBpbmdUaW1lb3V0ID0gQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmxvZy53YXJuKFwicGluZyB0aW1lb3V0IHRyaWdnZXJlZC4gbGFzdCBwb25nIHJlY2VpdmVkIGF0OiBcIi5jb25jYXQobmV3IERhdGUoRGF0ZS5ub3coKSAtIHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiAqIDEwMDApLnRvVVRDU3RyaW5nKCkpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdGhpcy5oYW5kbGVPbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgICB9LCB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gKiAxMDAwKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIHBpbmcgdGltZW91dCAoZG9lcyBub3Qgc3RhcnQgYSBuZXcgdGltZW91dClcbiAgICovXG4gIGNsZWFyUGluZ1RpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMucGluZ1RpbWVvdXQpIHtcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgc3RhcnRQaW5nSW50ZXJ2YWwoKSB7XG4gICAgdGhpcy5jbGVhclBpbmdJbnRlcnZhbCgpO1xuICAgIHRoaXMucmVzZXRQaW5nVGltZW91dCgpO1xuICAgIGlmICghdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvbikge1xuICAgICAgdGhpcy5sb2cud2FybigncGluZyBpbnRlcnZhbCBkdXJhdGlvbiBub3Qgc2V0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2cuZGVidWcoJ3N0YXJ0IHBpbmcgaW50ZXJ2YWwnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIHRoaXMucGluZ0ludGVydmFsID0gQ3JpdGljYWxUaW1lcnMuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5zZW5kUGluZygpO1xuICAgIH0sIHRoaXMucGluZ0ludGVydmFsRHVyYXRpb24gKiAxMDAwKTtcbiAgfVxuICBjbGVhclBpbmdJbnRlcnZhbCgpIHtcbiAgICB0aGlzLmxvZy5kZWJ1ZygnY2xlYXJpbmcgcGluZyBpbnRlcnZhbCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgdGhpcy5jbGVhclBpbmdUaW1lb3V0KCk7XG4gICAgaWYgKHRoaXMucGluZ0ludGVydmFsKSB7XG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhckludGVydmFsKHRoaXMucGluZ0ludGVydmFsKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihzZCkge1xuICBjb25zdCByc2QgPSB7XG4gICAgdHlwZTogJ29mZmVyJyxcbiAgICBzZHA6IHNkLnNkcFxuICB9O1xuICBzd2l0Y2ggKHNkLnR5cGUpIHtcbiAgICBjYXNlICdhbnN3ZXInOlxuICAgIGNhc2UgJ29mZmVyJzpcbiAgICBjYXNlICdwcmFuc3dlcic6XG4gICAgY2FzZSAncm9sbGJhY2snOlxuICAgICAgcnNkLnR5cGUgPSBzZC50eXBlO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHJzZDtcbn1cbmZ1bmN0aW9uIHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24ocnNkKSB7XG4gIGNvbnN0IHNkID0gbmV3IFNlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgc2RwOiByc2Quc2RwLFxuICAgIHR5cGU6IHJzZC50eXBlXG4gIH0pO1xuICByZXR1cm4gc2Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uUGFyYW1zKHRva2VuLCBpbmZvLCBvcHRzKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBwYXJhbXMuc2V0KCdhY2Nlc3NfdG9rZW4nLCB0b2tlbik7XG4gIC8vIG9wdHNcbiAgaWYgKG9wdHMucmVjb25uZWN0KSB7XG4gICAgcGFyYW1zLnNldCgncmVjb25uZWN0JywgJzEnKTtcbiAgICBpZiAob3B0cy5zaWQpIHtcbiAgICAgIHBhcmFtcy5zZXQoJ3NpZCcsIG9wdHMuc2lkKTtcbiAgICB9XG4gIH1cbiAgcGFyYW1zLnNldCgnYXV0b19zdWJzY3JpYmUnLCBvcHRzLmF1dG9TdWJzY3JpYmUgPyAnMScgOiAnMCcpO1xuICAvLyBDbGllbnRJbmZvXG4gIHBhcmFtcy5zZXQoJ3NkaycsIGlzUmVhY3ROYXRpdmUoKSA/ICdyZWFjdG5hdGl2ZScgOiAnanMnKTtcbiAgcGFyYW1zLnNldCgndmVyc2lvbicsIGluZm8udmVyc2lvbik7XG4gIHBhcmFtcy5zZXQoJ3Byb3RvY29sJywgaW5mby5wcm90b2NvbC50b1N0cmluZygpKTtcbiAgaWYgKGluZm8uZGV2aWNlTW9kZWwpIHtcbiAgICBwYXJhbXMuc2V0KCdkZXZpY2VfbW9kZWwnLCBpbmZvLmRldmljZU1vZGVsKTtcbiAgfVxuICBpZiAoaW5mby5vcykge1xuICAgIHBhcmFtcy5zZXQoJ29zJywgaW5mby5vcyk7XG4gIH1cbiAgaWYgKGluZm8ub3NWZXJzaW9uKSB7XG4gICAgcGFyYW1zLnNldCgnb3NfdmVyc2lvbicsIGluZm8ub3NWZXJzaW9uKTtcbiAgfVxuICBpZiAoaW5mby5icm93c2VyKSB7XG4gICAgcGFyYW1zLnNldCgnYnJvd3NlcicsIGluZm8uYnJvd3Nlcik7XG4gIH1cbiAgaWYgKGluZm8uYnJvd3NlclZlcnNpb24pIHtcbiAgICBwYXJhbXMuc2V0KCdicm93c2VyX3ZlcnNpb24nLCBpbmZvLmJyb3dzZXJWZXJzaW9uKTtcbiAgfVxuICBpZiAob3B0cy5wdWJsaXNoT25seSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLnNldCgncHVibGlzaCcsIG9wdHMucHVibGlzaE9ubHkpO1xuICB9XG4gIGlmIChvcHRzLmFkYXB0aXZlU3RyZWFtKSB7XG4gICAgcGFyYW1zLnNldCgnYWRhcHRpdmVfc3RyZWFtJywgJzEnKTtcbiAgfVxuICBpZiAob3B0cy5yZWNvbm5lY3RSZWFzb24pIHtcbiAgICBwYXJhbXMuc2V0KCdyZWNvbm5lY3RfcmVhc29uJywgb3B0cy5yZWNvbm5lY3RSZWFzb24udG9TdHJpbmcoKSk7XG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAoKF9hID0gbmF2aWdhdG9yLmNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBhcmFtcy5zZXQoJ25ldHdvcmsnLCBuYXZpZ2F0b3IuY29ubmVjdGlvbi50eXBlKTtcbiAgfVxuICByZXR1cm4gXCI/XCIuY29uY2F0KHBhcmFtcy50b1N0cmluZygpKTtcbn1cblxudmFyIHBhcnNlciQxID0ge307XG5cbnZhciBncmFtbWFyJDIgPSB7ZXhwb3J0czoge319O1xuXG52YXIgZ3JhbW1hciQxID0gZ3JhbW1hciQyLmV4cG9ydHMgPSB7XG4gIHY6IFt7XG4gICAgbmFtZTogJ3ZlcnNpb24nLFxuICAgIHJlZzogL14oXFxkKikkL1xuICB9XSxcbiAgbzogW3tcbiAgICAvLyBvPS0gMjA1MTggMCBJTiBJUDQgMjAzLjAuMTEzLjFcbiAgICAvLyBOQjogc2Vzc2lvbklkIHdpbGwgYmUgYSBTdHJpbmcgaW4gbW9zdCBjYXNlcyBiZWNhdXNlIGl0IGlzIGh1Z2VcbiAgICBuYW1lOiAnb3JpZ2luJyxcbiAgICByZWc6IC9eKFxcUyopIChcXGQqKSAoXFxkKikgKFxcUyopIElQKFxcZCkgKFxcUyopLyxcbiAgICBuYW1lczogWyd1c2VybmFtZScsICdzZXNzaW9uSWQnLCAnc2Vzc2lvblZlcnNpb24nLCAnbmV0VHlwZScsICdpcFZlcicsICdhZGRyZXNzJ10sXG4gICAgZm9ybWF0OiAnJXMgJXMgJWQgJXMgSVAlZCAlcydcbiAgfV0sXG4gIC8vIGRlZmF1bHQgcGFyc2luZyBvZiB0aGVzZSBvbmx5ICh0aG91Z2ggc29tZSBvZiB0aGVzZSBmZWVsIG91dGRhdGVkKVxuICBzOiBbe1xuICAgIG5hbWU6ICduYW1lJ1xuICB9XSxcbiAgaTogW3tcbiAgICBuYW1lOiAnZGVzY3JpcHRpb24nXG4gIH1dLFxuICB1OiBbe1xuICAgIG5hbWU6ICd1cmknXG4gIH1dLFxuICBlOiBbe1xuICAgIG5hbWU6ICdlbWFpbCdcbiAgfV0sXG4gIHA6IFt7XG4gICAgbmFtZTogJ3Bob25lJ1xuICB9XSxcbiAgejogW3tcbiAgICBuYW1lOiAndGltZXpvbmVzJ1xuICB9XSxcbiAgLy8gVE9ETzogdGhpcyBvbmUgY2FuIGFjdHVhbGx5IGJlIHBhcnNlZCBwcm9wZXJseS4uLlxuICByOiBbe1xuICAgIG5hbWU6ICdyZXBlYXRzJ1xuICB9XSxcbiAgLy8gVE9ETzogdGhpcyBvbmUgY2FuIGFsc28gYmUgcGFyc2VkIHByb3Blcmx5XG4gIC8vIGs6IFt7fV0sIC8vIG91dGRhdGVkIHRoaW5nIGlnbm9yZWRcbiAgdDogW3tcbiAgICAvLyB0PTAgMFxuICAgIG5hbWU6ICd0aW1pbmcnLFxuICAgIHJlZzogL14oXFxkKikgKFxcZCopLyxcbiAgICBuYW1lczogWydzdGFydCcsICdzdG9wJ10sXG4gICAgZm9ybWF0OiAnJWQgJWQnXG4gIH1dLFxuICBjOiBbe1xuICAgIC8vIGM9SU4gSVA0IDEwLjQ3LjE5Ny4yNlxuICAgIG5hbWU6ICdjb25uZWN0aW9uJyxcbiAgICByZWc6IC9eSU4gSVAoXFxkKSAoXFxTKikvLFxuICAgIG5hbWVzOiBbJ3ZlcnNpb24nLCAnaXAnXSxcbiAgICBmb3JtYXQ6ICdJTiBJUCVkICVzJ1xuICB9XSxcbiAgYjogW3tcbiAgICAvLyBiPUFTOjQwMDBcbiAgICBwdXNoOiAnYmFuZHdpZHRoJyxcbiAgICByZWc6IC9eKFRJQVN8QVN8Q1R8UlJ8UlMpOihcXGQqKS8sXG4gICAgbmFtZXM6IFsndHlwZScsICdsaW1pdCddLFxuICAgIGZvcm1hdDogJyVzOiVzJ1xuICB9XSxcbiAgbTogW3tcbiAgICAvLyBtPXZpZGVvIDUxNzQ0IFJUUC9BVlAgMTI2IDk3IDk4IDM0IDMxXG4gICAgLy8gTkI6IHNwZWNpYWwgLSBwdXNoZXMgdG8gc2Vzc2lvblxuICAgIC8vIFRPRE86IHJ0cC9mbXRwIHNob3VsZCBiZSBmaWx0ZXJlZCBieSB0aGUgcGF5bG9hZHMgZm91bmQgaGVyZT9cbiAgICByZWc6IC9eKFxcdyopIChcXGQqKSAoW1xcdy9dKikoPzogKC4qKSk/LyxcbiAgICBuYW1lczogWyd0eXBlJywgJ3BvcnQnLCAncHJvdG9jb2wnLCAncGF5bG9hZHMnXSxcbiAgICBmb3JtYXQ6ICclcyAlZCAlcyAlcydcbiAgfV0sXG4gIGE6IFt7XG4gICAgLy8gYT1ydHBtYXA6MTEwIG9wdXMvNDgwMDAvMlxuICAgIHB1c2g6ICdydHAnLFxuICAgIHJlZzogL15ydHBtYXA6KFxcZCopIChbXFx3XFwtLl0qKSg/OlxccypcXC8oXFxkKikoPzpcXHMqXFwvKFxcUyopKT8pPy8sXG4gICAgbmFtZXM6IFsncGF5bG9hZCcsICdjb2RlYycsICdyYXRlJywgJ2VuY29kaW5nJ10sXG4gICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG8uZW5jb2RpbmcgPyAncnRwbWFwOiVkICVzLyVzLyVzJyA6IG8ucmF0ZSA/ICdydHBtYXA6JWQgJXMvJXMnIDogJ3J0cG1hcDolZCAlcyc7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gYT1mbXRwOjEwOCBwcm9maWxlLWxldmVsLWlkPTI0O29iamVjdD0yMztiaXRyYXRlPTY0MDAwXG4gICAgLy8gYT1mbXRwOjExMSBtaW5wdGltZT0xMDsgdXNlaW5iYW5kZmVjPTFcbiAgICBwdXNoOiAnZm10cCcsXG4gICAgcmVnOiAvXmZtdHA6KFxcZCopIChbXFxTfCBdKikvLFxuICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAnY29uZmlnJ10sXG4gICAgZm9ybWF0OiAnZm10cDolZCAlcydcbiAgfSwge1xuICAgIC8vIGE9Y29udHJvbDpzdHJlYW1pZD0wXG4gICAgbmFtZTogJ2NvbnRyb2wnLFxuICAgIHJlZzogL15jb250cm9sOiguKikvLFxuICAgIGZvcm1hdDogJ2NvbnRyb2w6JXMnXG4gIH0sIHtcbiAgICAvLyBhPXJ0Y3A6NjUxNzkgSU4gSVA0IDE5My44NC43Ny4xOTRcbiAgICBuYW1lOiAncnRjcCcsXG4gICAgcmVnOiAvXnJ0Y3A6KFxcZCopKD86IChcXFMqKSBJUChcXGQpIChcXFMqKSk/LyxcbiAgICBuYW1lczogWydwb3J0JywgJ25ldFR5cGUnLCAnaXBWZXInLCAnYWRkcmVzcyddLFxuICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBvLmFkZHJlc3MgIT0gbnVsbCA/ICdydGNwOiVkICVzIElQJWQgJXMnIDogJ3J0Y3A6JWQnO1xuICAgIH1cbiAgfSwge1xuICAgIC8vIGE9cnRjcC1mYjo5OCB0cnItaW50IDEwMFxuICAgIHB1c2g6ICdydGNwRmJUcnJJbnQnLFxuICAgIHJlZzogL15ydGNwLWZiOihcXCp8XFxkKikgdHJyLWludCAoXFxkKikvLFxuICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAndmFsdWUnXSxcbiAgICBmb3JtYXQ6ICdydGNwLWZiOiVzIHRyci1pbnQgJWQnXG4gIH0sIHtcbiAgICAvLyBhPXJ0Y3AtZmI6OTggbmFjayBycHNpXG4gICAgcHVzaDogJ3J0Y3BGYicsXG4gICAgcmVnOiAvXnJ0Y3AtZmI6KFxcKnxcXGQqKSAoW1xcdy1fXSopKD86IChbXFx3LV9dKikpPy8sXG4gICAgbmFtZXM6IFsncGF5bG9hZCcsICd0eXBlJywgJ3N1YnR5cGUnXSxcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gby5zdWJ0eXBlICE9IG51bGwgPyAncnRjcC1mYjolcyAlcyAlcycgOiAncnRjcC1mYjolcyAlcyc7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gYT1leHRtYXA6MiB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG4gICAgLy8gYT1leHRtYXA6MS9yZWN2b25seSBVUkktZ3BzLXN0cmluZ1xuICAgIC8vIGE9ZXh0bWFwOjMgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6ZW5jcnlwdCB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDpzbXB0ZS10YyAyNUA2MDAvMjRcbiAgICBwdXNoOiAnZXh0JyxcbiAgICByZWc6IC9eZXh0bWFwOihcXGQrKSg/OlxcLyhcXHcrKSk/KD86ICh1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDplbmNyeXB0KSk/IChcXFMqKSg/OiAoXFxTKikpPy8sXG4gICAgbmFtZXM6IFsndmFsdWUnLCAnZGlyZWN0aW9uJywgJ2VuY3J5cHQtdXJpJywgJ3VyaScsICdjb25maWcnXSxcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gJ2V4dG1hcDolZCcgKyAoby5kaXJlY3Rpb24gPyAnLyVzJyA6ICcldicpICsgKG9bJ2VuY3J5cHQtdXJpJ10gPyAnICVzJyA6ICcldicpICsgJyAlcycgKyAoby5jb25maWcgPyAnICVzJyA6ICcnKTtcbiAgICB9XG4gIH0sIHtcbiAgICAvLyBhPWV4dG1hcC1hbGxvdy1taXhlZFxuICAgIG5hbWU6ICdleHRtYXBBbGxvd01peGVkJyxcbiAgICByZWc6IC9eKGV4dG1hcC1hbGxvdy1taXhlZCkvXG4gIH0sIHtcbiAgICAvLyBhPWNyeXB0bzoxIEFFU19DTV8xMjhfSE1BQ19TSEExXzgwIGlubGluZTpQUzF1UUNWZWVDRkNhblZtY2prcFB5d2pOV2hjWUQwbVhYdHhhVkJSfDJeMjB8MTozMlxuICAgIHB1c2g6ICdjcnlwdG8nLFxuICAgIHJlZzogL15jcnlwdG86KFxcZCopIChbXFx3X10qKSAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgIG5hbWVzOiBbJ2lkJywgJ3N1aXRlJywgJ2NvbmZpZycsICdzZXNzaW9uQ29uZmlnJ10sXG4gICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG8uc2Vzc2lvbkNvbmZpZyAhPSBudWxsID8gJ2NyeXB0bzolZCAlcyAlcyAlcycgOiAnY3J5cHRvOiVkICVzICVzJztcbiAgICB9XG4gIH0sIHtcbiAgICAvLyBhPXNldHVwOmFjdHBhc3NcbiAgICBuYW1lOiAnc2V0dXAnLFxuICAgIHJlZzogL15zZXR1cDooXFx3KikvLFxuICAgIGZvcm1hdDogJ3NldHVwOiVzJ1xuICB9LCB7XG4gICAgLy8gYT1jb25uZWN0aW9uOm5ld1xuICAgIG5hbWU6ICdjb25uZWN0aW9uVHlwZScsXG4gICAgcmVnOiAvXmNvbm5lY3Rpb246KG5ld3xleGlzdGluZykvLFxuICAgIGZvcm1hdDogJ2Nvbm5lY3Rpb246JXMnXG4gIH0sIHtcbiAgICAvLyBhPW1pZDoxXG4gICAgbmFtZTogJ21pZCcsXG4gICAgcmVnOiAvXm1pZDooW15cXHNdKikvLFxuICAgIGZvcm1hdDogJ21pZDolcydcbiAgfSwge1xuICAgIC8vIGE9bXNpZDowYzhiMDY0ZC1kODA3LTQzYjQtYjQzNC1mOTJhODg5ZDg1ODcgOTgxNzg2ODUtZDQwOS00NmUwLThlMTYtN2VmMGRiMGRiNjRhXG4gICAgbmFtZTogJ21zaWQnLFxuICAgIHJlZzogL15tc2lkOiguKikvLFxuICAgIGZvcm1hdDogJ21zaWQ6JXMnXG4gIH0sIHtcbiAgICAvLyBhPXB0aW1lOjIwXG4gICAgbmFtZTogJ3B0aW1lJyxcbiAgICByZWc6IC9ecHRpbWU6KFxcZCooPzpcXC5cXGQqKSopLyxcbiAgICBmb3JtYXQ6ICdwdGltZTolZCdcbiAgfSwge1xuICAgIC8vIGE9bWF4cHRpbWU6NjBcbiAgICBuYW1lOiAnbWF4cHRpbWUnLFxuICAgIHJlZzogL15tYXhwdGltZTooXFxkKig/OlxcLlxcZCopKikvLFxuICAgIGZvcm1hdDogJ21heHB0aW1lOiVkJ1xuICB9LCB7XG4gICAgLy8gYT1zZW5kcmVjdlxuICAgIG5hbWU6ICdkaXJlY3Rpb24nLFxuICAgIHJlZzogL14oc2VuZHJlY3Z8cmVjdm9ubHl8c2VuZG9ubHl8aW5hY3RpdmUpL1xuICB9LCB7XG4gICAgLy8gYT1pY2UtbGl0ZVxuICAgIG5hbWU6ICdpY2VsaXRlJyxcbiAgICByZWc6IC9eKGljZS1saXRlKS9cbiAgfSwge1xuICAgIC8vIGE9aWNlLXVmcmFnOkY3Z0lcbiAgICBuYW1lOiAnaWNlVWZyYWcnLFxuICAgIHJlZzogL15pY2UtdWZyYWc6KFxcUyopLyxcbiAgICBmb3JtYXQ6ICdpY2UtdWZyYWc6JXMnXG4gIH0sIHtcbiAgICAvLyBhPWljZS1wd2Q6eDljbWwvWXppY2hWMitYbGhpTXU4Z1xuICAgIG5hbWU6ICdpY2VQd2QnLFxuICAgIHJlZzogL15pY2UtcHdkOihcXFMqKS8sXG4gICAgZm9ybWF0OiAnaWNlLXB3ZDolcydcbiAgfSwge1xuICAgIC8vIGE9ZmluZ2VycHJpbnQ6U0hBLTEgMDA6MTE6MjI6MzM6NDQ6NTU6NjY6Nzc6ODg6OTk6QUE6QkI6Q0M6REQ6RUU6RkY6MDA6MTE6MjI6MzNcbiAgICBuYW1lOiAnZmluZ2VycHJpbnQnLFxuICAgIHJlZzogL15maW5nZXJwcmludDooXFxTKikgKFxcUyopLyxcbiAgICBuYW1lczogWyd0eXBlJywgJ2hhc2gnXSxcbiAgICBmb3JtYXQ6ICdmaW5nZXJwcmludDolcyAlcydcbiAgfSwge1xuICAgIC8vIGE9Y2FuZGlkYXRlOjAgMSBVRFAgMjExMzY2NzMyNyAyMDMuMC4xMTMuMSA1NDQwMCB0eXAgaG9zdFxuICAgIC8vIGE9Y2FuZGlkYXRlOjExNjI4NzUwODEgMSB1ZHAgMjExMzkzNzE1MSAxOTIuMTY4LjM0Ljc1IDYwMDE3IHR5cCBob3N0IGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgLy8gYT1jYW5kaWRhdGU6MzI4OTkxMjk1NyAyIHVkcCAxODQ1NTAxNjk1IDE5My44NC43Ny4xOTQgNjAwMTcgdHlwIHNyZmx4IHJhZGRyIDE5Mi4xNjguMzQuNzUgcnBvcnQgNjAwMTcgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAvLyBhPWNhbmRpZGF0ZToyMjk4MTU2MjAgMSB0Y3AgMTUxODI4MDQ0NyAxOTIuMTY4LjE1MC4xOSA2MDAxNyB0eXAgaG9zdCB0Y3B0eXBlIGFjdGl2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgIC8vIGE9Y2FuZGlkYXRlOjMyODk5MTI5NTcgMiB0Y3AgMTg0NTUwMTY5NSAxOTMuODQuNzcuMTk0IDYwMDE3IHR5cCBzcmZseCByYWRkciAxOTIuMTY4LjM0Ljc1IHJwb3J0IDYwMDE3IHRjcHR5cGUgcGFzc2l2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgIHB1c2g6ICdjYW5kaWRhdGVzJyxcbiAgICByZWc6IC9eY2FuZGlkYXRlOihcXFMqKSAoXFxkKikgKFxcUyopIChcXGQqKSAoXFxTKikgKFxcZCopIHR5cCAoXFxTKikoPzogcmFkZHIgKFxcUyopIHJwb3J0IChcXGQqKSk/KD86IHRjcHR5cGUgKFxcUyopKT8oPzogZ2VuZXJhdGlvbiAoXFxkKikpPyg/OiBuZXR3b3JrLWlkIChcXGQqKSk/KD86IG5ldHdvcmstY29zdCAoXFxkKikpPy8sXG4gICAgbmFtZXM6IFsnZm91bmRhdGlvbicsICdjb21wb25lbnQnLCAndHJhbnNwb3J0JywgJ3ByaW9yaXR5JywgJ2lwJywgJ3BvcnQnLCAndHlwZScsICdyYWRkcicsICdycG9ydCcsICd0Y3B0eXBlJywgJ2dlbmVyYXRpb24nLCAnbmV0d29yay1pZCcsICduZXR3b3JrLWNvc3QnXSxcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgc3RyID0gJ2NhbmRpZGF0ZTolcyAlZCAlcyAlZCAlcyAlZCB0eXAgJXMnO1xuICAgICAgc3RyICs9IG8ucmFkZHIgIT0gbnVsbCA/ICcgcmFkZHIgJXMgcnBvcnQgJWQnIDogJyV2JXYnO1xuXG4gICAgICAvLyBOQjogY2FuZGlkYXRlIGhhcyB0aHJlZSBvcHRpb25hbCBjaHVua3MsIHNvICV2b2lkIG1pZGRsZXMgb25lIGlmIGl0J3MgbWlzc2luZ1xuICAgICAgc3RyICs9IG8udGNwdHlwZSAhPSBudWxsID8gJyB0Y3B0eXBlICVzJyA6ICcldic7XG4gICAgICBpZiAoby5nZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc3RyICs9ICcgZ2VuZXJhdGlvbiAlZCc7XG4gICAgICB9XG4gICAgICBzdHIgKz0gb1snbmV0d29yay1pZCddICE9IG51bGwgPyAnIG5ldHdvcmstaWQgJWQnIDogJyV2JztcbiAgICAgIHN0ciArPSBvWyduZXR3b3JrLWNvc3QnXSAhPSBudWxsID8gJyBuZXR3b3JrLWNvc3QgJWQnIDogJyV2JztcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gYT1lbmQtb2YtY2FuZGlkYXRlcyAoa2VlcCBhZnRlciB0aGUgY2FuZGlkYXRlcyBsaW5lIGZvciByZWFkYWJpbGl0eSlcbiAgICBuYW1lOiAnZW5kT2ZDYW5kaWRhdGVzJyxcbiAgICByZWc6IC9eKGVuZC1vZi1jYW5kaWRhdGVzKS9cbiAgfSwge1xuICAgIC8vIGE9cmVtb3RlLWNhbmRpZGF0ZXM6MSAyMDMuMC4xMTMuMSA1NDQwMCAyIDIwMy4wLjExMy4xIDU0NDAxIC4uLlxuICAgIG5hbWU6ICdyZW1vdGVDYW5kaWRhdGVzJyxcbiAgICByZWc6IC9ecmVtb3RlLWNhbmRpZGF0ZXM6KC4qKS8sXG4gICAgZm9ybWF0OiAncmVtb3RlLWNhbmRpZGF0ZXM6JXMnXG4gIH0sIHtcbiAgICAvLyBhPWljZS1vcHRpb25zOmdvb2dsZS1pY2VcbiAgICBuYW1lOiAnaWNlT3B0aW9ucycsXG4gICAgcmVnOiAvXmljZS1vcHRpb25zOihcXFMqKS8sXG4gICAgZm9ybWF0OiAnaWNlLW9wdGlvbnM6JXMnXG4gIH0sIHtcbiAgICAvLyBhPXNzcmM6MjU2NjEwNzU2OSBjbmFtZTp0OVlVOE0xVXhURjhZMUExXG4gICAgcHVzaDogJ3NzcmNzJyxcbiAgICByZWc6IC9ec3NyYzooXFxkKikgKFtcXHdfLV0qKSg/OjooLiopKT8vLFxuICAgIG5hbWVzOiBbJ2lkJywgJ2F0dHJpYnV0ZScsICd2YWx1ZSddLFxuICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdHIgPSAnc3NyYzolZCc7XG4gICAgICBpZiAoby5hdHRyaWJ1dGUgIT0gbnVsbCkge1xuICAgICAgICBzdHIgKz0gJyAlcyc7XG4gICAgICAgIGlmIChvLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICBzdHIgKz0gJzolcyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gYT1zc3JjLWdyb3VwOkZFQyAxIDJcbiAgICAvLyBhPXNzcmMtZ3JvdXA6RkVDLUZSIDMwMDQzNjQxOTUgMTA4MDc3MjI0MVxuICAgIHB1c2g6ICdzc3JjR3JvdXBzJyxcbiAgICAvLyB0b2tlbi1jaGFyID0gJXgyMSAvICV4MjMtMjcgLyAleDJBLTJCIC8gJXgyRC0yRSAvICV4MzAtMzkgLyAleDQxLTVBIC8gJXg1RS03RVxuICAgIHJlZzogL15zc3JjLWdyb3VwOihbXFx4MjFcXHgyM1xceDI0XFx4MjVcXHgyNlxceDI3XFx4MkFcXHgyQlxceDJEXFx4MkVcXHddKikgKC4qKS8sXG4gICAgbmFtZXM6IFsnc2VtYW50aWNzJywgJ3NzcmNzJ10sXG4gICAgZm9ybWF0OiAnc3NyYy1ncm91cDolcyAlcydcbiAgfSwge1xuICAgIC8vIGE9bXNpZC1zZW1hbnRpYzogV01TIEp2bGFtNVgzU1gxT1A2cG4yMHpXb2d2YUtKejVIamY5T25sVlxuICAgIG5hbWU6ICdtc2lkU2VtYW50aWMnLFxuICAgIHJlZzogL15tc2lkLXNlbWFudGljOlxccz8oXFx3KikgKFxcUyopLyxcbiAgICBuYW1lczogWydzZW1hbnRpYycsICd0b2tlbiddLFxuICAgIGZvcm1hdDogJ21zaWQtc2VtYW50aWM6ICVzICVzJyAvLyBzcGFjZSBhZnRlciAnOicgaXMgbm90IGFjY2lkZW50YWxcbiAgfSwge1xuICAgIC8vIGE9Z3JvdXA6QlVORExFIGF1ZGlvIHZpZGVvXG4gICAgcHVzaDogJ2dyb3VwcycsXG4gICAgcmVnOiAvXmdyb3VwOihcXHcqKSAoLiopLyxcbiAgICBuYW1lczogWyd0eXBlJywgJ21pZHMnXSxcbiAgICBmb3JtYXQ6ICdncm91cDolcyAlcydcbiAgfSwge1xuICAgIC8vIGE9cnRjcC1tdXhcbiAgICBuYW1lOiAncnRjcE11eCcsXG4gICAgcmVnOiAvXihydGNwLW11eCkvXG4gIH0sIHtcbiAgICAvLyBhPXJ0Y3AtcnNpemVcbiAgICBuYW1lOiAncnRjcFJzaXplJyxcbiAgICByZWc6IC9eKHJ0Y3AtcnNpemUpL1xuICB9LCB7XG4gICAgLy8gYT1zY3RwbWFwOjUwMDAgd2VicnRjLWRhdGFjaGFubmVsIDEwMjRcbiAgICBuYW1lOiAnc2N0cG1hcCcsXG4gICAgcmVnOiAvXnNjdHBtYXA6KFtcXHdfL10qKSAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgIG5hbWVzOiBbJ3NjdHBtYXBOdW1iZXInLCAnYXBwJywgJ21heE1lc3NhZ2VTaXplJ10sXG4gICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG8ubWF4TWVzc2FnZVNpemUgIT0gbnVsbCA/ICdzY3RwbWFwOiVzICVzICVzJyA6ICdzY3RwbWFwOiVzICVzJztcbiAgICB9XG4gIH0sIHtcbiAgICAvLyBhPXgtZ29vZ2xlLWZsYWc6Y29uZmVyZW5jZVxuICAgIG5hbWU6ICd4R29vZ2xlRmxhZycsXG4gICAgcmVnOiAvXngtZ29vZ2xlLWZsYWc6KFteXFxzXSopLyxcbiAgICBmb3JtYXQ6ICd4LWdvb2dsZS1mbGFnOiVzJ1xuICB9LCB7XG4gICAgLy8gYT1yaWQ6MSBzZW5kIG1heC13aWR0aD0xMjgwO21heC1oZWlnaHQ9NzIwO21heC1mcHM9MzA7ZGVwZW5kPTBcbiAgICBwdXNoOiAncmlkcycsXG4gICAgcmVnOiAvXnJpZDooW1xcZFxcd10rKSAoXFx3KykoPzogKFtcXFN8IF0qKSk/LyxcbiAgICBuYW1lczogWydpZCcsICdkaXJlY3Rpb24nLCAncGFyYW1zJ10sXG4gICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG8ucGFyYW1zID8gJ3JpZDolcyAlcyAlcycgOiAncmlkOiVzICVzJztcbiAgICB9XG4gIH0sIHtcbiAgICAvLyBhPWltYWdlYXR0cjo5NyBzZW5kIFt4PTgwMCx5PTY0MCxzYXI9MS4xLHE9MC42XSBbeD00ODAseT0zMjBdIHJlY3YgW3g9MzMwLHk9MjUwXVxuICAgIC8vIGE9aW1hZ2VhdHRyOiogc2VuZCBbeD04MDAseT02NDBdIHJlY3YgKlxuICAgIC8vIGE9aW1hZ2VhdHRyOjEwMCByZWN2IFt4PTMyMCx5PTI0MF1cbiAgICBwdXNoOiAnaW1hZ2VhdHRycycsXG4gICAgcmVnOiBuZXcgUmVnRXhwKFxuICAgIC8vIGE9aW1hZ2VhdHRyOjk3XG4gICAgJ15pbWFnZWF0dHI6KFxcXFxkK3xcXFxcKiknICtcbiAgICAvLyBzZW5kIFt4PTgwMCx5PTY0MCxzYXI9MS4xLHE9MC42XSBbeD00ODAseT0zMjBdXG4gICAgJ1tcXFxcc1xcXFx0XSsoc2VuZHxyZWN2KVtcXFxcc1xcXFx0XSsoXFxcXCp8XFxcXFtcXFxcUytcXFxcXSg/OltcXFxcc1xcXFx0XStcXFxcW1xcXFxTK1xcXFxdKSopJyArXG4gICAgLy8gcmVjdiBbeD0zMzAseT0yNTBdXG4gICAgJyg/OltcXFxcc1xcXFx0XSsocmVjdnxzZW5kKVtcXFxcc1xcXFx0XSsoXFxcXCp8XFxcXFtcXFxcUytcXFxcXSg/OltcXFxcc1xcXFx0XStcXFxcW1xcXFxTK1xcXFxdKSopKT8nKSxcbiAgICBuYW1lczogWydwdCcsICdkaXIxJywgJ2F0dHJzMScsICdkaXIyJywgJ2F0dHJzMiddLFxuICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiAnaW1hZ2VhdHRyOiVzICVzICVzJyArIChvLmRpcjIgPyAnICVzICVzJyA6ICcnKTtcbiAgICB9XG4gIH0sIHtcbiAgICAvLyBhPXNpbXVsY2FzdDpzZW5kIDEsMiwzO340LH41IHJlY3YgNjt+Nyx+OFxuICAgIC8vIGE9c2ltdWxjYXN0OnJlY3YgMTs0LDUgc2VuZCA2OzdcbiAgICBuYW1lOiAnc2ltdWxjYXN0JyxcbiAgICByZWc6IG5ldyBSZWdFeHAoXG4gICAgLy8gYT1zaW11bGNhc3Q6XG4gICAgJ15zaW11bGNhc3Q6JyArXG4gICAgLy8gc2VuZCAxLDIsMzt+NCx+NVxuICAgICcoc2VuZHxyZWN2KSAoW2EtekEtWjAtOVxcXFwtX347LF0rKScgK1xuICAgIC8vIHNwYWNlICsgcmVjdiA2O343LH44XG4gICAgJyg/OlxcXFxzPyhzZW5kfHJlY3YpIChbYS16QS1aMC05XFxcXC1ffjssXSspKT8nICtcbiAgICAvLyBlbmRcbiAgICAnJCcpLFxuICAgIG5hbWVzOiBbJ2RpcjEnLCAnbGlzdDEnLCAnZGlyMicsICdsaXN0MiddLFxuICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiAnc2ltdWxjYXN0OiVzICVzJyArIChvLmRpcjIgPyAnICVzICVzJyA6ICcnKTtcbiAgICB9XG4gIH0sIHtcbiAgICAvLyBvbGQgc2ltdWxjYXN0IGRyYWZ0IDAzIChpbXBsZW1lbnRlZCBieSBGaXJlZm94KVxuICAgIC8vICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNkcC1zaW11bGNhc3QtMDNcbiAgICAvLyBhPXNpbXVsY2FzdDogcmVjdiBwdD05Nzs5OCBzZW5kIHB0PTk3XG4gICAgLy8gYT1zaW11bGNhc3Q6IHNlbmQgcmlkPTU7Njs3IHBhdXNlZD02LDdcbiAgICBuYW1lOiAnc2ltdWxjYXN0XzAzJyxcbiAgICByZWc6IC9ec2ltdWxjYXN0OltcXHNcXHRdKyhbXFxTK1xcc1xcdF0rKSQvLFxuICAgIG5hbWVzOiBbJ3ZhbHVlJ10sXG4gICAgZm9ybWF0OiAnc2ltdWxjYXN0OiAlcydcbiAgfSwge1xuICAgIC8vIGE9ZnJhbWVyYXRlOjI1XG4gICAgLy8gYT1mcmFtZXJhdGU6MjkuOTdcbiAgICBuYW1lOiAnZnJhbWVyYXRlJyxcbiAgICByZWc6IC9eZnJhbWVyYXRlOihcXGQrKD86JHxcXC5cXGQrKSkvLFxuICAgIGZvcm1hdDogJ2ZyYW1lcmF0ZTolcydcbiAgfSwge1xuICAgIC8vIFJGQzQ1NzBcbiAgICAvLyBhPXNvdXJjZS1maWx0ZXI6IGluY2wgSU4gSVA0IDIzOS41LjIuMzEgMTAuMS4xNS41XG4gICAgbmFtZTogJ3NvdXJjZUZpbHRlcicsXG4gICAgcmVnOiAvXnNvdXJjZS1maWx0ZXI6ICooZXhjbHxpbmNsKSAoXFxTKikgKElQNHxJUDZ8XFwqKSAoXFxTKikgKC4qKS8sXG4gICAgbmFtZXM6IFsnZmlsdGVyTW9kZScsICduZXRUeXBlJywgJ2FkZHJlc3NUeXBlcycsICdkZXN0QWRkcmVzcycsICdzcmNMaXN0J10sXG4gICAgZm9ybWF0OiAnc291cmNlLWZpbHRlcjogJXMgJXMgJXMgJXMgJXMnXG4gIH0sIHtcbiAgICAvLyBhPWJ1bmRsZS1vbmx5XG4gICAgbmFtZTogJ2J1bmRsZU9ubHknLFxuICAgIHJlZzogL14oYnVuZGxlLW9ubHkpL1xuICB9LCB7XG4gICAgLy8gYT1sYWJlbDoxXG4gICAgbmFtZTogJ2xhYmVsJyxcbiAgICByZWc6IC9ebGFiZWw6KC4rKS8sXG4gICAgZm9ybWF0OiAnbGFiZWw6JXMnXG4gIH0sIHtcbiAgICAvLyBSRkMgdmVyc2lvbiAyNiBmb3IgU0NUUCBvdmVyIERUTFNcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYjc2VjdGlvbi01XG4gICAgbmFtZTogJ3NjdHBQb3J0JyxcbiAgICByZWc6IC9ec2N0cC1wb3J0OihcXGQrKSQvLFxuICAgIGZvcm1hdDogJ3NjdHAtcG9ydDolcydcbiAgfSwge1xuICAgIC8vIFJGQyB2ZXJzaW9uIDI2IGZvciBTQ1RQIG92ZXIgRFRMU1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiNzZWN0aW9uLTZcbiAgICBuYW1lOiAnbWF4TWVzc2FnZVNpemUnLFxuICAgIHJlZzogL15tYXgtbWVzc2FnZS1zaXplOihcXGQrKSQvLFxuICAgIGZvcm1hdDogJ21heC1tZXNzYWdlLXNpemU6JXMnXG4gIH0sIHtcbiAgICAvLyBSRkM3MjczXG4gICAgLy8gYT10cy1yZWZjbGs6cHRwPUlFRUUxNTg4LTIwMDg6MzktQTctOTQtRkYtRkUtMDctQ0ItRDA6MzdcbiAgICBwdXNoOiAndHNSZWZDbG9ja3MnLFxuICAgIHJlZzogL150cy1yZWZjbGs6KFteXFxzPV0qKSg/Oj0oXFxTKikpPy8sXG4gICAgbmFtZXM6IFsnY2xrc3JjJywgJ2Nsa3NyY0V4dCddLFxuICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiAndHMtcmVmY2xrOiVzJyArIChvLmNsa3NyY0V4dCAhPSBudWxsID8gJz0lcycgOiAnJyk7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gUkZDNzI3M1xuICAgIC8vIGE9bWVkaWFjbGs6ZGlyZWN0PTk2MzIxNDQyNFxuICAgIG5hbWU6ICdtZWRpYUNsaycsXG4gICAgcmVnOiAvXm1lZGlhY2xrOig/OmlkPShcXFMqKSk/ICooW15cXHM9XSopKD86PShcXFMqKSk/KD86ICpyYXRlPShcXGQrKVxcLyhcXGQrKSk/LyxcbiAgICBuYW1lczogWydpZCcsICdtZWRpYUNsb2NrTmFtZScsICdtZWRpYUNsb2NrVmFsdWUnLCAncmF0ZU51bWVyYXRvcicsICdyYXRlRGVub21pbmF0b3InXSxcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgc3RyID0gJ21lZGlhY2xrOic7XG4gICAgICBzdHIgKz0gby5pZCAhPSBudWxsID8gJ2lkPSVzICVzJyA6ICcldiVzJztcbiAgICAgIHN0ciArPSBvLm1lZGlhQ2xvY2tWYWx1ZSAhPSBudWxsID8gJz0lcycgOiAnJztcbiAgICAgIHN0ciArPSBvLnJhdGVOdW1lcmF0b3IgIT0gbnVsbCA/ICcgcmF0ZT0lcycgOiAnJztcbiAgICAgIHN0ciArPSBvLnJhdGVEZW5vbWluYXRvciAhPSBudWxsID8gJy8lcycgOiAnJztcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gYT1rZXl3ZHM6a2V5d29yZHNcbiAgICBuYW1lOiAna2V5d29yZHMnLFxuICAgIHJlZzogL15rZXl3ZHM6KC4rKSQvLFxuICAgIGZvcm1hdDogJ2tleXdkczolcydcbiAgfSwge1xuICAgIC8vIGE9Y29udGVudDptYWluXG4gICAgbmFtZTogJ2NvbnRlbnQnLFxuICAgIHJlZzogL15jb250ZW50OiguKykvLFxuICAgIGZvcm1hdDogJ2NvbnRlbnQ6JXMnXG4gIH0sXG4gIC8vIEJGQ1AgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ1ODNcbiAge1xuICAgIC8vIGE9Zmxvb3JjdHJsOmMtc1xuICAgIG5hbWU6ICdiZmNwRmxvb3JDdHJsJyxcbiAgICByZWc6IC9eZmxvb3JjdHJsOihjLW9ubHl8cy1vbmx5fGMtcykvLFxuICAgIGZvcm1hdDogJ2Zsb29yY3RybDolcydcbiAgfSwge1xuICAgIC8vIGE9Y29uZmlkOjFcbiAgICBuYW1lOiAnYmZjcENvbmZJZCcsXG4gICAgcmVnOiAvXmNvbmZpZDooXFxkKykvLFxuICAgIGZvcm1hdDogJ2NvbmZpZDolcydcbiAgfSwge1xuICAgIC8vIGE9dXNlcmlkOjFcbiAgICBuYW1lOiAnYmZjcFVzZXJJZCcsXG4gICAgcmVnOiAvXnVzZXJpZDooXFxkKykvLFxuICAgIGZvcm1hdDogJ3VzZXJpZDolcydcbiAgfSwge1xuICAgIC8vIGE9Zmxvb3JpZDoxXG4gICAgbmFtZTogJ2JmY3BGbG9vcklkJyxcbiAgICByZWc6IC9eZmxvb3JpZDooLispICg/Om0tc3RyZWFtfG1zdHJtKTooLispLyxcbiAgICBuYW1lczogWydpZCcsICdtU3RyZWFtJ10sXG4gICAgZm9ybWF0OiAnZmxvb3JpZDolcyBtc3RybTolcydcbiAgfSwge1xuICAgIC8vIGFueSBhPSB0aGF0IHdlIGRvbid0IHVuZGVyc3RhbmQgaXMga2VwdCB2ZXJiYXRpbSBvbiBtZWRpYS5pbnZhbGlkXG4gICAgcHVzaDogJ2ludmFsaWQnLFxuICAgIG5hbWVzOiBbJ3ZhbHVlJ11cbiAgfV1cbn07XG5cbi8vIHNldCBzZW5zaWJsZSBkZWZhdWx0cyB0byBhdm9pZCBwb2xsdXRpbmcgdGhlIGdyYW1tYXIgd2l0aCBib3JpbmcgZGV0YWlsc1xuT2JqZWN0LmtleXMoZ3JhbW1hciQxKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIG9ianMgPSBncmFtbWFyJDFba2V5XTtcbiAgb2Jqcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoIW9iai5yZWcpIHtcbiAgICAgIG9iai5yZWcgPSAvKC4qKS87XG4gICAgfVxuICAgIGlmICghb2JqLmZvcm1hdCkge1xuICAgICAgb2JqLmZvcm1hdCA9ICclcyc7XG4gICAgfVxuICB9KTtcbn0pO1xudmFyIGdyYW1tYXJFeHBvcnRzID0gZ3JhbW1hciQyLmV4cG9ydHM7XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuICB2YXIgdG9JbnRJZkludCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFN0cmluZyhOdW1iZXIodikpID09PSB2ID8gTnVtYmVyKHYpIDogdjtcbiAgfTtcbiAgdmFyIGF0dGFjaFByb3BlcnRpZXMgPSBmdW5jdGlvbiAobWF0Y2gsIGxvY2F0aW9uLCBuYW1lcywgcmF3TmFtZSkge1xuICAgIGlmIChyYXdOYW1lICYmICFuYW1lcykge1xuICAgICAgbG9jYXRpb25bcmF3TmFtZV0gPSB0b0ludElmSW50KG1hdGNoWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAobWF0Y2hbaSArIDFdICE9IG51bGwpIHtcbiAgICAgICAgICBsb2NhdGlvbltuYW1lc1tpXV0gPSB0b0ludElmSW50KG1hdGNoW2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBwYXJzZVJlZyA9IGZ1bmN0aW9uIChvYmosIGxvY2F0aW9uLCBjb250ZW50KSB7XG4gICAgdmFyIG5lZWRzQmxhbmsgPSBvYmoubmFtZSAmJiBvYmoubmFtZXM7XG4gICAgaWYgKG9iai5wdXNoICYmICFsb2NhdGlvbltvYmoucHVzaF0pIHtcbiAgICAgIGxvY2F0aW9uW29iai5wdXNoXSA9IFtdO1xuICAgIH0gZWxzZSBpZiAobmVlZHNCbGFuayAmJiAhbG9jYXRpb25bb2JqLm5hbWVdKSB7XG4gICAgICBsb2NhdGlvbltvYmoubmFtZV0gPSB7fTtcbiAgICB9XG4gICAgdmFyIGtleUxvY2F0aW9uID0gb2JqLnB1c2ggPyB7fSA6XG4gICAgLy8gYmxhbmsgb2JqZWN0IHRoYXQgd2lsbCBiZSBwdXNoZWRcbiAgICBuZWVkc0JsYW5rID8gbG9jYXRpb25bb2JqLm5hbWVdIDogbG9jYXRpb247IC8vIG90aGVyd2lzZSwgbmFtZWQgbG9jYXRpb24gb3Igcm9vdFxuXG4gICAgYXR0YWNoUHJvcGVydGllcyhjb250ZW50Lm1hdGNoKG9iai5yZWcpLCBrZXlMb2NhdGlvbiwgb2JqLm5hbWVzLCBvYmoubmFtZSk7XG4gICAgaWYgKG9iai5wdXNoKSB7XG4gICAgICBsb2NhdGlvbltvYmoucHVzaF0ucHVzaChrZXlMb2NhdGlvbik7XG4gICAgfVxuICB9O1xuICB2YXIgZ3JhbW1hciA9IGdyYW1tYXJFeHBvcnRzO1xuICB2YXIgdmFsaWRMaW5lID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL14oW2Etel0pPSguKikvKTtcbiAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzZHApIHtcbiAgICB2YXIgc2Vzc2lvbiA9IHt9LFxuICAgICAgbWVkaWEgPSBbXSxcbiAgICAgIGxvY2F0aW9uID0gc2Vzc2lvbjsgLy8gcG9pbnRzIGF0IHdoZXJlIHByb3BlcnRpZXMgZ28gdW5kZXIgKG9uZSBvZiB0aGUgYWJvdmUpXG5cbiAgICAvLyBwYXJzZSBsaW5lcyB3ZSB1bmRlcnN0YW5kXG4gICAgc2RwLnNwbGl0KC8oXFxyXFxufFxccnxcXG4pLykuZmlsdGVyKHZhbGlkTGluZSkuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgdmFyIHR5cGUgPSBsWzBdO1xuICAgICAgdmFyIGNvbnRlbnQgPSBsLnNsaWNlKDIpO1xuICAgICAgaWYgKHR5cGUgPT09ICdtJykge1xuICAgICAgICBtZWRpYS5wdXNoKHtcbiAgICAgICAgICBydHA6IFtdLFxuICAgICAgICAgIGZtdHA6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBsb2NhdGlvbiA9IG1lZGlhW21lZGlhLmxlbmd0aCAtIDFdOyAvLyBwb2ludCBhdCBsYXRlc3QgbWVkaWEgbGluZVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAoZ3JhbW1hclt0eXBlXSB8fCBbXSkubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgdmFyIG9iaiA9IGdyYW1tYXJbdHlwZV1bal07XG4gICAgICAgIGlmIChvYmoucmVnLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VSZWcob2JqLCBsb2NhdGlvbiwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBzZXNzaW9uLm1lZGlhID0gbWVkaWE7IC8vIGxpbmsgaXQgdXBcbiAgICByZXR1cm4gc2Vzc2lvbjtcbiAgfTtcbiAgdmFyIHBhcmFtUmVkdWNlciA9IGZ1bmN0aW9uIChhY2MsIGV4cHIpIHtcbiAgICB2YXIgcyA9IGV4cHIuc3BsaXQoLz0oLispLywgMik7XG4gICAgaWYgKHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBhY2Nbc1swXV0gPSB0b0ludElmSW50KHNbMV0pO1xuICAgIH0gZWxzZSBpZiAocy5sZW5ndGggPT09IDEgJiYgZXhwci5sZW5ndGggPiAxKSB7XG4gICAgICBhY2Nbc1swXV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH07XG4gIGV4cG9ydHMucGFyc2VQYXJhbXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgvO1xccz8vKS5yZWR1Y2UocGFyYW1SZWR1Y2VyLCB7fSk7XG4gIH07XG5cbiAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgLSBhbGlhcyB3aWxsIGJlIHJlbW92ZWQgaW4gMy4wLjBcbiAgZXhwb3J0cy5wYXJzZUZtdHBDb25maWcgPSBleHBvcnRzLnBhcnNlUGFyYW1zO1xuICBleHBvcnRzLnBhcnNlUGF5bG9hZHMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50b1N0cmluZygpLnNwbGl0KCcgJykubWFwKE51bWJlcik7XG4gIH07XG4gIGV4cG9ydHMucGFyc2VSZW1vdGVDYW5kaWRhdGVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciBjYW5kaWRhdGVzID0gW107XG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCcgJykubWFwKHRvSW50SWZJbnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgIGNvbXBvbmVudDogcGFydHNbaV0sXG4gICAgICAgIGlwOiBwYXJ0c1tpICsgMV0sXG4gICAgICAgIHBvcnQ6IHBhcnRzW2kgKyAyXVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjYW5kaWRhdGVzO1xuICB9O1xuICBleHBvcnRzLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLnN1YnN0cmluZygxLCBpdGVtLmxlbmd0aCAtIDEpLnNwbGl0KCcsJykucmVkdWNlKHBhcmFtUmVkdWNlciwge30pO1xuICAgIH0pO1xuICB9O1xuICBleHBvcnRzLnBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCc7JykubWFwKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgIHJldHVybiBzdHJlYW0uc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICB2YXIgc2NpZCxcbiAgICAgICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGZvcm1hdFswXSAhPT0gJ34nKSB7XG4gICAgICAgICAgc2NpZCA9IHRvSW50SWZJbnQoZm9ybWF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2lkID0gdG9JbnRJZkludChmb3JtYXQuc3Vic3RyaW5nKDEsIGZvcm1hdC5sZW5ndGgpKTtcbiAgICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2NpZDogc2NpZCxcbiAgICAgICAgICBwYXVzZWQ6IHBhdXNlZFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59KShwYXJzZXIkMSk7XG5cbnZhciBncmFtbWFyID0gZ3JhbW1hckV4cG9ydHM7XG5cbi8vIGN1c3RvbWl6ZWQgdXRpbC5mb3JtYXQgLSBkaXNjYXJkcyBleGNlc3MgYXJndW1lbnRzIGFuZCBjYW4gdm9pZCBtaWRkbGUgb25lc1xudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkdiVdL2c7XG52YXIgZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdFN0cikge1xuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHJldHVybiBmb3JtYXRTdHIucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICByZXR1cm4geDsgLy8gbWlzc2luZyBhcmd1bWVudFxuICAgIH1cbiAgICB2YXIgYXJnID0gYXJnc1tpXTtcbiAgICBpICs9IDE7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclJSc6XG4gICAgICAgIHJldHVybiAnJSc7XG4gICAgICBjYXNlICclcyc6XG4gICAgICAgIHJldHVybiBTdHJpbmcoYXJnKTtcbiAgICAgIGNhc2UgJyVkJzpcbiAgICAgICAgcmV0dXJuIE51bWJlcihhcmcpO1xuICAgICAgY2FzZSAnJXYnOlxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9KTtcbiAgLy8gTkI6IHdlIGRpc2NhcmQgZXhjZXNzIGFyZ3VtZW50cyAtIHRoZXkgYXJlIHR5cGljYWxseSB1bmRlZmluZWQgZnJvbSBtYWtlTGluZVxufTtcbnZhciBtYWtlTGluZSA9IGZ1bmN0aW9uICh0eXBlLCBvYmosIGxvY2F0aW9uKSB7XG4gIHZhciBzdHIgPSBvYmouZm9ybWF0IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBvYmouZm9ybWF0KG9iai5wdXNoID8gbG9jYXRpb24gOiBsb2NhdGlvbltvYmoubmFtZV0pIDogb2JqLmZvcm1hdDtcbiAgdmFyIGFyZ3MgPSBbdHlwZSArICc9JyArIHN0cl07XG4gIGlmIChvYmoubmFtZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5uYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIG4gPSBvYmoubmFtZXNbaV07XG4gICAgICBpZiAob2JqLm5hbWUpIHtcbiAgICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lXVtuXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmb3IgbUxpbmUgYW5kIHB1c2ggYXR0cmlidXRlc1xuICAgICAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFyZ3MucHVzaChsb2NhdGlvbltvYmoubmFtZV0pO1xuICB9XG4gIHJldHVybiBmb3JtYXQuYXBwbHkobnVsbCwgYXJncyk7XG59O1xuXG4vLyBSRkMgc3BlY2lmaWVkIG9yZGVyXG4vLyBUT0RPOiBleHRlbmQgdGhpcyB3aXRoIGFsbCB0aGUgcmVzdFxudmFyIGRlZmF1bHRPdXRlck9yZGVyID0gWyd2JywgJ28nLCAncycsICdpJywgJ3UnLCAnZScsICdwJywgJ2MnLCAnYicsICd0JywgJ3InLCAneicsICdhJ107XG52YXIgZGVmYXVsdElubmVyT3JkZXIgPSBbJ2knLCAnYycsICdiJywgJ2EnXTtcbnZhciB3cml0ZXIkMSA9IGZ1bmN0aW9uIChzZXNzaW9uLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAvLyBlbnN1cmUgY2VydGFpbiBwcm9wZXJ0aWVzIGV4aXN0XG4gIGlmIChzZXNzaW9uLnZlcnNpb24gPT0gbnVsbCkge1xuICAgIHNlc3Npb24udmVyc2lvbiA9IDA7IC8vICd2PTAnIG11c3QgYmUgdGhlcmUgKG9ubHkgZGVmaW5lZCB2ZXJzaW9uIGF0bSlcbiAgfVxuICBpZiAoc2Vzc2lvbi5uYW1lID09IG51bGwpIHtcbiAgICBzZXNzaW9uLm5hbWUgPSAnICc7IC8vICdzPSAnIG11c3QgYmUgdGhlcmUgaWYgbm8gbWVhbmluZ2Z1bCBuYW1lIHNldFxuICB9XG4gIHNlc3Npb24ubWVkaWEuZm9yRWFjaChmdW5jdGlvbiAobUxpbmUpIHtcbiAgICBpZiAobUxpbmUucGF5bG9hZHMgPT0gbnVsbCkge1xuICAgICAgbUxpbmUucGF5bG9hZHMgPSAnJztcbiAgICB9XG4gIH0pO1xuICB2YXIgb3V0ZXJPcmRlciA9IG9wdHMub3V0ZXJPcmRlciB8fCBkZWZhdWx0T3V0ZXJPcmRlcjtcbiAgdmFyIGlubmVyT3JkZXIgPSBvcHRzLmlubmVyT3JkZXIgfHwgZGVmYXVsdElubmVyT3JkZXI7XG4gIHZhciBzZHAgPSBbXTtcblxuICAvLyBsb29wIHRocm91Z2ggb3V0ZXJPcmRlciBmb3IgbWF0Y2hpbmcgcHJvcGVydGllcyBvbiBzZXNzaW9uXG4gIG91dGVyT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGdyYW1tYXJbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICBpZiAob2JqLm5hbWUgaW4gc2Vzc2lvbiAmJiBzZXNzaW9uW29iai5uYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgc2Vzc2lvbikpO1xuICAgICAgfSBlbHNlIGlmIChvYmoucHVzaCBpbiBzZXNzaW9uICYmIHNlc3Npb25bb2JqLnB1c2hdICE9IG51bGwpIHtcbiAgICAgICAgc2Vzc2lvbltvYmoucHVzaF0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIGVsKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyB0aGVuIGZvciBlYWNoIG1lZGlhIGxpbmUsIGZvbGxvdyB0aGUgaW5uZXJPcmRlclxuICBzZXNzaW9uLm1lZGlhLmZvckVhY2goZnVuY3Rpb24gKG1MaW5lKSB7XG4gICAgc2RwLnB1c2gobWFrZUxpbmUoJ20nLCBncmFtbWFyLm1bMF0sIG1MaW5lKSk7XG4gICAgaW5uZXJPcmRlci5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBncmFtbWFyW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAob2JqLm5hbWUgaW4gbUxpbmUgJiYgbUxpbmVbb2JqLm5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIG1MaW5lKSk7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqLnB1c2ggaW4gbUxpbmUgJiYgbUxpbmVbb2JqLnB1c2hdICE9IG51bGwpIHtcbiAgICAgICAgICBtTGluZVtvYmoucHVzaF0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgZWwpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gc2RwLmpvaW4oJ1xcclxcbicpICsgJ1xcclxcbic7XG59O1xuXG52YXIgcGFyc2VyID0gcGFyc2VyJDE7XG52YXIgd3JpdGVyID0gd3JpdGVyJDE7XG52YXIgd3JpdGUgPSB3cml0ZXI7XG52YXIgcGFyc2UgPSBwYXJzZXIucGFyc2U7XG5wYXJzZXIucGFyc2VQYXJhbXM7XG5wYXJzZXIucGFyc2VGbXRwQ29uZmlnOyAvLyBBbGlhcyBvZiBwYXJzZVBhcmFtcygpLlxucGFyc2VyLnBhcnNlUGF5bG9hZHM7XG5wYXJzZXIucGFyc2VSZW1vdGVDYW5kaWRhdGVzO1xucGFyc2VyLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzO1xucGFyc2VyLnBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdDtcblxuLyogVGhlIHN2YyBjb2RlYyAoYXYxL3ZwOSkgd291bGQgdXNlIGEgdmVyeSBsb3cgYml0cmF0ZSBhdCB0aGUgYmVnaW5pbmcgYW5kXG5pbmNyZWFzZSBzbG93bHkgYnkgdGhlIGJhbmR3aWR0aCBlc3RpbWF0b3IgdW50aWwgaXQgcmVhY2ggdGhlIHRhcmdldCBiaXRyYXRlLiBUaGVcbnByb2Nlc3MgY29tbW9ubHkgY29zdCBtb3JlIHRoYW4gMTAgc2Vjb25kcyBjYXVzZSBzdWJzY3JpYmVyIHdpbGwgZ2V0IGJsdXIgdmlkZW8gYXRcbnRoZSBmaXJzdCBmZXcgc2Vjb25kcy4gU28gd2UgdXNlIGEgNzAlIG9mIHRhcmdldCBiaXRyYXRlIGhlcmUgYXMgdGhlIHN0YXJ0IGJpdHJhdGUgdG9cbmVsaW1pbmF0ZSB0aGlzIGlzc3VlLlxuKi9cbmNvbnN0IHN0YXJ0Qml0cmF0ZUZvclNWQyA9IDAuNztcbmNvbnN0IFBDRXZlbnRzID0ge1xuICBOZWdvdGlhdGlvblN0YXJ0ZWQ6ICduZWdvdGlhdGlvblN0YXJ0ZWQnLFxuICBOZWdvdGlhdGlvbkNvbXBsZXRlOiAnbmVnb3RpYXRpb25Db21wbGV0ZScsXG4gIFJUUFZpZGVvUGF5bG9hZFR5cGVzOiAncnRwVmlkZW9QYXlsb2FkVHlwZXMnXG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgUENUcmFuc3BvcnQgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGdldCBwYygpIHtcbiAgICBpZiAoIXRoaXMuX3BjKSB7XG4gICAgICB0aGlzLl9wYyA9IHRoaXMuY3JlYXRlUEMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BjO1xuICB9XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGxldCBtZWRpYUNvbnN0cmFpbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xuICAgIHRoaXMucGVuZGluZ0NhbmRpZGF0ZXMgPSBbXTtcbiAgICB0aGlzLnJlc3RhcnRpbmdJY2UgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmVnb3RpYXRlID0gZmFsc2U7XG4gICAgdGhpcy50cmFja0JpdHJhdGVzID0gW107XG4gICAgdGhpcy5yZW1vdGVTdGVyZW9NaWRzID0gW107XG4gICAgdGhpcy5yZW1vdGVOYWNrTWlkcyA9IFtdO1xuICAgIC8vIGRlYm91bmNlZCBuZWdvdGlhdGUgaW50ZXJmYWNlXG4gICAgdGhpcy5uZWdvdGlhdGUgPSByKG9uRXJyb3IgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5lbWl0KFBDRXZlbnRzLk5lZ290aWF0aW9uU3RhcnRlZCk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCB0aGlzLmNyZWF0ZUFuZFNlbmRPZmZlcigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLCAxMDApO1xuICAgIHRoaXMuY2xvc2UgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3BjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BjLmNsb3NlKCk7XG4gICAgICB0aGlzLl9wYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9uZGF0YWNoYW5uZWwgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25uZWdvdGlhdGlvbm5lZWRlZCA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9uaWNlY2FuZGlkYXRlID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9uZGF0YWNoYW5uZWwgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub250cmFjayA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYyA9IG51bGw7XG4gICAgfTtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSBsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlBDVHJhbnNwb3J0KTtcbiAgICB0aGlzLmxvZ2dlck9wdGlvbnMgPSBsb2dnZXJPcHRpb25zO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMubWVkaWFDb25zdHJhaW50cyA9IG1lZGlhQ29uc3RyYWludHM7XG4gICAgdGhpcy5fcGMgPSB0aGlzLmNyZWF0ZVBDKCk7XG4gIH1cbiAgY3JlYXRlUEMoKSB7XG4gICAgY29uc3QgcGMgPSBpc0Nocm9taXVtQmFzZWQoKSA/XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBjaHJvbWUgYWxsb3dzIGFkZGl0aW9uYWwgbWVkaWEgY29uc3RyYWludHMgdG8gYmUgcGFzc2VkIGludG8gdGhlIFJUQ1BlZXJDb25uZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHRoaXMuY29uZmlnLCB0aGlzLm1lZGlhQ29uc3RyYWludHMpIDogbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHRoaXMuY29uZmlnKTtcbiAgICBwYy5vbmljZWNhbmRpZGF0ZSA9IGV2ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghZXYuY2FuZGlkYXRlKSByZXR1cm47XG4gICAgICAoX2EgPSB0aGlzLm9uSWNlQ2FuZGlkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBldi5jYW5kaWRhdGUpO1xuICAgIH07XG4gICAgcGMub25pY2VjYW5kaWRhdGVlcnJvciA9IGV2ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25JY2VDYW5kaWRhdGVFcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xuICAgIH07XG4gICAgcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBwYy5pY2VDb25uZWN0aW9uU3RhdGUpO1xuICAgIH07XG4gICAgcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25TaWduYWxpbmdTdGF0ZWNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgcGMuc2lnbmFsaW5nU3RhdGUpO1xuICAgIH07XG4gICAgcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBwYy5jb25uZWN0aW9uU3RhdGUpO1xuICAgIH07XG4gICAgcGMub25kYXRhY2hhbm5lbCA9IGV2ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25EYXRhQ2hhbm5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xuICAgIH07XG4gICAgcGMub250cmFjayA9IGV2ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25UcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xuICAgIH07XG4gICAgcmV0dXJuIHBjO1xuICB9XG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIChfYiA9IChfYSA9IHRoaXMubG9nZ2VyT3B0aW9ucykubG9nZ2VyQ29udGV4dENiKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICB9XG4gIGdldCBpc0lDRUNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGMgIT09IG51bGwgJiYgKHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJyB8fCB0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpO1xuICB9XG4gIGFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMucGMucmVtb3RlRGVzY3JpcHRpb24gJiYgIXRoaXMucmVzdGFydGluZ0ljZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYy5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ0NhbmRpZGF0ZXMucHVzaChjYW5kaWRhdGUpO1xuICAgIH0pO1xuICB9XG4gIHNldFJlbW90ZURlc2NyaXB0aW9uKHNkKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsZXQgbXVuZ2VkU0RQID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHNkLnR5cGUgPT09ICdvZmZlcicpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBzdGVyZW9NaWRzLFxuICAgICAgICAgIG5hY2tNaWRzXG4gICAgICAgIH0gPSBleHRyYWN0U3RlcmVvQW5kTmFja0F1ZGlvRnJvbU9mZmVyKHNkKTtcbiAgICAgICAgdGhpcy5yZW1vdGVTdGVyZW9NaWRzID0gc3RlcmVvTWlkcztcbiAgICAgICAgdGhpcy5yZW1vdGVOYWNrTWlkcyA9IG5hY2tNaWRzO1xuICAgICAgfSBlbHNlIGlmIChzZC50eXBlID09PSAnYW5zd2VyJykge1xuICAgICAgICBjb25zdCBzZHBQYXJzZWQgPSBwYXJzZSgoX2EgPSBzZC5zZHApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgICAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2gobWVkaWEgPT4ge1xuICAgICAgICAgIGlmIChtZWRpYS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICAvLyBtdW5nIHNkcCBmb3Igb3B1cyBiaXRyYXRlIHNldHRpbmdzXG4gICAgICAgICAgICB0aGlzLnRyYWNrQml0cmF0ZXMuc29tZSh0cmFja2JyID0+IHtcbiAgICAgICAgICAgICAgaWYgKCF0cmFja2JyLnRyYW5zY2VpdmVyIHx8IG1lZGlhLm1pZCAhPSB0cmFja2JyLnRyYW5zY2VpdmVyLm1pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgY29kZWNQYXlsb2FkID0gMDtcbiAgICAgICAgICAgICAgbWVkaWEucnRwLnNvbWUocnRwID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocnRwLmNvZGVjLnRvVXBwZXJDYXNlKCkgPT09IHRyYWNrYnIuY29kZWMudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgY29kZWNQYXlsb2FkID0gcnRwLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGNvZGVjUGF5bG9hZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBmbXRwRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBmbXRwIG9mIG1lZGlhLmZtdHApIHtcbiAgICAgICAgICAgICAgICBpZiAoZm10cC5wYXlsb2FkID09PSBjb2RlY1BheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnID0gZm10cC5jb25maWcuc3BsaXQoJzsnKS5maWx0ZXIoYXR0ciA9PiAhYXR0ci5pbmNsdWRlcygnbWF4YXZlcmFnZWJpdHJhdGUnKSkuam9pbignOycpO1xuICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrYnIubWF4YnIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IFwiO21heGF2ZXJhZ2ViaXRyYXRlPVwiLmNvbmNhdCh0cmFja2JyLm1heGJyICogMTAwMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmbXRwRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZm10cEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrYnIubWF4YnIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBtZWRpYS5mbXRwLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBjb2RlY1BheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzogXCJtYXhhdmVyYWdlYml0cmF0ZT1cIi5jb25jYXQodHJhY2tici5tYXhiciAqIDEwMDApXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtdW5nZWRTRFAgPSB3cml0ZShzZHBQYXJzZWQpO1xuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5zZXRNdW5nZWRTRFAoc2QsIG11bmdlZFNEUCwgdHJ1ZSk7XG4gICAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzLmZvckVhY2goY2FuZGlkYXRlID0+IHtcbiAgICAgICAgdGhpcy5wYy5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wZW5kaW5nQ2FuZGlkYXRlcyA9IFtdO1xuICAgICAgdGhpcy5yZXN0YXJ0aW5nSWNlID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5yZW5lZ290aWF0ZSkge1xuICAgICAgICB0aGlzLnJlbmVnb3RpYXRlID0gZmFsc2U7XG4gICAgICAgIHlpZWxkIHRoaXMuY3JlYXRlQW5kU2VuZE9mZmVyKCk7XG4gICAgICB9IGVsc2UgaWYgKHNkLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICAgIHRoaXMuZW1pdChQQ0V2ZW50cy5OZWdvdGlhdGlvbkNvbXBsZXRlKTtcbiAgICAgICAgaWYgKHNkLnNkcCkge1xuICAgICAgICAgIGNvbnN0IHNkcFBhcnNlZCA9IHBhcnNlKHNkLnNkcCk7XG4gICAgICAgICAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2gobWVkaWEgPT4ge1xuICAgICAgICAgICAgaWYgKG1lZGlhLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KFBDRXZlbnRzLlJUUFZpZGVvUGF5bG9hZFR5cGVzLCBtZWRpYS5ydHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlQW5kU2VuZE9mZmVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLm9uT2ZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmljZVJlc3RhcnQpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3Jlc3RhcnRpbmcgSUNFJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgdGhpcy5yZXN0YXJ0aW5nSWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9wYyAmJiB0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2hhdmUtbG9jYWwtb2ZmZXInKSB7XG4gICAgICAgIC8vIHdlJ3JlIHdhaXRpbmcgZm9yIHRoZSBwZWVyIHRvIGFjY2VwdCBvdXIgb2ZmZXIsIHNvIHdlJ2xsIGp1c3Qgd2FpdFxuICAgICAgICAvLyB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyB3aGVuIElDRSByZXN0YXJ0IGlzIG5lZWRlZFxuICAgICAgICBjb25zdCBjdXJyZW50U0QgPSB0aGlzLl9wYy5yZW1vdGVEZXNjcmlwdGlvbjtcbiAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWNlUmVzdGFydCkgJiYgY3VycmVudFNEKSB7XG4gICAgICAgICAgLy8gVE9ETzogaGFuZGxlIHdoZW4gSUNFIHJlc3RhcnQgaXMgbmVlZGVkIGJ1dCB3ZSBkb24ndCBoYXZlIGEgcmVtb3RlIGRlc2NyaXB0aW9uXG4gICAgICAgICAgLy8gdGhlIGJlc3QgdGhpbmcgdG8gZG8gaXMgdG8gcmVjcmVhdGUgdGhlIHBlZXJjb25uZWN0aW9uXG4gICAgICAgICAgeWllbGQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oY3VycmVudFNEKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbmVnb3RpYXRlID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3BjIHx8IHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgY3JlYXRlT2ZmZXIgd2l0aCBjbG9zZWQgcGVlciBjb25uZWN0aW9uJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gYWN0dWFsbHkgbmVnb3RpYXRlXG4gICAgICB0aGlzLmxvZy5kZWJ1Zygnc3RhcnRpbmcgdG8gbmVnb3RpYXRlJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIGNvbnN0IG9mZmVyID0geWllbGQgdGhpcy5wYy5jcmVhdGVPZmZlcihvcHRpb25zKTtcbiAgICAgIGNvbnN0IHNkcFBhcnNlZCA9IHBhcnNlKChfYSA9IG9mZmVyLnNkcCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICAgICAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2gobWVkaWEgPT4ge1xuICAgICAgICBpZiAobWVkaWEudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgIGVuc3VyZUF1ZGlvTmFja0FuZFN0ZXJlbyhtZWRpYSwgW10sIFtdKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZWRpYS50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgZW5zdXJlVmlkZW9EREV4dGVuc2lvbkZvclNWQyhtZWRpYSk7XG4gICAgICAgICAgLy8gbXVuZyBzZHAgZm9yIGNvZGVjIGJpdHJhdGUgc2V0dGluZyB0aGF0IGNhbid0IGFwcGx5IGJ5IHNlbmRFbmNvZGluZ1xuICAgICAgICAgIHRoaXMudHJhY2tCaXRyYXRlcy5zb21lKHRyYWNrYnIgPT4ge1xuICAgICAgICAgICAgaWYgKCFtZWRpYS5tc2lkIHx8ICF0cmFja2JyLmNpZCB8fCAhbWVkaWEubXNpZC5pbmNsdWRlcyh0cmFja2JyLmNpZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvZGVjUGF5bG9hZCA9IDA7XG4gICAgICAgICAgICBtZWRpYS5ydHAuc29tZShydHAgPT4ge1xuICAgICAgICAgICAgICBpZiAocnRwLmNvZGVjLnRvVXBwZXJDYXNlKCkgPT09IHRyYWNrYnIuY29kZWMudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNvZGVjUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvZGVjUGF5bG9hZCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmbXRwRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZm10cCBvZiBtZWRpYS5mbXRwKSB7XG4gICAgICAgICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IGNvZGVjUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgIGlmICghZm10cC5jb25maWcuaW5jbHVkZXMoJ3gtZ29vZ2xlLXN0YXJ0LWJpdHJhdGUnKSkge1xuICAgICAgICAgICAgICAgICAgZm10cC5jb25maWcgKz0gXCI7eC1nb29nbGUtc3RhcnQtYml0cmF0ZT1cIi5jb25jYXQoTWF0aC5yb3VuZCh0cmFja2JyLm1heGJyICogc3RhcnRCaXRyYXRlRm9yU1ZDKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZm10cC5jb25maWcuaW5jbHVkZXMoJ3gtZ29vZ2xlLW1heC1iaXRyYXRlJykpIHtcbiAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IFwiO3gtZ29vZ2xlLW1heC1iaXRyYXRlPVwiLmNvbmNhdCh0cmFja2JyLm1heGJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm10cEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmbXRwRm91bmQpIHtcbiAgICAgICAgICAgICAgbWVkaWEuZm10cC5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBjb2RlY1BheWxvYWQsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBcIngtZ29vZ2xlLXN0YXJ0LWJpdHJhdGU9XCIuY29uY2F0KE1hdGgucm91bmQodHJhY2tici5tYXhiciAqIHN0YXJ0Qml0cmF0ZUZvclNWQyksIFwiO3gtZ29vZ2xlLW1heC1iaXRyYXRlPVwiKS5jb25jYXQodHJhY2tici5tYXhicilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB5aWVsZCB0aGlzLnNldE11bmdlZFNEUChvZmZlciwgd3JpdGUoc2RwUGFyc2VkKSk7XG4gICAgICB0aGlzLm9uT2ZmZXIob2ZmZXIpO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUFuZFNldEFuc3dlcigpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGFuc3dlciA9IHlpZWxkIHRoaXMucGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICBjb25zdCBzZHBQYXJzZWQgPSBwYXJzZSgoX2EgPSBhbnN3ZXIuc2RwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaChtZWRpYSA9PiB7XG4gICAgICAgIGlmIChtZWRpYS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgZW5zdXJlQXVkaW9OYWNrQW5kU3RlcmVvKG1lZGlhLCB0aGlzLnJlbW90ZVN0ZXJlb01pZHMsIHRoaXMucmVtb3RlTmFja01pZHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuc2V0TXVuZ2VkU0RQKGFuc3dlciwgd3JpdGUoc2RwUGFyc2VkKSk7XG4gICAgICByZXR1cm4gYW5zd2VyO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBkYXRhQ2hhbm5lbERpY3QpIHtcbiAgICByZXR1cm4gdGhpcy5wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KTtcbiAgfVxuICBhZGRUcmFuc2NlaXZlcihtZWRpYVN0cmVhbVRyYWNrLCB0cmFuc2NlaXZlckluaXQpIHtcbiAgICByZXR1cm4gdGhpcy5wYy5hZGRUcmFuc2NlaXZlcihtZWRpYVN0cmVhbVRyYWNrLCB0cmFuc2NlaXZlckluaXQpO1xuICB9XG4gIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIGNsb3NlZCwgY2Fubm90IGFkZCB0cmFjaycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGMuYWRkVHJhY2sodHJhY2spO1xuICB9XG4gIHNldFRyYWNrQ29kZWNCaXRyYXRlKGluZm8pIHtcbiAgICB0aGlzLnRyYWNrQml0cmF0ZXMucHVzaChpbmZvKTtcbiAgfVxuICBzZXRDb25maWd1cmF0aW9uKHJ0Y0NvbmZpZykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXRoaXMuX3BjKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgY2xvc2VkLCBjYW5ub3QgY29uZmlndXJlJyk7XG4gICAgfVxuICAgIHJldHVybiAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldENvbmZpZ3VyYXRpb24ocnRjQ29uZmlnKTtcbiAgfVxuICBjYW5SZW1vdmVUcmFjaygpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICEhKChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlVHJhY2spO1xuICB9XG4gIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICB9XG4gIGdldENvbm5lY3Rpb25TdGF0ZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbm5lY3Rpb25TdGF0ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2Nsb3NlZCc7XG4gIH1cbiAgZ2V0SUNFQ29ubmVjdGlvblN0YXRlKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWNlQ29ubmVjdGlvblN0YXRlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnY2xvc2VkJztcbiAgfVxuICBnZXRTaWduYWxsaW5nU3RhdGUoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaWduYWxpbmdTdGF0ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2Nsb3NlZCc7XG4gIH1cbiAgZ2V0VHJhbnNjZWl2ZXJzKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0VHJhbnNjZWl2ZXJzKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICB9XG4gIGdldFNlbmRlcnMoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTZW5kZXJzKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICB9XG4gIGdldExvY2FsRGVzY3JpcHRpb24oKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsRGVzY3JpcHRpb247XG4gIH1cbiAgZ2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnBjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3RlRGVzY3JpcHRpb247XG4gIH1cbiAgZ2V0U3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGMuZ2V0U3RhdHMoKTtcbiAgfVxuICBnZXRDb25uZWN0ZWRBZGRyZXNzKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSAnJztcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZVBhaXJzID0gbmV3IE1hcCgpO1xuICAgICAgLy8gaWQgLT4gY2FuZGlkYXRlIGlwXG4gICAgICBjb25zdCBjYW5kaWRhdGVzID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLl9wYy5nZXRTdGF0cygpO1xuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgc3dpdGNoICh2LnR5cGUpIHtcbiAgICAgICAgICBjYXNlICd0cmFuc3BvcnQnOlxuICAgICAgICAgICAgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSB2LnNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY2FuZGlkYXRlLXBhaXInOlxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID09PSAnJyAmJiB2LnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID0gdi5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbmRpZGF0ZVBhaXJzLnNldCh2LmlkLCB2KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JlbW90ZS1jYW5kaWRhdGUnOlxuICAgICAgICAgICAgY2FuZGlkYXRlcy5zZXQodi5pZCwgXCJcIi5jb25jYXQodi5hZGRyZXNzLCBcIjpcIikuY29uY2F0KHYucG9ydCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID09PSAnJykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0ZWRJRCA9IChfYSA9IGNhbmRpZGF0ZVBhaXJzLmdldChzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdGVDYW5kaWRhdGVJZDtcbiAgICAgIGlmIChzZWxlY3RlZElEID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYW5kaWRhdGVzLmdldChzZWxlY3RlZElEKTtcbiAgICB9KTtcbiAgfVxuICBzZXRNdW5nZWRTRFAoc2QsIG11bmdlZCwgcmVtb3RlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChtdW5nZWQpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTZHAgPSBzZC5zZHA7XG4gICAgICAgIHNkLnNkcCA9IG11bmdlZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInNldHRpbmcgbXVuZ2VkIFwiLmNvbmNhdChyZW1vdGUgPyAncmVtb3RlJyA6ICdsb2NhbCcsIFwiIGRlc2NyaXB0aW9uXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIGlmIChyZW1vdGUpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldExvY2FsRGVzY3JpcHRpb24oc2QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKFwibm90IGFibGUgdG8gc2V0IFwiLmNvbmNhdChzZC50eXBlLCBcIiwgZmFsbGluZyBiYWNrIHRvIHVubW9kaWZpZWQgc2RwXCIpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgc2RwOiBtdW5nZWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgc2Quc2RwID0gb3JpZ2luYWxTZHA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChyZW1vdGUpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldExvY2FsRGVzY3JpcHRpb24oc2QpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHRoaXMgZXJyb3IgY2Fubm90IGFsd2F5cyBiZSBjYXVnaHQuXG4gICAgICAgIC8vIElmIHRoZSBsb2NhbCBkZXNjcmlwdGlvbiBoYXMgYSBzZXRDb2RlY1ByZWZlcmVuY2VzIGVycm9yLCB0aGlzIGVycm9yIHdpbGwgYmUgdW5jYXVnaHRcbiAgICAgICAgbGV0IG1zZyA9ICd1bmtub3duIGVycm9yJztcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIG1zZyA9IGUubWVzc2FnZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBtc2cgPSBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHtcbiAgICAgICAgICBlcnJvcjogbXNnLFxuICAgICAgICAgIHNkcDogc2Quc2RwXG4gICAgICAgIH07XG4gICAgICAgIGlmICghcmVtb3RlICYmIHRoaXMucGMucmVtb3RlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICBmaWVsZHMucmVtb3RlU2RwID0gdGhpcy5wYy5yZW1vdGVEZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZy5lcnJvcihcInVuYWJsZSB0byBzZXQgXCIuY29uY2F0KHNkLnR5cGUpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBmaWVsZHNcbiAgICAgICAgfSkpO1xuICAgICAgICB0aHJvdyBuZXcgTmVnb3RpYXRpb25FcnJvcihtc2cpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBlbnN1cmVBdWRpb05hY2tBbmRTdGVyZW8obWVkaWEsIHN0ZXJlb01pZHMsIG5hY2tNaWRzKSB7XG4gIC8vIGZvdW5kIG9wdXMgY29kZWMgdG8gYWRkIG5hY2sgZmJcbiAgbGV0IG9wdXNQYXlsb2FkID0gMDtcbiAgbWVkaWEucnRwLnNvbWUocnRwID0+IHtcbiAgICBpZiAocnRwLmNvZGVjID09PSAnb3B1cycpIHtcbiAgICAgIG9wdXNQYXlsb2FkID0gcnRwLnBheWxvYWQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbiAgLy8gYWRkIG5hY2sgcnRjcGZiIGlmIG5vdCBleGlzdFxuICBpZiAob3B1c1BheWxvYWQgPiAwKSB7XG4gICAgaWYgKCFtZWRpYS5ydGNwRmIpIHtcbiAgICAgIG1lZGlhLnJ0Y3BGYiA9IFtdO1xuICAgIH1cbiAgICBpZiAobmFja01pZHMuaW5jbHVkZXMobWVkaWEubWlkKSAmJiAhbWVkaWEucnRjcEZiLnNvbWUoZmIgPT4gZmIucGF5bG9hZCA9PT0gb3B1c1BheWxvYWQgJiYgZmIudHlwZSA9PT0gJ25hY2snKSkge1xuICAgICAgbWVkaWEucnRjcEZiLnB1c2goe1xuICAgICAgICBwYXlsb2FkOiBvcHVzUGF5bG9hZCxcbiAgICAgICAgdHlwZTogJ25hY2snXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0ZXJlb01pZHMuaW5jbHVkZXMobWVkaWEubWlkKSkge1xuICAgICAgbWVkaWEuZm10cC5zb21lKGZtdHAgPT4ge1xuICAgICAgICBpZiAoZm10cC5wYXlsb2FkID09PSBvcHVzUGF5bG9hZCkge1xuICAgICAgICAgIGlmICghZm10cC5jb25maWcuaW5jbHVkZXMoJ3N0ZXJlbz0xJykpIHtcbiAgICAgICAgICAgIGZtdHAuY29uZmlnICs9ICc7c3RlcmVvPTEnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVuc3VyZVZpZGVvRERFeHRlbnNpb25Gb3JTVkMobWVkaWEpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICBjb25zdCBjb2RlYyA9IChfYiA9IChfYSA9IG1lZGlhLnJ0cFswXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGVjKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCFpc1NWQ0NvZGVjKGNvZGVjKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbWF4SUQgPSAwO1xuICBjb25zdCBkZEZvdW5kID0gKF9jID0gbWVkaWEuZXh0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc29tZShleHQgPT4ge1xuICAgIGlmIChleHQudXJpID09PSBkZEV4dGVuc2lvblVSSSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChleHQudmFsdWUgPiBtYXhJRCkge1xuICAgICAgbWF4SUQgPSBleHQudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG4gIGlmICghZGRGb3VuZCkge1xuICAgIChfZCA9IG1lZGlhLmV4dCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnB1c2goe1xuICAgICAgdmFsdWU6IG1heElEICsgMSxcbiAgICAgIHVyaTogZGRFeHRlbnNpb25VUklcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZXh0cmFjdFN0ZXJlb0FuZE5hY2tBdWRpb0Zyb21PZmZlcihvZmZlcikge1xuICB2YXIgX2E7XG4gIGNvbnN0IHN0ZXJlb01pZHMgPSBbXTtcbiAgY29uc3QgbmFja01pZHMgPSBbXTtcbiAgY29uc3Qgc2RwUGFyc2VkID0gcGFyc2UoKF9hID0gb2ZmZXIuc2RwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gIGxldCBvcHVzUGF5bG9hZCA9IDA7XG4gIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKG1lZGlhID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIG1lZGlhLnJ0cC5zb21lKHJ0cCA9PiB7XG4gICAgICAgIGlmIChydHAuY29kZWMgPT09ICdvcHVzJykge1xuICAgICAgICAgIG9wdXNQYXlsb2FkID0gcnRwLnBheWxvYWQ7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgICBpZiAoKF9hID0gbWVkaWEucnRjcEZiKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZShmYiA9PiBmYi5wYXlsb2FkID09PSBvcHVzUGF5bG9hZCAmJiBmYi50eXBlID09PSAnbmFjaycpKSB7XG4gICAgICAgIG5hY2tNaWRzLnB1c2gobWVkaWEubWlkKTtcbiAgICAgIH1cbiAgICAgIG1lZGlhLmZtdHAuc29tZShmbXRwID0+IHtcbiAgICAgICAgaWYgKGZtdHAucGF5bG9hZCA9PT0gb3B1c1BheWxvYWQpIHtcbiAgICAgICAgICBpZiAoZm10cC5jb25maWcuaW5jbHVkZXMoJ3Nwcm9wLXN0ZXJlbz0xJykpIHtcbiAgICAgICAgICAgIHN0ZXJlb01pZHMucHVzaChtZWRpYS5taWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHN0ZXJlb01pZHMsXG4gICAgbmFja01pZHNcbiAgfTtcbn1cblxuY29uc3QgZGVmYXVsdFZpZGVvQ29kZWMgPSAndnA4JztcbmNvbnN0IHB1Ymxpc2hEZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhdWRpb0JpdHJhdGU6IEF1ZGlvUHJlc2V0cy5tdXNpYy5tYXhCaXRyYXRlLFxuICBhdWRpb1ByZXNldDogQXVkaW9QcmVzZXRzLm11c2ljLFxuICBkdHg6IHRydWUsXG4gIHJlZDogdHJ1ZSxcbiAgZm9yY2VTdGVyZW86IGZhbHNlLFxuICBzaW11bGNhc3Q6IHRydWUsXG4gIHNjcmVlblNoYXJlRW5jb2Rpbmc6IFNjcmVlblNoYXJlUHJlc2V0cy5oMTA4MGZwczE1LmVuY29kaW5nLFxuICBzdG9wTWljVHJhY2tPbk11dGU6IGZhbHNlLFxuICB2aWRlb0NvZGVjOiBkZWZhdWx0VmlkZW9Db2RlYyxcbiAgYmFja3VwQ29kZWM6IHRydWVcbn07XG5jb25zdCBhdWRpb0RlZmF1bHRzID0ge1xuICBhdXRvR2FpbkNvbnRyb2w6IHRydWUsXG4gIGVjaG9DYW5jZWxsYXRpb246IHRydWUsXG4gIG5vaXNlU3VwcHJlc3Npb246IHRydWVcbn07XG5jb25zdCB2aWRlb0RlZmF1bHRzID0ge1xuICByZXNvbHV0aW9uOiBWaWRlb1ByZXNldHMuaDcyMC5yZXNvbHV0aW9uXG59O1xuY29uc3Qgcm9vbU9wdGlvbkRlZmF1bHRzID0ge1xuICBhZGFwdGl2ZVN0cmVhbTogZmFsc2UsXG4gIGR5bmFjYXN0OiBmYWxzZSxcbiAgc3RvcExvY2FsVHJhY2tPblVucHVibGlzaDogdHJ1ZSxcbiAgcmVjb25uZWN0UG9saWN5OiBuZXcgRGVmYXVsdFJlY29ubmVjdFBvbGljeSgpLFxuICBkaXNjb25uZWN0T25QYWdlTGVhdmU6IHRydWUsXG4gIGV4cFdlYkF1ZGlvTWl4OiBmYWxzZVxufTtcbmNvbnN0IHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMgPSB7XG4gIGF1dG9TdWJzY3JpYmU6IHRydWUsXG4gIG1heFJldHJpZXM6IDEsXG4gIHBlZXJDb25uZWN0aW9uVGltZW91dDogMTUwMDAsXG4gIHdlYnNvY2tldFRpbWVvdXQ6IDE1MDAwXG59O1xuXG52YXIgUENUcmFuc3BvcnRTdGF0ZTtcbihmdW5jdGlvbiAoUENUcmFuc3BvcnRTdGF0ZSkge1xuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJORVdcIl0gPSAwXSA9IFwiTkVXXCI7XG4gIFBDVHJhbnNwb3J0U3RhdGVbUENUcmFuc3BvcnRTdGF0ZVtcIkNPTk5FQ1RJTkdcIl0gPSAxXSA9IFwiQ09OTkVDVElOR1wiO1xuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJDT05ORUNURURcIl0gPSAyXSA9IFwiQ09OTkVDVEVEXCI7XG4gIFBDVHJhbnNwb3J0U3RhdGVbUENUcmFuc3BvcnRTdGF0ZVtcIkZBSUxFRFwiXSA9IDNdID0gXCJGQUlMRURcIjtcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiQ0xPU0lOR1wiXSA9IDRdID0gXCJDTE9TSU5HXCI7XG4gIFBDVHJhbnNwb3J0U3RhdGVbUENUcmFuc3BvcnRTdGF0ZVtcIkNMT1NFRFwiXSA9IDVdID0gXCJDTE9TRURcIjtcbn0pKFBDVHJhbnNwb3J0U3RhdGUgfHwgKFBDVHJhbnNwb3J0U3RhdGUgPSB7fSkpO1xuY2xhc3MgUENUcmFuc3BvcnRNYW5hZ2VyIHtcbiAgZ2V0IG5lZWRzUHVibGlzaGVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkO1xuICB9XG4gIGdldCBuZWVkc1N1YnNjcmliZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTdWJzY3JpYmVyQ29ubmVjdGlvblJlcXVpcmVkO1xuICB9XG4gIGdldCBjdXJyZW50U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH1cbiAgY29uc3RydWN0b3IocnRjQ29uZmlnLCBzdWJzY3JpYmVyUHJpbWFyeSwgbG9nZ2VyT3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dCA9IHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMucGVlckNvbm5lY3Rpb25UaW1lb3V0O1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBjb25uZWN0aW9uU3RhdGVzID0gdGhpcy5yZXF1aXJlZFRyYW5zcG9ydHMubWFwKHRyID0+IHRyLmdldENvbm5lY3Rpb25TdGF0ZSgpKTtcbiAgICAgIGlmIChjb25uZWN0aW9uU3RhdGVzLmV2ZXJ5KHN0ID0+IHN0ID09PSAnY29ubmVjdGVkJykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVEVEO1xuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLnNvbWUoc3QgPT4gc3QgPT09ICdmYWlsZWQnKSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5GQUlMRUQ7XG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0ZXMuc29tZShzdCA9PiBzdCA9PT0gJ2Nvbm5lY3RpbmcnKSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5DT05ORUNUSU5HO1xuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLmV2ZXJ5KHN0ID0+IHN0ID09PSAnY2xvc2VkJykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ0xPU0VEO1xuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLnNvbWUoc3QgPT4gc3QgPT09ICdjbG9zZWQnKSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5DTE9TSU5HO1xuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLmV2ZXJ5KHN0ID0+IHN0ID09PSAnbmV3JykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuTkVXO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IHRoaXMuc3RhdGUpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJwYyBzdGF0ZSBjaGFuZ2U6IGZyb20gXCIuY29uY2F0KFBDVHJhbnNwb3J0U3RhdGVbcHJldmlvdXNTdGF0ZV0sIFwiIHRvIFwiKS5jb25jYXQoUENUcmFuc3BvcnRTdGF0ZVt0aGlzLnN0YXRlXSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIChfYSA9IHRoaXMub25TdGF0ZUNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgdGhpcy5zdGF0ZSwgdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGlvblN0YXRlKCksIHRoaXMuc3Vic2NyaWJlci5nZXRDb25uZWN0aW9uU3RhdGUoKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSBsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlBDTWFuYWdlcik7XG4gICAgdGhpcy5sb2dnZXJPcHRpb25zID0gbG9nZ2VyT3B0aW9ucztcbiAgICB0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkID0gIXN1YnNjcmliZXJQcmltYXJ5O1xuICAgIHRoaXMuaXNTdWJzY3JpYmVyQ29ubmVjdGlvblJlcXVpcmVkID0gc3Vic2NyaWJlclByaW1hcnk7XG4gICAgY29uc3QgZ29vZ0NvbnN0cmFpbnRzID0ge1xuICAgICAgb3B0aW9uYWw6IFt7XG4gICAgICAgIGdvb2dEc2NwOiB0cnVlXG4gICAgICB9XVxuICAgIH07XG4gICAgdGhpcy5wdWJsaXNoZXIgPSBuZXcgUENUcmFuc3BvcnQocnRjQ29uZmlnLCBnb29nQ29uc3RyYWludHMsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuc3Vic2NyaWJlciA9IG5ldyBQQ1RyYW5zcG9ydChydGNDb25maWcsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMucHVibGlzaGVyLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnN1YnNjcmliZXIub25Db25uZWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMucHVibGlzaGVyLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnN1YnNjcmliZXIub25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMucHVibGlzaGVyLm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMuc3Vic2NyaWJlci5vblNpZ25hbGluZ1N0YXRlY2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnB1Ymxpc2hlci5vbkljZUNhbmRpZGF0ZSA9IGNhbmRpZGF0ZSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uSWNlQ2FuZGlkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBjYW5kaWRhdGUsIFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpO1xuICAgIH07XG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uSWNlQ2FuZGlkYXRlID0gY2FuZGlkYXRlID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25JY2VDYW5kaWRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGNhbmRpZGF0ZSwgU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpO1xuICAgIH07XG4gICAgLy8gaW4gc3Vic2NyaWJlciBwcmltYXJ5IG1vZGUsIHNlcnZlciBzaWRlIG9wZW5zIHN1YiBkYXRhIGNoYW5uZWxzLlxuICAgIHRoaXMuc3Vic2NyaWJlci5vbkRhdGFDaGFubmVsID0gZXYgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vbkRhdGFDaGFubmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBldik7XG4gICAgfTtcbiAgICB0aGlzLnN1YnNjcmliZXIub25UcmFjayA9IGV2ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25UcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xuICAgIH07XG4gICAgdGhpcy5wdWJsaXNoZXIub25PZmZlciA9IG9mZmVyID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25QdWJsaXNoZXJPZmZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgb2ZmZXIpO1xuICAgIH07XG4gICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuTkVXO1xuICAgIHRoaXMuY29ubmVjdGlvbkxvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgfVxuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAoX2IgPSAoX2EgPSB0aGlzLmxvZ2dlck9wdGlvbnMpLmxvZ2dlckNvbnRleHRDYikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcbiAgfVxuICByZXF1aXJlUHVibGlzaGVyKCkge1xuICAgIGxldCByZXF1aXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgIHRoaXMuaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQgPSByZXF1aXJlO1xuICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgfVxuICByZXF1aXJlU3Vic2NyaWJlcigpIHtcbiAgICBsZXQgcmVxdWlyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICB0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZCA9IHJlcXVpcmU7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICB9XG4gIGNyZWF0ZUFuZFNlbmRQdWJsaXNoZXJPZmZlcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmNyZWF0ZUFuZFNlbmRPZmZlcihvcHRpb25zKTtcbiAgfVxuICBzZXRQdWJsaXNoZXJBbnN3ZXIoc2QpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xuICB9XG4gIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5wdWJsaXNoZXIgJiYgdGhpcy5wdWJsaXNoZXIuZ2V0U2lnbmFsbGluZ1N0YXRlKCkgIT09ICdjbG9zZWQnKSB7XG4gICAgICAgIGNvbnN0IHB1Ymxpc2hlciA9IHRoaXMucHVibGlzaGVyO1xuICAgICAgICBmb3IgKGNvbnN0IHNlbmRlciBvZiBwdWJsaXNoZXIuZ2V0U2VuZGVycygpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlYWN0LW5hdGl2ZS13ZWJydGMgZG9lc24ndCBoYXZlIHJlbW92ZVRyYWNrIHlldC5cbiAgICAgICAgICAgIGlmIChwdWJsaXNoZXIuY2FuUmVtb3ZlVHJhY2soKSkge1xuICAgICAgICAgICAgICBwdWJsaXNoZXIucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgcmVtb3ZlVHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHlpZWxkIFByb21pc2UuYWxsKFt0aGlzLnB1Ymxpc2hlci5jbG9zZSgpLCB0aGlzLnN1YnNjcmliZXIuY2xvc2UoKV0pO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICAgIH0pO1xuICB9XG4gIHRyaWdnZXJJY2VSZXN0YXJ0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLnN1YnNjcmliZXIucmVzdGFydGluZ0ljZSA9IHRydWU7XG4gICAgICAvLyBvbmx5IHJlc3RhcnQgcHVibGlzaGVyIGlmIGl0J3MgbmVlZGVkXG4gICAgICBpZiAodGhpcy5uZWVkc1B1Ymxpc2hlcikge1xuICAgICAgICB5aWVsZCB0aGlzLmNyZWF0ZUFuZFNlbmRQdWJsaXNoZXJPZmZlcih7XG4gICAgICAgICAgaWNlUmVzdGFydDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRhcmdldCA9PT0gU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUikge1xuICAgICAgICB5aWVsZCB0aGlzLnB1Ymxpc2hlci5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIHRoaXMuc3Vic2NyaWJlci5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjcmVhdGVTdWJzY3JpYmVyQW5zd2VyRnJvbU9mZmVyKHNkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCBzZXJ2ZXIgb2ZmZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgUlRDU2RwVHlwZTogc2QudHlwZSxcbiAgICAgICAgc2RwOiBzZC5zZHAsXG4gICAgICAgIHNpZ25hbGluZ1N0YXRlOiB0aGlzLnN1YnNjcmliZXIuZ2V0U2lnbmFsbGluZ1N0YXRlKCkudG9TdHJpbmcoKVxuICAgICAgfSkpO1xuICAgICAgeWllbGQgdGhpcy5zdWJzY3JpYmVyLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkKTtcbiAgICAgIC8vIGFuc3dlciB0aGUgb2ZmZXJcbiAgICAgIGNvbnN0IGFuc3dlciA9IHlpZWxkIHRoaXMuc3Vic2NyaWJlci5jcmVhdGVBbmRTZXRBbnN3ZXIoKTtcbiAgICAgIHJldHVybiBhbnN3ZXI7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlQ29uZmlndXJhdGlvbihjb25maWcsIGljZVJlc3RhcnQpIHtcbiAgICB0aGlzLnB1Ymxpc2hlci5zZXRDb25maWd1cmF0aW9uKGNvbmZpZyk7XG4gICAgdGhpcy5zdWJzY3JpYmVyLnNldENvbmZpZ3VyYXRpb24oY29uZmlnKTtcbiAgICBpZiAoaWNlUmVzdGFydCkge1xuICAgICAgdGhpcy50cmlnZ2VySWNlUmVzdGFydCgpO1xuICAgIH1cbiAgfVxuICBlbnN1cmVQQ1RyYW5zcG9ydENvbm5lY3Rpb24oYWJvcnRDb250cm9sbGVyLCB0aW1lb3V0KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb25Mb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkICYmIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3Rpb25TdGF0ZSgpICE9PSAnY29ubmVjdGVkJyAmJiB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0aW9uU3RhdGUoKSAhPT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ25lZ290aWF0aW9uIHJlcXVpcmVkLCBzdGFydCBuZWdvdGlhdGluZycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgdGhpcy5wdWJsaXNoZXIubmVnb3RpYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoKF9hID0gdGhpcy5yZXF1aXJlZFRyYW5zcG9ydHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAodHJhbnNwb3J0ID0+IHRoaXMuZW5zdXJlVHJhbnNwb3J0Q29ubmVjdGVkKHRyYW5zcG9ydCwgYWJvcnRDb250cm9sbGVyLCB0aW1lb3V0KSkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbmVnb3RpYXRlKGFib3J0Q29udHJvbGxlcikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBuZWdvdGlhdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZWplY3QoJ25lZ290aWF0aW9uIHRpbWVkIG91dCcpO1xuICAgICAgICB9LCB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dCk7XG4gICAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQobmVnb3RpYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZWplY3QoJ25lZ290aWF0aW9uIGFib3J0ZWQnKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgIHRoaXMucHVibGlzaGVyLm9uY2UoUENFdmVudHMuTmVnb3RpYXRpb25TdGFydGVkLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnB1Ymxpc2hlci5vbmNlKFBDRXZlbnRzLk5lZ290aWF0aW9uQ29tcGxldGUsICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChuZWdvdGlhdGlvblRpbWVvdXQpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoZXIubmVnb3RpYXRlKGUgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dChuZWdvdGlhdGlvblRpbWVvdXQpO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXIodHJhY2ssIHRyYW5zY2VpdmVySW5pdCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5hZGRUcmFuc2NlaXZlcih0cmFjaywgdHJhbnNjZWl2ZXJJbml0KTtcbiAgfVxuICBhZGRQdWJsaXNoZXJUcmFjayh0cmFjaykge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5hZGRUcmFjayh0cmFjayk7XG4gIH1cbiAgY3JlYXRlUHVibGlzaGVyRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgcmVxdWlyZWQgdHJhbnNwb3J0J3MgYWRkcmVzcyBpZiBubyBleHBsaWNpdCB0YXJnZXQgaXMgc3BlY2lmaWVkXG4gICAqL1xuICBnZXRDb25uZWN0ZWRBZGRyZXNzKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQgPT09IFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0ZWRBZGRyZXNzKCk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQgPT09IFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGVkQWRkcmVzcygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXF1aXJlZFRyYW5zcG9ydHNbMF0uZ2V0Q29ubmVjdGVkQWRkcmVzcygpO1xuICB9XG4gIGdldCByZXF1aXJlZFRyYW5zcG9ydHMoKSB7XG4gICAgY29uc3QgdHJhbnNwb3J0cyA9IFtdO1xuICAgIGlmICh0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkKSB7XG4gICAgICB0cmFuc3BvcnRzLnB1c2godGhpcy5wdWJsaXNoZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQpIHtcbiAgICAgIHRyYW5zcG9ydHMucHVzaCh0aGlzLnN1YnNjcmliZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgfVxuICBlbnN1cmVUcmFuc3BvcnRDb25uZWN0ZWQocGNUcmFuc3BvcnQsIGFib3J0Q29udHJvbGxlcikge1xuICAgIGxldCB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgY29ubmVjdGlvblN0YXRlID0gcGNUcmFuc3BvcnQuZ2V0Q29ubmVjdGlvblN0YXRlKCk7XG4gICAgICBpZiAoY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBhYm9ydEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybignYWJvcnQgdHJhbnNwb3J0IGNvbm5lY3Rpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dChjb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ3Jvb20gY29ubmVjdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQnLCAzIC8qIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQgKi8pKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIGFib3J0SGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICBjb25zdCBjb25uZWN0VGltZW91dCA9IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdjb3VsZCBub3QgZXN0YWJsaXNoIHBjIGNvbm5lY3Rpb24nKSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB3aGlsZSAodGhpcy5zdGF0ZSAhPT0gUENUcmFuc3BvcnRTdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgICB5aWVsZCBzbGVlcCg1MCk7IC8vIEZJWE1FIHdlIHNob3VsZG4ndCByZWx5IG9uIGBzbGVlcGAgaW4gdGhlIGNvbm5lY3Rpb24gcGF0aHMsIGFzIGl0IGludm9rZXMgYHNldFRpbWVvdXRgIHdoaWNoIGNhbiBiZSBkcmFzdGljYWxseSB0aHJvdHRsZWQgYnkgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyID09PSBudWxsIHx8IGFib3J0Q29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcigncm9vbSBjb25uZWN0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCcsIDMgLyogQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCAqLykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IGxvc3N5RGF0YUNoYW5uZWwgPSAnX2xvc3N5JztcbmNvbnN0IHJlbGlhYmxlRGF0YUNoYW5uZWwgPSAnX3JlbGlhYmxlJztcbmNvbnN0IG1pblJlY29ubmVjdFdhaXQgPSAyICogMTAwMDtcbmNvbnN0IGxlYXZlUmVjb25uZWN0ID0gJ2xlYXZlLXJlY29ubmVjdCc7XG52YXIgUENTdGF0ZTtcbihmdW5jdGlvbiAoUENTdGF0ZSkge1xuICBQQ1N0YXRlW1BDU3RhdGVbXCJOZXdcIl0gPSAwXSA9IFwiTmV3XCI7XG4gIFBDU3RhdGVbUENTdGF0ZVtcIkNvbm5lY3RlZFwiXSA9IDFdID0gXCJDb25uZWN0ZWRcIjtcbiAgUENTdGF0ZVtQQ1N0YXRlW1wiRGlzY29ubmVjdGVkXCJdID0gMl0gPSBcIkRpc2Nvbm5lY3RlZFwiO1xuICBQQ1N0YXRlW1BDU3RhdGVbXCJSZWNvbm5lY3RpbmdcIl0gPSAzXSA9IFwiUmVjb25uZWN0aW5nXCI7XG4gIFBDU3RhdGVbUENTdGF0ZVtcIkNsb3NlZFwiXSA9IDRdID0gXCJDbG9zZWRcIjtcbn0pKFBDU3RhdGUgfHwgKFBDU3RhdGUgPSB7fSkpO1xuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgUlRDRW5naW5lIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBnZXQgaXNDbG9zZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzQ2xvc2VkO1xuICB9XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucnRjQ29uZmlnID0ge307XG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQgPSByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSBmYWxzZTtcbiAgICB0aGlzLnN1YnNjcmliZXJQcmltYXJ5ID0gZmFsc2U7XG4gICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5OZXc7XG4gICAgdGhpcy5faXNDbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzID0ge307XG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgdGhpcy5yZWNvbm5lY3RTdGFydCA9IDA7XG4gICAgdGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgLyoqIGtlZXBzIHRyYWNrIG9mIGhvdyBvZnRlbiBhbiBpbml0aWFsIGpvaW4gY29ubmVjdGlvbiBoYXMgYmVlbiB0cmllZCAqL1xuICAgIHRoaXMuam9pbkF0dGVtcHRzID0gMDtcbiAgICAvKiogc3BlY2lmaWVzIGhvdyBvZnRlbiBhbiBpbml0aWFsIGpvaW4gY29ubmVjdGlvbiBpcyBhbGxvd2VkIHRvIHJldHJ5ICovXG4gICAgdGhpcy5tYXhKb2luQXR0ZW1wdHMgPSAxO1xuICAgIHRoaXMuc2hvdWxkRmFpbE5leHQgPSBmYWxzZTtcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XG4gICAgdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbCA9IF9yZWYgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgY2hhbm5lbFxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5uZWwubGFiZWwgPT09IHJlbGlhYmxlRGF0YUNoYW5uZWwpIHtcbiAgICAgICAgICB0aGlzLnJlbGlhYmxlRENTdWIgPSBjaGFubmVsO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWwubGFiZWwgPT09IGxvc3N5RGF0YUNoYW5uZWwpIHtcbiAgICAgICAgICB0aGlzLmxvc3N5RENTdWIgPSBjaGFubmVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcIm9uIGRhdGEgY2hhbm5lbCBcIi5jb25jYXQoY2hhbm5lbC5pZCwgXCIsIFwiKS5jb25jYXQoY2hhbm5lbC5sYWJlbCksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIGNoYW5uZWwub25tZXNzYWdlID0gdGhpcy5oYW5kbGVEYXRhTWVzc2FnZTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVEYXRhTWVzc2FnZSA9IG1lc3NhZ2UgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9iLCBfYztcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byByZXNwZWN0IGluY29taW5nIGRhdGEgbWVzc2FnZSBvcmRlciBieSBwcm9jZXNzaW5nIG1lc3NhZ2UgZXZlbnRzIG9uZSBhZnRlciB0aGUgb3RoZXJcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMuZGF0YVByb2Nlc3NMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIGRlY29kZVxuICAgICAgICBsZXQgYnVmZmVyO1xuICAgICAgICBpZiAobWVzc2FnZS5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICBidWZmZXIgPSBtZXNzYWdlLmRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgIGJ1ZmZlciA9IHlpZWxkIG1lc3NhZ2UuZGF0YS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nLmVycm9yKCd1bnN1cHBvcnRlZCBkYXRhIHR5cGUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UuZGF0YVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHAgPSBEYXRhUGFja2V0LmZyb21CaW5hcnkobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gICAgICAgIGlmICgoKF9iID0gZHAudmFsdWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYXNlKSA9PT0gJ3NwZWFrZXInKSB7XG4gICAgICAgICAgLy8gZGlzcGF0Y2ggc3BlYWtlciB1cGRhdGVzXG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkFjdGl2ZVNwZWFrZXJzVXBkYXRlLCBkcC52YWx1ZS52YWx1ZS5zcGVha2Vycyk7XG4gICAgICAgIH0gZWxzZSBpZiAoKChfYyA9IGRwLnZhbHVlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FzZSkgPT09ICd1c2VyJykge1xuICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EYXRhUGFja2V0UmVjZWl2ZWQsIGRwLnZhbHVlLnZhbHVlLCBkcC5raW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5oYW5kbGVEYXRhRXJyb3IgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBjaGFubmVsID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgIGNvbnN0IGNoYW5uZWxLaW5kID0gY2hhbm5lbC5tYXhSZXRyYW5zbWl0cyA9PT0gMCA/ICdsb3NzeScgOiAncmVsaWFibGUnO1xuICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgRXJyb3JFdmVudCAmJiBldmVudC5lcnJvcikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSA9IGV2ZW50LmVycm9yO1xuICAgICAgICB0aGlzLmxvZy5lcnJvcihcIkRhdGFDaGFubmVsIGVycm9yIG9uIFwiLmNvbmNhdChjaGFubmVsS2luZCwgXCI6IFwiKS5jb25jYXQoZXZlbnQubWVzc2FnZSksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIGVycm9yXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKFwiVW5rbm93biBEYXRhQ2hhbm5lbCBlcnJvciBvbiBcIi5jb25jYXQoY2hhbm5lbEtpbmQpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBldmVudFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93ID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBjb25zdCBjaGFubmVsS2luZCA9IGNoYW5uZWwubWF4UmV0cmFuc21pdHMgPT09IDAgPyBEYXRhUGFja2V0X0tpbmQuTE9TU1kgOiBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEU7XG4gICAgICB0aGlzLnVwZGF0ZUFuZEVtaXREQ0J1ZmZlclN0YXR1cyhjaGFubmVsS2luZCk7XG4gICAgfTtcbiAgICAvLyB3ZWJzb2NrZXQgcmVjb25uZWN0IGJlaGF2aW9yLiBpZiB3ZWJzb2NrZXQgaXMgaW50ZXJydXB0ZWQsIGFuZCB0aGUgUGVlckNvbm5lY3Rpb25cbiAgICAvLyBjb250aW51ZXMgdG8gd29yaywgd2UgY2FuIHJlY29ubmVjdCB0byB3ZWJzb2NrZXQgdG8gY29udGludWUgdGhlIHNlc3Npb25cbiAgICAvLyBhZnRlciBhIG51bWJlciBvZiByZXRyaWVzLCB3ZSdsbCBjbG9zZSBhbmQgZ2l2ZSB1cCBwZXJtYW5lbnRseVxuICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCA9IChjb25uZWN0aW9uLCBkaXNjb25uZWN0UmVhc29uKSA9PiB7XG4gICAgICBpZiAodGhpcy5faXNDbG9zZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cud2FybihcIlwiLmNvbmNhdChjb25uZWN0aW9uLCBcIiBkaXNjb25uZWN0ZWRcIiksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICBpZiAodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9PT0gMCkge1xuICAgICAgICAvLyBvbmx5IHJlc2V0IHN0YXJ0IHRpbWUgb24gdGhlIGZpcnN0IHRyeVxuICAgICAgICB0aGlzLnJlY29ubmVjdFN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpc2Nvbm5lY3QgPSBkdXJhdGlvbiA9PiB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oXCJjb3VsZCBub3QgcmVjb3ZlciBjb25uZWN0aW9uIGFmdGVyIFwiLmNvbmNhdCh0aGlzLnJlY29ubmVjdEF0dGVtcHRzLCBcIiBhdHRlbXB0cywgXCIpLmNvbmNhdChkdXJhdGlvbiwgXCJtcy4gZ2l2aW5nIHVwXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHRoaXMucmVjb25uZWN0U3RhcnQ7XG4gICAgICBsZXQgZGVsYXkgPSB0aGlzLmdldE5leHRSZXRyeURlbGF5KHtcbiAgICAgICAgZWxhcHNlZE1zOiBkdXJhdGlvbixcbiAgICAgICAgcmV0cnlDb3VudDogdGhpcy5yZWNvbm5lY3RBdHRlbXB0c1xuICAgICAgfSk7XG4gICAgICBpZiAoZGVsYXkgPT09IG51bGwpIHtcbiAgICAgICAgZGlzY29ubmVjdChkdXJhdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjb25uZWN0aW9uID09PSBsZWF2ZVJlY29ubmVjdCkge1xuICAgICAgICBkZWxheSA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInJlY29ubmVjdGluZyBpbiBcIi5jb25jYXQoZGVsYXksIFwibXNcIiksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLmNsZWFyUmVjb25uZWN0VGltZW91dCgpO1xuICAgICAgaWYgKHRoaXMudG9rZW4gJiYgdGhpcy5yZWdpb25VcmxQcm92aWRlcikge1xuICAgICAgICAvLyB0b2tlbiBtYXkgaGF2ZSBiZWVuIHJlZnJlc2hlZCwgd2UgZG8gbm90IHdhbnQgdG8gcmVjcmVhdGUgdGhlIHJlZ2lvblVybFByb3ZpZGVyXG4gICAgICAgIC8vIHNpbmNlIHRoZSBjdXJyZW50IGVuZ2luZSBtYXkgaGF2ZSBpbmhlcml0ZWQgYSByZWdpb25hbCB1cmxcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci51cGRhdGVUb2tlbih0aGlzLnRva2VuKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4gdGhpcy5hdHRlbXB0UmVjb25uZWN0KGRpc2Nvbm5lY3RSZWFzb24pLCBkZWxheSk7XG4gICAgfTtcbiAgICB0aGlzLndhaXRGb3JSZXN0YXJ0ZWQgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5wY1N0YXRlID09PSBQQ1N0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvblJlc3RhcnRlZCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLm9mZihFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIG9uRGlzY29ubmVjdGVkKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uRGlzY29ubmVjdGVkID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMub2ZmKEVuZ2luZUV2ZW50LlJlc3RhcnRlZCwgb25SZXN0YXJ0ZWQpO1xuICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uY2UoRW5naW5lRXZlbnQuUmVzdGFydGVkLCBvblJlc3RhcnRlZCk7XG4gICAgICAgIHRoaXMub25jZShFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIG9uRGlzY29ubmVjdGVkKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMgPSBraW5kID0+IHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuaXNCdWZmZXJTdGF0dXNMb3coa2luZCk7XG4gICAgICBpZiAodHlwZW9mIHN0YXR1cyAhPT0gJ3VuZGVmaW5lZCcgJiYgc3RhdHVzICE9PSB0aGlzLmRjQnVmZmVyU3RhdHVzLmdldChraW5kKSkge1xuICAgICAgICB0aGlzLmRjQnVmZmVyU3RhdHVzLnNldChraW5kLCBzdGF0dXMpO1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRENCdWZmZXJTdGF0dXNDaGFuZ2VkLCBzdGF0dXMsIGtpbmQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pc0J1ZmZlclN0YXR1c0xvdyA9IGtpbmQgPT4ge1xuICAgICAgY29uc3QgZGMgPSB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChraW5kKTtcbiAgICAgIGlmIChkYykge1xuICAgICAgICByZXR1cm4gZGMuYnVmZmVyZWRBbW91bnQgPD0gZGMuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQ7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUJyb3dzZXJPbkxpbmUgPSAoKSA9PiB7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBlbmdpbmUgaXMgY3VycmVudGx5IHJlY29ubmVjdGluZywgYXR0ZW1wdCBhIHJlY29ubmVjdCBpbW1lZGlhdGVseSBhZnRlciB0aGUgYnJvd3NlciBzdGF0ZSBoYXMgY2hhbmdlZCB0byAnb25MaW5lJ1xuICAgICAgaWYgKHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORykge1xuICAgICAgICB0aGlzLmNsZWFyUmVjb25uZWN0VGltZW91dCgpO1xuICAgICAgICB0aGlzLmF0dGVtcHRSZWNvbm5lY3QoUmVjb25uZWN0UmVhc29uLlJSX1NJR05BTF9ESVNDT05ORUNURUQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gb3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5FbmdpbmUpO1xuICAgIHRoaXMubG9nZ2VyT3B0aW9ucyA9IHtcbiAgICAgIGxvZ2dlck5hbWU6IG9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudCA9IG5ldyBTaWduYWxDbGllbnQodW5kZWZpbmVkLCB0aGlzLmxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuY2xpZW50LnNpZ25hbExhdGVuY3kgPSB0aGlzLm9wdGlvbnMuZXhwU2lnbmFsTGF0ZW5jeTtcbiAgICB0aGlzLnJlY29ubmVjdFBvbGljeSA9IHRoaXMub3B0aW9ucy5yZWNvbm5lY3RQb2xpY3k7XG4gICAgdGhpcy5yZWdpc3Rlck9uTGluZUxpc3RlbmVyKCk7XG4gICAgdGhpcy5jbG9zaW5nTG9jayA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMuZGF0YVByb2Nlc3NMb2NrID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5kY0J1ZmZlclN0YXR1cyA9IG5ldyBNYXAoW1tEYXRhUGFja2V0X0tpbmQuTE9TU1ksIHRydWVdLCBbRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLCB0cnVlXV0pO1xuICAgIHRoaXMuY2xpZW50Lm9uUGFydGljaXBhbnRVcGRhdGUgPSB1cGRhdGVzID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5QYXJ0aWNpcGFudFVwZGF0ZSwgdXBkYXRlcyk7XG4gICAgdGhpcy5jbGllbnQub25Db25uZWN0aW9uUXVhbGl0eSA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsIHVwZGF0ZSk7XG4gICAgdGhpcy5jbGllbnQub25Sb29tVXBkYXRlID0gdXBkYXRlID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCB1cGRhdGUpO1xuICAgIHRoaXMuY2xpZW50Lm9uU3Vic2NyaXB0aW9uRXJyb3IgPSByZXNwID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25FcnJvciwgcmVzcCk7XG4gICAgdGhpcy5jbGllbnQub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlID0gdXBkYXRlID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLCB1cGRhdGUpO1xuICAgIHRoaXMuY2xpZW50Lm9uU3BlYWtlcnNDaGFuZ2VkID0gdXBkYXRlID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TcGVha2Vyc0NoYW5nZWQsIHVwZGF0ZSk7XG4gICAgdGhpcy5jbGllbnQub25TdHJlYW1TdGF0ZVVwZGF0ZSA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3RyZWFtU3RhdGVDaGFuZ2VkLCB1cGRhdGUpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb206IChfYiA9IChfYSA9IHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eucm9vbSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5hbWUsXG4gICAgICByb29tU2lkOiAoX2QgPSAoX2MgPSB0aGlzLmxhdGVzdEpvaW5SZXNwb25zZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJvb20pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zaWQsXG4gICAgICBpZGVudGl0eTogKF9mID0gKF9lID0gdGhpcy5sYXRlc3RKb2luUmVzcG9uc2UpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5wYXJ0aWNpcGFudCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmlkZW50aXR5XG4gICAgfTtcbiAgfVxuICBqb2luKHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgdGhpcy5zaWduYWxPcHRzID0gb3B0cztcbiAgICAgIHRoaXMubWF4Sm9pbkF0dGVtcHRzID0gb3B0cy5tYXhSZXRyaWVzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5qb2luQXR0ZW1wdHMgKz0gMTtcbiAgICAgICAgdGhpcy5zZXR1cFNpZ25hbENsaWVudENhbGxiYWNrcygpO1xuICAgICAgICBjb25zdCBqb2luUmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNsaWVudC5qb2luKHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKTtcbiAgICAgICAgdGhpcy5faXNDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXRlc3RKb2luUmVzcG9uc2UgPSBqb2luUmVzcG9uc2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlclByaW1hcnkgPSBqb2luUmVzcG9uc2Uuc3Vic2NyaWJlclByaW1hcnk7XG4gICAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLmNvbmZpZ3VyZShqb2luUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBvZmZlclxuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlclByaW1hcnkpIHtcbiAgICAgICAgICB0aGlzLm5lZ290aWF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpZW50Q29uZmlndXJhdGlvbiA9IGpvaW5SZXNwb25zZS5jbGllbnRDb25maWd1cmF0aW9uO1xuICAgICAgICByZXR1cm4gam9pblJlc3BvbnNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvcikge1xuICAgICAgICAgIGlmIChlLnJlYXNvbiA9PT0gMSAvKiBDb25uZWN0aW9uRXJyb3JSZWFzb24uU2VydmVyVW5yZWFjaGFibGUgKi8pIHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oXCJDb3VsZG4ndCBjb25uZWN0IHRvIHNlcnZlciwgYXR0ZW1wdCBcIi5jb25jYXQodGhpcy5qb2luQXR0ZW1wdHMsIFwiIG9mIFwiKS5jb25jYXQodGhpcy5tYXhKb2luQXR0ZW1wdHMpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuam9pbkF0dGVtcHRzIDwgdGhpcy5tYXhKb2luQXR0ZW1wdHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuam9pbih1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMuY2xvc2luZ0xvY2subG9jaygpO1xuICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX2lzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkNsb3NpbmcpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLmRlcmVnaXN0ZXJPbkxpbmVMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLmNsZWFyUGVuZGluZ1JlY29ubmVjdCgpO1xuICAgICAgICB5aWVsZCB0aGlzLmNsZWFudXBQZWVyQ29ubmVjdGlvbnMoKTtcbiAgICAgICAgeWllbGQgdGhpcy5jbGVhbnVwQ2xpZW50KCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjbGVhbnVwUGVlckNvbm5lY3Rpb25zKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgKF9hID0gdGhpcy5wY01hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgICAgdGhpcy5wY01hbmFnZXIgPSB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBkY0NsZWFudXAgPSBkYyA9PiB7XG4gICAgICAgIGlmICghZGMpIHJldHVybjtcbiAgICAgICAgZGMuY2xvc2UoKTtcbiAgICAgICAgZGMub25idWZmZXJlZGFtb3VudGxvdyA9IG51bGw7XG4gICAgICAgIGRjLm9uY2xvc2UgPSBudWxsO1xuICAgICAgICBkYy5vbmNsb3NpbmcgPSBudWxsO1xuICAgICAgICBkYy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgZGMub25tZXNzYWdlID0gbnVsbDtcbiAgICAgICAgZGMub25vcGVuID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBkY0NsZWFudXAodGhpcy5sb3NzeURDKTtcbiAgICAgIGRjQ2xlYW51cCh0aGlzLmxvc3N5RENTdWIpO1xuICAgICAgZGNDbGVhbnVwKHRoaXMucmVsaWFibGVEQyk7XG4gICAgICBkY0NsZWFudXAodGhpcy5yZWxpYWJsZURDU3ViKTtcbiAgICAgIHRoaXMubG9zc3lEQyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMubG9zc3lEQ1N1YiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucmVsaWFibGVEQyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucmVsaWFibGVEQ1N1YiA9IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgfVxuICBjbGVhbnVwQ2xpZW50KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCB0aGlzLmNsaWVudC5jbG9zZSgpO1xuICAgICAgdGhpcy5jbGllbnQucmVzZXRDYWxsYmFja3MoKTtcbiAgICB9KTtcbiAgfVxuICBhZGRUcmFjayhyZXEpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVxLmNpZF0pIHtcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignYSB0cmFjayB3aXRoIHRoZSBzYW1lIElEIGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBwdWJsaWNhdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3JlcS5jaWRdO1xuICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcigncHVibGljYXRpb24gb2YgbG9jYWwgdHJhY2sgdGltZWQgb3V0LCBubyByZXNwb25zZSBmcm9tIHNlcnZlcicpKTtcbiAgICAgIH0sIDEwMDAwKTtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3JlcS5jaWRdID0ge1xuICAgICAgICByZXNvbHZlOiBpbmZvID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocHVibGljYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZXNvbHZlKGluZm8pO1xuICAgICAgICB9LFxuICAgICAgICByZWplY3Q6ICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocHVibGljYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDYW5jZWxsZWQgcHVibGljYXRpb24gYnkgY2FsbGluZyB1bnB1Ymxpc2gnKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmNsaWVudC5zZW5kQWRkVHJhY2socmVxKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBzZW5kZXIgZnJvbSBQZWVyQ29ubmVjdGlvbiwgcmV0dXJuaW5nIHRydWUgaWYgaXQgd2FzIHJlbW92ZWQgc3VjY2Vzc2Z1bGx5XG4gICAqIGFuZCBhIG5lZ290aWF0aW9uIGlzIG5lY2Vzc2FyeVxuICAgKiBAcGFyYW0gc2VuZGVyXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICBpZiAoc2VuZGVyLnRyYWNrICYmIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3NlbmRlci50cmFjay5pZF0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVqZWN0XG4gICAgICB9ID0gdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbc2VuZGVyLnRyYWNrLmlkXTtcbiAgICAgIGlmIChyZWplY3QpIHtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbc2VuZGVyLnRyYWNrLmlkXTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucGNNYW5hZ2VyLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdmYWlsZWQgdG8gcmVtb3ZlIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGVycm9yOiBlXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB1cGRhdGVNdXRlU3RhdHVzKHRyYWNrU2lkLCBtdXRlZCkge1xuICAgIHRoaXMuY2xpZW50LnNlbmRNdXRlVHJhY2sodHJhY2tTaWQsIG11dGVkKTtcbiAgfVxuICBnZXQgZGF0YVN1YnNjcmliZXJSZWFkeVN0YXRlKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5yZWxpYWJsZURDU3ViKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhZHlTdGF0ZTtcbiAgfVxuICBnZXRDb25uZWN0ZWRTZXJ2ZXJBZGRyZXNzKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIChfYSA9IHRoaXMucGNNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Q29ubmVjdGVkQWRkcmVzcygpO1xuICAgIH0pO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzZXRSZWdpb25VcmxQcm92aWRlcihwcm92aWRlcikge1xuICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgfVxuICBjb25maWd1cmUoam9pblJlc3BvbnNlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBhbHJlYWR5IGNvbmZpZ3VyZWRcbiAgICAgIGlmICh0aGlzLnBjTWFuYWdlciAmJiB0aGlzLnBjTWFuYWdlci5jdXJyZW50U3RhdGUgIT09IFBDVHJhbnNwb3J0U3RhdGUuTkVXKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFydGljaXBhbnRTaWQgPSAoX2EgPSBqb2luUmVzcG9uc2UucGFydGljaXBhbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaWQ7XG4gICAgICBjb25zdCBydGNDb25maWcgPSB0aGlzLm1ha2VSVENDb25maWd1cmF0aW9uKGpvaW5SZXNwb25zZSk7XG4gICAgICB0aGlzLnBjTWFuYWdlciA9IG5ldyBQQ1RyYW5zcG9ydE1hbmFnZXIocnRjQ29uZmlnLCBqb2luUmVzcG9uc2Uuc3Vic2NyaWJlclByaW1hcnksIHRoaXMubG9nZ2VyT3B0aW9ucyk7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuVHJhbnNwb3J0c0NyZWF0ZWQsIHRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlciwgdGhpcy5wY01hbmFnZXIuc3Vic2NyaWJlcik7XG4gICAgICB0aGlzLnBjTWFuYWdlci5vbkljZUNhbmRpZGF0ZSA9IChjYW5kaWRhdGUsIHRhcmdldCkgPT4ge1xuICAgICAgICB0aGlzLmNsaWVudC5zZW5kSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KTtcbiAgICAgIH07XG4gICAgICB0aGlzLnBjTWFuYWdlci5vblB1Ymxpc2hlck9mZmVyID0gb2ZmZXIgPT4ge1xuICAgICAgICB0aGlzLmNsaWVudC5zZW5kT2ZmZXIob2ZmZXIpO1xuICAgICAgfTtcbiAgICAgIHRoaXMucGNNYW5hZ2VyLm9uRGF0YUNoYW5uZWwgPSB0aGlzLmhhbmRsZURhdGFDaGFubmVsO1xuICAgICAgdGhpcy5wY01hbmFnZXIub25TdGF0ZUNoYW5nZSA9IChjb25uZWN0aW9uU3RhdGUsIHB1Ymxpc2hlclN0YXRlLCBzdWJzY3JpYmVyU3RhdGUpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJwcmltYXJ5IFBDIHN0YXRlIGNoYW5nZWQgXCIuY29uY2F0KGNvbm5lY3Rpb25TdGF0ZSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIGlmIChjb25uZWN0aW9uU3RhdGUgPT09IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkRW1pdCA9IHRoaXMucGNTdGF0ZSA9PT0gUENTdGF0ZS5OZXc7XG4gICAgICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5Db25uZWN0ZWQ7XG4gICAgICAgICAgaWYgKHNob3VsZEVtaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5Db25uZWN0ZWQsIGpvaW5SZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0ZSA9PT0gUENUcmFuc3BvcnRTdGF0ZS5GQUlMRUQpIHtcbiAgICAgICAgICAvLyBvbiBTYWZhcmksIFBlZXJDb25uZWN0aW9uIHdpbGwgc3dpdGNoIHRvICdkaXNjb25uZWN0ZWQnIGR1cmluZyByZW5lZ290aWF0aW9uXG4gICAgICAgICAgaWYgKHRoaXMucGNTdGF0ZSA9PT0gUENTdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuRGlzY29ubmVjdGVkO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCdwZWVyY29ubmVjdGlvbiBmYWlsZWQnLCBzdWJzY3JpYmVyU3RhdGUgPT09ICdmYWlsZWQnID8gUmVjb25uZWN0UmVhc29uLlJSX1NVQlNDUklCRVJfRkFJTEVEIDogUmVjb25uZWN0UmVhc29uLlJSX1BVQkxJU0hFUl9GQUlMRUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBjTWFuYWdlci5vblRyYWNrID0gZXYgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuTWVkaWFUcmFja0FkZGVkLCBldi50cmFjaywgZXYuc3RyZWFtc1swXSwgZXYucmVjZWl2ZXIpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuY3JlYXRlRGF0YUNoYW5uZWxzKCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0dXBTaWduYWxDbGllbnRDYWxsYmFja3MoKSB7XG4gICAgLy8gY29uZmlndXJlIHNpZ25hbGluZyBjbGllbnRcbiAgICB0aGlzLmNsaWVudC5vbkFuc3dlciA9IHNkID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHNlcnZlciBhbnN3ZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgUlRDU2RwVHlwZTogc2QudHlwZVxuICAgICAgfSkpO1xuICAgICAgeWllbGQgdGhpcy5wY01hbmFnZXIuc2V0UHVibGlzaGVyQW5zd2VyKHNkKTtcbiAgICB9KTtcbiAgICAvLyBhZGQgY2FuZGlkYXRlIG9uIHRyaWNrbGVcbiAgICB0aGlzLmNsaWVudC5vblRyaWNrbGUgPSAoY2FuZGlkYXRlLCB0YXJnZXQpID0+IHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cudHJhY2UoJ2dvdCBJQ0UgY2FuZGlkYXRlIGZyb20gcGVlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBjYW5kaWRhdGUsXG4gICAgICAgIHRhcmdldFxuICAgICAgfSkpO1xuICAgICAgdGhpcy5wY01hbmFnZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KTtcbiAgICB9O1xuICAgIC8vIHdoZW4gc2VydmVyIGNyZWF0ZXMgYW4gb2ZmZXIgZm9yIHRoZSBjbGllbnRcbiAgICB0aGlzLmNsaWVudC5vbk9mZmVyID0gc2QgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhbnN3ZXIgPSB5aWVsZCB0aGlzLnBjTWFuYWdlci5jcmVhdGVTdWJzY3JpYmVyQW5zd2VyRnJvbU9mZmVyKHNkKTtcbiAgICAgIHRoaXMuY2xpZW50LnNlbmRBbnN3ZXIoYW5zd2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLmNsaWVudC5vbkxvY2FsVHJhY2tQdWJsaXNoZWQgPSByZXMgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHRyYWNrUHVibGlzaGVkUmVzcG9uc2UnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgY2lkOiByZXMuY2lkLFxuICAgICAgICB0cmFjazogKF9hID0gcmVzLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lkXG4gICAgICB9KSk7XG4gICAgICBpZiAoIXRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3Jlcy5jaWRdKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKFwibWlzc2luZyB0cmFjayByZXNvbHZlciBmb3IgXCIuY29uY2F0KHJlcy5jaWQpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBjaWQ6IHJlcy5jaWRcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlc29sdmVcbiAgICAgIH0gPSB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXMuY2lkXTtcbiAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXMuY2lkXTtcbiAgICAgIHJlc29sdmUocmVzLnRyYWNrKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50Lm9uTG9jYWxUcmFja1VucHVibGlzaGVkID0gcmVzcG9uc2UgPT4ge1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgcmVzcG9uc2UpO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25Ub2tlblJlZnJlc2ggPSB0b2tlbiA9PiB7XG4gICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudC5vblJlbW90ZU11dGVDaGFuZ2VkID0gKHRyYWNrU2lkLCBtdXRlZCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJlbW90ZU11dGUsIHRyYWNrU2lkLCBtdXRlZCk7XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudC5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlID0gdXBkYXRlID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSwgdXBkYXRlKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50Lm9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoJ3NpZ25hbCcsIFJlY29ubmVjdFJlYXNvbi5SUl9TSUdOQUxfRElTQ09OTkVDVEVEKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50Lm9uTGVhdmUgPSBsZWF2ZSA9PiB7XG4gICAgICBpZiAobGVhdmUgPT09IG51bGwgfHwgbGVhdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlYXZlLmNhblJlY29ubmVjdCkge1xuICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgICAvLyByZWNvbm5lY3QgaW1tZWRpYXRlbHkgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciBuZXh0IGF0dGVtcHRcbiAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KGxlYXZlUmVjb25uZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIGxlYXZlID09PSBudWxsIHx8IGxlYXZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWF2ZS5yZWFzb24pO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygnY2xpZW50IGxlYXZlIHJlcXVlc3QnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgcmVhc29uOiBsZWF2ZSA9PT0gbnVsbCB8fCBsZWF2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhdmUucmVhc29uXG4gICAgICB9KSk7XG4gICAgfTtcbiAgfVxuICBtYWtlUlRDQ29uZmlndXJhdGlvbihzZXJ2ZXJSZXNwb25zZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBydGNDb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJ0Y0NvbmZpZyk7XG4gICAgaWYgKChfYSA9IHRoaXMuc2lnbmFsT3B0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmUyZWVFbmFibGVkKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygnRTJFRSAtIHNldHRpbmcgdXAgdHJhbnNwb3J0cyB3aXRoIGluc2VydGFibGUgc3RyZWFtcycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAvLyAgdGhpcyBtYWtlcyBzdXJlIHRoYXQgbm8gZGF0YSBpcyBzZW50IGJlZm9yZSB0aGUgdHJhbnNmb3JtcyBhcmUgcmVhZHlcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJ0Y0NvbmZpZy5lbmNvZGVkSW5zZXJ0YWJsZVN0cmVhbXMgPSB0cnVlO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgSUNFIHNlcnZlcnMgYmVmb3JlIGNyZWF0aW5nIFBlZXJDb25uZWN0aW9uXG4gICAgaWYgKHNlcnZlclJlc3BvbnNlLmljZVNlcnZlcnMgJiYgIXJ0Y0NvbmZpZy5pY2VTZXJ2ZXJzKSB7XG4gICAgICBjb25zdCBydGNJY2VTZXJ2ZXJzID0gW107XG4gICAgICBzZXJ2ZXJSZXNwb25zZS5pY2VTZXJ2ZXJzLmZvckVhY2goaWNlU2VydmVyID0+IHtcbiAgICAgICAgY29uc3QgcnRjSWNlU2VydmVyID0ge1xuICAgICAgICAgIHVybHM6IGljZVNlcnZlci51cmxzXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpY2VTZXJ2ZXIudXNlcm5hbWUpIHJ0Y0ljZVNlcnZlci51c2VybmFtZSA9IGljZVNlcnZlci51c2VybmFtZTtcbiAgICAgICAgaWYgKGljZVNlcnZlci5jcmVkZW50aWFsKSB7XG4gICAgICAgICAgcnRjSWNlU2VydmVyLmNyZWRlbnRpYWwgPSBpY2VTZXJ2ZXIuY3JlZGVudGlhbDtcbiAgICAgICAgfVxuICAgICAgICBydGNJY2VTZXJ2ZXJzLnB1c2gocnRjSWNlU2VydmVyKTtcbiAgICAgIH0pO1xuICAgICAgcnRjQ29uZmlnLmljZVNlcnZlcnMgPSBydGNJY2VTZXJ2ZXJzO1xuICAgIH1cbiAgICBpZiAoc2VydmVyUmVzcG9uc2UuY2xpZW50Q29uZmlndXJhdGlvbiAmJiBzZXJ2ZXJSZXNwb25zZS5jbGllbnRDb25maWd1cmF0aW9uLmZvcmNlUmVsYXkgPT09IENsaWVudENvbmZpZ1NldHRpbmcuRU5BQkxFRCkge1xuICAgICAgcnRjQ29uZmlnLmljZVRyYW5zcG9ydFBvbGljeSA9ICdyZWxheSc7XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBydGNDb25maWcuc2RwU2VtYW50aWNzID0gJ3VuaWZpZWQtcGxhbic7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJ0Y0NvbmZpZy5jb250aW51YWxHYXRoZXJpbmdQb2xpY3kgPSAnZ2F0aGVyX2NvbnRpbnVhbGx5JztcbiAgICByZXR1cm4gcnRjQ29uZmlnO1xuICB9XG4gIGNyZWF0ZURhdGFDaGFubmVscygpIHtcbiAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGNsZWFyIG9sZCBkYXRhIGNoYW5uZWwgY2FsbGJhY2tzIGlmIHJlY3JlYXRlXG4gICAgaWYgKHRoaXMubG9zc3lEQykge1xuICAgICAgdGhpcy5sb3NzeURDLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICB0aGlzLmxvc3N5REMub25lcnJvciA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbGlhYmxlREMpIHtcbiAgICAgIHRoaXMucmVsaWFibGVEQy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgdGhpcy5yZWxpYWJsZURDLm9uZXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgZGF0YSBjaGFubmVsc1xuICAgIHRoaXMubG9zc3lEQyA9IHRoaXMucGNNYW5hZ2VyLmNyZWF0ZVB1Ymxpc2hlckRhdGFDaGFubmVsKGxvc3N5RGF0YUNoYW5uZWwsIHtcbiAgICAgIC8vIHdpbGwgZHJvcCBvbGRlciBwYWNrZXRzIHRoYXQgYXJyaXZlXG4gICAgICBvcmRlcmVkOiB0cnVlLFxuICAgICAgbWF4UmV0cmFuc21pdHM6IDBcbiAgICB9KTtcbiAgICB0aGlzLnJlbGlhYmxlREMgPSB0aGlzLnBjTWFuYWdlci5jcmVhdGVQdWJsaXNoZXJEYXRhQ2hhbm5lbChyZWxpYWJsZURhdGFDaGFubmVsLCB7XG4gICAgICBvcmRlcmVkOiB0cnVlXG4gICAgfSk7XG4gICAgLy8gYWxzbyBoYW5kbGUgbWVzc2FnZXMgb3ZlciB0aGUgcHViIGNoYW5uZWwsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIHRoaXMubG9zc3lEQy5vbm1lc3NhZ2UgPSB0aGlzLmhhbmRsZURhdGFNZXNzYWdlO1xuICAgIHRoaXMucmVsaWFibGVEQy5vbm1lc3NhZ2UgPSB0aGlzLmhhbmRsZURhdGFNZXNzYWdlO1xuICAgIC8vIGhhbmRsZSBkYXRhY2hhbm5lbCBlcnJvcnNcbiAgICB0aGlzLmxvc3N5REMub25lcnJvciA9IHRoaXMuaGFuZGxlRGF0YUVycm9yO1xuICAgIHRoaXMucmVsaWFibGVEQy5vbmVycm9yID0gdGhpcy5oYW5kbGVEYXRhRXJyb3I7XG4gICAgLy8gc2V0IHVwIGRjIGJ1ZmZlciB0aHJlc2hvbGQsIHNldCB0byA2NGtCIChvdGhlcndpc2UgMCBieSBkZWZhdWx0KVxuICAgIHRoaXMubG9zc3lEQy5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9IDY1NTM1O1xuICAgIHRoaXMucmVsaWFibGVEQy5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9IDY1NTM1O1xuICAgIC8vIGhhbmRsZSBidWZmZXIgYW1vdW50IGxvdyBldmVudHNcbiAgICB0aGlzLmxvc3N5REMub25idWZmZXJlZGFtb3VudGxvdyA9IHRoaXMuaGFuZGxlQnVmZmVyZWRBbW91bnRMb3c7XG4gICAgdGhpcy5yZWxpYWJsZURDLm9uYnVmZmVyZWRhbW91bnRsb3cgPSB0aGlzLmhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93O1xuICB9XG4gIHNldFByZWZlcnJlZENvZGVjKHRyYW5zY2VpdmVyLCBraW5kLCB2aWRlb0NvZGVjKSB7XG4gICAgaWYgKCEoJ2dldENhcGFiaWxpdGllcycgaW4gUlRDUnRwU2VuZGVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjYXAgPSBSVENSdHBTZW5kZXIuZ2V0Q2FwYWJpbGl0aWVzKGtpbmQpO1xuICAgIGlmICghY2FwKSByZXR1cm47XG4gICAgdGhpcy5sb2cuZGVidWcoJ2dldCBzZW5kZXIgY2FwYWJpbGl0aWVzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICBjYXBcbiAgICB9KSk7XG4gICAgY29uc3QgbWF0Y2hlZCA9IFtdO1xuICAgIGNvbnN0IHBhcnRpYWxNYXRjaGVkID0gW107XG4gICAgY29uc3QgdW5tYXRjaGVkID0gW107XG4gICAgY2FwLmNvZGVjcy5mb3JFYWNoKGMgPT4ge1xuICAgICAgY29uc3QgY29kZWMgPSBjLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoY29kZWMgPT09ICdhdWRpby9vcHVzJykge1xuICAgICAgICBtYXRjaGVkLnB1c2goYyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hdGNoZXNWaWRlb0NvZGVjID0gY29kZWMgPT09IFwidmlkZW8vXCIuY29uY2F0KHZpZGVvQ29kZWMpO1xuICAgICAgaWYgKCFtYXRjaGVzVmlkZW9Db2RlYykge1xuICAgICAgICB1bm1hdGNoZWQucHVzaChjKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gZm9yIGgyNjQgY29kZWNzIHRoYXQgaGF2ZSBzZHBGbXRwTGluZSBhdmFpbGFibGUsIHVzZSBvbmx5IGlmIHRoZVxuICAgICAgLy8gcHJvZmlsZS1sZXZlbC1pZCBpcyA0MmUwMWYgZm9yIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJpbGl0eVxuICAgICAgaWYgKHZpZGVvQ29kZWMgPT09ICdoMjY0Jykge1xuICAgICAgICBpZiAoYy5zZHBGbXRwTGluZSAmJiBjLnNkcEZtdHBMaW5lLmluY2x1ZGVzKCdwcm9maWxlLWxldmVsLWlkPTQyZTAxZicpKSB7XG4gICAgICAgICAgbWF0Y2hlZC5wdXNoKGMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRpYWxNYXRjaGVkLnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWF0Y2hlZC5wdXNoKGMpO1xuICAgIH0pO1xuICAgIGlmIChzdXBwb3J0c1NldENvZGVjUHJlZmVyZW5jZXModHJhbnNjZWl2ZXIpKSB7XG4gICAgICB0cmFuc2NlaXZlci5zZXRDb2RlY1ByZWZlcmVuY2VzKG1hdGNoZWQuY29uY2F0KHBhcnRpYWxNYXRjaGVkLCB1bm1hdGNoZWQpKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlU2VuZGVyKHRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHN1cHBvcnRzVHJhbnNjZWl2ZXIoKSkge1xuICAgICAgICBjb25zdCBzZW5kZXIgPSB5aWVsZCB0aGlzLmNyZWF0ZVRyYW5zY2VpdmVyUlRDUnRwU2VuZGVyKHRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpO1xuICAgICAgICByZXR1cm4gc2VuZGVyO1xuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzQWRkVHJhY2soKSkge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCd1c2luZyBhZGQtdHJhY2sgZmFsbGJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICBjb25zdCBzZW5kZXIgPSB5aWVsZCB0aGlzLmNyZWF0ZVJUQ1J0cFNlbmRlcih0cmFjay5tZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdSZXF1aXJlZCB3ZWJSVEMgQVBJcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlJyk7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlU2ltdWxjYXN0U2VuZGVyKHRyYWNrLCBzaW11bGNhc3RUcmFjaywgb3B0cywgZW5jb2RpbmdzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIHN0b3JlIFJUQ1J0cFNlbmRlclxuICAgICAgaWYgKHN1cHBvcnRzVHJhbnNjZWl2ZXIoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTaW11bGNhc3RUcmFuc2NlaXZlclNlbmRlcih0cmFjaywgc2ltdWxjYXN0VHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XG4gICAgICB9XG4gICAgICBpZiAoc3VwcG9ydHNBZGRUcmFjaygpKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCd1c2luZyBhZGQtdHJhY2sgZmFsbGJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVSVENSdHBTZW5kZXIodHJhY2subWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnQ2Fubm90IHN0cmVhbSBvbiB0aGlzIGRldmljZScpO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVRyYW5zY2VpdmVyUlRDUnRwU2VuZGVyKHRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgncHVibGlzaGVyIGlzIGNsb3NlZCcpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RyZWFtcyA9IFtdO1xuICAgICAgaWYgKHRyYWNrLm1lZGlhU3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbXMucHVzaCh0cmFjay5tZWRpYVN0cmVhbSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2NlaXZlckluaXQgPSB7XG4gICAgICAgIGRpcmVjdGlvbjogJ3NlbmRvbmx5JyxcbiAgICAgICAgc3RyZWFtc1xuICAgICAgfTtcbiAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgdHJhbnNjZWl2ZXJJbml0LnNlbmRFbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICB9XG4gICAgICAvLyBhZGRUcmFuc2NlaXZlciBmb3IgcmVhY3QtbmF0aXZlIGlzIGFzeW5jLiB3ZWIgaXMgc3luY2hyb25vdXMsIGJ1dCBhd2FpdCB3b24ndCBlZmZlY3QgaXQuXG4gICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHlpZWxkIHRoaXMucGNNYW5hZ2VyLmFkZFB1Ymxpc2hlclRyYW5zY2VpdmVyKHRyYWNrLm1lZGlhU3RyZWFtVHJhY2ssIHRyYW5zY2VpdmVySW5pdCk7XG4gICAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbyAmJiBvcHRzLnZpZGVvQ29kZWMpIHtcbiAgICAgICAgdGhpcy5zZXRQcmVmZXJyZWRDb2RlYyh0cmFuc2NlaXZlciwgdHJhY2sua2luZCwgb3B0cy52aWRlb0NvZGVjKTtcbiAgICAgICAgdHJhY2suY29kZWMgPSBvcHRzLnZpZGVvQ29kZWM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhbnNjZWl2ZXIuc2VuZGVyO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVNpbXVsY2FzdFRyYW5zY2VpdmVyU2VuZGVyKHRyYWNrLCBzaW11bGNhc3RUcmFjaywgb3B0cywgZW5jb2RpbmdzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ3B1Ymxpc2hlciBpcyBjbG9zZWQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zY2VpdmVySW5pdCA9IHtcbiAgICAgICAgZGlyZWN0aW9uOiAnc2VuZG9ubHknXG4gICAgICB9O1xuICAgICAgaWYgKGVuY29kaW5ncykge1xuICAgICAgICB0cmFuc2NlaXZlckluaXQuc2VuZEVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICAgIH1cbiAgICAgIC8vIGFkZFRyYW5zY2VpdmVyIGZvciByZWFjdC1uYXRpdmUgaXMgYXN5bmMuIHdlYiBpcyBzeW5jaHJvbm91cywgYnV0IGF3YWl0IHdvbid0IGVmZmVjdCBpdC5cbiAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0geWllbGQgdGhpcy5wY01hbmFnZXIuYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXIoc2ltdWxjYXN0VHJhY2subWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0KTtcbiAgICAgIGlmICghb3B0cy52aWRlb0NvZGVjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0UHJlZmVycmVkQ29kZWModHJhbnNjZWl2ZXIsIHRyYWNrLmtpbmQsIG9wdHMudmlkZW9Db2RlYyk7XG4gICAgICB0cmFjay5zZXRTaW11bGNhc3RUcmFja1NlbmRlcihvcHRzLnZpZGVvQ29kZWMsIHRyYW5zY2VpdmVyLnNlbmRlcik7XG4gICAgICByZXR1cm4gdHJhbnNjZWl2ZXIuc2VuZGVyO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVJUQ1J0cFNlbmRlcih0cmFjaykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wY01hbmFnZXIuYWRkUHVibGlzaGVyVHJhY2sodHJhY2spO1xuICAgIH0pO1xuICB9XG4gIGF0dGVtcHRSZWNvbm5lY3QocmVhc29uKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLl9pc0Nsb3NlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBndWFyZCBmb3IgYXR0ZW1wdGluZyByZWNvbm5lY3Rpb24gbXVsdGlwbGUgdGltZXMgd2hpbGUgb25lIGF0dGVtcHQgaXMgc3RpbGwgbm90IGZpbmlzaGVkXG4gICAgICBpZiAodGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0KSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIud2FybignYWxyZWFkeSBhdHRlbXB0aW5nIHJlY29ubmVjdCwgcmV0dXJuaW5nIGVhcmx5JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCgoX2EgPSB0aGlzLmNsaWVudENvbmZpZ3VyYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXN1bWVDb25uZWN0aW9uKSA9PT0gQ2xpZW50Q29uZmlnU2V0dGluZy5ESVNBQkxFRCB8fFxuICAgICAgLy8gc2lnbmFsaW5nIHN0YXRlIGNvdWxkIGNoYW5nZSB0byBjbG9zZWQgZHVlIHRvIGhhcmR3YXJlIHNsZWVwXG4gICAgICAvLyB0aG9zZSBjb25uZWN0aW9ucyBjYW5ub3QgYmUgcmVzdW1lZFxuICAgICAgKChfYyA9IChfYiA9IHRoaXMucGNNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY3VycmVudFN0YXRlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBQQ1RyYW5zcG9ydFN0YXRlLk5FVykgPT09IFBDVHJhbnNwb3J0U3RhdGUuTkVXKSB7XG4gICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmF0dGVtcHRpbmdSZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5mdWxsUmVjb25uZWN0T25OZXh0KSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0Q29ubmVjdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIHRoaXMucmVzdW1lQ29ubmVjdGlvbihyZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJQZW5kaW5nUmVjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IGZhbHNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzICs9IDE7XG4gICAgICAgIGxldCByZWNvdmVyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCB1bnJlY292ZXJhYmxlIGVycm9yJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICAvLyB1bnJlY292ZXJhYmxlXG4gICAgICAgICAgcmVjb3ZlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghKGUgaW5zdGFuY2VvZiBTaWduYWxSZWNvbm5lY3RFcnJvcikpIHtcbiAgICAgICAgICAvLyBjYW5ub3QgcmVzdW1lXG4gICAgICAgICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjb3ZlcmFibGUpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoJ3JlY29ubmVjdCcsIFJlY29ubmVjdFJlYXNvbi5SUl9VTktOT1dOKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZy5pbmZvKFwiY291bGQgbm90IHJlY292ZXIgY29ubmVjdGlvbiBhZnRlciBcIi5jb25jYXQodGhpcy5yZWNvbm5lY3RBdHRlbXB0cywgXCIgYXR0ZW1wdHMsIFwiKS5jb25jYXQoRGF0ZS5ub3coKSAtIHRoaXMucmVjb25uZWN0U3RhcnQsIFwibXMuIGdpdmluZyB1cFwiKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkKTtcbiAgICAgICAgICB5aWVsZCB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuYXR0ZW1wdGluZ1JlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldE5leHRSZXRyeURlbGF5KGNvbnRleHQpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMucmVjb25uZWN0UG9saWN5Lm5leHRSZXRyeURlbGF5SW5Ncyhjb250ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdlbmNvdW50ZXJlZCBlcnJvciBpbiByZWNvbm5lY3QgcG9saWN5JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGVycm9yOiBlXG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8vIGVycm9yIGluIHVzZXIgY29kZSB3aXRoIHByb3ZpZGVkIHJlY29ubmVjdCBwb2xpY3ksIHN0b3AgcmVjb25uZWN0aW5nXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmVzdGFydENvbm5lY3Rpb24ocmVnaW9uVXJsKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghdGhpcy51cmwgfHwgIXRoaXMudG9rZW4pIHtcbiAgICAgICAgICAvLyBwZXJtYW5lbnQgZmFpbHVyZSwgZG9uJ3QgYXR0ZW1wdCByZWNvbm5lY3Rpb25cbiAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY291bGQgbm90IHJlY29ubmVjdCwgdXJsIG9yIHRva2VuIG5vdCBzYXZlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nLmluZm8oXCJyZWNvbm5lY3RpbmcsIGF0dGVtcHQ6IFwiLmNvbmNhdCh0aGlzLnJlY29ubmVjdEF0dGVtcHRzKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJlc3RhcnRpbmcpO1xuICAgICAgICBpZiAoIXRoaXMuY2xpZW50LmlzRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5jbGllbnQuc2VuZExlYXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgdGhpcy5jbGVhbnVwUGVlckNvbm5lY3Rpb25zKCk7XG4gICAgICAgIHlpZWxkIHRoaXMuY2xlYW51cENsaWVudCgpO1xuICAgICAgICBsZXQgam9pblJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghdGhpcy5zaWduYWxPcHRzKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKCdhdHRlbXB0ZWQgY29ubmVjdGlvbiByZXN0YXJ0LCB3aXRob3V0IHNpZ25hbCBvcHRpb25zIHByZXNlbnQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGluIGNhc2UgYSByZWdpb25VcmwgaXMgcGFzc2VkLCB0aGUgcmVnaW9uIFVSTCB0YWtlcyBwcmVjZWRlbmNlXG4gICAgICAgICAgam9pblJlc3BvbnNlID0geWllbGQgdGhpcy5qb2luKHJlZ2lvblVybCAhPT0gbnVsbCAmJiByZWdpb25VcmwgIT09IHZvaWQgMCA/IHJlZ2lvblVybCA6IHRoaXMudXJsLCB0aGlzLnRva2VuLCB0aGlzLnNpZ25hbE9wdHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgJiYgZS5yZWFzb24gPT09IDAgLyogQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQgKi8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjb3VsZCBub3QgcmVjb25uZWN0LCB0b2tlbiBtaWdodCBiZSBleHBpcmVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNob3VsZEZhaWxOZXh0KSB7XG4gICAgICAgICAgdGhpcy5zaG91bGRGYWlsTmV4dCA9IGZhbHNlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2ltdWxhdGVkIGZhaWx1cmUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsaWVudC5zZXRSZWNvbm5lY3RlZCgpO1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU2lnbmFsUmVzdGFydGVkLCBqb2luUmVzcG9uc2UpO1xuICAgICAgICB5aWVsZCB0aGlzLndhaXRGb3JQQ1JlY29ubmVjdGVkKCk7XG4gICAgICAgIC8vIHJlLWNoZWNrIHNpZ25hbCBjb25uZWN0aW9uIHN0YXRlIGJlZm9yZSBzZXR0aW5nIGVuZ2luZSBhcyByZXN1bWVkXG4gICAgICAgIGlmICh0aGlzLmNsaWVudC5jdXJyZW50U3RhdGUgIT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IoJ1NpZ25hbCBjb25uZWN0aW9uIGdvdCBzZXZlcmVkIGR1cmluZyByZWNvbm5lY3QnKTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzZXRBdHRlbXB0cygpO1xuICAgICAgICAvLyByZWNvbm5lY3Qgc3VjY2Vzc1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVzdGFydGVkKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG5leHRSZWdpb25VcmwgPSB5aWVsZCAoX2IgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0TmV4dEJlc3RSZWdpb25VcmwoKTtcbiAgICAgICAgaWYgKG5leHRSZWdpb25VcmwpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnRDb25uZWN0aW9uKG5leHRSZWdpb25VcmwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyBtb3JlIHJlZ2lvbnMgdG8gdHJ5IChvciB3ZSdyZSBub3Qgb24gY2xvdWQpXG4gICAgICAgICAgKF9jID0gdGhpcy5yZWdpb25VcmxQcm92aWRlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlc2V0QXR0ZW1wdHMoKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlc3VtZUNvbm5lY3Rpb24ocmVhc29uKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMudXJsIHx8ICF0aGlzLnRva2VuKSB7XG4gICAgICAgIC8vIHBlcm1hbmVudCBmYWlsdXJlLCBkb24ndCBhdHRlbXB0IHJlY29ubmVjdGlvblxuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY291bGQgbm90IHJlY29ubmVjdCwgdXJsIG9yIHRva2VuIG5vdCBzYXZlZCcpO1xuICAgICAgfVxuICAgICAgLy8gdHJpZ2dlciBwdWJsaXNoZXIgcmVjb25uZWN0XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgYW5kIHN1YnNjcmliZXIgY29ubmVjdGlvbnMgdW5zZXQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmluZm8oXCJyZXN1bWluZyBzaWduYWwgY29ubmVjdGlvbiwgYXR0ZW1wdCBcIi5jb25jYXQodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVzdW1pbmcpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zZXR1cFNpZ25hbENsaWVudENhbGxiYWNrcygpO1xuICAgICAgICBjb25zdCByZXMgPSB5aWVsZCB0aGlzLmNsaWVudC5yZWNvbm5lY3QodGhpcy51cmwsIHRoaXMudG9rZW4sIHRoaXMucGFydGljaXBhbnRTaWQsIHJlYXNvbik7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICBjb25zdCBydGNDb25maWcgPSB0aGlzLm1ha2VSVENDb25maWd1cmF0aW9uKHJlcyk7XG4gICAgICAgICAgdGhpcy5wY01hbmFnZXIudXBkYXRlQ29uZmlndXJhdGlvbihydGNDb25maWcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsZXQgbWVzc2FnZSA9ICcnO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgIHRoaXMubG9nLmVycm9yKGVycm9yLm1lc3NhZ2UsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGVycm9yLnJlYXNvbiA9PT0gMCAvKiBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCAqLykge1xuICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjb3VsZCBub3QgcmVjb25uZWN0LCB0b2tlbiBtaWdodCBiZSBleHBpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGVycm9yLnJlYXNvbiA9PT0gNCAvKiBDb25uZWN0aW9uRXJyb3JSZWFzb24uTGVhdmVSZXF1ZXN0ICovKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlNpZ25hbFJlc3VtZWQpO1xuICAgICAgaWYgKHRoaXMuc2hvdWxkRmFpbE5leHQpIHtcbiAgICAgICAgdGhpcy5zaG91bGRGYWlsTmV4dCA9IGZhbHNlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpbXVsYXRlZCBmYWlsdXJlJyk7XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLnBjTWFuYWdlci50cmlnZ2VySWNlUmVzdGFydCgpO1xuICAgICAgeWllbGQgdGhpcy53YWl0Rm9yUENSZWNvbm5lY3RlZCgpO1xuICAgICAgLy8gcmUtY2hlY2sgc2lnbmFsIGNvbm5lY3Rpb24gc3RhdGUgYmVmb3JlIHNldHRpbmcgZW5naW5lIGFzIHJlc3VtZWRcbiAgICAgIGlmICh0aGlzLmNsaWVudC5jdXJyZW50U3RhdGUgIT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKCdTaWduYWwgY29ubmVjdGlvbiBnb3Qgc2V2ZXJlZCBkdXJpbmcgcmVjb25uZWN0Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsaWVudC5zZXRSZWNvbm5lY3RlZCgpO1xuICAgICAgLy8gcmVjcmVhdGUgcHVibGlzaCBkYXRhY2hhbm5lbCBpZiBpdCdzIGlkIGlzIG51bGxcbiAgICAgIC8vIChmb3Igc2FmYXJpIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xODQ2ODgpXG4gICAgICBpZiAoKChfYSA9IHRoaXMucmVsaWFibGVEQykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWR5U3RhdGUpID09PSAnb3BlbicgJiYgdGhpcy5yZWxpYWJsZURDLmlkID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlRGF0YUNoYW5uZWxzKCk7XG4gICAgICB9XG4gICAgICAvLyByZXN1bWUgc3VjY2Vzc1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJlc3VtZWQpO1xuICAgIH0pO1xuICB9XG4gIHdhaXRGb3JQQ0luaXRpYWxDb25uZWN0aW9uKHRpbWVvdXQsIGFib3J0Q29udHJvbGxlcikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdQQyBtYW5hZ2VyIGlzIGNsb3NlZCcpO1xuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5wY01hbmFnZXIuZW5zdXJlUENUcmFuc3BvcnRDb25uZWN0aW9uKGFib3J0Q29udHJvbGxlciwgdGltZW91dCk7XG4gICAgfSk7XG4gIH1cbiAgd2FpdEZvclBDUmVjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuUmVjb25uZWN0aW5nO1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3dhaXRpbmcgZm9yIHBlZXIgY29ubmVjdGlvbiB0byByZWNvbm5lY3QnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgc2xlZXAobWluUmVjb25uZWN0V2FpdCk7IC8vIEZJWE1FIHNldFRpbWVvdXQgYWdhaW4gbm90IGlkZWFsIGZvciBhIGNvbm5lY3Rpb24gY3JpdGljYWwgcGF0aFxuICAgICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgdGhpcy5wY01hbmFnZXIuZW5zdXJlUENUcmFuc3BvcnRDb25uZWN0aW9uKHVuZGVmaW5lZCwgdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQpO1xuICAgICAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLkNvbm5lY3RlZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gVE9ETyBkbyB3ZSBuZWVkIGEgYGZhaWxlZGAgc3RhdGUgaGVyZSBmb3IgdGhlIFBDP1xuICAgICAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLkRpc2Nvbm5lY3RlZDtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihcImNvdWxkIG5vdCBlc3RhYmxpc2ggUEMgY29ubmVjdGlvbiwgXCIuY29uY2F0KGUubWVzc2FnZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzZW5kRGF0YVBhY2tldChwYWNrZXQsIGtpbmQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgbXNnID0gcGFja2V0LnRvQmluYXJ5KCk7XG4gICAgICAvLyBtYWtlIHN1cmUgd2UgZG8gaGF2ZSBhIGRhdGEgY29ubmVjdGlvblxuICAgICAgeWllbGQgdGhpcy5lbnN1cmVQdWJsaXNoZXJDb25uZWN0ZWQoa2luZCk7XG4gICAgICBjb25zdCBkYyA9IHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQpO1xuICAgICAgaWYgKGRjKSB7XG4gICAgICAgIGRjLnNlbmQobXNnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlQW5kRW1pdERDQnVmZmVyU3RhdHVzKGtpbmQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVuc3VyZURhdGFUcmFuc3BvcnRDb25uZWN0ZWQoa2luZCkge1xuICAgIGxldCBzdWJzY3JpYmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnN1YnNjcmliZXJQcmltYXJ5O1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgbWFuYWdlciBpcyBjbG9zZWQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IHN1YnNjcmliZXIgPyB0aGlzLnBjTWFuYWdlci5zdWJzY3JpYmVyIDogdGhpcy5wY01hbmFnZXIucHVibGlzaGVyO1xuICAgICAgY29uc3QgdHJhbnNwb3J0TmFtZSA9IHN1YnNjcmliZXIgPyAnU3Vic2NyaWJlcicgOiAnUHVibGlzaGVyJztcbiAgICAgIGlmICghdHJhbnNwb3J0KSB7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJcIi5jb25jYXQodHJhbnNwb3J0TmFtZSwgXCIgY29ubmVjdGlvbiBub3Qgc2V0XCIpKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3Vic2NyaWJlciAmJiAhdGhpcy5wY01hbmFnZXIucHVibGlzaGVyLmlzSUNFQ29ubmVjdGVkICYmIHRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlci5nZXRJQ0VDb25uZWN0aW9uU3RhdGUoKSAhPT0gJ2NoZWNraW5nJykge1xuICAgICAgICAvLyBzdGFydCBuZWdvdGlhdGlvblxuICAgICAgICB0aGlzLm5lZ290aWF0ZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0Q2hhbm5lbCA9IHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQsIHN1YnNjcmliZXIpO1xuICAgICAgaWYgKCh0YXJnZXRDaGFubmVsID09PSBudWxsIHx8IHRhcmdldENoYW5uZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldENoYW5uZWwucmVhZHlTdGF0ZSkgPT09ICdvcGVuJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyB3YWl0IHVudGlsIElDRSBjb25uZWN0ZWRcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0O1xuICAgICAgd2hpbGUgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIDwgZW5kVGltZSkge1xuICAgICAgICBpZiAodHJhbnNwb3J0LmlzSUNFQ29ubmVjdGVkICYmICgoX2EgPSB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChraW5kLCBzdWJzY3JpYmVyKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWR5U3RhdGUpID09PSAnb3BlbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgc2xlZXAoNTApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihcImNvdWxkIG5vdCBlc3RhYmxpc2ggXCIuY29uY2F0KHRyYW5zcG9ydE5hbWUsIFwiIGNvbm5lY3Rpb24sIHN0YXRlOiBcIikuY29uY2F0KHRyYW5zcG9ydC5nZXRJQ0VDb25uZWN0aW9uU3RhdGUoKSkpO1xuICAgIH0pO1xuICB9XG4gIGVuc3VyZVB1Ymxpc2hlckNvbm5lY3RlZChraW5kKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIHRoaXMuZW5zdXJlRGF0YVRyYW5zcG9ydENvbm5lY3RlZChraW5kLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHZlcmlmeVRyYW5zcG9ydCgpIHtcbiAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHByaW1hcnkgY29ubmVjdGlvblxuICAgIGlmICh0aGlzLnBjTWFuYWdlci5jdXJyZW50U3RhdGUgIT09IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGVuc3VyZSBzaWduYWwgaXMgY29ubmVjdGVkXG4gICAgaWYgKCF0aGlzLmNsaWVudC53cyB8fCB0aGlzLmNsaWVudC53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgbmVnb3RpYXRlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBvYnNlcnZlIHNpZ25hbCBzdGF0ZVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICAgIHJlamVjdChuZXcgTmVnb3RpYXRpb25FcnJvcignUEMgbWFuYWdlciBpcyBjbG9zZWQnKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGNNYW5hZ2VyLnJlcXVpcmVQdWJsaXNoZXIoKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCBoYW5kbGVDbG9zZWQgPSAoKSA9PiB7XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2VuZ2luZSBkaXNjb25uZWN0ZWQgd2hpbGUgbmVnb3RpYXRpb24gd2FzIG9uZ29pbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgcmVqZWN0KCdjYW5ub3QgbmVnb3RpYXRlIG9uIGNsb3NlZCBlbmdpbmUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uKEVuZ2luZUV2ZW50LkNsb3NpbmcsIGhhbmRsZUNsb3NlZCk7XG4gICAgICAgIHRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlci5vbmNlKFBDRXZlbnRzLlJUUFZpZGVvUGF5bG9hZFR5cGVzLCBydHBUeXBlcyA9PiB7XG4gICAgICAgICAgY29uc3QgcnRwTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHJ0cFR5cGVzLmZvckVhY2gocnRwID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjID0gcnRwLmNvZGVjLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoaXNWaWRlb0NvZGVjKGNvZGVjKSkge1xuICAgICAgICAgICAgICBydHBNYXAuc2V0KHJ0cC5wYXlsb2FkLCBjb2RlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJUUFZpZGVvTWFwVXBkYXRlLCBydHBNYXApO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnBjTWFuYWdlci5uZWdvdGlhdGUoYWJvcnRDb250cm9sbGVyKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIE5lZ290aWF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgnbmVnb3RpYXRpb24nLCBSZWNvbm5lY3RSZWFzb24uUlJfVU5LTk9XTik7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRoaXMub2ZmKEVuZ2luZUV2ZW50LkNsb3NpbmcsIGhhbmRsZUNsb3NlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfVxuICBkYXRhQ2hhbm5lbEZvcktpbmQoa2luZCwgc3ViKSB7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuTE9TU1kpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9zc3lEQztcbiAgICAgIH1cbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsaWFibGVEQztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5MT1NTWSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb3NzeURDU3ViO1xuICAgICAgfVxuICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWxpYWJsZURDU3ViO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNlbmRTeW5jU3RhdGUocmVtb3RlVHJhY2tzLCBsb2NhbFRyYWNrcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgdGhpcy5sb2cud2Fybignc3luYyBzdGF0ZSBjYW5ub3QgYmUgc2VudCB3aXRob3V0IHBlZXIgY29ubmVjdGlvbiBzZXR1cCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByZXZpb3VzQW5zd2VyID0gdGhpcy5wY01hbmFnZXIuc3Vic2NyaWJlci5nZXRMb2NhbERlc2NyaXB0aW9uKCk7XG4gICAgY29uc3QgcHJldmlvdXNPZmZlciA9IHRoaXMucGNNYW5hZ2VyLnN1YnNjcmliZXIuZ2V0UmVtb3RlRGVzY3JpcHRpb24oKTtcbiAgICAvKiAxLiBhdXRvc3Vic2NyaWJlIG9uLCBzbyBzdWJzY3JpYmVkIHRyYWNrcyA9IGFsbCB0cmFja3MgLSB1bnN1YiB0cmFja3MsXG4gICAgICAgICAgaW4gdGhpcyBjYXNlLCB3ZSBzZW5kIHVuc3ViIHRyYWNrcywgc28gc2VydmVyIGFkZCBhbGwgdHJhY2tzIHRvIHRoaXNcbiAgICAgICAgICBzdWJzY3JpYmUgcGMgYW5kIHVuc3ViIHNwZWNpYWwgdHJhY2tzIGZyb20gaXQuXG4gICAgICAgMi4gYXV0b3N1YnNjcmliZSBvZmYsIHdlIHNlbmQgc3Vic2NyaWJlZCB0cmFja3MuXG4gICAgKi9cbiAgICBjb25zdCBhdXRvU3Vic2NyaWJlID0gKF9iID0gKF9hID0gdGhpcy5zaWduYWxPcHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXV0b1N1YnNjcmliZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcbiAgICBjb25zdCB0cmFja1NpZHMgPSBuZXcgQXJyYXkoKTtcbiAgICByZW1vdGVUcmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBpZiAodHJhY2suaXNEZXNpcmVkICE9PSBhdXRvU3Vic2NyaWJlKSB7XG4gICAgICAgIHRyYWNrU2lkcy5wdXNoKHRyYWNrLnRyYWNrU2lkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmNsaWVudC5zZW5kU3luY1N0YXRlKG5ldyBTeW5jU3RhdGUoe1xuICAgICAgYW5zd2VyOiBwcmV2aW91c0Fuc3dlciA/IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICBzZHA6IHByZXZpb3VzQW5zd2VyLnNkcCxcbiAgICAgICAgdHlwZTogcHJldmlvdXNBbnN3ZXIudHlwZVxuICAgICAgfSkgOiB1bmRlZmluZWQsXG4gICAgICBvZmZlcjogcHJldmlvdXNPZmZlciA/IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICBzZHA6IHByZXZpb3VzT2ZmZXIuc2RwLFxuICAgICAgICB0eXBlOiBwcmV2aW91c09mZmVyLnR5cGVcbiAgICAgIH0pIDogdW5kZWZpbmVkLFxuICAgICAgc3Vic2NyaXB0aW9uOiBuZXcgVXBkYXRlU3Vic2NyaXB0aW9uKHtcbiAgICAgICAgdHJhY2tTaWRzLFxuICAgICAgICBzdWJzY3JpYmU6ICFhdXRvU3Vic2NyaWJlLFxuICAgICAgICBwYXJ0aWNpcGFudFRyYWNrczogW11cbiAgICAgIH0pLFxuICAgICAgcHVibGlzaFRyYWNrczogZ2V0VHJhY2tQdWJsaWNhdGlvbkluZm8obG9jYWxUcmFja3MpLFxuICAgICAgZGF0YUNoYW5uZWxzOiB0aGlzLmRhdGFDaGFubmVsc0luZm8oKVxuICAgIH0pKTtcbiAgfVxuICAvKiBAaW50ZXJuYWwgKi9cbiAgZmFpbE5leHQoKSB7XG4gICAgLy8gZGVidWdnaW5nIG1ldGhvZCB0byBmYWlsIHRoZSBuZXh0IHJlY29ubmVjdC9yZXN1bWUgYXR0ZW1wdFxuICAgIHRoaXMuc2hvdWxkRmFpbE5leHQgPSB0cnVlO1xuICB9XG4gIGRhdGFDaGFubmVsc0luZm8oKSB7XG4gICAgY29uc3QgaW5mb3MgPSBbXTtcbiAgICBjb25zdCBnZXRJbmZvID0gKGRjLCB0YXJnZXQpID0+IHtcbiAgICAgIGlmICgoZGMgPT09IG51bGwgfHwgZGMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRjLmlkKSAhPT0gdW5kZWZpbmVkICYmIGRjLmlkICE9PSBudWxsKSB7XG4gICAgICAgIGluZm9zLnB1c2gobmV3IERhdGFDaGFubmVsSW5mbyh7XG4gICAgICAgICAgbGFiZWw6IGRjLmxhYmVsLFxuICAgICAgICAgIGlkOiBkYy5pZCxcbiAgICAgICAgICB0YXJnZXRcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgZ2V0SW5mbyh0aGlzLmRhdGFDaGFubmVsRm9yS2luZChEYXRhUGFja2V0X0tpbmQuTE9TU1kpLCBTaWduYWxUYXJnZXQuUFVCTElTSEVSKTtcbiAgICBnZXRJbmZvKHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSksIFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpO1xuICAgIGdldEluZm8odGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLkxPU1NZLCB0cnVlKSwgU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpO1xuICAgIGdldEluZm8odGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLCB0cnVlKSwgU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpO1xuICAgIHJldHVybiBpbmZvcztcbiAgfVxuICBjbGVhclJlY29ubmVjdFRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgQ3JpdGljYWxUaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgfVxuICB9XG4gIGNsZWFyUGVuZGluZ1JlY29ubmVjdCgpIHtcbiAgICB0aGlzLmNsZWFyUmVjb25uZWN0VGltZW91dCgpO1xuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICB9XG4gIHJlZ2lzdGVyT25MaW5lTGlzdGVuZXIoKSB7XG4gICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCB0aGlzLmhhbmRsZUJyb3dzZXJPbkxpbmUpO1xuICAgIH1cbiAgfVxuICBkZXJlZ2lzdGVyT25MaW5lTGlzdGVuZXIoKSB7XG4gICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvbmxpbmUnLCB0aGlzLmhhbmRsZUJyb3dzZXJPbkxpbmUpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgU2lnbmFsUmVjb25uZWN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5jbGFzcyBSZWdpb25VcmxQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKHVybCwgdG9rZW4pIHtcbiAgICB0aGlzLmxhc3RVcGRhdGVBdCA9IDA7XG4gICAgdGhpcy5zZXR0aW5nc0NhY2hlVGltZSA9IDMwMDA7XG4gICAgdGhpcy5hdHRlbXB0ZWRSZWdpb25zID0gW107XG4gICAgdGhpcy5zZXJ2ZXJVcmwgPSBuZXcgVVJMKHVybCk7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICB9XG4gIHVwZGF0ZVRva2VuKHRva2VuKSB7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICB9XG4gIGlzQ2xvdWQoKSB7XG4gICAgcmV0dXJuIGlzQ2xvdWQodGhpcy5zZXJ2ZXJVcmwpO1xuICB9XG4gIGdldFNlcnZlclVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2ZXJVcmw7XG4gIH1cbiAgZ2V0TmV4dEJlc3RSZWdpb25VcmwoYWJvcnRTaWduYWwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLmlzQ2xvdWQoKSkge1xuICAgICAgICB0aHJvdyBFcnJvcigncmVnaW9uIGF2YWlsYWJpbGl0eSBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgTGl2ZUtpdCBDbG91ZCBkb21haW5zJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucmVnaW9uU2V0dGluZ3MgfHwgRGF0ZS5ub3coKSAtIHRoaXMubGFzdFVwZGF0ZUF0ID4gdGhpcy5zZXR0aW5nc0NhY2hlVGltZSkge1xuICAgICAgICB0aGlzLnJlZ2lvblNldHRpbmdzID0geWllbGQgdGhpcy5mZXRjaFJlZ2lvblNldHRpbmdzKGFib3J0U2lnbmFsKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlZ2lvbnNMZWZ0ID0gdGhpcy5yZWdpb25TZXR0aW5ncy5yZWdpb25zLmZpbHRlcihyZWdpb24gPT4gIXRoaXMuYXR0ZW1wdGVkUmVnaW9ucy5maW5kKGF0dGVtcHRlZCA9PiBhdHRlbXB0ZWQudXJsID09PSByZWdpb24udXJsKSk7XG4gICAgICBpZiAocmVnaW9uc0xlZnQubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBuZXh0UmVnaW9uID0gcmVnaW9uc0xlZnRbMF07XG4gICAgICAgIHRoaXMuYXR0ZW1wdGVkUmVnaW9ucy5wdXNoKG5leHRSZWdpb24pO1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwibmV4dCByZWdpb246IFwiLmNvbmNhdChuZXh0UmVnaW9uLnJlZ2lvbikpO1xuICAgICAgICByZXR1cm4gbmV4dFJlZ2lvbi51cmw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXNldEF0dGVtcHRzKCkge1xuICAgIHRoaXMuYXR0ZW1wdGVkUmVnaW9ucyA9IFtdO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBmZXRjaFJlZ2lvblNldHRpbmdzKHNpZ25hbCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCByZWdpb25TZXR0aW5nc1Jlc3BvbnNlID0geWllbGQgZmV0Y2goXCJcIi5jb25jYXQoZ2V0Q2xvdWRDb25maWdVcmwodGhpcy5zZXJ2ZXJVcmwpLCBcIi9yZWdpb25zXCIpLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBhdXRob3JpemF0aW9uOiBcIkJlYXJlciBcIi5jb25jYXQodGhpcy50b2tlbilcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGlmIChyZWdpb25TZXR0aW5nc1Jlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IHJlZ2lvblNldHRpbmdzID0geWllbGQgcmVnaW9uU2V0dGluZ3NSZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHRoaXMubGFzdFVwZGF0ZUF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlZ2lvblNldHRpbmdzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihcIkNvdWxkIG5vdCBmZXRjaCByZWdpb24gc2V0dGluZ3M6IFwiLmNvbmNhdChyZWdpb25TZXR0aW5nc1Jlc3BvbnNlLnN0YXR1c1RleHQpLCByZWdpb25TZXR0aW5nc1Jlc3BvbnNlLnN0YXR1cyA9PT0gNDAxID8gMCAvKiBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCAqLyA6IHVuZGVmaW5lZCwgcmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDbG91ZENvbmZpZ1VybChzZXJ2ZXJVcmwpIHtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHNlcnZlclVybC5wcm90b2NvbC5yZXBsYWNlKCd3cycsICdodHRwJyksIFwiLy9cIikuY29uY2F0KHNlcnZlclVybC5ob3N0LCBcIi9zZXR0aW5nc1wiKTtcbn1cblxuY29uc3QgbW9uaXRvckZyZXF1ZW5jeSA9IDIwMDA7XG5mdW5jdGlvbiBjb21wdXRlQml0cmF0ZShjdXJyZW50U3RhdHMsIHByZXZTdGF0cykge1xuICBpZiAoIXByZXZTdGF0cykge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCBieXRlc05vdztcbiAgbGV0IGJ5dGVzUHJldjtcbiAgaWYgKCdieXRlc1JlY2VpdmVkJyBpbiBjdXJyZW50U3RhdHMpIHtcbiAgICBieXRlc05vdyA9IGN1cnJlbnRTdGF0cy5ieXRlc1JlY2VpdmVkO1xuICAgIGJ5dGVzUHJldiA9IHByZXZTdGF0cy5ieXRlc1JlY2VpdmVkO1xuICB9IGVsc2UgaWYgKCdieXRlc1NlbnQnIGluIGN1cnJlbnRTdGF0cykge1xuICAgIGJ5dGVzTm93ID0gY3VycmVudFN0YXRzLmJ5dGVzU2VudDtcbiAgICBieXRlc1ByZXYgPSBwcmV2U3RhdHMuYnl0ZXNTZW50O1xuICB9XG4gIGlmIChieXRlc05vdyA9PT0gdW5kZWZpbmVkIHx8IGJ5dGVzUHJldiA9PT0gdW5kZWZpbmVkIHx8IGN1cnJlbnRTdGF0cy50aW1lc3RhbXAgPT09IHVuZGVmaW5lZCB8fCBwcmV2U3RhdHMudGltZXN0YW1wID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gKGJ5dGVzTm93IC0gYnl0ZXNQcmV2KSAqIDggKiAxMDAwIC8gKGN1cnJlbnRTdGF0cy50aW1lc3RhbXAgLSBwcmV2U3RhdHMudGltZXN0YW1wKTtcbn1cblxuY2xhc3MgTG9jYWxBdWRpb1RyYWNrIGV4dGVuZHMgTG9jYWxUcmFjayB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gbWVkaWFUcmFja1xuICAgKiBAcGFyYW0gY29uc3RyYWludHMgTWVkaWFUcmFja0NvbnN0cmFpbnRzIHRoYXQgYXJlIGJlaW5nIHVzZWQgd2hlbiByZXN0YXJ0aW5nIG9yIHJlYWNxdWlyaW5nIHRyYWNrc1xuICAgKiBAcGFyYW0gdXNlclByb3ZpZGVkVHJhY2sgU2lnbmFscyB0byB0aGUgU0RLIHdoZXRoZXIgb3Igbm90IHRoZSBtZWRpYVRyYWNrIHNob3VsZCBiZSBtYW5hZ2VkIChpLmUuIHJlbGVhc2VkIGFuZCByZWFjcXVpcmVkKSBpbnRlcm5hbGx5IGJ5IHRoZSBTREtcbiAgICovXG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIGNvbnN0cmFpbnRzKSB7XG4gICAgbGV0IHVzZXJQcm92aWRlZFRyYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgIGxldCBhdWRpb0NvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIFRyYWNrLktpbmQuQXVkaW8sIGNvbnN0cmFpbnRzLCB1c2VyUHJvdmlkZWRUcmFjaywgbG9nZ2VyT3B0aW9ucyk7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuc3RvcE9uTXV0ZSA9IGZhbHNlO1xuICAgIHRoaXMubW9uaXRvclNlbmRlciA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3RhdHM7XG4gICAgICB0cnkge1xuICAgICAgICBzdGF0cyA9IHlpZWxkIHRoaXMuZ2V0U2VuZGVyU3RhdHMoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBnZXQgYXVkaW8gc2VuZGVyIHN0YXRzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc3RhdHMgJiYgdGhpcy5wcmV2U3RhdHMpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSBjb21wdXRlQml0cmF0ZShzdGF0cywgdGhpcy5wcmV2U3RhdHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcbiAgICB9KTtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgICB0aGlzLmNoZWNrRm9yU2lsZW5jZSgpO1xuICB9XG4gIHNldERldmljZUlkKGRldmljZUlkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCA9PT0gZGV2aWNlSWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCA9IGRldmljZUlkO1xuICAgICAgaWYgKCF0aGlzLmlzTXV0ZWQpIHtcbiAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmlzTXV0ZWQgfHwgdW53cmFwQ29uc3RyYWludChkZXZpY2VJZCkgPT09IHRoaXMubWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkO1xuICAgIH0pO1xuICB9XG4gIG11dGUoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBtdXRlOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIubXV0ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLm11dGVMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIGRpc2FibGVkIHNwZWNpYWwgaGFuZGxpbmcgYXMgaXQgd2lsbCBjYXVzZSBCVCBoZWFkc2V0cyB0byBzd2l0Y2ggY29tbXVuaWNhdGlvbiBtb2Rlc1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lICYmIHRoaXMuc3RvcE9uTXV0ZSAmJiAhdGhpcy5pc1VzZXJQcm92aWRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdzdG9wcGluZyBtaWMgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIC8vIGFsc28gc3RvcCB0aGUgdHJhY2ssIHNvIHRoYXQgbWljcm9waG9uZSBpbmRpY2F0b3IgaXMgdHVybmVkIG9mZlxuICAgICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIF9zdXBlci5tdXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdW5tdXRlKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgdW5tdXRlOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIudW5tdXRlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMubXV0ZUxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGV2aWNlSGFzQ2hhbmdlZCA9IHRoaXMuX2NvbnN0cmFpbnRzLmRldmljZUlkICYmIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZCAhPT0gdW53cmFwQ29uc3RyYWludCh0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCk7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUgJiYgKHRoaXMuc3RvcE9uTXV0ZSB8fCB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlYWR5U3RhdGUgPT09ICdlbmRlZCcgfHwgZGV2aWNlSGFzQ2hhbmdlZCkgJiYgIXRoaXMuaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVhY3F1aXJpbmcgbWljIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnRUcmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIF9zdXBlci51bm11dGUuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXN0YXJ0VHJhY2sob3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsZXQgY29uc3RyYWludHM7XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IGNvbnN0cmFpbnRzRm9yT3B0aW9ucyh7XG4gICAgICAgICAgYXVkaW86IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtQ29uc3RyYWludHMuYXVkaW8gIT09ICdib29sZWFuJykge1xuICAgICAgICAgIGNvbnN0cmFpbnRzID0gc3RyZWFtQ29uc3RyYWludHMuYXVkaW87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMucmVzdGFydChjb25zdHJhaW50cyk7XG4gICAgfSk7XG4gIH1cbiAgcmVzdGFydChjb25zdHJhaW50cykge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgcmVzdGFydDoge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLnJlc3RhcnRcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdHJhY2sgPSB5aWVsZCBfc3VwZXIucmVzdGFydC5jYWxsKHRoaXMsIGNvbnN0cmFpbnRzKTtcbiAgICAgIHRoaXMuY2hlY2tGb3JTaWxlbmNlKCk7XG4gICAgICByZXR1cm4gdHJhY2s7XG4gICAgfSk7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHN0YXJ0TW9uaXRvcigpIHtcbiAgICBpZiAoIWlzV2ViKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9uaXRvckludGVydmFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubW9uaXRvckludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5tb25pdG9yU2VuZGVyKCk7XG4gICAgfSwgbW9uaXRvckZyZXF1ZW5jeSk7XG4gIH1cbiAgc2V0UHJvY2Vzc29yKHByb2Nlc3Nvcikge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5wcm9jZXNzb3JMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghdGhpcy5hdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignQXVkaW8gY29udGV4dCBuZWVkcyB0byBiZSBzZXQgb24gTG9jYWxBdWRpb1RyYWNrIGluIG9yZGVyIHRvIGVuYWJsZSBwcm9jZXNzb3JzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc29yKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5zdG9wUHJvY2Vzc29yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMua2luZCA9PT0gJ3Vua25vd24nKSB7XG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdjYW5ub3Qgc2V0IHByb2Nlc3NvciBvbiB0cmFjayBvZiB1bmtub3duIGtpbmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9jZXNzb3JPcHRpb25zID0ge1xuICAgICAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgICAgICB0cmFjazogdGhpcy5fbWVkaWFTdHJlYW1UcmFjayxcbiAgICAgICAgICBhdWRpb0NvbnRleHQ6IHRoaXMuYXVkaW9Db250ZXh0XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwic2V0dGluZyB1cCBhdWRpbyBwcm9jZXNzb3IgXCIuY29uY2F0KHByb2Nlc3Nvci5uYW1lKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgeWllbGQgcHJvY2Vzc29yLmluaXQocHJvY2Vzc29yT3B0aW9ucyk7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spIHtcbiAgICAgICAgICB5aWVsZCAoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2VUcmFjayh0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc2V0QXVkaW9Db250ZXh0KGF1ZGlvQ29udGV4dCkge1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0O1xuICB9XG4gIGdldFNlbmRlclN0YXRzKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCEoKF9hID0gdGhpcy5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTdGF0cykpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5zZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICAgIGxldCBhdWRpb1N0YXRzO1xuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gJ291dGJvdW5kLXJ0cCcpIHtcbiAgICAgICAgICBhdWRpb1N0YXRzID0ge1xuICAgICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgICAgIHN0cmVhbUlkOiB2LmlkLFxuICAgICAgICAgICAgcGFja2V0c1NlbnQ6IHYucGFja2V0c1NlbnQsXG4gICAgICAgICAgICBwYWNrZXRzTG9zdDogdi5wYWNrZXRzTG9zdCxcbiAgICAgICAgICAgIGJ5dGVzU2VudDogdi5ieXRlc1NlbnQsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxuICAgICAgICAgICAgcm91bmRUcmlwVGltZTogdi5yb3VuZFRyaXBUaW1lLFxuICAgICAgICAgICAgaml0dGVyOiB2LmppdHRlclxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGF1ZGlvU3RhdHM7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tGb3JTaWxlbmNlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB0cmFja0lzU2lsZW50ID0geWllbGQgZGV0ZWN0U2lsZW5jZSh0aGlzKTtcbiAgICAgIGlmICh0cmFja0lzU2lsZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5pc011dGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2Fybignc2lsZW5jZSBkZXRlY3RlZCBvbiBsb2NhbCBhdWRpbyB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuQXVkaW9TaWxlbmNlRGV0ZWN0ZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYWNrSXNTaWxlbnQ7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gbWVkaWFUcmFja1RvTG9jYWxUcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBjb25zdHJhaW50cywgbG9nZ2VyT3B0aW9ucykge1xuICBzd2l0Y2ggKG1lZGlhU3RyZWFtVHJhY2sua2luZCkge1xuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIHJldHVybiBuZXcgTG9jYWxBdWRpb1RyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIGNvbnN0cmFpbnRzLCBmYWxzZSwgdW5kZWZpbmVkLCBsb2dnZXJPcHRpb25zKTtcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgICByZXR1cm4gbmV3IExvY2FsVmlkZW9UcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBjb25zdHJhaW50cywgZmFsc2UsIGxvZ2dlck9wdGlvbnMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoXCJ1bnN1cHBvcnRlZCB0cmFjayB0eXBlOiBcIi5jb25jYXQobWVkaWFTdHJlYW1UcmFjay5raW5kKSk7XG4gIH1cbn1cbi8qIEBpbnRlcm5hbCAqL1xuY29uc3QgcHJlc2V0czE2OSA9IE9iamVjdC52YWx1ZXMoVmlkZW9QcmVzZXRzKTtcbi8qIEBpbnRlcm5hbCAqL1xuY29uc3QgcHJlc2V0czQzID0gT2JqZWN0LnZhbHVlcyhWaWRlb1ByZXNldHM0Myk7XG4vKiBAaW50ZXJuYWwgKi9cbmNvbnN0IHByZXNldHNTY3JlZW5TaGFyZSA9IE9iamVjdC52YWx1ZXMoU2NyZWVuU2hhcmVQcmVzZXRzKTtcbi8qIEBpbnRlcm5hbCAqL1xuY29uc3QgZGVmYXVsdFNpbXVsY2FzdFByZXNldHMxNjkgPSBbVmlkZW9QcmVzZXRzLmgxODAsIFZpZGVvUHJlc2V0cy5oMzYwXTtcbi8qIEBpbnRlcm5hbCAqL1xuY29uc3QgZGVmYXVsdFNpbXVsY2FzdFByZXNldHM0MyA9IFtWaWRlb1ByZXNldHM0My5oMTgwLCBWaWRlb1ByZXNldHM0My5oMzYwXTtcbi8qIEBpbnRlcm5hbCAqL1xuY29uc3QgY29tcHV0ZURlZmF1bHRTY3JlZW5TaGFyZVNpbXVsY2FzdFByZXNldHMgPSBmcm9tUHJlc2V0ID0+IHtcbiAgY29uc3QgbGF5ZXJzID0gW3tcbiAgICBzY2FsZVJlc29sdXRpb25Eb3duQnk6IDIsXG4gICAgZnBzOiBmcm9tUHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZVxuICB9XTtcbiAgcmV0dXJuIGxheWVycy5tYXAodCA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gbmV3IFZpZGVvUHJlc2V0KE1hdGguZmxvb3IoZnJvbVByZXNldC53aWR0aCAvIHQuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSwgTWF0aC5mbG9vcihmcm9tUHJlc2V0LmhlaWdodCAvIHQuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSwgTWF0aC5tYXgoMTUwMDAwLCBNYXRoLmZsb29yKGZyb21QcmVzZXQuZW5jb2RpbmcubWF4Qml0cmF0ZSAvIChNYXRoLnBvdyh0LnNjYWxlUmVzb2x1dGlvbkRvd25CeSwgMikgKiAoKChfYSA9IGZyb21QcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAzMCkgLyAoKF9iID0gdC5mcHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDMwKSkpKSksIHQuZnBzLCBmcm9tUHJlc2V0LmVuY29kaW5nLnByaW9yaXR5KTtcbiAgfSk7XG59O1xuLy8gLyoqXG4vLyAgKlxuLy8gICogQGludGVybmFsXG4vLyAgKiBAZXhwZXJpbWVudGFsXG4vLyAgKi9cbi8vIGNvbnN0IGNvbXB1dGVEZWZhdWx0TXVsdGlDb2RlY1NpbXVsY2FzdEVuY29kaW5ncyA9ICh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikgPT4ge1xuLy8gICAvLyB1c2UgdnA4IGFzIGEgZGVmYXVsdFxuLy8gICBjb25zdCB2cDggPSBkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nKGZhbHNlLCB3aWR0aCwgaGVpZ2h0KTtcbi8vICAgY29uc3QgdnA5ID0geyAuLi52cDgsIG1heEJpdHJhdGU6IHZwOC5tYXhCaXRyYXRlICogMC45IH07XG4vLyAgIGNvbnN0IGgyNjQgPSB7IC4uLnZwOCwgbWF4Qml0cmF0ZTogdnA4Lm1heEJpdHJhdGUgKiAxLjEgfTtcbi8vICAgY29uc3QgYXYxID0geyAuLi52cDgsIG1heEJpdHJhdGU6IHZwOC5tYXhCaXRyYXRlICogMC43IH07XG4vLyAgIHJldHVybiB7XG4vLyAgICAgdnA4LFxuLy8gICAgIHZwOSxcbi8vICAgICBoMjY0LFxuLy8gICAgIGF2MSxcbi8vICAgfTtcbi8vIH07XG5jb25zdCB2aWRlb1JpZHMgPSBbJ3EnLCAnaCcsICdmJ107XG4vKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGNvbXB1dGVWaWRlb0VuY29kaW5ncyhpc1NjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gIHZhciBfYSwgX2I7XG4gIGxldCB2aWRlb0VuY29kaW5nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZpZGVvRW5jb2Rpbmc7XG4gIGlmIChpc1NjcmVlblNoYXJlKSB7XG4gICAgdmlkZW9FbmNvZGluZyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY3JlZW5TaGFyZUVuY29kaW5nO1xuICB9XG4gIGNvbnN0IHVzZVNpbXVsY2FzdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaW11bGNhc3Q7XG4gIGNvbnN0IHNjYWxhYmlsaXR5TW9kZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY2FsYWJpbGl0eU1vZGU7XG4gIGNvbnN0IHZpZGVvQ29kZWMgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmlkZW9Db2RlYztcbiAgaWYgKCF2aWRlb0VuY29kaW5nICYmICF1c2VTaW11bGNhc3QgJiYgIXNjYWxhYmlsaXR5TW9kZSB8fCAhd2lkdGggfHwgIWhlaWdodCkge1xuICAgIC8vIHdoZW4gd2UgYXJlbid0IHNpbXVsY2FzdGluZyBvciBzdmMsIHdpbGwgbmVlZCB0byByZXR1cm4gYSBzaW5nbGUgZW5jb2Rpbmcgd2l0aG91dFxuICAgIC8vIGNhcHBpbmcgYmFuZHdpZHRoLiB3ZSBhbHdheXMgcmVxdWlyZSBhIGVuY29kaW5nIGZvciBkeW5hY2FzdFxuICAgIHJldHVybiBbe31dO1xuICB9XG4gIGlmICghdmlkZW9FbmNvZGluZykge1xuICAgIC8vIGZpbmQgdGhlIHJpZ2h0IGVuY29kaW5nIGJhc2VkIG9uIHdpZHRoL2hlaWdodFxuICAgIHZpZGVvRW5jb2RpbmcgPSBkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQsIHZpZGVvQ29kZWMpO1xuICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3VzaW5nIHZpZGVvIGVuY29kaW5nJywgdmlkZW9FbmNvZGluZyk7XG4gIH1cbiAgY29uc3Qgb3JpZ2luYWwgPSBuZXcgVmlkZW9QcmVzZXQod2lkdGgsIGhlaWdodCwgdmlkZW9FbmNvZGluZy5tYXhCaXRyYXRlLCB2aWRlb0VuY29kaW5nLm1heEZyYW1lcmF0ZSwgdmlkZW9FbmNvZGluZy5wcmlvcml0eSk7XG4gIGlmIChzY2FsYWJpbGl0eU1vZGUgJiYgaXNTVkNDb2RlYyh2aWRlb0NvZGVjKSkge1xuICAgIGxpdmVraXRMb2dnZXIuZGVidWcoXCJ1c2luZyBzdmMgd2l0aCBzY2FsYWJpbGl0eU1vZGUgXCIuY29uY2F0KHNjYWxhYmlsaXR5TW9kZSkpO1xuICAgIGNvbnN0IHNtID0gbmV3IFNjYWxhYmlsaXR5TW9kZShzY2FsYWJpbGl0eU1vZGUpO1xuICAgIGNvbnN0IGVuY29kaW5ncyA9IFtdO1xuICAgIGlmIChzbS5zcGF0aWFsID4gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgc2NhbGFiaWxpdHlNb2RlOiBcIi5jb25jYXQoc2NhbGFiaWxpdHlNb2RlKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc20uc3BhdGlhbDsgaSArPSAxKSB7XG4gICAgICBlbmNvZGluZ3MucHVzaCh7XG4gICAgICAgIHJpZDogdmlkZW9SaWRzWzIgLSBpXSxcbiAgICAgICAgbWF4Qml0cmF0ZTogdmlkZW9FbmNvZGluZy5tYXhCaXRyYXRlIC8gTWF0aC5wb3coMywgaSksXG4gICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgbWF4RnJhbWVyYXRlOiBvcmlnaW5hbC5lbmNvZGluZy5tYXhGcmFtZXJhdGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKiBAdHMtaWdub3JlICovXG4gICAgZW5jb2RpbmdzWzBdLnNjYWxhYmlsaXR5TW9kZSA9IHNjYWxhYmlsaXR5TW9kZTtcbiAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdlbmNvZGluZ3MnLCBlbmNvZGluZ3MpO1xuICAgIHJldHVybiBlbmNvZGluZ3M7XG4gIH1cbiAgaWYgKCF1c2VTaW11bGNhc3QpIHtcbiAgICByZXR1cm4gW3ZpZGVvRW5jb2RpbmddO1xuICB9XG4gIGxldCBwcmVzZXRzID0gW107XG4gIGlmIChpc1NjcmVlblNoYXJlKSB7XG4gICAgcHJlc2V0cyA9IChfYSA9IHNvcnRQcmVzZXRzKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY3JlZW5TaGFyZVNpbXVsY2FzdExheWVycykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRTaW11bGNhc3RMYXllcnMoaXNTY3JlZW5TaGFyZSwgb3JpZ2luYWwpO1xuICB9IGVsc2Uge1xuICAgIHByZXNldHMgPSAoX2IgPSBzb3J0UHJlc2V0cyhvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmlkZW9TaW11bGNhc3RMYXllcnMpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKGlzU2NyZWVuU2hhcmUsIG9yaWdpbmFsKTtcbiAgfVxuICBsZXQgbWlkUHJlc2V0O1xuICBpZiAocHJlc2V0cy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbG93UHJlc2V0ID0gcHJlc2V0c1swXTtcbiAgICBpZiAocHJlc2V0cy5sZW5ndGggPiAxKSB7XG4gICAgICBbLCBtaWRQcmVzZXRdID0gcHJlc2V0cztcbiAgICB9XG4gICAgLy8gTk9URTpcbiAgICAvLyAgIDEuIE9yZGVyaW5nIG9mIHRoZXNlIGVuY29kaW5ncyBpcyBpbXBvcnRhbnQuIENocm9tZSBzZWVtc1xuICAgIC8vICAgICAgdG8gdXNlIHRoZSBpbmRleCBpbnRvIGVuY29kaW5ncyB0byBkZWNpZGUgd2hpY2ggbGF5ZXJcbiAgICAvLyAgICAgIHRvIGRpc2FibGUgd2hlbiBDUFUgY29uc3RyYWluZWQuXG4gICAgLy8gICAgICBTbyBlbmNvZGluZ3Mgc2hvdWxkIGJlIG9yZGVyZWQgaW4gaW5jcmVhc2luZyBzcGF0aWFsXG4gICAgLy8gICAgICByZXNvbHV0aW9uIG9yZGVyLlxuICAgIC8vICAgMi4gaW9uLXNmdSB0cmFuc2xhdGVzIHJpZHMgaW50byBsYXllcnMuIFNvLCBhbGwgZW5jb2RpbmdzXG4gICAgLy8gICAgICBzaG91bGQgaGF2ZSB0aGUgYmFzZSBsYXllciBgcWAgYW5kIHRoZW4gbW9yZSBhZGRlZFxuICAgIC8vICAgICAgYmFzZWQgb24gb3RoZXIgY29uZGl0aW9ucy5cbiAgICBjb25zdCBzaXplID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHNpemUgPj0gOTYwICYmIG1pZFByZXNldCkge1xuICAgICAgcmV0dXJuIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIFtsb3dQcmVzZXQsIG1pZFByZXNldCwgb3JpZ2luYWxdKTtcbiAgICB9XG4gICAgaWYgKHNpemUgPj0gNDgwKSB7XG4gICAgICByZXR1cm4gZW5jb2RpbmdzRnJvbVByZXNldHMod2lkdGgsIGhlaWdodCwgW2xvd1ByZXNldCwgb3JpZ2luYWxdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIFtvcmlnaW5hbF0pO1xufVxuZnVuY3Rpb24gY29tcHV0ZVRyYWNrQmFja3VwRW5jb2RpbmdzKHRyYWNrLCB2aWRlb0NvZGVjLCBvcHRzKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgLy8gYmFja3VwQ29kZWMgc2hvdWxkIG5vdCBiZSB0cnVlIGFueW1vcmUsIGRlZmF1bHQgY29kZWMgaXMgc2V0IGluIExvY2FsUGFydGljaXBhbnQucHVibGlzaFxuICBpZiAoIW9wdHMuYmFja3VwQ29kZWMgfHwgb3B0cy5iYWNrdXBDb2RlYyA9PT0gdHJ1ZSB8fCBvcHRzLmJhY2t1cENvZGVjLmNvZGVjID09PSBvcHRzLnZpZGVvQ29kZWMpIHtcbiAgICAvLyBiYWNrdXAgY29kZWMgcHVibGlzaGluZyBpcyBkaXNhYmxlZFxuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmlkZW9Db2RlYyAhPT0gb3B0cy5iYWNrdXBDb2RlYy5jb2RlYykge1xuICAgIGxpdmVraXRMb2dnZXIud2FybigncmVxdWVzdGVkIGEgZGlmZmVyZW50IGNvZGVjIHRoYW4gc3BlY2lmaWVkIGFzIGJhY2t1cCcsIHtcbiAgICAgIHNlcnZlclJlcXVlc3RlZDogdmlkZW9Db2RlYyxcbiAgICAgIGJhY2t1cDogb3B0cy5iYWNrdXBDb2RlYy5jb2RlY1xuICAgIH0pO1xuICB9XG4gIG9wdHMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gIC8vIHVzZSBiYWNrdXAgZW5jb2Rpbmcgc2V0dGluZyBhcyB2aWRlb0VuY29kaW5nIGZvciBiYWNrdXAgY29kZWMgcHVibGlzaGluZ1xuICBvcHRzLnZpZGVvRW5jb2RpbmcgPSBvcHRzLmJhY2t1cENvZGVjLmVuY29kaW5nO1xuICBjb25zdCBzZXR0aW5ncyA9IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgY29uc3Qgd2lkdGggPSAoX2EgPSBzZXR0aW5ncy53aWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iID0gdHJhY2suZGltZW5zaW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLndpZHRoO1xuICBjb25zdCBoZWlnaHQgPSAoX2MgPSBzZXR0aW5ncy5oZWlnaHQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IChfZCA9IHRyYWNrLmRpbWVuc2lvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5oZWlnaHQ7XG4gIGNvbnN0IGVuY29kaW5ncyA9IGNvbXB1dGVWaWRlb0VuY29kaW5ncyh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCwgb3B0cyk7XG4gIHJldHVybiBlbmNvZGluZ3M7XG59XG4vKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGRldGVybWluZUFwcHJvcHJpYXRlRW5jb2RpbmcoaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCwgY29kZWMpIHtcbiAgY29uc3QgcHJlc2V0cyA9IHByZXNldHNGb3JSZXNvbHV0aW9uKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQpO1xuICBsZXQge1xuICAgIGVuY29kaW5nXG4gIH0gPSBwcmVzZXRzWzBdO1xuICAvLyBoYW5kbGUgcG9ydHJhaXQgYnkgc3dhcHBpbmcgZGltZW5zaW9uc1xuICBjb25zdCBzaXplID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlc2V0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHByZXNldCA9IHByZXNldHNbaV07XG4gICAgZW5jb2RpbmcgPSBwcmVzZXQuZW5jb2Rpbmc7XG4gICAgaWYgKHByZXNldC53aWR0aCA+PSBzaXplKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLy8gcHJlc2V0cyBhcmUgYmFzZWQgb24gdGhlIGFzc3VtcHRpb24gb2YgdnA4IGFzIGEgY29kZWNcbiAgLy8gZm9yIG90aGVyIGNvZGVjcyB3ZSBhZGp1c3QgdGhlIG1heEJpdHJhdGUgaWYgbm8gc3BlY2lmaWMgdmlkZW9FbmNvZGluZyBoYXMgYmVlbiBwcm92aWRlZFxuICAvLyB1c2VycyBzaG91bGQgb3ZlcnJpZGUgdGhlc2Ugd2l0aCBvbmVzIHRoYXQgYXJlIG9wdGltaXplZCBmb3IgdGhlaXIgdXNlIGNhc2VcbiAgLy8gTk9URTogU1ZDIGNvZGVjIGJpdHJhdGVzIGFyZSBpbmNsdXNpdmUgb2YgYWxsIHNjYWxhYmlsaXR5IGxheWVycy4gd2hpbGVcbiAgLy8gYml0cmF0ZSBmb3Igbm9uLVNWQyBjb2RlY3MgZG9lcyBub3QgaW5jbHVkZSBvdGhlciBzaW11bGNhc3QgbGF5ZXJzLlxuICBpZiAoY29kZWMpIHtcbiAgICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgICBjYXNlICdhdjEnOlxuICAgICAgICBlbmNvZGluZyA9IE9iamVjdC5hc3NpZ24oe30sIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IGVuY29kaW5nLm1heEJpdHJhdGUgKiAwLjc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndnA5JzpcbiAgICAgICAgZW5jb2RpbmcgPSBPYmplY3QuYXNzaWduKHt9LCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSBlbmNvZGluZy5tYXhCaXRyYXRlICogMC44NTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmNvZGluZztcbn1cbi8qIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gcHJlc2V0c0ZvclJlc29sdXRpb24oaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgIHJldHVybiBwcmVzZXRzU2NyZWVuU2hhcmU7XG4gIH1cbiAgY29uc3QgYXNwZWN0ID0gd2lkdGggPiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IGhlaWdodCAvIHdpZHRoO1xuICBpZiAoTWF0aC5hYnMoYXNwZWN0IC0gMTYuMCAvIDkpIDwgTWF0aC5hYnMoYXNwZWN0IC0gNC4wIC8gMykpIHtcbiAgICByZXR1cm4gcHJlc2V0czE2OTtcbiAgfVxuICByZXR1cm4gcHJlc2V0czQzO1xufVxuLyogQGludGVybmFsICovXG5mdW5jdGlvbiBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKGlzU2NyZWVuU2hhcmUsIG9yaWdpbmFsKSB7XG4gIGlmIChpc1NjcmVlblNoYXJlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVEZWZhdWx0U2NyZWVuU2hhcmVTaW11bGNhc3RQcmVzZXRzKG9yaWdpbmFsKTtcbiAgfVxuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSBvcmlnaW5hbDtcbiAgY29uc3QgYXNwZWN0ID0gd2lkdGggPiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IGhlaWdodCAvIHdpZHRoO1xuICBpZiAoTWF0aC5hYnMoYXNwZWN0IC0gMTYuMCAvIDkpIDwgTWF0aC5hYnMoYXNwZWN0IC0gNC4wIC8gMykpIHtcbiAgICByZXR1cm4gZGVmYXVsdFNpbXVsY2FzdFByZXNldHMxNjk7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRTaW11bGNhc3RQcmVzZXRzNDM7XG59XG4vLyBwcmVzZXRzIHNob3VsZCBiZSBvcmRlcmVkIGJ5IGxvdywgbWVkaXVtLCBoaWdoXG5mdW5jdGlvbiBlbmNvZGluZ3NGcm9tUHJlc2V0cyh3aWR0aCwgaGVpZ2h0LCBwcmVzZXRzKSB7XG4gIGNvbnN0IGVuY29kaW5ncyA9IFtdO1xuICBwcmVzZXRzLmZvckVhY2goKHByZXNldCwgaWR4KSA9PiB7XG4gICAgaWYgKGlkeCA+PSB2aWRlb1JpZHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCByaWQgPSB2aWRlb1JpZHNbaWR4XTtcbiAgICBjb25zdCBlbmNvZGluZyA9IHtcbiAgICAgIHJpZCxcbiAgICAgIHNjYWxlUmVzb2x1dGlvbkRvd25CeTogTWF0aC5tYXgoMSwgc2l6ZSAvIE1hdGgubWluKHByZXNldC53aWR0aCwgcHJlc2V0LmhlaWdodCkpLFxuICAgICAgbWF4Qml0cmF0ZTogcHJlc2V0LmVuY29kaW5nLm1heEJpdHJhdGVcbiAgICB9O1xuICAgIGlmIChwcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlKSB7XG4gICAgICBlbmNvZGluZy5tYXhGcmFtZXJhdGUgPSBwcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlO1xuICAgIH1cbiAgICBjb25zdCBjYW5TZXRQcmlvcml0eSA9IGlzRmlyZUZveCgpIHx8IGlkeCA9PT0gMDtcbiAgICBpZiAocHJlc2V0LmVuY29kaW5nLnByaW9yaXR5ICYmIGNhblNldFByaW9yaXR5KSB7XG4gICAgICBlbmNvZGluZy5wcmlvcml0eSA9IHByZXNldC5lbmNvZGluZy5wcmlvcml0eTtcbiAgICAgIGVuY29kaW5nLm5ldHdvcmtQcmlvcml0eSA9IHByZXNldC5lbmNvZGluZy5wcmlvcml0eTtcbiAgICB9XG4gICAgZW5jb2RpbmdzLnB1c2goZW5jb2RpbmcpO1xuICB9KTtcbiAgLy8gUk4gaW9zIHNpbXVsY2FzdCByZXF1aXJlcyBhbGwgc2FtZSBmcmFtZXJhdGVzLlxuICBpZiAoaXNSZWFjdE5hdGl2ZSgpICYmIGdldFJlYWN0TmF0aXZlT3MoKSA9PT0gJ2lvcycpIHtcbiAgICBsZXQgdG9wRnJhbWVyYXRlID0gdW5kZWZpbmVkO1xuICAgIGVuY29kaW5ncy5mb3JFYWNoKGVuY29kaW5nID0+IHtcbiAgICAgIGlmICghdG9wRnJhbWVyYXRlKSB7XG4gICAgICAgIHRvcEZyYW1lcmF0ZSA9IGVuY29kaW5nLm1heEZyYW1lcmF0ZTtcbiAgICAgIH0gZWxzZSBpZiAoZW5jb2RpbmcubWF4RnJhbWVyYXRlICYmIGVuY29kaW5nLm1heEZyYW1lcmF0ZSA+IHRvcEZyYW1lcmF0ZSkge1xuICAgICAgICB0b3BGcmFtZXJhdGUgPSBlbmNvZGluZy5tYXhGcmFtZXJhdGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IG5vdGlmeU9uY2UgPSB0cnVlO1xuICAgIGVuY29kaW5ncy5mb3JFYWNoKGVuY29kaW5nID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChlbmNvZGluZy5tYXhGcmFtZXJhdGUgIT0gdG9wRnJhbWVyYXRlKSB7XG4gICAgICAgIGlmIChub3RpZnlPbmNlKSB7XG4gICAgICAgICAgbm90aWZ5T25jZSA9IGZhbHNlO1xuICAgICAgICAgIGxpdmVraXRMb2dnZXIuaW5mbyhcIlNpbXVsY2FzdCBvbiBpT1MgUmVhY3QtTmF0aXZlIHJlcXVpcmVzIGFsbCBlbmNvZGluZ3MgdG8gc2hhcmUgdGhlIHNhbWUgZnJhbWVyYXRlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsaXZla2l0TG9nZ2VyLmluZm8oXCJTZXR0aW5nIGZyYW1lcmF0ZSBvZiBlbmNvZGluZyBcXFwiXCIuY29uY2F0KChfYSA9IGVuY29kaW5nLnJpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycsIFwiXFxcIiB0byBcIikuY29uY2F0KHRvcEZyYW1lcmF0ZSkpO1xuICAgICAgICBlbmNvZGluZy5tYXhGcmFtZXJhdGUgPSB0b3BGcmFtZXJhdGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5ncztcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHNvcnRQcmVzZXRzKHByZXNldHMpIHtcbiAgaWYgKCFwcmVzZXRzKSByZXR1cm47XG4gIHJldHVybiBwcmVzZXRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBlbmNvZGluZzogYUVuY1xuICAgIH0gPSBhO1xuICAgIGNvbnN0IHtcbiAgICAgIGVuY29kaW5nOiBiRW5jXG4gICAgfSA9IGI7XG4gICAgaWYgKGFFbmMubWF4Qml0cmF0ZSA+IGJFbmMubWF4Qml0cmF0ZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChhRW5jLm1heEJpdHJhdGUgPCBiRW5jLm1heEJpdHJhdGUpIHJldHVybiAtMTtcbiAgICBpZiAoYUVuYy5tYXhCaXRyYXRlID09PSBiRW5jLm1heEJpdHJhdGUgJiYgYUVuYy5tYXhGcmFtZXJhdGUgJiYgYkVuYy5tYXhGcmFtZXJhdGUpIHtcbiAgICAgIHJldHVybiBhRW5jLm1heEZyYW1lcmF0ZSA+IGJFbmMubWF4RnJhbWVyYXRlID8gMSA6IC0xO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5jbGFzcyBTY2FsYWJpbGl0eU1vZGUge1xuICBjb25zdHJ1Y3RvcihzY2FsYWJpbGl0eU1vZGUpIHtcbiAgICBjb25zdCByZXN1bHRzID0gc2NhbGFiaWxpdHlNb2RlLm1hdGNoKC9eTChcXGQpVChcXGQpKGh8X0tFWXxfS0VZX1NISUZUKXswLDF9JC8pO1xuICAgIGlmICghcmVzdWx0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNjYWxhYmlsaXR5IG1vZGUnKTtcbiAgICB9XG4gICAgdGhpcy5zcGF0aWFsID0gcGFyc2VJbnQocmVzdWx0c1sxXSk7XG4gICAgdGhpcy50ZW1wb3JhbCA9IHBhcnNlSW50KHJlc3VsdHNbMl0pO1xuICAgIGlmIChyZXN1bHRzLmxlbmd0aCA+IDMpIHtcbiAgICAgIHN3aXRjaCAocmVzdWx0c1szXSkge1xuICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgY2FzZSAnX0tFWSc6XG4gICAgICAgIGNhc2UgJ19LRVlfU0hJRlQnOlxuICAgICAgICAgIHRoaXMuc3VmZml4ID0gcmVzdWx0c1szXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBcIkxcIi5jb25jYXQodGhpcy5zcGF0aWFsLCBcIlRcIikuY29uY2F0KHRoaXMudGVtcG9yYWwpLmNvbmNhdCgoX2EgPSB0aGlzLnN1ZmZpeCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICB9XG59XG5cbmNvbnN0IHJlZnJlc2hTdWJzY3JpYmVkQ29kZWNBZnRlck5ld0NvZGVjID0gNTAwMDtcbmNsYXNzIExvY2FsVmlkZW9UcmFjayBleHRlbmRzIExvY2FsVHJhY2sge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG1lZGlhVHJhY2tcbiAgICogQHBhcmFtIGNvbnN0cmFpbnRzIE1lZGlhVHJhY2tDb25zdHJhaW50cyB0aGF0IGFyZSBiZWluZyB1c2VkIHdoZW4gcmVzdGFydGluZyBvciByZWFjcXVpcmluZyB0cmFja3NcbiAgICogQHBhcmFtIHVzZXJQcm92aWRlZFRyYWNrIFNpZ25hbHMgdG8gdGhlIFNESyB3aGV0aGVyIG9yIG5vdCB0aGUgbWVkaWFUcmFjayBzaG91bGQgYmUgbWFuYWdlZCAoaS5lLiByZWxlYXNlZCBhbmQgcmVhY3F1aXJlZCkgaW50ZXJuYWxseSBieSB0aGUgU0RLXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBjb25zdHJhaW50cykge1xuICAgIGxldCB1c2VyUHJvdmlkZWRUcmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIFRyYWNrLktpbmQuVmlkZW8sIGNvbnN0cmFpbnRzLCB1c2VyUHJvdmlkZWRUcmFjaywgbG9nZ2VyT3B0aW9ucyk7XG4gICAgLyogQGludGVybmFsICovXG4gICAgdGhpcy5zaW11bGNhc3RDb2RlY3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5tb25pdG9yU2VuZGVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBzdGF0cztcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXRzID0geWllbGQgdGhpcy5nZXRTZW5kZXJTdGF0cygpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGdldCBhdWRpbyBzZW5kZXIgc3RhdHMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlcnJvcjogZVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzTWFwID0gbmV3IE1hcChzdGF0cy5tYXAocyA9PiBbcy5yaWQsIHNdKSk7XG4gICAgICBpZiAodGhpcy5wcmV2U3RhdHMpIHtcbiAgICAgICAgbGV0IHRvdGFsQml0cmF0ZSA9IDA7XG4gICAgICAgIHN0YXRzTWFwLmZvckVhY2goKHMsIGtleSkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gKF9hID0gdGhpcy5wcmV2U3RhdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoa2V5KTtcbiAgICAgICAgICB0b3RhbEJpdHJhdGUgKz0gY29tcHV0ZUJpdHJhdGUocywgcHJldik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IHRvdGFsQml0cmF0ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJldlN0YXRzID0gc3RhdHNNYXA7XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kZXJMb2NrID0gbmV3IE11dGV4KCk7XG4gIH1cbiAgZ2V0IGlzU2ltdWxjYXN0KCkge1xuICAgIGlmICh0aGlzLnNlbmRlciAmJiB0aGlzLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCkuZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHN0YXJ0TW9uaXRvcihzaWduYWxDbGllbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5zaWduYWxDbGllbnQgPSBzaWduYWxDbGllbnQ7XG4gICAgaWYgKCFpc1dlYigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHNhdmUgb3JpZ2luYWwgZW5jb2RpbmdzXG4gICAgLy8gVE9ETyA6IG1lcmdlIHNpbXVsY2FzdCB0cmFja3Mgc3RhdHNcbiAgICBjb25zdCBwYXJhbXMgPSAoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBhcmFtZXRlcnMoKTtcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICB0aGlzLmVuY29kaW5ncyA9IHBhcmFtcy5lbmNvZGluZ3M7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMubW9uaXRvclNlbmRlcigpO1xuICAgIH0sIG1vbml0b3JGcmVxdWVuY3kpO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgIHRoaXMuc2ltdWxjYXN0Q29kZWNzLmZvckVhY2godHJhY2tJbmZvID0+IHtcbiAgICAgIHRyYWNrSW5mby5tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICB9KTtcbiAgICBzdXBlci5zdG9wKCk7XG4gIH1cbiAgcGF1c2VVcHN0cmVhbSgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIHBhdXNlVXBzdHJlYW06IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5wYXVzZVVwc3RyZWFtXG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICB2YXIgX2Q7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIF9zdXBlci5wYXVzZVVwc3RyZWFtLmNhbGwodGhpcyk7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfZSA9IHRydWUsIF9mID0gX19hc3luY1ZhbHVlcyh0aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSksIF9nOyBfZyA9IHlpZWxkIF9mLm5leHQoKSwgX2EgPSBfZy5kb25lLCAhX2E7IF9lID0gdHJ1ZSkge1xuICAgICAgICAgIF9jID0gX2cudmFsdWU7XG4gICAgICAgICAgX2UgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBzYyA9IF9jO1xuICAgICAgICAgIHlpZWxkIChfZCA9IHNjLnNlbmRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgICAgZV8xID0ge1xuICAgICAgICAgIGVycm9yOiBlXzFfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9lICYmICFfYSAmJiAoX2IgPSBfZi5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKF9mKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXN1bWVVcHN0cmVhbSgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIHJlc3VtZVVwc3RyZWFtOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIucmVzdW1lVXBzdHJlYW1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xuICAgIHZhciBfZDtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgX3N1cGVyLnJlc3VtZVVwc3RyZWFtLmNhbGwodGhpcyk7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfZSA9IHRydWUsIF9mID0gX19hc3luY1ZhbHVlcyh0aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSksIF9nOyBfZyA9IHlpZWxkIF9mLm5leHQoKSwgX2EgPSBfZy5kb25lLCAhX2E7IF9lID0gdHJ1ZSkge1xuICAgICAgICAgIF9jID0gX2cudmFsdWU7XG4gICAgICAgICAgX2UgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBzYyA9IF9jO1xuICAgICAgICAgIHlpZWxkIChfZCA9IHNjLnNlbmRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnJlcGxhY2VUcmFjayhzYy5tZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV8yXzEpIHtcbiAgICAgICAgZV8yID0ge1xuICAgICAgICAgIGVycm9yOiBlXzJfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9lICYmICFfYSAmJiAoX2IgPSBfZi5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKF9mKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtdXRlKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgbXV0ZToge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLm11dGVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5tdXRlTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEgJiYgIXRoaXMuaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1Zygnc3RvcHBpbmcgY2FtZXJhIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAvLyBhbHNvIHN0b3AgdGhlIHRyYWNrLCBzbyB0aGF0IGNhbWVyYSBpbmRpY2F0b3IgaXMgdHVybmVkIG9mZlxuICAgICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIF9zdXBlci5tdXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdW5tdXRlKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgdW5tdXRlOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIudW5tdXRlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMubXV0ZUxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlYWNxdWlyaW5nIGNhbWVyYSB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBfc3VwZXIudW5tdXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2V0VHJhY2tNdXRlZChtdXRlZCkge1xuICAgIHN1cGVyLnNldFRyYWNrTXV0ZWQobXV0ZWQpO1xuICAgIGZvciAoY29uc3Qgc2Mgb2YgdGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpIHtcbiAgICAgIHNjLm1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICFtdXRlZDtcbiAgICB9XG4gIH1cbiAgZ2V0U2VuZGVyU3RhdHMoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoISgoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLnNlbmRlci5nZXRTdGF0cygpO1xuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodi50eXBlID09PSAnb3V0Ym91bmQtcnRwJykge1xuICAgICAgICAgIGNvbnN0IHZzID0ge1xuICAgICAgICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICAgIHN0cmVhbUlkOiB2LmlkLFxuICAgICAgICAgICAgZnJhbWVIZWlnaHQ6IHYuZnJhbWVIZWlnaHQsXG4gICAgICAgICAgICBmcmFtZVdpZHRoOiB2LmZyYW1lV2lkdGgsXG4gICAgICAgICAgICBmaXJDb3VudDogdi5maXJDb3VudCxcbiAgICAgICAgICAgIHBsaUNvdW50OiB2LnBsaUNvdW50LFxuICAgICAgICAgICAgbmFja0NvdW50OiB2Lm5hY2tDb3VudCxcbiAgICAgICAgICAgIHBhY2tldHNTZW50OiB2LnBhY2tldHNTZW50LFxuICAgICAgICAgICAgYnl0ZXNTZW50OiB2LmJ5dGVzU2VudCxcbiAgICAgICAgICAgIGZyYW1lc1NlbnQ6IHYuZnJhbWVzU2VudCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdi50aW1lc3RhbXAsXG4gICAgICAgICAgICByaWQ6IChfYSA9IHYucmlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2LmlkLFxuICAgICAgICAgICAgcmV0cmFuc21pdHRlZFBhY2tldHNTZW50OiB2LnJldHJhbnNtaXR0ZWRQYWNrZXRzU2VudCxcbiAgICAgICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uUmVhc29uOiB2LnF1YWxpdHlMaW1pdGF0aW9uUmVhc29uLFxuICAgICAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25SZXNvbHV0aW9uQ2hhbmdlczogdi5xdWFsaXR5TGltaXRhdGlvblJlc29sdXRpb25DaGFuZ2VzXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvL8KgbG9jYXRlIHRoZSBhcHByb3ByaWF0ZSByZW1vdGUtaW5ib3VuZC1ydHAgaXRlbVxuICAgICAgICAgIGNvbnN0IHIgPSBzdGF0cy5nZXQodi5yZW1vdGVJZCk7XG4gICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHZzLmppdHRlciA9IHIuaml0dGVyO1xuICAgICAgICAgICAgdnMucGFja2V0c0xvc3QgPSByLnBhY2tldHNMb3N0O1xuICAgICAgICAgICAgdnMucm91bmRUcmlwVGltZSA9IHIucm91bmRUcmlwVGltZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbXMucHVzaCh2cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0pO1xuICB9XG4gIHNldFB1Ymxpc2hpbmdRdWFsaXR5KG1heFF1YWxpdHkpIHtcbiAgICBjb25zdCBxdWFsaXRpZXMgPSBbXTtcbiAgICBmb3IgKGxldCBxID0gVmlkZW9RdWFsaXR5LkxPVzsgcSA8PSBWaWRlb1F1YWxpdHkuSElHSDsgcSArPSAxKSB7XG4gICAgICBxdWFsaXRpZXMucHVzaChuZXcgU3Vic2NyaWJlZFF1YWxpdHkoe1xuICAgICAgICBxdWFsaXR5OiBxLFxuICAgICAgICBlbmFibGVkOiBxIDw9IG1heFF1YWxpdHlcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgdGhpcy5sb2cuZGVidWcoXCJzZXR0aW5nIHB1Ymxpc2hpbmcgcXVhbGl0eS4gbWF4IHF1YWxpdHkgXCIuY29uY2F0KG1heFF1YWxpdHkpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIHRoaXMuc2V0UHVibGlzaGluZ0xheWVycyhxdWFsaXRpZXMpO1xuICB9XG4gIHNldERldmljZUlkKGRldmljZUlkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCA9PT0gZGV2aWNlSWQgJiYgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkID09PSB1bndyYXBDb25zdHJhaW50KGRldmljZUlkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbnN0cmFpbnRzLmRldmljZUlkID0gZGV2aWNlSWQ7XG4gICAgICAvLyB3aGVuIHZpZGVvIGlzIG11dGVkLCB1bmRlcmx5aW5nIG1lZGlhIHN0cmVhbSB0cmFjayBpcyBzdG9wcGVkIGFuZFxuICAgICAgLy8gd2lsbCBiZSByZXN0YXJ0ZWQgbGF0ZXJcbiAgICAgIGlmICghdGhpcy5pc011dGVkKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucmVzdGFydFRyYWNrKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5pc011dGVkIHx8IHVud3JhcENvbnN0cmFpbnQoZGV2aWNlSWQpID09PSB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWQ7XG4gICAgfSk7XG4gIH1cbiAgcmVzdGFydFRyYWNrKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIGVfMywgX2IsIF9jO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsZXQgY29uc3RyYWludHM7XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IGNvbnN0cmFpbnRzRm9yT3B0aW9ucyh7XG4gICAgICAgICAgdmlkZW86IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtQ29uc3RyYWludHMudmlkZW8gIT09ICdib29sZWFuJykge1xuICAgICAgICAgIGNvbnN0cmFpbnRzID0gc3RyZWFtQ29uc3RyYWludHMudmlkZW87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMucmVzdGFydChjb25zdHJhaW50cyk7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIF9lID0gX19hc3luY1ZhbHVlcyh0aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSksIF9mOyBfZiA9IHlpZWxkIF9lLm5leHQoKSwgX2EgPSBfZi5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgIF9jID0gX2YudmFsdWU7XG4gICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBzYyA9IF9jO1xuICAgICAgICAgIGlmIChzYy5zZW5kZXIpIHtcbiAgICAgICAgICAgIHNjLm1lZGlhU3RyZWFtVHJhY2sgPSB0aGlzLm1lZGlhU3RyZWFtVHJhY2suY2xvbmUoKTtcbiAgICAgICAgICAgIHlpZWxkIHNjLnNlbmRlci5yZXBsYWNlVHJhY2soc2MubWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzNfMSkge1xuICAgICAgICBlXzMgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfM18xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IF9lLnJldHVybikpIHlpZWxkIF9iLmNhbGwoX2UpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldFByb2Nlc3Nvcihwcm9jZXNzb3IpIHtcbiAgICBsZXQgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBzZXRQcm9jZXNzb3I6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5zZXRQcm9jZXNzb3JcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX2EsIGVfNCwgX2IsIF9jO1xuICAgIHZhciBfZCwgX2U7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIF9zdXBlci5zZXRQcm9jZXNzb3IuY2FsbCh0aGlzLCBwcm9jZXNzb3IsIHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5KTtcbiAgICAgIGlmICgoX2QgPSB0aGlzLnByb2Nlc3NvcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBfZyA9IF9fYXN5bmNWYWx1ZXModGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpLCBfaDsgX2ggPSB5aWVsZCBfZy5uZXh0KCksIF9hID0gX2guZG9uZSwgIV9hOyBfZiA9IHRydWUpIHtcbiAgICAgICAgICAgIF9jID0gX2gudmFsdWU7XG4gICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qgc2MgPSBfYztcbiAgICAgICAgICAgIHlpZWxkIChfZSA9IHNjLnNlbmRlcikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlcGxhY2VUcmFjayh0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlXzRfMSkge1xuICAgICAgICAgIGVfNCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBlXzRfMVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2YgJiYgIV9hICYmIChfYiA9IF9nLnJldHVybikpIHlpZWxkIF9iLmNhbGwoX2cpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYWRkU2ltdWxjYXN0VHJhY2soY29kZWMsIGVuY29kaW5ncykge1xuICAgIGlmICh0aGlzLnNpbXVsY2FzdENvZGVjcy5oYXMoY29kZWMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQoY29kZWMsIFwiIGFscmVhZHkgYWRkZWRcIikpO1xuICAgIH1cbiAgICBjb25zdCBzaW11bGNhc3RDb2RlY0luZm8gPSB7XG4gICAgICBjb2RlYyxcbiAgICAgIG1lZGlhU3RyZWFtVHJhY2s6IHRoaXMubWVkaWFTdHJlYW1UcmFjay5jbG9uZSgpLFxuICAgICAgc2VuZGVyOiB1bmRlZmluZWQsXG4gICAgICBlbmNvZGluZ3NcbiAgICB9O1xuICAgIHRoaXMuc2ltdWxjYXN0Q29kZWNzLnNldChjb2RlYywgc2ltdWxjYXN0Q29kZWNJbmZvKTtcbiAgICByZXR1cm4gc2ltdWxjYXN0Q29kZWNJbmZvO1xuICB9XG4gIHNldFNpbXVsY2FzdFRyYWNrU2VuZGVyKGNvZGVjLCBzZW5kZXIpIHtcbiAgICBjb25zdCBzaW11bGNhc3RDb2RlY0luZm8gPSB0aGlzLnNpbXVsY2FzdENvZGVjcy5nZXQoY29kZWMpO1xuICAgIGlmICghc2ltdWxjYXN0Q29kZWNJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNpbXVsY2FzdENvZGVjSW5mby5zZW5kZXIgPSBzZW5kZXI7XG4gICAgLy8gYnJvd3NlciB3aWxsIHJlZW5hYmxlIGRpc2FibGVkIGNvZGVjL2xheWVycyBhZnRlciBuZXcgY29kZWMgaGFzIGJlZW4gcHVibGlzaGVkLFxuICAgIC8vIHNvIHJlZnJlc2ggc3Vic2NyaWJlZENvZGVjcyBhZnRlciBwdWJsaXNoIGEgbmV3IGNvZGVjXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdWJzY3JpYmVkQ29kZWNzKSB7XG4gICAgICAgIHRoaXMuc2V0UHVibGlzaGluZ0NvZGVjcyh0aGlzLnN1YnNjcmliZWRDb2RlY3MpO1xuICAgICAgfVxuICAgIH0sIHJlZnJlc2hTdWJzY3JpYmVkQ29kZWNBZnRlck5ld0NvZGVjKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFNldHMgY29kZWNzIHRoYXQgc2hvdWxkIGJlIHB1Ymxpc2hpbmcsIHJldHVybnMgbmV3IGNvZGVjcyB0aGF0IGhhdmUgbm90IHlldFxuICAgKiBiZWVuIHB1Ymxpc2hlZFxuICAgKi9cbiAgc2V0UHVibGlzaGluZ0NvZGVjcyhjb2RlY3MpIHtcbiAgICB2YXIgX2EsIGNvZGVjc18xLCBjb2RlY3NfMV8xO1xuICAgIHZhciBfYiwgZV81LCBfYywgX2Q7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdzZXR0aW5nIHB1Ymxpc2hpbmcgY29kZWNzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGNvZGVjcyxcbiAgICAgICAgY3VycmVudENvZGVjOiB0aGlzLmNvZGVjXG4gICAgICB9KSk7XG4gICAgICAvLyBvbmx5IGVuYWJsZSBzaW11bGNhc3QgY29kZWMgZm9yIHByZWZlcmVuY2UgY29kZWMgc2V0dGVkXG4gICAgICBpZiAoIXRoaXMuY29kZWMgJiYgY29kZWNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgeWllbGQgdGhpcy5zZXRQdWJsaXNoaW5nTGF5ZXJzKGNvZGVjc1swXS5xdWFsaXRpZXMpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB0aGlzLnN1YnNjcmliZWRDb2RlY3MgPSBjb2RlY3M7XG4gICAgICBjb25zdCBuZXdDb2RlY3MgPSBbXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2EgPSB0cnVlLCBjb2RlY3NfMSA9IF9fYXN5bmNWYWx1ZXMoY29kZWNzKTsgY29kZWNzXzFfMSA9IHlpZWxkIGNvZGVjc18xLm5leHQoKSwgX2IgPSBjb2RlY3NfMV8xLmRvbmUsICFfYjsgX2EgPSB0cnVlKSB7XG4gICAgICAgICAgX2QgPSBjb2RlY3NfMV8xLnZhbHVlO1xuICAgICAgICAgIF9hID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgY29kZWMgPSBfZDtcbiAgICAgICAgICBpZiAoIXRoaXMuY29kZWMgfHwgdGhpcy5jb2RlYyA9PT0gY29kZWMuY29kZWMpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc2V0UHVibGlzaGluZ0xheWVycyhjb2RlYy5xdWFsaXRpZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzaW11bGNhc3RDb2RlY0luZm8gPSB0aGlzLnNpbXVsY2FzdENvZGVjcy5nZXQoY29kZWMuY29kZWMpO1xuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJ0cnkgc2V0UHVibGlzaGluZ0NvZGVjIGZvciBcIi5jb25jYXQoY29kZWMuY29kZWMpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgICAgc2ltdWxjYXN0Q29kZWNJbmZvXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoIXNpbXVsY2FzdENvZGVjSW5mbyB8fCAhc2ltdWxjYXN0Q29kZWNJbmZvLnNlbmRlcikge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHEgb2YgY29kZWMucXVhbGl0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHEuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgbmV3Q29kZWNzLnB1c2goY29kZWMuY29kZWMpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNpbXVsY2FzdENvZGVjSW5mby5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJ0cnkgc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlciBcIi5jb25jYXQoY29kZWMuY29kZWMpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgICB5aWVsZCBzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyKHNpbXVsY2FzdENvZGVjSW5mby5zZW5kZXIsIHNpbXVsY2FzdENvZGVjSW5mby5lbmNvZGluZ3MsIGNvZGVjLnF1YWxpdGllcywgdGhpcy5zZW5kZXJMb2NrLCB0aGlzLmxvZywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVfNV8xKSB7XG4gICAgICAgIGVfNSA9IHtcbiAgICAgICAgICBlcnJvcjogZV81XzFcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfYSAmJiAhX2IgJiYgKF9jID0gY29kZWNzXzEucmV0dXJuKSkgeWllbGQgX2MuY2FsbChjb2RlY3NfMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3Q29kZWNzO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogU2V0cyBsYXllcnMgdGhhdCBzaG91bGQgYmUgcHVibGlzaGluZ1xuICAgKi9cbiAgc2V0UHVibGlzaGluZ0xheWVycyhxdWFsaXRpZXMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3NldHRpbmcgcHVibGlzaGluZyBsYXllcnMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgcXVhbGl0aWVzXG4gICAgICB9KSk7XG4gICAgICBpZiAoIXRoaXMuc2VuZGVyIHx8ICF0aGlzLmVuY29kaW5ncykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB5aWVsZCBzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyKHRoaXMuc2VuZGVyLCB0aGlzLmVuY29kaW5ncywgcXVhbGl0aWVzLCB0aGlzLnNlbmRlckxvY2ssIHRoaXMubG9nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIH0pO1xuICB9XG4gIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQ6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZFxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCBfc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQuY2FsbCh0aGlzKTtcbiAgICAgIGlmICghaXNNb2JpbGUoKSkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuaXNJbkJhY2tncm91bmQgJiYgdGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIoc2VuZGVyLCBzZW5kZXJFbmNvZGluZ3MsIHF1YWxpdGllcywgc2VuZGVyTG9jaywgbG9nLCBsb2dDb250ZXh0KSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgdW5sb2NrID0geWllbGQgc2VuZGVyTG9jay5sb2NrKCk7XG4gICAgbG9nLmRlYnVnKCdzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2dDb250ZXh0KSwge1xuICAgICAgc2VuZGVyLFxuICAgICAgcXVhbGl0aWVzLFxuICAgICAgc2VuZGVyRW5jb2RpbmdzXG4gICAgfSkpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBzZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbmNvZGluZ3NcbiAgICAgIH0gPSBwYXJhbXM7XG4gICAgICBpZiAoIWVuY29kaW5ncykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZW5jb2RpbmdzLmxlbmd0aCAhPT0gc2VuZGVyRW5jb2RpbmdzLmxlbmd0aCkge1xuICAgICAgICBsb2cud2FybignY2Fubm90IHNldCBwdWJsaXNoaW5nIGxheWVycywgZW5jb2RpbmdzIG1pc21hdGNoJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAvKiBkaXNhYmxlIGNsb3NhYmxlIHNwYXRpYWwgbGF5ZXIgYXMgaXQgaGFzIHZpZGVvIGJsdXIgLyBmcm96ZW4gaXNzdWUgd2l0aCBjdXJyZW50IHNlcnZlciAvIGNsaWVudFxuICAgICAgMS4gY2hyb21lIDExMzogd2hlbiBzd2l0Y2hpbmcgdG8gdXAgbGF5ZXIgd2l0aCBzY2FsYWJpbGl0eSBNb2RlIGNoYW5nZSwgaXQgd2lsbCBnZW5lcmF0ZSBhXG4gICAgICAgICAgICBsb3cgcmVzb2x1dGlvbiBmcmFtZSBhbmQgcmVjb3ZlciB2ZXJ5IHF1aWNrbHksIGJ1dCBub3RpY2FibGVcbiAgICAgIDIuIGxpdmVraXQgc2Z1OiBhZGRpdGlvbmFsIHBsaSByZXF1ZXN0IGNhdXNlIHZpZGVvIGZyb3plbiBmb3IgYSBmZXcgZnJhbWVzLCBhbHNvIG5vdGljYWJsZSAqL1xuICAgICAgY29uc3QgY2xvc2FibGVTcGF0aWFsID0gZmFsc2U7XG4gICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICBpZiAoY2xvc2FibGVTcGF0aWFsICYmIGVuY29kaW5nc1swXS5zY2FsYWJpbGl0eU1vZGUpIDsgZWxzZSB7XG4gICAgICAgIC8vIHNpbXVsY2FzdCBkeW5hY2FzdCBlbmNvZGluZ3NcbiAgICAgICAgZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgbGV0IHJpZCA9IChfYSA9IGVuY29kaW5nLnJpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgICAgaWYgKHJpZCA9PT0gJycpIHtcbiAgICAgICAgICAgIHJpZCA9ICdxJztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcXVhbGl0eSA9IHZpZGVvUXVhbGl0eUZvclJpZChyaWQpO1xuICAgICAgICAgIGNvbnN0IHN1YnNjcmliZWRRdWFsaXR5ID0gcXVhbGl0aWVzLmZpbmQocSA9PiBxLnF1YWxpdHkgPT09IHF1YWxpdHkpO1xuICAgICAgICAgIGlmICghc3Vic2NyaWJlZFF1YWxpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuY29kaW5nLmFjdGl2ZSAhPT0gc3Vic2NyaWJlZFF1YWxpdHkuZW5hYmxlZCkge1xuICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBzdWJzY3JpYmVkUXVhbGl0eS5lbmFibGVkO1xuICAgICAgICAgICAgbG9nLmRlYnVnKFwic2V0dGluZyBsYXllciBcIi5jb25jYXQoc3Vic2NyaWJlZFF1YWxpdHkucXVhbGl0eSwgXCIgdG8gXCIpLmNvbmNhdChlbmNvZGluZy5hY3RpdmUgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnKSwgbG9nQ29udGV4dCk7XG4gICAgICAgICAgICAvLyBGaXJlRm94IGRvZXMgbm90IHN1cHBvcnQgc2V0dGluZyBlbmNvZGluZy5hY3RpdmUgdG8gZmFsc2UsIHNvIHdlXG4gICAgICAgICAgICAvLyBoYXZlIGEgd29ya2Fyb3VuZCBvZiBsb3dlcmluZyBpdHMgYml0cmF0ZSBhbmQgcmVzb2x1dGlvbiB0byB0aGUgbWluLlxuICAgICAgICAgICAgaWYgKGlzRmlyZUZveCgpKSB7XG4gICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVkUXVhbGl0eS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID0gc2VuZGVyRW5jb2RpbmdzW2lkeF0uc2NhbGVSZXNvbHV0aW9uRG93bkJ5O1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSBzZW5kZXJFbmNvZGluZ3NbaWR4XS5tYXhCaXRyYXRlO1xuICAgICAgICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgICAgICAgICBlbmNvZGluZy5tYXhGcmFtZVJhdGUgPSBzZW5kZXJFbmNvZGluZ3NbaWR4XS5tYXhGcmFtZVJhdGU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID0gNDtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gMTA7XG4gICAgICAgICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLm1heEZyYW1lUmF0ZSA9IDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICAgICAgbG9nLmRlYnVnKFwic2V0dGluZyBlbmNvZGluZ3NcIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2dDb250ZXh0KSwge1xuICAgICAgICAgIGVuY29kaW5nczogcGFyYW1zLmVuY29kaW5nc1xuICAgICAgICB9KSk7XG4gICAgICAgIHlpZWxkIHNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtcyk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB2aWRlb1F1YWxpdHlGb3JSaWQocmlkKSB7XG4gIHN3aXRjaCAocmlkKSB7XG4gICAgY2FzZSAnZic6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5LkhJR0g7XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5Lk1FRElVTTtcbiAgICBjYXNlICdxJzpcbiAgICAgIHJldHVybiBWaWRlb1F1YWxpdHkuTE9XO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5LkhJR0g7XG4gIH1cbn1cbmZ1bmN0aW9uIHZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyh3aWR0aCwgaGVpZ2h0LCBlbmNvZGluZ3MsIHN2Yykge1xuICAvLyBkZWZhdWx0IHRvIGEgc2luZ2xlIGxheWVyLCBIUVxuICBpZiAoIWVuY29kaW5ncykge1xuICAgIHJldHVybiBbbmV3IFZpZGVvTGF5ZXIoe1xuICAgICAgcXVhbGl0eTogVmlkZW9RdWFsaXR5LkhJR0gsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGJpdHJhdGU6IDAsXG4gICAgICBzc3JjOiAwXG4gICAgfSldO1xuICB9XG4gIGlmIChzdmMpIHtcbiAgICAvLyBzdmMgbGF5ZXJzXG4gICAgLyogQHRzLWlnbm9yZSAqL1xuICAgIGNvbnN0IGVuY29kaW5nU00gPSBlbmNvZGluZ3NbMF0uc2NhbGFiaWxpdHlNb2RlO1xuICAgIGNvbnN0IHNtID0gbmV3IFNjYWxhYmlsaXR5TW9kZShlbmNvZGluZ1NNKTtcbiAgICBjb25zdCBsYXllcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNtLnNwYXRpYWw7IGkgKz0gMSkge1xuICAgICAgbGF5ZXJzLnB1c2gobmV3IFZpZGVvTGF5ZXIoe1xuICAgICAgICBxdWFsaXR5OiBWaWRlb1F1YWxpdHkuSElHSCAtIGksXG4gICAgICAgIHdpZHRoOiBNYXRoLmNlaWwod2lkdGggLyBNYXRoLnBvdygyLCBpKSksXG4gICAgICAgIGhlaWdodDogTWF0aC5jZWlsKGhlaWdodCAvIE1hdGgucG93KDIsIGkpKSxcbiAgICAgICAgYml0cmF0ZTogZW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgPyBNYXRoLmNlaWwoZW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgLyBNYXRoLnBvdygzLCBpKSkgOiAwLFxuICAgICAgICBzc3JjOiAwXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBsYXllcnM7XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5ncy5tYXAoZW5jb2RpbmcgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IHNjYWxlID0gKF9hID0gZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxO1xuICAgIGxldCBxdWFsaXR5ID0gdmlkZW9RdWFsaXR5Rm9yUmlkKChfYiA9IGVuY29kaW5nLnJpZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycpO1xuICAgIHJldHVybiBuZXcgVmlkZW9MYXllcih7XG4gICAgICBxdWFsaXR5LFxuICAgICAgd2lkdGg6IE1hdGguY2VpbCh3aWR0aCAvIHNjYWxlKSxcbiAgICAgIGhlaWdodDogTWF0aC5jZWlsKGhlaWdodCAvIHNjYWxlKSxcbiAgICAgIGJpdHJhdGU6IChfYyA9IGVuY29kaW5nLm1heEJpdHJhdGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDAsXG4gICAgICBzc3JjOiAwXG4gICAgfSk7XG4gIH0pO1xufVxuXG5jbGFzcyBSZW1vdGVUcmFjayBleHRlbmRzIFRyYWNrIHtcbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgc2lkLCBraW5kLCByZWNlaXZlciwgbG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIGtpbmQsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuc2lkID0gc2lkO1xuICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldE11dGVkKG11dGVkKSB7XG4gICAgaWYgKHRoaXMuaXNNdXRlZCAhPT0gbXV0ZWQpIHtcbiAgICAgIHRoaXMuaXNNdXRlZCA9IG11dGVkO1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gIW11dGVkO1xuICAgICAgdGhpcy5lbWl0KG11dGVkID8gVHJhY2tFdmVudC5NdXRlZCA6IFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0TWVkaWFTdHJlYW0oc3RyZWFtKSB7XG4gICAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHRyYWNrIGlzIGZpbmlzaGVkXG4gICAgdGhpcy5tZWRpYVN0cmVhbSA9IHN0cmVhbTtcbiAgICBjb25zdCBvblJlbW92ZVRyYWNrID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRyYWNrID09PSB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgIHN0cmVhbS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIG9uUmVtb3ZlVHJhY2spO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIG9uUmVtb3ZlVHJhY2spO1xuICB9XG4gIHN0YXJ0KCkge1xuICAgIHRoaXMuc3RhcnRNb25pdG9yKCk7XG4gICAgLy8gdXNlIGBlbmFibGVkYCBvZiB0cmFjayB0byBlbmFibGUgcmUtdXNlIG9mIHRyYW5zY2VpdmVyXG4gICAgc3VwZXIuZW5hYmxlKCk7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnN0b3BNb25pdG9yKCk7XG4gICAgLy8gdXNlIGBlbmFibGVkYCBvZiB0cmFjayB0byBlbmFibGUgcmUtdXNlIG9mIHRyYW5zY2VpdmVyXG4gICAgc3VwZXIuZGlzYWJsZSgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBSVENTdGF0c1JlcG9ydCBmb3IgdGhlIFJlbW90ZVRyYWNrJ3MgdW5kZXJseWluZyBSVENSdHBSZWNlaXZlclxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1N0YXRzUmVwb3J0XG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2U8UlRDU3RhdHNSZXBvcnQ+IHwgdW5kZWZpbmVkXG4gICAqL1xuICBnZXRSVENTdGF0c1JlcG9ydCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghKChfYSA9IHRoaXMucmVjZWl2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTdGF0cykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHNSZXBvcnQgPSB5aWVsZCB0aGlzLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgICByZXR1cm4gc3RhdHNSZXBvcnQ7XG4gICAgfSk7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHN0YXJ0TW9uaXRvcigpIHtcbiAgICBpZiAoIXRoaXMubW9uaXRvckludGVydmFsKSB7XG4gICAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHRoaXMubW9uaXRvclJlY2VpdmVyKCksIG1vbml0b3JGcmVxdWVuY3kpO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBSZW1vdGVBdWRpb1RyYWNrIGV4dGVuZHMgUmVtb3RlVHJhY2sge1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyLCBhdWRpb0NvbnRleHQsIGF1ZGlvT3V0cHV0LCBsb2dnZXJPcHRpb25zKSB7XG4gICAgc3VwZXIobWVkaWFUcmFjaywgc2lkLCBUcmFjay5LaW5kLkF1ZGlvLCByZWNlaXZlciwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5tb25pdG9yUmVjZWl2ZXIgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuZ2V0UmVjZWl2ZXJTdGF0cygpO1xuICAgICAgaWYgKHN0YXRzICYmIHRoaXMucHJldlN0YXRzICYmIHRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSBjb21wdXRlQml0cmF0ZShzdGF0cywgdGhpcy5wcmV2U3RhdHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcbiAgICB9KTtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgICB0aGlzLndlYkF1ZGlvUGx1Z2luTm9kZXMgPSBbXTtcbiAgICBpZiAoYXVkaW9PdXRwdXQpIHtcbiAgICAgIHRoaXMuc2lua0lkID0gYXVkaW9PdXRwdXQuZGV2aWNlSWQ7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBzZXRzIHRoZSB2b2x1bWUgZm9yIGFsbCBhdHRhY2hlZCBhdWRpbyBlbGVtZW50c1xuICAgKi9cbiAgc2V0Vm9sdW1lKHZvbHVtZSkge1xuICAgIHZhciBfYTtcbiAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMuYXR0YWNoZWRFbGVtZW50cykge1xuICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgIChfYSA9IHRoaXMuZ2Fpbk5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nYWluLnNldFRhcmdldEF0VGltZSh2b2x1bWUsIDAsIDAuMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC52b2x1bWUgPSB2b2x1bWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suX3NldFZvbHVtZSh2b2x1bWUpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRWb2x1bWUgPSB2b2x1bWU7XG4gIH1cbiAgLyoqXG4gICAqIGdldHMgdGhlIHZvbHVtZSBvZiBhdHRhY2hlZCBhdWRpbyBlbGVtZW50cyAobG91ZGVzdClcbiAgICovXG4gIGdldFZvbHVtZSgpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50Vm9sdW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50Vm9sdW1lO1xuICAgIH1cbiAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAvLyBSTiB2b2x1bWUgdmFsdWUgZGVmYXVsdHMgdG8gMS4wIGlmIGhhc24ndCBiZWVuIGNoYW5nZWQuXG4gICAgICByZXR1cm4gMS4wO1xuICAgIH1cbiAgICBsZXQgaGlnaGVzdFZvbHVtZSA9IDA7XG4gICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBpZiAoZWxlbWVudC52b2x1bWUgPiBoaWdoZXN0Vm9sdW1lKSB7XG4gICAgICAgIGhpZ2hlc3RWb2x1bWUgPSBlbGVtZW50LnZvbHVtZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGlnaGVzdFZvbHVtZTtcbiAgfVxuICAvKipcbiAgICogY2FsbHMgc2V0U2lua0lkIG9uIGFsbCBhdHRhY2hlZCBlbGVtZW50cywgaWYgc3VwcG9ydGVkXG4gICAqIEBwYXJhbSBkZXZpY2VJZCBhdWRpbyBvdXRwdXQgZGV2aWNlXG4gICAqL1xuICBzZXRTaW5rSWQoZGV2aWNlSWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5zaW5rSWQgPSBkZXZpY2VJZDtcbiAgICAgIHlpZWxkIFByb21pc2UuYWxsKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5tYXAoZWxtID0+IHtcbiAgICAgICAgaWYgKCFzdXBwb3J0c1NldFNpbmtJZChlbG0pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgcmV0dXJuIGVsbS5zZXRTaW5rSWQoZGV2aWNlSWQpO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIGF0dGFjaChlbGVtZW50KSB7XG4gICAgY29uc3QgbmVlZHNOZXdXZWJBdWRpb0Nvbm5lY3Rpb24gPSB0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID09PSAwO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IHN1cGVyLmF0dGFjaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5hdHRhY2goZWxlbWVudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNpbmtJZCAmJiBzdXBwb3J0c1NldFNpbmtJZChlbGVtZW50KSkge1xuICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgZWxlbWVudC5zZXRTaW5rSWQodGhpcy5zaW5rSWQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQgJiYgbmVlZHNOZXdXZWJBdWRpb0Nvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1c2luZyBhdWRpbyBjb250ZXh0IG1hcHBpbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdGhpcy5jb25uZWN0V2ViQXVkaW8odGhpcy5hdWRpb0NvbnRleHQsIGVsZW1lbnQpO1xuICAgICAgZWxlbWVudC52b2x1bWUgPSAwO1xuICAgICAgZWxlbWVudC5tdXRlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsZW1lbnRWb2x1bWUpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB2b2x1bWUgc2V0dGluZyBpcyBiZWluZyBhcHBsaWVkIHRvIHRoZSBuZXdseSBhdHRhY2hlZCBlbGVtZW50XG4gICAgICB0aGlzLnNldFZvbHVtZSh0aGlzLmVsZW1lbnRWb2x1bWUpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBkZXRhY2goZWxlbWVudCkge1xuICAgIGxldCBkZXRhY2hlZDtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGRldGFjaGVkID0gc3VwZXIuZGV0YWNoKCk7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhY2hlZCA9IHN1cGVyLmRldGFjaChlbGVtZW50KTtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBzdGlsbCBhbnkgYXR0YWNoZWQgZWxlbWVudHMgYWZ0ZXIgZGV0YWNoaW5nLCBjb25uZWN0IHdlYmF1ZGlvIHRvIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQncyBsZWZ0XG4gICAgICAvLyBkaXNjb25uZWN0IHdlYmF1ZGlvIG90aGVyd2lzZVxuICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKHRoaXMuYXVkaW9Db250ZXh0LCB0aGlzLmF0dGFjaGVkRWxlbWVudHNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdFdlYkF1ZGlvKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRldGFjaGVkO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc2V0QXVkaW9Db250ZXh0KGF1ZGlvQ29udGV4dCkge1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0O1xuICAgIGlmIChhdWRpb0NvbnRleHQgJiYgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKGF1ZGlvQ29udGV4dCwgdGhpcy5hdHRhY2hlZEVsZW1lbnRzWzBdKTtcbiAgICB9IGVsc2UgaWYgKCFhdWRpb0NvbnRleHQpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdFdlYkF1ZGlvKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKiBAcGFyYW0ge0F1ZGlvTm9kZVtdfSBub2RlcyAtIEFuIGFycmF5IG9mIFdlYkF1ZGlvIG5vZGVzLiBUaGVzZSBub2RlcyBzaG91bGQgbm90IGJlIGNvbm5lY3RlZCB0byBlYWNoIG90aGVyIHdoZW4gcGFzc2VkLCBhcyB0aGUgc2RrIHdpbGwgdGFrZSBjYXJlIG9mIGNvbm5lY3RpbmcgdGhlbSBpbiB0aGUgb3JkZXIgb2YgdGhlIGFycmF5LlxuICAgKi9cbiAgc2V0V2ViQXVkaW9QbHVnaW5zKG5vZGVzKSB7XG4gICAgdGhpcy53ZWJBdWRpb1BsdWdpbk5vZGVzID0gbm9kZXM7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPiAwICYmIHRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICB0aGlzLmNvbm5lY3RXZWJBdWRpbyh0aGlzLmF1ZGlvQ29udGV4dCwgdGhpcy5hdHRhY2hlZEVsZW1lbnRzWzBdKTtcbiAgICB9XG4gIH1cbiAgY29ubmVjdFdlYkF1ZGlvKGNvbnRleHQsIGVsZW1lbnQpIHtcbiAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgIC8vIEB0cy1pZ25vcmUgYXR0YWNoZWQgZWxlbWVudHMgYWx3YXlzIGhhdmUgYSBzcmNPYmplY3Qgc2V0XG4gICAgdGhpcy5zb3VyY2VOb2RlID0gY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShlbGVtZW50LnNyY09iamVjdCk7XG4gICAgbGV0IGxhc3ROb2RlID0gdGhpcy5zb3VyY2VOb2RlO1xuICAgIHRoaXMud2ViQXVkaW9QbHVnaW5Ob2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgbGFzdE5vZGUuY29ubmVjdChub2RlKTtcbiAgICAgIGxhc3ROb2RlID0gbm9kZTtcbiAgICB9KTtcbiAgICB0aGlzLmdhaW5Ob2RlID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgbGFzdE5vZGUuY29ubmVjdCh0aGlzLmdhaW5Ob2RlKTtcbiAgICB0aGlzLmdhaW5Ob2RlLmNvbm5lY3QoY29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgaWYgKHRoaXMuZWxlbWVudFZvbHVtZSkge1xuICAgICAgdGhpcy5nYWluTm9kZS5nYWluLnNldFRhcmdldEF0VGltZSh0aGlzLmVsZW1lbnRWb2x1bWUsIDAsIDAuMSk7XG4gICAgfVxuICAgIC8vIHRyeSB0byByZXN1bWUgdGhlIGNvbnRleHQgaWYgaXQgaXNuJ3QgcnVubmluZyBhbHJlYWR5XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgIT09ICdydW5uaW5nJykge1xuICAgICAgY29udGV4dC5yZXN1bWUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKGNvbnRleHQuc3RhdGUgIT09ICdydW5uaW5nJykge1xuICAgICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQsIG5ldyBFcnJvcihcIkF1ZGlvIENvbnRleHQgY291bGRuJ3QgYmUgc3RhcnRlZCBhdXRvbWF0aWNhbGx5XCIpKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQsIGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RXZWJBdWRpbygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIChfYSA9IHRoaXMuZ2Fpbk5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgKF9iID0gdGhpcy5zb3VyY2VOb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuZ2Fpbk5vZGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zb3VyY2VOb2RlID0gdW5kZWZpbmVkO1xuICB9XG4gIGdldFJlY2VpdmVyU3RhdHMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5yZWNlaXZlciB8fCAhdGhpcy5yZWNlaXZlci5nZXRTdGF0cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICAgIGxldCByZWNlaXZlclN0YXRzO1xuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gJ2luYm91bmQtcnRwJykge1xuICAgICAgICAgIHJlY2VpdmVyU3RhdHMgPSB7XG4gICAgICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB2LnRpbWVzdGFtcCxcbiAgICAgICAgICAgIGppdHRlcjogdi5qaXR0ZXIsXG4gICAgICAgICAgICBieXRlc1JlY2VpdmVkOiB2LmJ5dGVzUmVjZWl2ZWQsXG4gICAgICAgICAgICBjb25jZWFsZWRTYW1wbGVzOiB2LmNvbmNlYWxlZFNhbXBsZXMsXG4gICAgICAgICAgICBjb25jZWFsbWVudEV2ZW50czogdi5jb25jZWFsbWVudEV2ZW50cyxcbiAgICAgICAgICAgIHNpbGVudENvbmNlYWxlZFNhbXBsZXM6IHYuc2lsZW50Q29uY2VhbGVkU2FtcGxlcyxcbiAgICAgICAgICAgIHNpbGVudENvbmNlYWxtZW50RXZlbnRzOiB2LnNpbGVudENvbmNlYWxtZW50RXZlbnRzLFxuICAgICAgICAgICAgdG90YWxBdWRpb0VuZXJneTogdi50b3RhbEF1ZGlvRW5lcmd5LFxuICAgICAgICAgICAgdG90YWxTYW1wbGVzRHVyYXRpb246IHYudG90YWxTYW1wbGVzRHVyYXRpb25cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZWNlaXZlclN0YXRzO1xuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IFJFQUNUSU9OX0RFTEFZID0gMTAwO1xuY2xhc3MgUmVtb3RlVmlkZW9UcmFjayBleHRlbmRzIFJlbW90ZVRyYWNrIHtcbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncywgbG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIHNpZCwgVHJhY2suS2luZC5WaWRlbywgcmVjZWl2ZXIsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuZWxlbWVudEluZm9zID0gW107XG4gICAgdGhpcy5tb25pdG9yUmVjZWl2ZXIgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuZ2V0UmVjZWl2ZXJTdGF0cygpO1xuICAgICAgaWYgKHN0YXRzICYmIHRoaXMucHJldlN0YXRzICYmIHRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSBjb21wdXRlQml0cmF0ZShzdGF0cywgdGhpcy5wcmV2U3RhdHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcbiAgICB9KTtcbiAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSA9IHIoKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgfSwgUkVBQ1RJT05fREVMQVkpO1xuICAgIHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyA9IGFkYXB0aXZlU3RyZWFtU2V0dGluZ3M7XG4gIH1cbiAgZ2V0IGlzQWRhcHRpdmVTdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBOb3RlOiBXaGVuIHVzaW5nIGFkYXB0aXZlU3RyZWFtLCB5b3UgbmVlZCB0byB1c2UgcmVtb3RlVmlkZW9UcmFjay5hdHRhY2goKSB0byBhZGQgdGhlIHRyYWNrIHRvIGEgSFRNTFZpZGVvRWxlbWVudCwgb3RoZXJ3aXNlIHlvdXIgdmlkZW8gdHJhY2tzIG1pZ2h0IG5ldmVyIHN0YXJ0XG4gICAqL1xuICBnZXQgbWVkaWFTdHJlYW1UcmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjaztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldE11dGVkKG11dGVkKSB7XG4gICAgc3VwZXIuc2V0TXV0ZWQobXV0ZWQpO1xuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgLy8gZGV0YWNoIG9yIGF0dGFjaFxuICAgICAgaWYgKG11dGVkKSB7XG4gICAgICAgIGRldGFjaFRyYWNrKHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0YWNoVG9FbGVtZW50KHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGF0dGFjaChlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gc3VwZXIuYXR0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmF0dGFjaChlbGVtZW50KTtcbiAgICB9XG4gICAgLy8gSXQncyBwb3NzaWJsZSBhdHRhY2ggaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIG9uIGFuIGVsZW1lbnQuIFdoZW4gdGhhdCdzXG4gICAgLy8gdGhlIGNhc2UsIHdlJ2Qgd2FudCB0byBhdm9pZCBhZGRpbmcgZHVwbGljYXRlIGVsZW1lbnRJbmZvc1xuICAgIGlmICh0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgJiYgdGhpcy5lbGVtZW50SW5mb3MuZmluZChpbmZvID0+IGluZm8uZWxlbWVudCA9PT0gZWxlbWVudCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZWxlbWVudEluZm8gPSBuZXcgSFRNTEVsZW1lbnRJbmZvKGVsZW1lbnQpO1xuICAgICAgdGhpcy5vYnNlcnZlRWxlbWVudEluZm8oZWxlbWVudEluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICAvKipcbiAgICogT2JzZXJ2ZSBhbiBFbGVtZW50SW5mbyBmb3IgY2hhbmdlcyB3aGVuIGFkYXB0aXZlIHN0cmVhbWluZy5cbiAgICogQHBhcmFtIGVsZW1lbnRJbmZvXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb2JzZXJ2ZUVsZW1lbnRJbmZvKGVsZW1lbnRJbmZvKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyAmJiB0aGlzLmVsZW1lbnRJbmZvcy5maW5kKGluZm8gPT4gaW5mbyA9PT0gZWxlbWVudEluZm8pID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVsZW1lbnRJbmZvLmhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWRIYW5kbGVSZXNpemUoKTtcbiAgICAgIH07XG4gICAgICBlbGVtZW50SW5mby5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5lbGVtZW50SW5mb3MucHVzaChlbGVtZW50SW5mbyk7XG4gICAgICBlbGVtZW50SW5mby5vYnNlcnZlKCk7XG4gICAgICAvLyB0cmlnZ2VyIHRoZSBmaXJzdCByZXNpemUgdXBkYXRlIGN5Y2xlXG4gICAgICAvLyBpZiB0aGUgdGFiIGlzIGJhY2tncm91bmRlZCwgdGhlIGluaXRpYWwgcmVzaXplIGV2ZW50IGRvZXMgbm90IGZpcmUgdW50aWxcbiAgICAgIC8vIHRoZSB0YWIgY29tZXMgaW50byBmb2N1cyBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xuICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3Zpc2liaWxpdHkgcmVzaXplIG9ic2VydmVyIG5vdCB0cmlnZ2VyZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3RvcCBvYnNlcnZpbmcgYW4gRWxlbWVudEluZm8gZm9yIGNoYW5nZXMuXG4gICAqIEBwYXJhbSBlbGVtZW50SW5mb1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyhlbGVtZW50SW5mbykge1xuICAgIGlmICghdGhpcy5pc0FkYXB0aXZlU3RyZWFtKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdzdG9wT2JzZXJ2aW5nRWxlbWVudEluZm8gaWdub3JlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0b3BFbGVtZW50SW5mb3MgPSB0aGlzLmVsZW1lbnRJbmZvcy5maWx0ZXIoaW5mbyA9PiBpbmZvID09PSBlbGVtZW50SW5mbyk7XG4gICAgZm9yIChjb25zdCBpbmZvIG9mIHN0b3BFbGVtZW50SW5mb3MpIHtcbiAgICAgIGluZm8uc3RvcE9ic2VydmluZygpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRJbmZvcyA9IHRoaXMuZWxlbWVudEluZm9zLmZpbHRlcihpbmZvID0+IGluZm8gIT09IGVsZW1lbnRJbmZvKTtcbiAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xuICB9XG4gIGRldGFjaChlbGVtZW50KSB7XG4gICAgbGV0IGRldGFjaGVkRWxlbWVudHMgPSBbXTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5zdG9wT2JzZXJ2aW5nRWxlbWVudChlbGVtZW50KTtcbiAgICAgIHJldHVybiBzdXBlci5kZXRhY2goZWxlbWVudCk7XG4gICAgfVxuICAgIGRldGFjaGVkRWxlbWVudHMgPSBzdXBlci5kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IGUgb2YgZGV0YWNoZWRFbGVtZW50cykge1xuICAgICAgdGhpcy5zdG9wT2JzZXJ2aW5nRWxlbWVudChlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRldGFjaGVkRWxlbWVudHM7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXREZWNvZGVySW1wbGVtZW50YXRpb24oKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnByZXZTdGF0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlY29kZXJJbXBsZW1lbnRhdGlvbjtcbiAgfVxuICBnZXRSZWNlaXZlclN0YXRzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucmVjZWl2ZXIgfHwgIXRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgICBsZXQgcmVjZWl2ZXJTdGF0cztcbiAgICAgIGxldCBjb2RlY0lEID0gJyc7XG4gICAgICBsZXQgY29kZWNzID0gbmV3IE1hcCgpO1xuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gJ2luYm91bmQtcnRwJykge1xuICAgICAgICAgIGNvZGVjSUQgPSB2LmNvZGVjSWQ7XG4gICAgICAgICAgcmVjZWl2ZXJTdGF0cyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICd2aWRlbycsXG4gICAgICAgICAgICBmcmFtZXNEZWNvZGVkOiB2LmZyYW1lc0RlY29kZWQsXG4gICAgICAgICAgICBmcmFtZXNEcm9wcGVkOiB2LmZyYW1lc0Ryb3BwZWQsXG4gICAgICAgICAgICBmcmFtZXNSZWNlaXZlZDogdi5mcmFtZXNSZWNlaXZlZCxcbiAgICAgICAgICAgIHBhY2tldHNSZWNlaXZlZDogdi5wYWNrZXRzUmVjZWl2ZWQsXG4gICAgICAgICAgICBwYWNrZXRzTG9zdDogdi5wYWNrZXRzTG9zdCxcbiAgICAgICAgICAgIGZyYW1lV2lkdGg6IHYuZnJhbWVXaWR0aCxcbiAgICAgICAgICAgIGZyYW1lSGVpZ2h0OiB2LmZyYW1lSGVpZ2h0LFxuICAgICAgICAgICAgcGxpQ291bnQ6IHYucGxpQ291bnQsXG4gICAgICAgICAgICBmaXJDb3VudDogdi5maXJDb3VudCxcbiAgICAgICAgICAgIG5hY2tDb3VudDogdi5uYWNrQ291bnQsXG4gICAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB2LnRpbWVzdGFtcCxcbiAgICAgICAgICAgIGJ5dGVzUmVjZWl2ZWQ6IHYuYnl0ZXNSZWNlaXZlZCxcbiAgICAgICAgICAgIGRlY29kZXJJbXBsZW1lbnRhdGlvbjogdi5kZWNvZGVySW1wbGVtZW50YXRpb25cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHYudHlwZSA9PT0gJ2NvZGVjJykge1xuICAgICAgICAgIGNvZGVjcy5zZXQodi5pZCwgdik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHJlY2VpdmVyU3RhdHMgJiYgY29kZWNJRCAhPT0gJycgJiYgY29kZWNzLmdldChjb2RlY0lEKSkge1xuICAgICAgICByZWNlaXZlclN0YXRzLm1pbWVUeXBlID0gY29kZWNzLmdldChjb2RlY0lEKS5taW1lVHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWNlaXZlclN0YXRzO1xuICAgIH0pO1xuICB9XG4gIHN0b3BPYnNlcnZpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCBzdG9wRWxlbWVudEluZm9zID0gdGhpcy5lbGVtZW50SW5mb3MuZmlsdGVyKGluZm8gPT4gaW5mby5lbGVtZW50ID09PSBlbGVtZW50KTtcbiAgICBmb3IgKGNvbnN0IGluZm8gb2Ygc3RvcEVsZW1lbnRJbmZvcykge1xuICAgICAgdGhpcy5zdG9wT2JzZXJ2aW5nRWxlbWVudEluZm8oaW5mbyk7XG4gICAgfVxuICB9XG4gIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQ6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZFxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCBfc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQuY2FsbCh0aGlzKTtcbiAgICAgIGlmICghdGhpcy5pc0FkYXB0aXZlU3RyZWFtKSByZXR1cm47XG4gICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVWaXNpYmlsaXR5KCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgbGFzdFZpc2liaWxpdHlDaGFuZ2UgPSB0aGlzLmVsZW1lbnRJbmZvcy5yZWR1Y2UoKHByZXYsIGluZm8pID0+IE1hdGgubWF4KHByZXYsIGluZm8udmlzaWJpbGl0eUNoYW5nZWRBdCB8fCAwKSwgMCk7XG4gICAgY29uc3QgYmFja2dyb3VuZFBhdXNlID0gKChfYiA9IChfYSA9IHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdXNlVmlkZW9JbkJhY2tncm91bmQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUgLy8gZGVmYXVsdCB0byB0cnVlXG4gICAgKSA/IHRoaXMuaXNJbkJhY2tncm91bmQgOiBmYWxzZTtcbiAgICBjb25zdCBpc1BpUE1vZGUgPSB0aGlzLmVsZW1lbnRJbmZvcy5zb21lKGluZm8gPT4gaW5mby5waWN0dXJlSW5QaWN0dXJlKTtcbiAgICBjb25zdCBpc1Zpc2libGUgPSB0aGlzLmVsZW1lbnRJbmZvcy5zb21lKGluZm8gPT4gaW5mby52aXNpYmxlKSAmJiAhYmFja2dyb3VuZFBhdXNlIHx8IGlzUGlQTW9kZTtcbiAgICBpZiAodGhpcy5sYXN0VmlzaWJsZSA9PT0gaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNWaXNpYmxlICYmIERhdGUubm93KCkgLSBsYXN0VmlzaWJpbGl0eUNoYW5nZSA8IFJFQUNUSU9OX0RFTEFZKSB7XG4gICAgICAvLyBkZWxheSBoaWRkZW4gZXZlbnRzXG4gICAgICBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgICB9LCBSRUFDVElPTl9ERUxBWSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdFZpc2libGUgPSBpc1Zpc2libGU7XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVmlzaWJpbGl0eUNoYW5nZWQsIGlzVmlzaWJsZSwgdGhpcyk7XG4gIH1cbiAgdXBkYXRlRGltZW5zaW9ucygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGxldCBtYXhXaWR0aCA9IDA7XG4gICAgbGV0IG1heEhlaWdodCA9IDA7XG4gICAgY29uc3QgcGl4ZWxEZW5zaXR5ID0gdGhpcy5nZXRQaXhlbERlbnNpdHkoKTtcbiAgICBmb3IgKGNvbnN0IGluZm8gb2YgdGhpcy5lbGVtZW50SW5mb3MpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50V2lkdGggPSBpbmZvLndpZHRoKCkgKiBwaXhlbERlbnNpdHk7XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudEhlaWdodCA9IGluZm8uaGVpZ2h0KCkgKiBwaXhlbERlbnNpdHk7XG4gICAgICBpZiAoY3VycmVudEVsZW1lbnRXaWR0aCArIGN1cnJlbnRFbGVtZW50SGVpZ2h0ID4gbWF4V2lkdGggKyBtYXhIZWlnaHQpIHtcbiAgICAgICAgbWF4V2lkdGggPSBjdXJyZW50RWxlbWVudFdpZHRoO1xuICAgICAgICBtYXhIZWlnaHQgPSBjdXJyZW50RWxlbWVudEhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCgoX2EgPSB0aGlzLmxhc3REaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2lkdGgpID09PSBtYXhXaWR0aCAmJiAoKF9iID0gdGhpcy5sYXN0RGltZW5zaW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlaWdodCkgPT09IG1heEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3REaW1lbnNpb25zID0ge1xuICAgICAgd2lkdGg6IG1heFdpZHRoLFxuICAgICAgaGVpZ2h0OiBtYXhIZWlnaHRcbiAgICB9O1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlZpZGVvRGltZW5zaW9uc0NoYW5nZWQsIHRoaXMubGFzdERpbWVuc2lvbnMsIHRoaXMpO1xuICB9XG4gIGdldFBpeGVsRGVuc2l0eSgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcGl4ZWxEZW5zaXR5ID0gKF9hID0gdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGl4ZWxEZW5zaXR5O1xuICAgIGlmIChwaXhlbERlbnNpdHkgPT09ICdzY3JlZW4nKSB7XG4gICAgICByZXR1cm4gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIH0gZWxzZSBpZiAoIXBpeGVsRGVuc2l0eSkge1xuICAgICAgLy8gd2hlbiB1bnNldCwgd2UnbGwgcGljayBhIHNhbmUgZGVmYXVsdCBoZXJlLlxuICAgICAgLy8gZm9yIGhpZ2hlciBwaXhlbCBkZW5zaXR5IGRldmljZXMgKG1vYmlsZSBwaG9uZXMsIGV0YyksIHdlJ2xsIHVzZSAyXG4gICAgICAvLyBvdGhlcndpc2UgaXQgZGVmYXVsdHMgdG8gMVxuICAgICAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IGdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICAgIGlmIChkZXZpY2VQaXhlbFJhdGlvID4gMikge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGl4ZWxEZW5zaXR5O1xuICB9XG59XG5jbGFzcyBIVE1MRWxlbWVudEluZm8ge1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BpUCB8fCB0aGlzLmlzSW50ZXJzZWN0aW5nO1xuICB9XG4gIGdldCBwaWN0dXJlSW5QaWN0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGlQO1xuICB9XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHZpc2libGUpIHtcbiAgICB0aGlzLm9uVmlzaWJpbGl0eUNoYW5nZWQgPSBlbnRyeSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgaXNJbnRlcnNlY3RpbmdcbiAgICAgIH0gPSBlbnRyeTtcbiAgICAgIGlmICh0YXJnZXQgPT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgICB0aGlzLmlzSW50ZXJzZWN0aW5nID0gaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgIChfYSA9IHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vbkVudGVyUGlQID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgdGhpcy5pc1BpUCA9IHRydWU7XG4gICAgICAoX2EgPSB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMub25MZWF2ZVBpUCA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHRoaXMuaXNQaVAgPSBmYWxzZTtcbiAgICAgIChfYSA9IHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlzSW50ZXJzZWN0aW5nID0gdmlzaWJsZSAhPT0gbnVsbCAmJiB2aXNpYmxlICE9PSB2b2lkIDAgPyB2aXNpYmxlIDogaXNFbGVtZW50SW5WaWV3cG9ydChlbGVtZW50KTtcbiAgICB0aGlzLmlzUGlQID0gaXNXZWIoKSAmJiBkb2N1bWVudC5waWN0dXJlSW5QaWN0dXJlRWxlbWVudCA9PT0gZWxlbWVudDtcbiAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQXQgPSAwO1xuICB9XG4gIHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIH1cbiAgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICB9XG4gIG9ic2VydmUoKSB7XG4gICAgLy8gbWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgY3VycmVudCB2aXNpYmxlIHN0YXRlIG9uY2Ugd2Ugc3RhcnQgdG8gb2JzZXJ2ZVxuICAgIHRoaXMuaXNJbnRlcnNlY3RpbmcgPSBpc0VsZW1lbnRJblZpZXdwb3J0KHRoaXMuZWxlbWVudCk7XG4gICAgdGhpcy5pc1BpUCA9IGRvY3VtZW50LnBpY3R1cmVJblBpY3R1cmVFbGVtZW50ID09PSB0aGlzLmVsZW1lbnQ7XG4gICAgdGhpcy5lbGVtZW50LmhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMuaGFuZGxlUmVzaXplKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMuZWxlbWVudC5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCA9IHRoaXMub25WaXNpYmlsaXR5Q2hhbmdlZDtcbiAgICBnZXRJbnRlcnNlY3Rpb25PYnNlcnZlcigpLm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICBnZXRSZXNpemVPYnNlcnZlcigpLm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZW50ZXJwaWN0dXJlaW5waWN0dXJlJywgdGhpcy5vbkVudGVyUGlQKTtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbGVhdmVwaWN0dXJlaW5waWN0dXJlJywgdGhpcy5vbkxlYXZlUGlQKTtcbiAgfVxuICBzdG9wT2JzZXJ2aW5nKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgKF9hID0gZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgIChfYiA9IGdldFJlc2l6ZU9ic2VydmVyKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi51bm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW50ZXJwaWN0dXJlaW5waWN0dXJlJywgdGhpcy5vbkVudGVyUGlQKTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbGVhdmVwaWN0dXJlaW5waWN0dXJlJywgdGhpcy5vbkxlYXZlUGlQKTtcbiAgfVxufVxuLy8gZG9lcyBub3QgYWNjb3VudCBmb3Igb2NjbHVzaW9uIGJ5IG90aGVyIGVsZW1lbnRzXG5mdW5jdGlvbiBpc0VsZW1lbnRJblZpZXdwb3J0KGVsKSB7XG4gIGxldCB0b3AgPSBlbC5vZmZzZXRUb3A7XG4gIGxldCBsZWZ0ID0gZWwub2Zmc2V0TGVmdDtcbiAgY29uc3Qgd2lkdGggPSBlbC5vZmZzZXRXaWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0O1xuICBjb25zdCB7XG4gICAgaGlkZGVuXG4gIH0gPSBlbDtcbiAgY29uc3Qge1xuICAgIG9wYWNpdHksXG4gICAgZGlzcGxheVxuICB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHdoaWxlIChlbC5vZmZzZXRQYXJlbnQpIHtcbiAgICBlbCA9IGVsLm9mZnNldFBhcmVudDtcbiAgICB0b3AgKz0gZWwub2Zmc2V0VG9wO1xuICAgIGxlZnQgKz0gZWwub2Zmc2V0TGVmdDtcbiAgfVxuICByZXR1cm4gdG9wIDwgd2luZG93LnBhZ2VZT2Zmc2V0ICsgd2luZG93LmlubmVySGVpZ2h0ICYmIGxlZnQgPCB3aW5kb3cucGFnZVhPZmZzZXQgKyB3aW5kb3cuaW5uZXJXaWR0aCAmJiB0b3AgKyBoZWlnaHQgPiB3aW5kb3cucGFnZVlPZmZzZXQgJiYgbGVmdCArIHdpZHRoID4gd2luZG93LnBhZ2VYT2Zmc2V0ICYmICFoaWRkZW4gJiYgKG9wYWNpdHkgIT09ICcnID8gcGFyc2VGbG9hdChvcGFjaXR5KSA+IDAgOiB0cnVlKSAmJiBkaXNwbGF5ICE9PSAnbm9uZSc7XG59XG5cbmNsYXNzIFRyYWNrUHVibGljYXRpb24gZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGtpbmQsIGlkLCBuYW1lLCBsb2dnZXJPcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tZXRhZGF0YU11dGVkID0gZmFsc2U7XG4gICAgdGhpcy5lbmNyeXB0aW9uID0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xuICAgIHRoaXMuaGFuZGxlTXV0ZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5NdXRlZCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVVubXV0ZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5Vbm11dGVkKTtcbiAgICB9O1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IGxvZ2dlck9wdGlvbnMgPT09IG51bGwgfHwgbG9nZ2VyT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5QdWJsaWNhdGlvbik7XG4gICAgdGhpcy5sb2dnZXJDb250ZXh0Q2IgPSB0aGlzLmxvZ2dlckNvbnRleHRDYjtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgdGhpcy50cmFja1NpZCA9IGlkO1xuICAgIHRoaXMudHJhY2tOYW1lID0gbmFtZTtcbiAgICB0aGlzLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5Vbmtub3duO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0VHJhY2sodHJhY2spIHtcbiAgICBpZiAodGhpcy50cmFjaykge1xuICAgICAgdGhpcy50cmFjay5vZmYoVHJhY2tFdmVudC5NdXRlZCwgdGhpcy5oYW5kbGVNdXRlZCk7XG4gICAgICB0aGlzLnRyYWNrLm9mZihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMuaGFuZGxlVW5tdXRlZCk7XG4gICAgfVxuICAgIHRoaXMudHJhY2sgPSB0cmFjaztcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIC8vIGZvcndhcmQgZXZlbnRzXG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50Lk11dGVkLCB0aGlzLmhhbmRsZU11dGVkKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcy5oYW5kbGVVbm11dGVkKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChfYSA9IHRoaXMubG9nZ2VyQ29udGV4dENiKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKSksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodGhpcykpO1xuICB9XG4gIGdldCBpc011dGVkKCkge1xuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhTXV0ZWQ7XG4gIH1cbiAgZ2V0IGlzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXQgaXNTdWJzY3JpYmVkKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrICE9PSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0IGlzRW5jcnlwdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVuY3J5cHRpb24gIT09IEVuY3J5cHRpb25fVHlwZS5OT05FO1xuICB9XG4gIC8qKlxuICAgKiBhbiBbQXVkaW9UcmFja10gaWYgdGhpcyBwdWJsaWNhdGlvbiBob2xkcyBhbiBhdWRpbyB0cmFja1xuICAgKi9cbiAgZ2V0IGF1ZGlvVHJhY2soKSB7XG4gICAgaWYgKHRoaXMudHJhY2sgaW5zdGFuY2VvZiBMb2NhbEF1ZGlvVHJhY2sgfHwgdGhpcy50cmFjayBpbnN0YW5jZW9mIFJlbW90ZUF1ZGlvVHJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogYW4gW1ZpZGVvVHJhY2tdIGlmIHRoaXMgcHVibGljYXRpb24gaG9sZHMgYSB2aWRlbyB0cmFja1xuICAgKi9cbiAgZ2V0IHZpZGVvVHJhY2soKSB7XG4gICAgaWYgKHRoaXMudHJhY2sgaW5zdGFuY2VvZiBMb2NhbFZpZGVvVHJhY2sgfHwgdGhpcy50cmFjayBpbnN0YW5jZW9mIFJlbW90ZVZpZGVvVHJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbykge1xuICAgIHRoaXMudHJhY2tTaWQgPSBpbmZvLnNpZDtcbiAgICB0aGlzLnRyYWNrTmFtZSA9IGluZm8ubmFtZTtcbiAgICB0aGlzLnNvdXJjZSA9IFRyYWNrLnNvdXJjZUZyb21Qcm90byhpbmZvLnNvdXJjZSk7XG4gICAgdGhpcy5taW1lVHlwZSA9IGluZm8ubWltZVR5cGU7XG4gICAgaWYgKHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbyAmJiBpbmZvLndpZHRoID4gMCkge1xuICAgICAgdGhpcy5kaW1lbnNpb25zID0ge1xuICAgICAgICB3aWR0aDogaW5mby53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBpbmZvLmhlaWdodFxuICAgICAgfTtcbiAgICAgIHRoaXMuc2ltdWxjYXN0ZWQgPSBpbmZvLnNpbXVsY2FzdDtcbiAgICB9XG4gICAgdGhpcy5lbmNyeXB0aW9uID0gaW5mby5lbmNyeXB0aW9uO1xuICAgIHRoaXMudHJhY2tJbmZvID0gaW5mbztcbiAgICB0aGlzLmxvZy5kZWJ1ZygndXBkYXRlIHB1YmxpY2F0aW9uIGluZm8nLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgIGluZm9cbiAgICB9KSk7XG4gIH1cbn1cbihmdW5jdGlvbiAoVHJhY2tQdWJsaWNhdGlvbikge1xuICAoZnVuY3Rpb24gKFN1YnNjcmlwdGlvblN0YXR1cykge1xuICAgIFN1YnNjcmlwdGlvblN0YXR1c1tcIkRlc2lyZWRcIl0gPSBcImRlc2lyZWRcIjtcbiAgICBTdWJzY3JpcHRpb25TdGF0dXNbXCJTdWJzY3JpYmVkXCJdID0gXCJzdWJzY3JpYmVkXCI7XG4gICAgU3Vic2NyaXB0aW9uU3RhdHVzW1wiVW5zdWJzY3JpYmVkXCJdID0gXCJ1bnN1YnNjcmliZWRcIjtcbiAgfSkoVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMgfHwgKFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzID0ge30pKTtcbiAgKGZ1bmN0aW9uIChQZXJtaXNzaW9uU3RhdHVzKSB7XG4gICAgUGVybWlzc2lvblN0YXR1c1tcIkFsbG93ZWRcIl0gPSBcImFsbG93ZWRcIjtcbiAgICBQZXJtaXNzaW9uU3RhdHVzW1wiTm90QWxsb3dlZFwiXSA9IFwibm90X2FsbG93ZWRcIjtcbiAgfSkoVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzIHx8IChUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMgPSB7fSkpO1xufSkoVHJhY2tQdWJsaWNhdGlvbiB8fCAoVHJhY2tQdWJsaWNhdGlvbiA9IHt9KSk7XG5cbmNsYXNzIExvY2FsVHJhY2tQdWJsaWNhdGlvbiBleHRlbmRzIFRyYWNrUHVibGljYXRpb24ge1xuICBnZXQgaXNVcHN0cmVhbVBhdXNlZCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1Vwc3RyZWFtUGF1c2VkO1xuICB9XG4gIGNvbnN0cnVjdG9yKGtpbmQsIHRpLCB0cmFjaywgbG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKGtpbmQsIHRpLnNpZCwgdGkubmFtZSwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy50cmFjayA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhhbmRsZVRyYWNrRW5kZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbmRlZCk7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZUluZm8odGkpO1xuICAgIHRoaXMuc2V0VHJhY2sodHJhY2spO1xuICB9XG4gIHNldFRyYWNrKHRyYWNrKSB7XG4gICAgaWYgKHRoaXMudHJhY2spIHtcbiAgICAgIHRoaXMudHJhY2sub2ZmKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCk7XG4gICAgfVxuICAgIHN1cGVyLnNldFRyYWNrKHRyYWNrKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCk7XG4gICAgfVxuICB9XG4gIGdldCBpc011dGVkKCkge1xuICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFjay5pc011dGVkO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuaXNNdXRlZDtcbiAgfVxuICBnZXQgYXVkaW9UcmFjaygpIHtcbiAgICByZXR1cm4gc3VwZXIuYXVkaW9UcmFjaztcbiAgfVxuICBnZXQgdmlkZW9UcmFjaygpIHtcbiAgICByZXR1cm4gc3VwZXIudmlkZW9UcmFjaztcbiAgfVxuICAvKipcbiAgICogTXV0ZSB0aGUgdHJhY2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHVibGljYXRpb25cbiAgICovXG4gIG11dGUoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gKF9hID0gdGhpcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm11dGUoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVW5tdXRlIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uXG4gICAqL1xuICB1bm11dGUoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gKF9hID0gdGhpcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVubXV0ZSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQYXVzZXMgdGhlIG1lZGlhIHN0cmVhbSB0cmFjayBhc3NvY2lhdGVkIHdpdGggdGhpcyBwdWJsaWNhdGlvbiBmcm9tIGJlaW5nIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgKiBhbmQgc2lnbmFscyBcIm11dGVkXCIgZXZlbnQgdG8gb3RoZXIgcGFydGljaXBhbnRzXG4gICAqIFVzZWZ1bCBpZiB5b3Ugd2FudCB0byBwYXVzZSB0aGUgc3RyZWFtIHdpdGhvdXQgcGF1c2luZyB0aGUgbG9jYWwgbWVkaWEgc3RyZWFtIHRyYWNrXG4gICAqL1xuICBwYXVzZVVwc3RyZWFtKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgKF9hID0gdGhpcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdXNlVXBzdHJlYW0oKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVzdW1lcyBzZW5kaW5nIHRoZSBtZWRpYSBzdHJlYW0gdHJhY2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHVibGljYXRpb24gdG8gdGhlIHNlcnZlciBhZnRlciBhIGNhbGwgdG8gW1twYXVzZVVwc3RyZWFtKCldXVxuICAgKiBhbmQgc2lnbmFscyBcInVubXV0ZWRcIiBldmVudCB0byBvdGhlciBwYXJ0aWNpcGFudHMgKHVubGVzcyB0aGUgdHJhY2sgaXMgZXhwbGljaXRseSBtdXRlZClcbiAgICovXG4gIHJlc3VtZVVwc3RyZWFtKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgKF9hID0gdGhpcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3VtZVVwc3RyZWFtKCk7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIENvbm5lY3Rpb25RdWFsaXR5O1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uUXVhbGl0eSkge1xuICBDb25uZWN0aW9uUXVhbGl0eVtcIkV4Y2VsbGVudFwiXSA9IFwiZXhjZWxsZW50XCI7XG4gIENvbm5lY3Rpb25RdWFsaXR5W1wiR29vZFwiXSA9IFwiZ29vZFwiO1xuICBDb25uZWN0aW9uUXVhbGl0eVtcIlBvb3JcIl0gPSBcInBvb3JcIjtcbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGF0IGEgcGFydGljaXBhbnQgaGFzIHRlbXBvcmFyaWx5IChvciBwZXJtYW5lbnRseSkgbG9zdCBjb25uZWN0aW9uIHRvIExpdmVLaXQuXG4gICAqIEZvciBwZXJtYW5lbnQgZGlzY29ubmVjdGlvbiBhIGBQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZGAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIGFmdGVyIGEgdGltZW91dFxuICAgKi9cbiAgQ29ubmVjdGlvblF1YWxpdHlbXCJMb3N0XCJdID0gXCJsb3N0XCI7XG4gIENvbm5lY3Rpb25RdWFsaXR5W1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xufSkoQ29ubmVjdGlvblF1YWxpdHkgfHwgKENvbm5lY3Rpb25RdWFsaXR5ID0ge30pKTtcbmZ1bmN0aW9uIHF1YWxpdHlGcm9tUHJvdG8ocSkge1xuICBzd2l0Y2ggKHEpIHtcbiAgICBjYXNlIENvbm5lY3Rpb25RdWFsaXR5JDEuRVhDRUxMRU5UOlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5LkV4Y2VsbGVudDtcbiAgICBjYXNlIENvbm5lY3Rpb25RdWFsaXR5JDEuR09PRDpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Hb29kO1xuICAgIGNhc2UgQ29ubmVjdGlvblF1YWxpdHkkMS5QT09SOlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5LlBvb3I7XG4gICAgY2FzZSBDb25uZWN0aW9uUXVhbGl0eSQxLkxPU1Q6XG4gICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuTG9zdDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5LlVua25vd247XG4gIH1cbn1cbmNsYXNzIFBhcnRpY2lwYW50IGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChfYiA9IChfYSA9IHRoaXMubG9nZ2VyT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvZ2dlckNvbnRleHRDYikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKSwge1xuICAgICAgcGFydGljaXBhbnRTaWQ6IHRoaXMuc2lkLFxuICAgICAgcGFydGljaXBhbnRJZDogdGhpcy5pZGVudGl0eVxuICAgIH0pO1xuICB9XG4gIGdldCBpc0VuY3J5cHRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3Muc2l6ZSA+IDAgJiYgQXJyYXkuZnJvbSh0aGlzLnRyYWNrcy52YWx1ZXMoKSkuZXZlcnkodHIgPT4gdHIuaXNFbmNyeXB0ZWQpO1xuICB9XG4gIGdldCBpc0FnZW50KCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZ2VudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihzaWQsIGlkZW50aXR5LCBuYW1lLCBtZXRhZGF0YSwgbG9nZ2VyT3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBhdWRpbyBsZXZlbCBiZXR3ZWVuIDAtMS4wLCAxIGJlaW5nIGxvdWRlc3QsIDAgYmVpbmcgc29mdGVzdCAqL1xuICAgIHRoaXMuYXVkaW9MZXZlbCA9IDA7XG4gICAgLyoqIGlmIHBhcnRpY2lwYW50IGlzIGN1cnJlbnRseSBzcGVha2luZyAqL1xuICAgIHRoaXMuaXNTcGVha2luZyA9IGZhbHNlO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5ID0gQ29ubmVjdGlvblF1YWxpdHkuVW5rbm93bjtcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gbG9nZ2VyT3B0aW9ucyA9PT0gbnVsbCB8fCBsb2dnZXJPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlBhcnRpY2lwYW50KTtcbiAgICB0aGlzLmxvZ2dlck9wdGlvbnMgPSBsb2dnZXJPcHRpb25zO1xuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDEwMCk7XG4gICAgdGhpcy5zaWQgPSBzaWQ7XG4gICAgdGhpcy5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgIHRoaXMuYXVkaW9UcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy52aWRlb1RyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRyYWNrcyA9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXRUcmFja3MoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy50cmFja3MudmFsdWVzKCkpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgZmlyc3QgdHJhY2sgdGhhdCBtYXRjaGVzIHRoZSBzb3VyY2UgZmlsdGVyLCBmb3IgZXhhbXBsZSwgZ2V0dGluZ1xuICAgKiB0aGUgdXNlcidzIGNhbWVyYSB0cmFjayB3aXRoIGdldFRyYWNrQnlTb3VyY2UoVHJhY2suU291cmNlLkNhbWVyYSkuXG4gICAqIEBwYXJhbSBzb3VyY2VcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFRyYWNrKHNvdXJjZSkge1xuICAgIGZvciAoY29uc3QgWywgcHViXSBvZiB0aGlzLnRyYWNrcykge1xuICAgICAgaWYgKHB1Yi5zb3VyY2UgPT09IHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gcHViO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRmluZHMgdGhlIGZpcnN0IHRyYWNrIHRoYXQgbWF0Y2hlcyB0aGUgdHJhY2sncyBuYW1lLlxuICAgKiBAcGFyYW0gbmFtZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0VHJhY2tCeU5hbWUobmFtZSkge1xuICAgIGZvciAoY29uc3QgWywgcHViXSBvZiB0aGlzLnRyYWNrcykge1xuICAgICAgaWYgKHB1Yi50cmFja05hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHB1YjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IGNvbm5lY3Rpb25RdWFsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eTtcbiAgfVxuICBnZXQgaXNDYW1lcmFFbmFibGVkKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0VHJhY2soVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgcmV0dXJuICEoKF9hID0gdHJhY2sgPT09IG51bGwgfHwgdHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrLmlzTXV0ZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWUpO1xuICB9XG4gIGdldCBpc01pY3JvcGhvbmVFbmFibGVkKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0VHJhY2soVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xuICAgIHJldHVybiAhKChfYSA9IHRyYWNrID09PSBudWxsIHx8IHRyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFjay5pc011dGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlKTtcbiAgfVxuICBnZXQgaXNTY3JlZW5TaGFyZUVuYWJsZWQoKSB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldFRyYWNrKFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSk7XG4gICAgcmV0dXJuICEhdHJhY2s7XG4gIH1cbiAgZ2V0IGlzTG9jYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKiB3aGVuIHBhcnRpY2lwYW50IGpvaW5lZCB0aGUgcm9vbSAqL1xuICBnZXQgam9pbmVkQXQoKSB7XG4gICAgaWYgKHRoaXMucGFydGljaXBhbnRJbmZvKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyLnBhcnNlSW50KHRoaXMucGFydGljaXBhbnRJbmZvLmpvaW5lZEF0LnRvU3RyaW5nKCkpICogMTAwMCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlSW5mbyhpbmZvKSB7XG4gICAgLy8gaXQncyBwb3NzaWJsZSB0aGUgdXBkYXRlIGNvdWxkIGJlIGFwcGxpZWQgb3V0IG9mIG9yZGVyIGR1ZSB0byBhd2FpdFxuICAgIC8vIGR1cmluZyByZWNvbm5lY3Qgc2VxdWVuY2VzLiB3aGVuIHRoYXQgaGFwcGVucywgaXQncyBwb3NzaWJsZSBmb3Igc2VydmVyXG4gICAgLy8gdG8gaGF2ZSBzZW50IG1vcmUgcmVjZW50IHZlcnNpb24gb2YgcGFydGljaXBhbnQgaW5mbyB3aGlsZSBKUyBpcyB3YWl0aW5nXG4gICAgLy8gdG8gcHJvY2VzcyB0aGUgZXhpc3RpbmcgcGF5bG9hZC5cbiAgICAvLyB3aGVuIHRoZSBwYXJ0aWNpcGFudCBzaWQgcmVtYWlucyB0aGUgc2FtZSwgYW5kIHdlIGFscmVhZHkgaGF2ZSBhIGxhdGVyIHZlcnNpb25cbiAgICAvLyBvZiB0aGUgcGF5bG9hZCwgdGhleSBjYW4gYmUgc2FmZWx5IHNraXBwZWRcbiAgICBpZiAodGhpcy5wYXJ0aWNpcGFudEluZm8gJiYgdGhpcy5wYXJ0aWNpcGFudEluZm8uc2lkID09PSBpbmZvLnNpZCAmJiB0aGlzLnBhcnRpY2lwYW50SW5mby52ZXJzaW9uID4gaW5mby52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaWRlbnRpdHkgPSBpbmZvLmlkZW50aXR5O1xuICAgIHRoaXMuc2lkID0gaW5mby5zaWQ7XG4gICAgdGhpcy5fc2V0TmFtZShpbmZvLm5hbWUpO1xuICAgIHRoaXMuX3NldE1ldGFkYXRhKGluZm8ubWV0YWRhdGEpO1xuICAgIGlmIChpbmZvLnBlcm1pc3Npb24pIHtcbiAgICAgIHRoaXMuc2V0UGVybWlzc2lvbnMoaW5mby5wZXJtaXNzaW9uKTtcbiAgICB9XG4gICAgLy8gc2V0IHRoaXMgbGFzdCBzbyBzZXRNZXRhZGF0YSBjYW4gZGV0ZWN0IGNoYW5nZXNcbiAgICB0aGlzLnBhcnRpY2lwYW50SW5mbyA9IGluZm87XG4gICAgdGhpcy5sb2cudHJhY2UoJ3VwZGF0ZSBwYXJ0aWNpcGFudCBpbmZvJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICBpbmZvXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIG1ldGFkYXRhIGZyb20gc2VydmVyXG4gICAqKi9cbiAgX3NldE1ldGFkYXRhKG1kKSB7XG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMubWV0YWRhdGEgIT09IG1kO1xuICAgIGNvbnN0IHByZXZNZXRhZGF0YSA9IHRoaXMubWV0YWRhdGE7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1kO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgcHJldk1ldGFkYXRhKTtcbiAgICB9XG4gIH1cbiAgX3NldE5hbWUobmFtZSkge1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLm5hbWUgIT09IG5hbWU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgbmFtZSk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0UGVybWlzc2lvbnMocGVybWlzc2lvbnMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9ucyA9IHRoaXMucGVybWlzc2lvbnM7XG4gICAgY29uc3QgY2hhbmdlZCA9IHBlcm1pc3Npb25zLmNhblB1Ymxpc2ggIT09ICgoX2EgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuUHVibGlzaCkgfHwgcGVybWlzc2lvbnMuY2FuU3Vic2NyaWJlICE9PSAoKF9iID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhblN1YnNjcmliZSkgfHwgcGVybWlzc2lvbnMuY2FuUHVibGlzaERhdGEgIT09ICgoX2MgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FuUHVibGlzaERhdGEpIHx8IHBlcm1pc3Npb25zLmhpZGRlbiAhPT0gKChfZCA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5oaWRkZW4pIHx8IHBlcm1pc3Npb25zLnJlY29yZGVyICE9PSAoKF9lID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlY29yZGVyKSB8fCBwZXJtaXNzaW9ucy5jYW5QdWJsaXNoU291cmNlcy5sZW5ndGggIT09IHRoaXMucGVybWlzc2lvbnMuY2FuUHVibGlzaFNvdXJjZXMubGVuZ3RoIHx8IHBlcm1pc3Npb25zLmNhblB1Ymxpc2hTb3VyY2VzLnNvbWUoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSAoKF9hID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhblB1Ymxpc2hTb3VyY2VzW2luZGV4XSk7XG4gICAgfSk7XG4gICAgdGhpcy5wZXJtaXNzaW9ucyA9IHBlcm1pc3Npb25zO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgcHJldlBlcm1pc3Npb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRJc1NwZWFraW5nKHNwZWFraW5nKSB7XG4gICAgaWYgKHNwZWFraW5nID09PSB0aGlzLmlzU3BlYWtpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc1NwZWFraW5nID0gc3BlYWtpbmc7XG4gICAgaWYgKHNwZWFraW5nKSB7XG4gICAgICB0aGlzLmxhc3RTcG9rZUF0ID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuSXNTcGVha2luZ0NoYW5nZWQsIHNwZWFraW5nKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldENvbm5lY3Rpb25RdWFsaXR5KHEpIHtcbiAgICBjb25zdCBwcmV2UXVhbGl0eSA9IHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5O1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5ID0gcXVhbGl0eUZyb21Qcm90byhxKTtcbiAgICBpZiAocHJldlF1YWxpdHkgIT09IHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5KSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0QXVkaW9Db250ZXh0KGN0eCkge1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gY3R4O1xuICAgIHRoaXMuYXVkaW9UcmFja3MuZm9yRWFjaCh0cmFjayA9PiAodHJhY2sudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVBdWRpb1RyYWNrIHx8IHRyYWNrLnRyYWNrIGluc3RhbmNlb2YgTG9jYWxBdWRpb1RyYWNrKSAmJiB0cmFjay50cmFjay5zZXRBdWRpb0NvbnRleHQoY3R4KSk7XG4gIH1cbiAgYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbikge1xuICAgIC8vIGZvcndhcmQgcHVibGljYXRpb24gZHJpdmVuIGV2ZW50c1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuTXV0ZWQsICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrTXV0ZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlVubXV0ZWQsICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5tdXRlZCwgcHVibGljYXRpb24pO1xuICAgIH0pO1xuICAgIGNvbnN0IHB1YiA9IHB1YmxpY2F0aW9uO1xuICAgIGlmIChwdWIudHJhY2spIHtcbiAgICAgIHB1Yi50cmFjay5zaWQgPSBwdWJsaWNhdGlvbi50cmFja1NpZDtcbiAgICB9XG4gICAgdGhpcy50cmFja3Muc2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBwdWJsaWNhdGlvbik7XG4gICAgc3dpdGNoIChwdWJsaWNhdGlvbi5raW5kKSB7XG4gICAgICBjYXNlIFRyYWNrLktpbmQuQXVkaW86XG4gICAgICAgIHRoaXMuYXVkaW9UcmFja3Muc2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFjay5LaW5kLlZpZGVvOlxuICAgICAgICB0aGlzLnZpZGVvVHJhY2tzLnNldChwdWJsaWNhdGlvbi50cmFja1NpZCwgcHVibGljYXRpb24pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhY2tQZXJtaXNzaW9uVG9Qcm90byhwZXJtcykge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgaWYgKCFwZXJtcy5wYXJ0aWNpcGFudFNpZCAmJiAhcGVybXMucGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFjayBwZXJtaXNzaW9uLCBtdXN0IHByb3ZpZGUgYXQgbGVhc3Qgb25lIG9mIHBhcnRpY2lwYW50SWRlbnRpdHkgYW5kIHBhcnRpY2lwYW50U2lkJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBUcmFja1Blcm1pc3Npb24oe1xuICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IChfYSA9IHBlcm1zLnBhcnRpY2lwYW50SWRlbnRpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLFxuICAgIHBhcnRpY2lwYW50U2lkOiAoX2IgPSBwZXJtcy5wYXJ0aWNpcGFudFNpZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycsXG4gICAgYWxsVHJhY2tzOiAoX2MgPSBwZXJtcy5hbGxvd0FsbCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2UsXG4gICAgdHJhY2tTaWRzOiBwZXJtcy5hbGxvd2VkVHJhY2tTaWRzIHx8IFtdXG4gIH0pO1xufVxuXG5jbGFzcyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uIGV4dGVuZHMgVHJhY2tQdWJsaWNhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGtpbmQsIHRpLCBhdXRvU3Vic2NyaWJlLCBsb2dnZXJPcHRpb25zKSB7XG4gICAgc3VwZXIoa2luZCwgdGkuc2lkLCB0aS5uYW1lLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLnRyYWNrID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLmFsbG93ZWQgPSB0cnVlO1xuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHkgPSBWaWRlb1F1YWxpdHkuSElHSDtcbiAgICB0aGlzLmhhbmRsZUVuZGVkID0gdHJhY2sgPT4ge1xuICAgICAgdGhpcy5zZXRUcmFjayh1bmRlZmluZWQpO1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRW5kZWQsIHRyYWNrKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSA9IHZpc2libGUgPT4ge1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJhZGFwdGl2ZXN0cmVhbSB2aWRlbyB2aXNpYmlsaXR5IFwiLmNvbmNhdCh0aGlzLnRyYWNrU2lkLCBcIiwgdmlzaWJsZT1cIikuY29uY2F0KHZpc2libGUpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdGhpcy5kaXNhYmxlZCA9ICF2aXNpYmxlO1xuICAgICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlID0gZGltZW5zaW9ucyA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcImFkYXB0aXZlc3RyZWFtIHZpZGVvIGRpbWVuc2lvbnMgXCIuY29uY2F0KGRpbWVuc2lvbnMud2lkdGgsIFwieFwiKS5jb25jYXQoZGltZW5zaW9ucy5oZWlnaHQpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdGhpcy52aWRlb0RpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xuICAgICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgICB9O1xuICAgIHRoaXMuc3Vic2NyaWJlZCA9IGF1dG9TdWJzY3JpYmU7XG4gICAgdGhpcy51cGRhdGVJbmZvKHRpKTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHRvIHRoaXMgcmVtb3RlIHRyYWNrXG4gICAqIEBwYXJhbSBzdWJzY3JpYmVkIHRydWUgdG8gc3Vic2NyaWJlIHRvIGEgdHJhY2ssIGZhbHNlIHRvIHVuc3Vic2NyaWJlXG4gICAqL1xuICBzZXRTdWJzY3JpYmVkKHN1YnNjcmliZWQpIHtcbiAgICBjb25zdCBwcmV2U3RhdHVzID0gdGhpcy5zdWJzY3JpcHRpb25TdGF0dXM7XG4gICAgY29uc3QgcHJldlBlcm1pc3Npb24gPSB0aGlzLnBlcm1pc3Npb25TdGF0dXM7XG4gICAgdGhpcy5zdWJzY3JpYmVkID0gc3Vic2NyaWJlZDtcbiAgICAvLyByZXNldCBhbGxvd2VkIHN0YXR1cyB3aGVuIGRlc2lyZWQgc3Vic2NyaXB0aW9uIHN0YXRlIGNoYW5nZXNcbiAgICAvLyBzZXJ2ZXIgd2lsbCBub3RpZnkgY2xpZW50IHZpYSBzaWduYWwgbWVzc2FnZSBpZiBpdCdzIG5vdCBhbGxvd2VkXG4gICAgaWYgKHN1YnNjcmliZWQpIHtcbiAgICAgIHRoaXMuYWxsb3dlZCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHN1YiA9IG5ldyBVcGRhdGVTdWJzY3JpcHRpb24oe1xuICAgICAgdHJhY2tTaWRzOiBbdGhpcy50cmFja1NpZF0sXG4gICAgICBzdWJzY3JpYmU6IHRoaXMuc3Vic2NyaWJlZCxcbiAgICAgIHBhcnRpY2lwYW50VHJhY2tzOiBbbmV3IFBhcnRpY2lwYW50VHJhY2tzKHtcbiAgICAgICAgLy8gc2VuZGluZyBhbiBlbXB0eSBwYXJ0aWNpcGFudCBpZCBzaW5jZSBUcmFja1B1YmxpY2F0aW9uIGRvZXNuJ3Qga2VlcCBpdFxuICAgICAgICAvLyB0aGlzIGlzIGZpbGxlZCBpbiBieSB0aGUgcGFydGljaXBhbnQgdGhhdCByZWNlaXZlcyB0aGlzIG1lc3NhZ2VcbiAgICAgICAgcGFydGljaXBhbnRTaWQ6ICcnLFxuICAgICAgICB0cmFja1NpZHM6IFt0aGlzLnRyYWNrU2lkXVxuICAgICAgfSldXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBkYXRlU3Vic2NyaXB0aW9uLCBzdWIpO1xuICAgIHRoaXMuZW1pdFN1YnNjcmlwdGlvblVwZGF0ZUlmQ2hhbmdlZChwcmV2U3RhdHVzKTtcbiAgICB0aGlzLmVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZQZXJtaXNzaW9uKTtcbiAgfVxuICBnZXQgc3Vic2NyaXB0aW9uU3RhdHVzKCkge1xuICAgIGlmICh0aGlzLnN1YnNjcmliZWQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMuVW5zdWJzY3JpYmVkO1xuICAgIH1cbiAgICBpZiAoIXN1cGVyLmlzU3Vic2NyaWJlZCkge1xuICAgICAgcmV0dXJuIFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzLkRlc2lyZWQ7XG4gICAgfVxuICAgIHJldHVybiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cy5TdWJzY3JpYmVkO1xuICB9XG4gIGdldCBwZXJtaXNzaW9uU3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLmFsbG93ZWQgPyBUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMuQWxsb3dlZCA6IFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cy5Ob3RBbGxvd2VkO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdHJhY2sgaXMgc3Vic2NyaWJlZCwgYW5kIHJlYWR5IGZvciBwbGF5YmFja1xuICAgKi9cbiAgZ2V0IGlzU3Vic2NyaWJlZCgpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpYmVkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuaXNTdWJzY3JpYmVkO1xuICB9XG4gIC8vIHJldHVybnMgY2xpZW50J3MgZGVzaXJlIHRvIHN1YnNjcmliZSB0byBhIHRyYWNrLCBhbHNvIHRydWUgaWYgYXV0b1N1YnNjcmliZSBpcyBlbmFibGVkXG4gIGdldCBpc0Rlc2lyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlZCAhPT0gZmFsc2U7XG4gIH1cbiAgZ2V0IGlzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gIXRoaXMuZGlzYWJsZWQ7XG4gIH1cbiAgLyoqXG4gICAqIGRpc2FibGUgc2VydmVyIGZyb20gc2VuZGluZyBkb3duIGRhdGEgZm9yIHRoaXMgdHJhY2suIHRoaXMgaXMgdXNlZnVsIHdoZW5cbiAgICogdGhlIHBhcnRpY2lwYW50IGlzIG9mZiBzY3JlZW4sIHlvdSBtYXkgZGlzYWJsZSBzdHJlYW1pbmcgZG93biB0aGVpciB2aWRlb1xuICAgKiB0byByZWR1Y2UgYmFuZHdpZHRoIHJlcXVpcmVtZW50c1xuICAgKiBAcGFyYW0gZW5hYmxlZFxuICAgKi9cbiAgc2V0RW5hYmxlZChlbmFibGVkKSB7XG4gICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpIHx8IHRoaXMuZGlzYWJsZWQgPT09ICFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZWQgPSAhZW5hYmxlZDtcbiAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBmb3IgdHJhY2tzIHRoYXQgc3VwcG9ydCBzaW11bGNhc3RpbmcsIGFkanVzdCBzdWJzY3JpYmVkIHF1YWxpdHlcbiAgICpcbiAgICogVGhpcyBpbmRpY2F0ZXMgdGhlIGhpZ2hlc3QgcXVhbGl0eSB0aGUgY2xpZW50IGNhbiBhY2NlcHQuIGlmIG5ldHdvcmtcbiAgICogYmFuZHdpZHRoIGRvZXMgbm90IGFsbG93LCBzZXJ2ZXIgd2lsbCBhdXRvbWF0aWNhbGx5IHJlZHVjZSBxdWFsaXR5IHRvXG4gICAqIG9wdGltaXplIGZvciB1bmludGVycnVwdGVkIHZpZGVvXG4gICAqL1xuICBzZXRWaWRlb1F1YWxpdHkocXVhbGl0eSkge1xuICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSB8fCB0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHkgPT09IHF1YWxpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5ID0gcXVhbGl0eTtcbiAgICB0aGlzLnZpZGVvRGltZW5zaW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICB9XG4gIHNldFZpZGVvRGltZW5zaW9ucyhkaW1lbnNpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIXRoaXMuaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCgoX2EgPSB0aGlzLnZpZGVvRGltZW5zaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndpZHRoKSA9PT0gZGltZW5zaW9ucy53aWR0aCAmJiAoKF9iID0gdGhpcy52aWRlb0RpbWVuc2lvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWlnaHQpID09PSBkaW1lbnNpb25zLmhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy50cmFjayBpbnN0YW5jZW9mIFJlbW90ZVZpZGVvVHJhY2spIHtcbiAgICAgIHRoaXMudmlkZW9EaW1lbnNpb25zID0gZGltZW5zaW9ucztcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gIH1cbiAgc2V0VmlkZW9GUFMoZnBzKSB7XG4gICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKHRoaXMudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVWaWRlb1RyYWNrKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcHMgPT09IGZwcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZwcyA9IGZwcztcbiAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICB9XG4gIGdldCB2aWRlb1F1YWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldFRyYWNrKHRyYWNrKSB7XG4gICAgY29uc3QgcHJldlN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZUcmFjayA9IHRoaXMudHJhY2s7XG4gICAgaWYgKHByZXZUcmFjayA9PT0gdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByZXZUcmFjaykge1xuICAgICAgLy8gdW5yZWdpc3RlciBsaXN0ZW5lclxuICAgICAgcHJldlRyYWNrLm9mZihUcmFja0V2ZW50LlZpZGVvRGltZW5zaW9uc0NoYW5nZWQsIHRoaXMuaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlKTtcbiAgICAgIHByZXZUcmFjay5vZmYoVHJhY2tFdmVudC5WaXNpYmlsaXR5Q2hhbmdlZCwgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHByZXZUcmFjay5vZmYoVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgICBwcmV2VHJhY2suZGV0YWNoKCk7XG4gICAgICBwcmV2VHJhY2suc3RvcE1vbml0b3IoKTtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVuc3Vic2NyaWJlZCwgcHJldlRyYWNrKTtcbiAgICB9XG4gICAgc3VwZXIuc2V0VHJhY2sodHJhY2spO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgdHJhY2suc2lkID0gdGhpcy50cmFja1NpZDtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCwgdGhpcy5oYW5kbGVWaWRlb0RpbWVuc2lvbnNDaGFuZ2UpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5WaXNpYmlsaXR5Q2hhbmdlZCwgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuU3Vic2NyaWJlZCwgdHJhY2spO1xuICAgIH1cbiAgICB0aGlzLmVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZQZXJtaXNzaW9uKTtcbiAgICB0aGlzLmVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldlN0YXR1cyk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRBbGxvd2VkKGFsbG93ZWQpIHtcbiAgICBjb25zdCBwcmV2U3RhdHVzID0gdGhpcy5zdWJzY3JpcHRpb25TdGF0dXM7XG4gICAgY29uc3QgcHJldlBlcm1pc3Npb24gPSB0aGlzLnBlcm1pc3Npb25TdGF0dXM7XG4gICAgdGhpcy5hbGxvd2VkID0gYWxsb3dlZDtcbiAgICB0aGlzLmVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZQZXJtaXNzaW9uKTtcbiAgICB0aGlzLmVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldlN0YXR1cyk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRTdWJzY3JpcHRpb25FcnJvcihlcnJvcikge1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlN1YnNjcmlwdGlvbkZhaWxlZCwgZXJyb3IpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlSW5mbyhpbmZvKSB7XG4gICAgc3VwZXIudXBkYXRlSW5mbyhpbmZvKTtcbiAgICBjb25zdCBwcmV2TWV0YWRhdGFNdXRlZCA9IHRoaXMubWV0YWRhdGFNdXRlZDtcbiAgICB0aGlzLm1ldGFkYXRhTXV0ZWQgPSBpbmZvLm11dGVkO1xuICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICB0aGlzLnRyYWNrLnNldE11dGVkKGluZm8ubXV0ZWQpO1xuICAgIH0gZWxzZSBpZiAocHJldk1ldGFkYXRhTXV0ZWQgIT09IGluZm8ubXV0ZWQpIHtcbiAgICAgIHRoaXMuZW1pdChpbmZvLm11dGVkID8gVHJhY2tFdmVudC5NdXRlZCA6IFRyYWNrRXZlbnQuVW5tdXRlZCk7XG4gICAgfVxuICB9XG4gIGVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldmlvdXNTdGF0dXMpIHtcbiAgICBjb25zdCBjdXJyZW50U3RhdHVzID0gdGhpcy5zdWJzY3JpcHRpb25TdGF0dXM7XG4gICAgaWYgKHByZXZpb3VzU3RhdHVzID09PSBjdXJyZW50U3RhdHVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIGN1cnJlbnRTdGF0dXMsIHByZXZpb3VzU3RhdHVzKTtcbiAgfVxuICBlbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZChwcmV2aW91c1Blcm1pc3Npb25TdGF0dXMpIHtcbiAgICBjb25zdCBjdXJyZW50UGVybWlzc2lvblN0YXR1cyA9IHRoaXMucGVybWlzc2lvblN0YXR1cztcbiAgICBpZiAoY3VycmVudFBlcm1pc3Npb25TdGF0dXMgIT09IHByZXZpb3VzUGVybWlzc2lvblN0YXR1cykge1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIHRoaXMucGVybWlzc2lvblN0YXR1cywgcHJldmlvdXNQZXJtaXNzaW9uU3RhdHVzKTtcbiAgICB9XG4gIH1cbiAgaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkge1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8gJiYgdGhpcy5pc0FkYXB0aXZlU3RyZWFtKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdhZGFwdGl2ZSBzdHJlYW0gaXMgZW5hYmxlZCwgY2Fubm90IGNoYW5nZSB2aWRlbyB0cmFjayBzZXR0aW5ncycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0Rlc2lyZWQpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ2Nhbm5vdCB1cGRhdGUgdHJhY2sgc2V0dGluZ3Mgd2hlbiBub3Qgc3Vic2NyaWJlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCBpc0FkYXB0aXZlU3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrIGluc3RhbmNlb2YgUmVtb3RlVmlkZW9UcmFjayAmJiB0aGlzLnRyYWNrLmlzQWRhcHRpdmVTdHJlYW07XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIGVtaXRUcmFja1VwZGF0ZSgpIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IG5ldyBVcGRhdGVUcmFja1NldHRpbmdzKHtcbiAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdLFxuICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQsXG4gICAgICBmcHM6IHRoaXMuZnBzXG4gICAgfSk7XG4gICAgaWYgKHRoaXMudmlkZW9EaW1lbnNpb25zKSB7XG4gICAgICBzZXR0aW5ncy53aWR0aCA9IE1hdGguY2VpbCh0aGlzLnZpZGVvRGltZW5zaW9ucy53aWR0aCk7XG4gICAgICBzZXR0aW5ncy5oZWlnaHQgPSBNYXRoLmNlaWwodGhpcy52aWRlb0RpbWVuc2lvbnMuaGVpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZXR0aW5ncy5xdWFsaXR5ID0gdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkZWZhdWx0cyB0byBoaWdoIHF1YWxpdHlcbiAgICAgIHNldHRpbmdzLnF1YWxpdHkgPSBWaWRlb1F1YWxpdHkuSElHSDtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBkYXRlU2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgfVxufVxuXG5jbGFzcyBSZW1vdGVQYXJ0aWNpcGFudCBleHRlbmRzIFBhcnRpY2lwYW50IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgZnJvbVBhcnRpY2lwYW50SW5mbyhzaWduYWxDbGllbnQsIHBpKSB7XG4gICAgcmV0dXJuIG5ldyBSZW1vdGVQYXJ0aWNpcGFudChzaWduYWxDbGllbnQsIHBpLnNpZCwgcGkuaWRlbnRpdHksIHBpLm5hbWUsIHBpLm1ldGFkYXRhKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKHNpZ25hbENsaWVudCwgc2lkLCBpZGVudGl0eSwgbmFtZSwgbWV0YWRhdGEsIGxvZ2dlck9wdGlvbnMpIHtcbiAgICBzdXBlcihzaWQsIGlkZW50aXR5IHx8ICcnLCBuYW1lLCBtZXRhZGF0YSwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5zaWduYWxDbGllbnQgPSBzaWduYWxDbGllbnQ7XG4gICAgdGhpcy50cmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hdWRpb1RyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnZpZGVvVHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudm9sdW1lTWFwID0gbmV3IE1hcCgpO1xuICB9XG4gIGFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pIHtcbiAgICBzdXBlci5hZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uKTtcbiAgICAvLyByZWdpc3RlciBhY3Rpb24gZXZlbnRzXG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5VcGRhdGVTZXR0aW5ncywgc2V0dGluZ3MgPT4ge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3NlbmQgdXBkYXRlIHNldHRpbmdzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSkpO1xuICAgICAgdGhpcy5zaWduYWxDbGllbnQuc2VuZFVwZGF0ZVRyYWNrU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIH0pO1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuVXBkYXRlU3Vic2NyaXB0aW9uLCBzdWIgPT4ge1xuICAgICAgc3ViLnBhcnRpY2lwYW50VHJhY2tzLmZvckVhY2gocHQgPT4ge1xuICAgICAgICBwdC5wYXJ0aWNpcGFudFNpZCA9IHRoaXMuc2lkO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNpZ25hbENsaWVudC5zZW5kVXBkYXRlU3Vic2NyaXB0aW9uKHN1Yik7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCwgc3RhdHVzID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIHB1YmxpY2F0aW9uLCBzdGF0dXMpO1xuICAgIH0pO1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgc3RhdHVzID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgcHVibGljYXRpb24sIHN0YXR1cyk7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5TdWJzY3JpYmVkLCB0cmFjayA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmliZWQsIHRyYWNrLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5VbnN1YnNjcmliZWQsIHByZXZpb3VzVHJhY2sgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbnN1YnNjcmliZWQsIHByZXZpb3VzVHJhY2ssIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlN1YnNjcmlwdGlvbkZhaWxlZCwgZXJyb3IgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBlcnJvcik7XG4gICAgfSk7XG4gIH1cbiAgZ2V0VHJhY2soc291cmNlKSB7XG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFjayhzb3VyY2UpO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH1cbiAgfVxuICBnZXRUcmFja0J5TmFtZShuYW1lKSB7XG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFja0J5TmFtZShuYW1lKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjaztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIHNldHMgdGhlIHZvbHVtZSBvbiB0aGUgcGFydGljaXBhbnQncyBhdWRpbyB0cmFja1xuICAgKiBieSBkZWZhdWx0LCB0aGlzIGFmZmVjdHMgdGhlIG1pY3JvcGhvbmUgcHVibGljYXRpb25cbiAgICogYSBkaWZmZXJlbnQgc291cmNlIGNhbiBiZSBwYXNzZWQgaW4gYXMgYSBzZWNvbmQgYXJndW1lbnRcbiAgICogaWYgbm8gdHJhY2sgZXhpc3RzIHRoZSB2b2x1bWUgd2lsbCBiZSBhcHBsaWVkIHdoZW4gdGhlIG1pY3JvcGhvbmUgdHJhY2sgaXMgYWRkZWRcbiAgICovXG4gIHNldFZvbHVtZSh2b2x1bWUpIHtcbiAgICBsZXQgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTtcbiAgICB0aGlzLnZvbHVtZU1hcC5zZXQoc291cmNlLCB2b2x1bWUpO1xuICAgIGNvbnN0IGF1ZGlvUHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrKHNvdXJjZSk7XG4gICAgaWYgKGF1ZGlvUHVibGljYXRpb24gJiYgYXVkaW9QdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgYXVkaW9QdWJsaWNhdGlvbi50cmFjay5zZXRWb2x1bWUodm9sdW1lKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIGdldHMgdGhlIHZvbHVtZSBvbiB0aGUgcGFydGljaXBhbnQncyBtaWNyb3Bob25lIHRyYWNrXG4gICAqL1xuICBnZXRWb2x1bWUoKSB7XG4gICAgbGV0IHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gICAgY29uc3QgYXVkaW9QdWJsaWNhdGlvbiA9IHRoaXMuZ2V0VHJhY2soc291cmNlKTtcbiAgICBpZiAoYXVkaW9QdWJsaWNhdGlvbiAmJiBhdWRpb1B1YmxpY2F0aW9uLnRyYWNrKSB7XG4gICAgICByZXR1cm4gYXVkaW9QdWJsaWNhdGlvbi50cmFjay5nZXRWb2x1bWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudm9sdW1lTWFwLmdldChzb3VyY2UpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2sobWVkaWFUcmFjaywgc2lkLCBtZWRpYVN0cmVhbSwgcmVjZWl2ZXIsIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MsIHRyaWVzTGVmdCkge1xuICAgIC8vIGZpbmQgdGhlIHRyYWNrIHB1YmxpY2F0aW9uXG4gICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgdGhlIG1lZGlhIHRyYWNrIHRvIGFycml2ZSBiZWZvcmUgcGFydGljaXBhbnQgaW5mb1xuICAgIGxldCBwdWJsaWNhdGlvbiA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihzaWQpO1xuICAgIC8vIGl0J3MgYWxzbyBwb3NzaWJsZSB0aGF0IHRoZSBicm93c2VyIGRpZG4ndCBob25vciBvdXIgb3JpZ2luYWwgdHJhY2sgaWRcbiAgICAvLyBGaXJlRm94IHdvdWxkIHVzZSBpdHMgb3duIGxvY2FsIHV1aWQgaW5zdGVhZCBvZiBzZXJ2ZXIgdHJhY2sgaWRcbiAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICBpZiAoIXNpZC5zdGFydHNXaXRoKCdUUicpKSB7XG4gICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IHRyYWNrIHRoYXQgbWF0Y2hlcyB0eXBlXG4gICAgICAgIHRoaXMudHJhY2tzLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgaWYgKCFwdWJsaWNhdGlvbiAmJiBtZWRpYVRyYWNrLmtpbmQgPT09IHAua2luZC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICBwdWJsaWNhdGlvbiA9IHA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd2hlbiB3ZSBjb3VsZG4ndCBsb2NhdGUgdGhlIHRyYWNrLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIG1ldGFkYXRhIGhhc24ndFxuICAgIC8vIHlldCBhcnJpdmVkLiBXYWl0IGEgYml0IGxvbmdlciBmb3IgaXQgdG8gYXJyaXZlLCBvciBmaXJlIGFuIGVycm9yXG4gICAgaWYgKCFwdWJsaWNhdGlvbikge1xuICAgICAgaWYgKHRyaWVzTGVmdCA9PT0gMCkge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGZpbmQgcHVibGlzaGVkIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgdHJhY2tTaWQ6IHNpZFxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBzaWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHJpZXNMZWZ0ID09PSB1bmRlZmluZWQpIHRyaWVzTGVmdCA9IDIwO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2sobWVkaWFUcmFjaywgc2lkLCBtZWRpYVN0cmVhbSwgcmVjZWl2ZXIsIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MsIHRyaWVzTGVmdCAtIDEpO1xuICAgICAgfSwgMTUwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1lZGlhVHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2VuZGVkJykge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoJ3VuYWJsZSB0byBzdWJzY3JpYmUgYmVjYXVzZSBNZWRpYVN0cmVhbVRyYWNrIGlzIGVuZGVkLiBEbyBub3QgY2FsbCBNZWRpYVN0cmVhbVRyYWNrLnN0b3AoKScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikpKTtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBzaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc1ZpZGVvID0gbWVkaWFUcmFjay5raW5kID09PSAndmlkZW8nO1xuICAgIGxldCB0cmFjaztcbiAgICBpZiAoaXNWaWRlbykge1xuICAgICAgdHJhY2sgPSBuZXcgUmVtb3RlVmlkZW9UcmFjayhtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2sgPSBuZXcgUmVtb3RlQXVkaW9UcmFjayhtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyLCB0aGlzLmF1ZGlvQ29udGV4dCwgdGhpcy5hdWRpb091dHB1dCk7XG4gICAgfVxuICAgIC8vIHNldCB0cmFjayBpbmZvXG4gICAgdHJhY2suc291cmNlID0gcHVibGljYXRpb24uc291cmNlO1xuICAgIC8vIGtlZXAgcHVibGljYXRpb24ncyBtdXRlZCBzdGF0dXNcbiAgICB0cmFjay5pc011dGVkID0gcHVibGljYXRpb24uaXNNdXRlZDtcbiAgICB0cmFjay5zZXRNZWRpYVN0cmVhbShtZWRpYVN0cmVhbSk7XG4gICAgdHJhY2suc3RhcnQoKTtcbiAgICBwdWJsaWNhdGlvbi5zZXRUcmFjayh0cmFjayk7XG4gICAgLy8gc2V0IHBhcnRpY2lwYW50IHZvbHVtZXMgb24gbmV3IGF1ZGlvIHRyYWNrc1xuICAgIGlmICh0aGlzLnZvbHVtZU1hcC5oYXMocHVibGljYXRpb24uc291cmNlKSAmJiB0cmFjayBpbnN0YW5jZW9mIFJlbW90ZUF1ZGlvVHJhY2spIHtcbiAgICAgIHRyYWNrLnNldFZvbHVtZSh0aGlzLnZvbHVtZU1hcC5nZXQocHVibGljYXRpb24uc291cmNlKSk7XG4gICAgfVxuICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBoYXNNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gISF0aGlzLnBhcnRpY2lwYW50SW5mbztcbiAgfVxuICBnZXRUcmFja1B1YmxpY2F0aW9uKHNpZCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrcy5nZXQoc2lkKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbykge1xuICAgIGlmICghc3VwZXIudXBkYXRlSW5mbyhpbmZvKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyB3ZSBhcmUgZ2V0dGluZyBhIGxpc3Qgb2YgYWxsIGF2YWlsYWJsZSB0cmFja3MsIHJlY29uY2lsZSBpbiBoZXJlXG4gICAgLy8gYW5kIHNlbmQgb3V0IGV2ZW50cyBmb3IgY2hhbmdlc1xuICAgIC8vIHJlY29uY2lsZSB0cmFjayBwdWJsaWNhdGlvbnMsIHB1Ymxpc2ggZXZlbnRzIG9ubHkgaWYgbWV0YWRhdGEgaXMgYWxyZWFkeSB0aGVyZVxuICAgIC8vIGkuZS4gY2hhbmdlcyBzaW5jZSB0aGUgbG9jYWwgcGFydGljaXBhbnQgaGFzIGpvaW5lZFxuICAgIGNvbnN0IHZhbGlkVHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG5ld1RyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICBpbmZvLnRyYWNrcy5mb3JFYWNoKHRpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBsZXQgcHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24odGkuc2lkKTtcbiAgICAgIGlmICghcHVibGljYXRpb24pIHtcbiAgICAgICAgLy8gbmV3IHB1YmxpY2F0aW9uXG4gICAgICAgIGNvbnN0IGtpbmQgPSBUcmFjay5raW5kRnJvbVByb3RvKHRpLnR5cGUpO1xuICAgICAgICBpZiAoIWtpbmQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHVibGljYXRpb24gPSBuZXcgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbihraW5kLCB0aSwgKF9hID0gdGhpcy5zaWduYWxDbGllbnQuY29ubmVjdE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdXRvU3Vic2NyaWJlLCB7XG4gICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgbG9nZ2VyTmFtZTogKF9iID0gdGhpcy5sb2dnZXJPcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubG9nZ2VyTmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgcHVibGljYXRpb24udXBkYXRlSW5mbyh0aSk7XG4gICAgICAgIG5ld1RyYWNrcy5zZXQodGkuc2lkLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVHJhY2tPZlNvdXJjZSA9IEFycmF5LmZyb20odGhpcy50cmFja3MudmFsdWVzKCkpLmZpbmQocHVibGlzaGVkVHJhY2sgPT4gcHVibGlzaGVkVHJhY2suc291cmNlID09PSAocHVibGljYXRpb24gPT09IG51bGwgfHwgcHVibGljYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHB1YmxpY2F0aW9uLnNvdXJjZSkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdUcmFja09mU291cmNlICYmIHB1YmxpY2F0aW9uLnNvdXJjZSAhPT0gVHJhY2suU291cmNlLlVua25vd24pIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInJlY2VpdmVkIGEgc2Vjb25kIHRyYWNrIHB1YmxpY2F0aW9uIGZvciBcIi5jb25jYXQodGhpcy5pZGVudGl0eSwgXCIgd2l0aCB0aGUgc2FtZSBzb3VyY2U6IFwiKS5jb25jYXQocHVibGljYXRpb24uc291cmNlKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBvbGRUcmFjazogZ2V0TG9nQ29udGV4dEZyb21UcmFjayhleGlzdGluZ1RyYWNrT2ZTb3VyY2UpLFxuICAgICAgICAgICAgbmV3VHJhY2s6IGdldExvZ0NvbnRleHRGcm9tVHJhY2socHVibGljYXRpb24pXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdWJsaWNhdGlvbi51cGRhdGVJbmZvKHRpKTtcbiAgICAgIH1cbiAgICAgIHZhbGlkVHJhY2tzLnNldCh0aS5zaWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICAvLyBkZXRlY3QgcmVtb3ZlZCB0cmFja3NcbiAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHtcbiAgICAgIGlmICghdmFsaWRUcmFja3MuaGFzKHB1YmxpY2F0aW9uLnRyYWNrU2lkKSkge1xuICAgICAgICB0aGlzLmxvZy50cmFjZSgnZGV0ZWN0ZWQgcmVtb3ZlZCB0cmFjayBvbiByZW1vdGUgcGFydGljaXBhbnQsIHVucHVibGlzaGluZycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikpKTtcbiAgICAgICAgdGhpcy51bnB1Ymxpc2hUcmFjayhwdWJsaWNhdGlvbi50cmFja1NpZCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gYWx3YXlzIGVtaXQgZXZlbnRzIGZvciBuZXcgcHVibGljYXRpb25zLCBSb29tIHdpbGwgbm90IGZvcndhcmQgdGhlbSB1bmxlc3MgaXQncyByZWFkeVxuICAgIG5ld1RyYWNrcy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrUHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1bnB1Ymxpc2hUcmFjayhzaWQsIHNlbmRVbnB1Ymxpc2gpIHtcbiAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHRoaXMudHJhY2tzLmdldChzaWQpO1xuICAgIGlmICghcHVibGljYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYWxzbyBzZW5kIHVuc3Vic2NyaWJlLCBpZiB0cmFjayBpcyBhY3RpdmVseSBzdWJzY3JpYmVkXG4gICAgY29uc3Qge1xuICAgICAgdHJhY2tcbiAgICB9ID0gcHVibGljYXRpb247XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5zdG9wKCk7XG4gICAgICBwdWJsaWNhdGlvbi5zZXRUcmFjayh1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgdHJhY2sgZnJvbSBtYXBzIG9ubHkgYWZ0ZXIgdW5zdWJzY3JpYmVkIGhhcyBiZWVuIGZpcmVkXG4gICAgdGhpcy50cmFja3MuZGVsZXRlKHNpZCk7XG4gICAgLy8gcmVtb3ZlIGZyb20gdGhlIHJpZ2h0IHR5cGUgbWFwXG4gICAgc3dpdGNoIChwdWJsaWNhdGlvbi5raW5kKSB7XG4gICAgICBjYXNlIFRyYWNrLktpbmQuQXVkaW86XG4gICAgICAgIHRoaXMuYXVkaW9UcmFja3MuZGVsZXRlKHNpZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFjay5LaW5kLlZpZGVvOlxuICAgICAgICB0aGlzLnZpZGVvVHJhY2tzLmRlbGV0ZShzaWQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHNlbmRVbnB1Ymxpc2gpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5wdWJsaXNoZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0QXVkaW9PdXRwdXQob3V0cHV0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuYXVkaW9PdXRwdXQgPSBvdXRwdXQ7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgdGhpcy5hdWRpb1RyYWNrcy5mb3JFYWNoKHB1YiA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHB1Yi50cmFjayBpbnN0YW5jZW9mIFJlbW90ZUF1ZGlvVHJhY2spIHtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHB1Yi50cmFjay5zZXRTaW5rSWQoKF9hID0gb3V0cHV0LmRldmljZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnZGVmYXVsdCcpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB5aWVsZCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBlbWl0KGV2ZW50KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHRoaXMubG9nLnRyYWNlKCdwYXJ0aWNpcGFudCBldmVudCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgZXZlbnQsXG4gICAgICBhcmdzXG4gICAgfSkpO1xuICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfVxufVxuXG5jbGFzcyBMb2NhbFBhcnRpY2lwYW50IGV4dGVuZHMgUGFydGljaXBhbnQge1xuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKHNpZCwgaWRlbnRpdHksIGVuZ2luZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKHNpZCwgaWRlbnRpdHksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICBsb2dnZXJOYW1lOiBvcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMuZW5naW5lLmxvZ0NvbnRleHRcbiAgICB9KTtcbiAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nID0gbmV3IFNldCgpO1xuICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyA9IFtdO1xuICAgIHRoaXMuYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlID0gdHJ1ZTtcbiAgICB0aGlzLmVuY3J5cHRpb25UeXBlID0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gICAgdGhpcy5oYW5kbGVSZWNvbm5lY3RpbmcgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMucmVjb25uZWN0RnV0dXJlKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0RnV0dXJlID0gbmV3IEZ1dHVyZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICAoX2IgPSAoX2EgPSB0aGlzLnJlY29ubmVjdEZ1dHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc29sdmUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgIHRoaXMucmVjb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy51cGRhdGVUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zKCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3RlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBpZiAodGhpcy5yZWNvbm5lY3RGdXR1cmUpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUucHJvbWlzZS5jYXRjaChlID0+IHRoaXMubG9nLndhcm4oZS5tZXNzYWdlLCB0aGlzLmxvZ0NvbnRleHQpKTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5yZWNvbm5lY3RGdXR1cmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWplY3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAnR290IGRpc2Nvbm5lY3RlZCBkdXJpbmcgcmVjb25uZWN0aW9uIGF0dGVtcHQnKTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZVRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndXBkYXRpbmcgdHJhY2sgc3Vic2NyaXB0aW9uIHBlcm1pc3Npb25zJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGFsbFBhcnRpY2lwYW50c0FsbG93ZWQ6IHRoaXMuYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlLFxuICAgICAgICBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnM6IHRoaXMucGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zXG4gICAgICB9KSk7XG4gICAgICB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZFVwZGF0ZVN1YnNjcmlwdGlvblBlcm1pc3Npb25zKHRoaXMuYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlLCB0aGlzLnBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucy5tYXAocCA9PiB0cmFja1Blcm1pc3Npb25Ub1Byb3RvKHApKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5vblRyYWNrVW5tdXRlZCA9IHRyYWNrID0+IHtcbiAgICAgIHRoaXMub25UcmFja011dGVkKHRyYWNrLCB0cmFjay5pc1Vwc3RyZWFtUGF1c2VkKTtcbiAgICB9O1xuICAgIC8vIHdoZW4gdGhlIGxvY2FsIHRyYWNrIGNoYW5nZXMgaW4gbXV0ZSBzdGF0dXMsIHdlJ2xsIG5vdGlmeSBzZXJ2ZXIgYXMgc3VjaFxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLm9uVHJhY2tNdXRlZCA9ICh0cmFjaywgbXV0ZWQpID0+IHtcbiAgICAgIGlmIChtdXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG11dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdHJhY2suc2lkKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdjb3VsZCBub3QgdXBkYXRlIG11dGUgc3RhdHVzIGZvciB1bnB1Ymxpc2hlZCB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5lbmdpbmUudXBkYXRlTXV0ZVN0YXR1cyh0cmFjay5zaWQsIG11dGVkKTtcbiAgICB9O1xuICAgIHRoaXMub25UcmFja1Vwc3RyZWFtUGF1c2VkID0gdHJhY2sgPT4ge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3Vwc3RyZWFtIHBhdXNlZCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgIHRoaXMub25UcmFja011dGVkKHRyYWNrLCB0cnVlKTtcbiAgICB9O1xuICAgIHRoaXMub25UcmFja1Vwc3RyZWFtUmVzdW1lZCA9IHRyYWNrID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1cHN0cmVhbSByZXN1bWVkJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgdGhpcy5vblRyYWNrTXV0ZWQodHJhY2ssIHRyYWNrLmlzTXV0ZWQpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9IHVwZGF0ZSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgdmFyIF9kLCBfZTtcbiAgICAgIGlmICghKChfZCA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5keW5hY2FzdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcHViID0gdGhpcy52aWRlb1RyYWNrcy5nZXQodXBkYXRlLnRyYWNrU2lkKTtcbiAgICAgIGlmICghcHViKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3JlY2VpdmVkIHN1YnNjcmliZWQgcXVhbGl0eSB1cGRhdGUgZm9yIHVua25vd24gdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICB0cmFja1NpZDogdXBkYXRlLnRyYWNrU2lkXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHVwZGF0ZS5zdWJzY3JpYmVkQ29kZWNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKCFwdWIudmlkZW9UcmFjaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdDb2RlY3MgPSB5aWVsZCBwdWIudmlkZW9UcmFjay5zZXRQdWJsaXNoaW5nQ29kZWNzKHVwZGF0ZS5zdWJzY3JpYmVkQ29kZWNzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfZiA9IHRydWUsIG5ld0NvZGVjc18xID0gX19hc3luY1ZhbHVlcyhuZXdDb2RlY3MpLCBuZXdDb2RlY3NfMV8xOyBuZXdDb2RlY3NfMV8xID0geWllbGQgbmV3Q29kZWNzXzEubmV4dCgpLCBfYSA9IG5ld0NvZGVjc18xXzEuZG9uZSwgIV9hOyBfZiA9IHRydWUpIHtcbiAgICAgICAgICAgIF9jID0gbmV3Q29kZWNzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgIF9mID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBjb2RlYyA9IF9jO1xuICAgICAgICAgICAgaWYgKGlzQmFja3VwQ29kZWMoY29kZWMpKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwicHVibGlzaCBcIi5jb25jYXQoY29kZWMsIFwiIGZvciBcIikuY29uY2F0KHB1Yi52aWRlb1RyYWNrLnNpZCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWIpKSk7XG4gICAgICAgICAgICAgIHlpZWxkIHRoaXMucHVibGlzaEFkZGl0aW9uYWxDb2RlY0ZvclRyYWNrKHB1Yi52aWRlb1RyYWNrLCBjb2RlYywgcHViLm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgICAgICBlXzEgPSB7XG4gICAgICAgICAgICBlcnJvcjogZV8xXzFcbiAgICAgICAgICB9O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9mICYmICFfYSAmJiAoX2IgPSBuZXdDb2RlY3NfMS5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKG5ld0NvZGVjc18xKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh1cGRhdGUuc3Vic2NyaWJlZFF1YWxpdGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHlpZWxkIChfZSA9IHB1Yi52aWRlb1RyYWNrKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Uuc2V0UHVibGlzaGluZ0xheWVycyh1cGRhdGUuc3Vic2NyaWJlZFF1YWxpdGllcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5oYW5kbGVMb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSB1bnB1Ymxpc2hlZCA9PiB7XG4gICAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2tzLmdldCh1bnB1Ymxpc2hlZC50cmFja1NpZCk7XG4gICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3JlY2VpdmVkIHVucHVibGlzaGVkIGV2ZW50IGZvciB1bmtub3duIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgdHJhY2tTaWQ6IHVucHVibGlzaGVkLnRyYWNrU2lkXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjay50cmFjayk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVRyYWNrRW5kZWQgPSB0cmFjayA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgfHwgdHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbykge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygndW5wdWJsaXNoaW5nIGxvY2FsIHRyYWNrIGR1ZSB0byBUcmFja0VuZGVkJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICB0aGlzLnVucHVibGlzaFRyYWNrKHRyYWNrKTtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2suaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgICAgeWllbGQgdHJhY2subXV0ZSgpO1xuICAgICAgfSBlbHNlIGlmICh0cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjayB8fCB0cmFjayBpbnN0YW5jZW9mIExvY2FsVmlkZW9UcmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChpc1dlYigpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UGVybWlzc2lvbnMgPSB5aWVsZCBuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IucGVybWlzc2lvbnMucXVlcnkoe1xuICAgICAgICAgICAgICAgIC8vIHRoZSBwZXJtaXNzaW9uIHF1ZXJ5IGZvciBjYW1lcmEgYW5kIG1pY3JvcGhvbmUgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgaW4gU2FmYXJpIGFuZCBGaXJlZm94XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIG5hbWU6IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSA/ICdjYW1lcmEnIDogJ21pY3JvcGhvbmUnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoY3VycmVudFBlcm1pc3Npb25zICYmIGN1cnJlbnRQZXJtaXNzaW9ucy5zdGF0ZSA9PT0gJ2RlbmllZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy53YXJuKFwidXNlciBoYXMgcmV2b2tlZCBhY2Nlc3MgdG8gXCIuY29uY2F0KHRyYWNrLnNvdXJjZSksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgICAgICAgICAgICAvLyBkZXRlY3QgZ3JhbnRlZCBjaGFuZ2UgYWZ0ZXIgcGVybWlzc2lvbnMgd2VyZSBkZW5pZWQgdG8gdHJ5IGFuZCByZXN1bWUgdGhlblxuICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJtaXNzaW9ucy5vbmNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGVybWlzc2lvbnMuc3RhdGUgIT09ICdkZW5pZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJhY2suaXNNdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnJlc3RhcnRUcmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJtaXNzaW9ucy5vbmNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dldFVzZXJNZWRpYSBQZXJtaXNzaW9uIGRlbmllZCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vIHBlcm1pc3Npb25zIHF1ZXJ5IGZhaWxzIGZvciBmaXJlZm94LCB3ZSBjb250aW51ZSBhbmQgdHJ5IHRvIHJlc3RhcnQgdGhlIHRyYWNrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdHJhY2suaXNNdXRlZCkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3RyYWNrIGVuZGVkLCBhdHRlbXB0aW5nIHRvIHVzZSBhIGRpZmZlcmVudCBkZXZpY2UnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgICAgICB5aWVsZCB0cmFjay5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKFwiY291bGQgbm90IHJlc3RhcnQgdHJhY2ssIG11dGluZyBpbnN0ZWFkXCIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgICAgICB5aWVsZCB0cmFjay5tdXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudmlkZW9UcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy50cmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgdGhpcy5yb29tT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zZXR1cEVuZ2luZShlbmdpbmUpO1xuICAgIHRoaXMuYWN0aXZlRGV2aWNlTWFwID0gbmV3IE1hcCgpO1xuICB9XG4gIGdldCBsYXN0Q2FtZXJhRXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FtZXJhRXJyb3I7XG4gIH1cbiAgZ2V0IGxhc3RNaWNyb3Bob25lRXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMubWljcm9waG9uZUVycm9yO1xuICB9XG4gIGdldCBpc0UyRUVFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVuY3J5cHRpb25UeXBlICE9PSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcbiAgfVxuICBnZXRUcmFjayhzb3VyY2UpIHtcbiAgICBjb25zdCB0cmFjayA9IHN1cGVyLmdldFRyYWNrKHNvdXJjZSk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2s7XG4gICAgfVxuICB9XG4gIGdldFRyYWNrQnlOYW1lKG5hbWUpIHtcbiAgICBjb25zdCB0cmFjayA9IHN1cGVyLmdldFRyYWNrQnlOYW1lKG5hbWUpO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXR1cEVuZ2luZShlbmdpbmUpIHtcbiAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICB0aGlzLmVuZ2luZS5vbihFbmdpbmVFdmVudC5SZW1vdGVNdXRlLCAodHJhY2tTaWQsIG11dGVkKSA9PiB7XG4gICAgICBjb25zdCBwdWIgPSB0aGlzLnRyYWNrcy5nZXQodHJhY2tTaWQpO1xuICAgICAgaWYgKCFwdWIgfHwgIXB1Yi50cmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobXV0ZWQpIHtcbiAgICAgICAgcHViLm11dGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1Yi51bm11dGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVuZ2luZS5vbihFbmdpbmVFdmVudC5Db25uZWN0ZWQsIHRoaXMuaGFuZGxlUmVjb25uZWN0ZWQpLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3RhcnRlZCwgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZCkub24oRW5naW5lRXZlbnQuU2lnbmFsUmVzdW1lZCwgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZCkub24oRW5naW5lRXZlbnQuUmVzdGFydGluZywgdGhpcy5oYW5kbGVSZWNvbm5lY3RpbmcpLm9uKEVuZ2luZUV2ZW50LlJlc3VtaW5nLCB0aGlzLmhhbmRsZVJlY29ubmVjdGluZykub24oRW5naW5lRXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCB0aGlzLmhhbmRsZUxvY2FsVHJhY2tVbnB1Ymxpc2hlZCkub24oRW5naW5lRXZlbnQuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUsIHRoaXMuaGFuZGxlU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUpLm9uKEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgdGhpcy5oYW5kbGVEaXNjb25uZWN0ZWQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGFuZCB1cGRhdGVzIHRoZSBtZXRhZGF0YSBvZiB0aGUgbG9jYWwgcGFydGljaXBhbnQuXG4gICAqIFRoZSBjaGFuZ2UgZG9lcyBub3QgdGFrZSBpbW1lZGlhdGUgZWZmZWN0LlxuICAgKiBJZiBzdWNjZXNzZnVsLCBhIGBQYXJ0aWNpcGFudEV2ZW50Lk1ldGFkYXRhQ2hhbmdlZGAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIG9uIHRoZSBsb2NhbCBwYXJ0aWNpcGFudC5cbiAgICogTm90ZTogdGhpcyByZXF1aXJlcyBgY2FuVXBkYXRlT3duTWV0YWRhdGFgIHBlcm1pc3Npb24uXG4gICAqIEBwYXJhbSBtZXRhZGF0YVxuICAgKi9cbiAgc2V0TWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRVcGRhdGVMb2NhbE1ldGFkYXRhKG1ldGFkYXRhLCAoX2EgPSB0aGlzLm5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhbmQgdXBkYXRlcyB0aGUgbmFtZSBvZiB0aGUgbG9jYWwgcGFydGljaXBhbnQuXG4gICAqIFRoZSBjaGFuZ2UgZG9lcyBub3QgdGFrZSBpbW1lZGlhdGUgZWZmZWN0LlxuICAgKiBJZiBzdWNjZXNzZnVsLCBhIGBQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWRgIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCBvbiB0aGUgbG9jYWwgcGFydGljaXBhbnQuXG4gICAqIE5vdGU6IHRoaXMgcmVxdWlyZXMgYGNhblVwZGF0ZU93bk1ldGFkYXRhYCBwZXJtaXNzaW9uLlxuICAgKiBAcGFyYW0gbWV0YWRhdGFcbiAgICovXG4gIHNldE5hbWUobmFtZSkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZFVwZGF0ZUxvY2FsTWV0YWRhdGEoKF9hID0gdGhpcy5tZXRhZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycsIG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBhIHBhcnRpY2lwYW50J3MgY2FtZXJhIHRyYWNrLlxuICAgKlxuICAgKiBJZiBhIHRyYWNrIGhhcyBhbHJlYWR5IHB1Ymxpc2hlZCwgaXQnbGwgbXV0ZSBvciB1bm11dGUgdGhlIHRyYWNrLlxuICAgKiBSZXNvbHZlcyB3aXRoIGEgYExvY2FsVHJhY2tQdWJsaWNhdGlvbmAgaW5zdGFuY2UgaWYgc3VjY2Vzc2Z1bCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlXG4gICAqL1xuICBzZXRDYW1lcmFFbmFibGVkKGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0VHJhY2tFbmFibGVkKFRyYWNrLlNvdXJjZS5DYW1lcmEsIGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgYSBwYXJ0aWNpcGFudCdzIG1pY3JvcGhvbmUgdHJhY2suXG4gICAqXG4gICAqIElmIGEgdHJhY2sgaGFzIGFscmVhZHkgcHVibGlzaGVkLCBpdCdsbCBtdXRlIG9yIHVubXV0ZSB0aGUgdHJhY2suXG4gICAqIFJlc29sdmVzIHdpdGggYSBgTG9jYWxUcmFja1B1YmxpY2F0aW9uYCBpbnN0YW5jZSBpZiBzdWNjZXNzZnVsIGFuZCBgdW5kZWZpbmVkYCBvdGhlcndpc2VcbiAgICovXG4gIHNldE1pY3JvcGhvbmVFbmFibGVkKGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0VHJhY2tFbmFibGVkKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IG9yIHN0b3Agc2hhcmluZyBhIHBhcnRpY2lwYW50J3Mgc2NyZWVuXG4gICAqIFJlc29sdmVzIHdpdGggYSBgTG9jYWxUcmFja1B1YmxpY2F0aW9uYCBpbnN0YW5jZSBpZiBzdWNjZXNzZnVsIGFuZCBgdW5kZWZpbmVkYCBvdGhlcndpc2VcbiAgICovXG4gIHNldFNjcmVlblNoYXJlRW5hYmxlZChlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldFRyYWNrRW5hYmxlZChUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUsIGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zKSB7XG4gICAgY29uc3QgcHJldlBlcm1pc3Npb25zID0gdGhpcy5wZXJtaXNzaW9ucztcbiAgICBjb25zdCBjaGFuZ2VkID0gc3VwZXIuc2V0UGVybWlzc2lvbnMocGVybWlzc2lvbnMpO1xuICAgIGlmIChjaGFuZ2VkICYmIHByZXZQZXJtaXNzaW9ucykge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0RTJFRUVuYWJsZWQoZW5hYmxlZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmVuY3J5cHRpb25UeXBlID0gZW5hYmxlZCA/IEVuY3J5cHRpb25fVHlwZS5HQ00gOiBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcbiAgICAgIHlpZWxkIHRoaXMucmVwdWJsaXNoQWxsVHJhY2tzKHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG4gIHNldFRyYWNrRW5hYmxlZChzb3VyY2UsIGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3NldFRyYWNrRW5hYmxlZCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGVuYWJsZWRcbiAgICAgIH0pKTtcbiAgICAgIGxldCB0cmFjayA9IHRoaXMuZ2V0VHJhY2soc291cmNlKTtcbiAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgIHlpZWxkIHRyYWNrLnVubXV0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBsb2NhbFRyYWNrcztcbiAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoc291cmNlKSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuaW5mbygnc2tpcHBpbmcgZHVwbGljYXRlIHB1Ymxpc2hlZCBzb3VyY2UnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgICAgc291cmNlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAvLyBuby1vcCBpdCdzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5hZGQoc291cmNlKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3dpdGNoIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuQ2FtZXJhOlxuICAgICAgICAgICAgICAgIGxvY2FsVHJhY2tzID0geWllbGQgdGhpcy5jcmVhdGVUcmFja3Moe1xuICAgICAgICAgICAgICAgICAgdmlkZW86IChfYSA9IG9wdGlvbnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTpcbiAgICAgICAgICAgICAgICBsb2NhbFRyYWNrcyA9IHlpZWxkIHRoaXMuY3JlYXRlVHJhY2tzKHtcbiAgICAgICAgICAgICAgICAgIGF1ZGlvOiAoX2IgPSBvcHRpb25zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLlNjcmVlblNoYXJlOlxuICAgICAgICAgICAgICAgIGxvY2FsVHJhY2tzID0geWllbGQgdGhpcy5jcmVhdGVTY3JlZW5UcmFja3MoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcihzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHVibGlzaFByb21pc2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxvY2FsVHJhY2sgb2YgbG9jYWxUcmFja3MpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2cuaW5mbygncHVibGlzaGluZyB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhsb2NhbFRyYWNrKSkpO1xuICAgICAgICAgICAgICBwdWJsaXNoUHJvbWlzZXMucHVzaCh0aGlzLnB1Ymxpc2hUcmFjayhsb2NhbFRyYWNrLCBwdWJsaXNoT3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHVibGlzaGVkVHJhY2tzID0geWllbGQgUHJvbWlzZS5hbGwocHVibGlzaFByb21pc2VzKTtcbiAgICAgICAgICAgIC8vIGZvciBzY3JlZW4gc2hhcmUgcHVibGljYXRpb25zIGluY2x1ZGluZyBhdWRpbywgdGhpcyB3aWxsIG9ubHkgcmV0dXJuIHRoZSBzY3JlZW4gc2hhcmUgcHVibGljYXRpb24sIG5vdCB0aGUgc2NyZWVuIHNoYXJlIGF1ZGlvIG9uZVxuICAgICAgICAgICAgLy8gcmV2aXNpdCBpZiB3ZSB3YW50IHRvIHJldHVybiBhbiBhcnJheSBvZiB0cmFja3MgaW5zdGVhZCBmb3IgdjJcbiAgICAgICAgICAgIFt0cmFja10gPSBwdWJsaXNoZWRUcmFja3M7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9jYWxUcmFja3MgPT09IG51bGwgfHwgbG9jYWxUcmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvY2FsVHJhY2tzLmZvckVhY2godHIgPT4ge1xuICAgICAgICAgICAgICB0ci5zdG9wKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlIGluc3RhbmNlb2YgVHJhY2tJbnZhbGlkRXJyb3IpKSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50Lk1lZGlhRGV2aWNlc0Vycm9yLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuZGVsZXRlKHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrICYmIHRyYWNrLnRyYWNrKSB7XG4gICAgICAgIC8vIHNjcmVlbnNoYXJlIGNhbm5vdCBiZSBtdXRlZCwgdW5wdWJsaXNoIGluc3RlYWRcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlKSB7XG4gICAgICAgICAgdHJhY2sgPSB5aWVsZCB0aGlzLnVucHVibGlzaFRyYWNrKHRyYWNrLnRyYWNrKTtcbiAgICAgICAgICBjb25zdCBzY3JlZW5BdWRpb1RyYWNrID0gdGhpcy5nZXRUcmFjayhUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbyk7XG4gICAgICAgICAgaWYgKHNjcmVlbkF1ZGlvVHJhY2sgJiYgc2NyZWVuQXVkaW9UcmFjay50cmFjaykge1xuICAgICAgICAgICAgdGhpcy51bnB1Ymxpc2hUcmFjayhzY3JlZW5BdWRpb1RyYWNrLnRyYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgdHJhY2subXV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhY2s7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYm90aCBjYW1lcmEgYW5kIG1pY3JvcGhvbmUgYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIGRpc3BsYXlpbmcgYSBzaW5nbGUgUGVybWlzc2lvbiBEaWFsb2cgYm94IHRvIHRoZSBlbmQgdXNlci5cbiAgICovXG4gIGVuYWJsZUNhbWVyYUFuZE1pY3JvcGhvbmUoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmhhcyhUcmFjay5Tb3VyY2UuQ2FtZXJhKSB8fCB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmhhcyhUcmFjay5Tb3VyY2UuTWljcm9waG9uZSkpIHtcbiAgICAgICAgLy8gbm8tb3AgaXQncyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuYWRkKFRyYWNrLlNvdXJjZS5DYW1lcmEpO1xuICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5hZGQoVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdHJhY2tzID0geWllbGQgdGhpcy5jcmVhdGVUcmFja3Moe1xuICAgICAgICAgIGF1ZGlvOiB0cnVlLFxuICAgICAgICAgIHZpZGVvOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbCh0cmFja3MubWFwKHRyYWNrID0+IHRoaXMucHVibGlzaFRyYWNrKHRyYWNrKSkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5kZWxldGUoVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuZGVsZXRlKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGxvY2FsIGNhbWVyYSBhbmQvb3IgbWljcm9waG9uZSB0cmFja3NcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHJldHVybnNcbiAgICovXG4gIGNyZWF0ZVRyYWNrcyhvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3Qgb3B0cyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywgKF9hID0gdGhpcy5yb29tT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLCAoX2IgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmlkZW9DYXB0dXJlRGVmYXVsdHMpO1xuICAgICAgY29uc3QgY29uc3RyYWludHMgPSBjb25zdHJhaW50c0Zvck9wdGlvbnMob3B0cyk7XG4gICAgICBsZXQgc3RyZWFtO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RyZWFtID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGlmIChjb25zdHJhaW50cy5hdWRpbykge1xuICAgICAgICAgICAgdGhpcy5taWNyb3Bob25lRXJyb3IgPSBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb25zdHJhaW50cy52aWRlbykge1xuICAgICAgICAgICAgdGhpcy5jYW1lcmFFcnJvciA9IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnN0cmFpbnRzLmF1ZGlvKSB7XG4gICAgICAgIHRoaXMubWljcm9waG9uZUVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5BdWRpb1N0cmVhbUFjcXVpcmVkKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25zdHJhaW50cy52aWRlbykge1xuICAgICAgICB0aGlzLmNhbWVyYUVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmVhbS5nZXRUcmFja3MoKS5tYXAobWVkaWFTdHJlYW1UcmFjayA9PiB7XG4gICAgICAgIGNvbnN0IGlzQXVkaW8gPSBtZWRpYVN0cmVhbVRyYWNrLmtpbmQgPT09ICdhdWRpbyc7XG4gICAgICAgIGlzQXVkaW8gPyBvcHRpb25zLmF1ZGlvIDogb3B0aW9ucy52aWRlbztcbiAgICAgICAgbGV0IHRyYWNrQ29uc3RyYWludHM7XG4gICAgICAgIGNvbnN0IGNvbk9yQm9vbCA9IGlzQXVkaW8gPyBjb25zdHJhaW50cy5hdWRpbyA6IGNvbnN0cmFpbnRzLnZpZGVvO1xuICAgICAgICBpZiAodHlwZW9mIGNvbk9yQm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdHJhY2tDb25zdHJhaW50cyA9IGNvbk9yQm9vbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFjayA9IG1lZGlhVHJhY2tUb0xvY2FsVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgdHJhY2tDb25zdHJhaW50cywge1xuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgICB0cmFjay5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuQ2FtZXJhO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcbiAgICAgICAgICB0cmFjay5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjay5tZWRpYVN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzY3JlZW4gY2FwdHVyZSB0cmFja3Mgd2l0aCBnZXREaXNwbGF5TWVkaWEoKS5cbiAgICogQSBMb2NhbFZpZGVvVHJhY2sgaXMgYWx3YXlzIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxuICAgKiBJZiB7IGF1ZGlvOiB0cnVlIH0sIGFuZCB0aGUgYnJvd3NlciBzdXBwb3J0cyBhdWRpbyBjYXB0dXJlLCBhIExvY2FsQXVkaW9UcmFjayBpcyBhbHNvIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVTY3JlZW5UcmFja3Mob3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yKCdnZXREaXNwbGF5TWVkaWEgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiA9PT0gdW5kZWZpbmVkICYmICFpc1NhZmFyaTE3KCkpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBjb25zdHJhaW4gdGhlIGRpbWVuc2lvbnMsIG90aGVyd2lzZSBpdCBjb3VsZCBsZWFkIHRvIGxvdyBiaXRyYXRlXG4gICAgICAgIC8vIGR1ZSB0byBlbmNvZGluZyBhIGh1Z2UgdmlkZW8uIEVuY29kaW5nIHN1Y2ggbGFyZ2Ugc3VyZmFjZXMgaXMgcmVhbGx5IGV4cGVuc2l2ZVxuICAgICAgICAvLyB1bmZvcnR1bmF0ZWx5IFNhZmFyaSAxNyBoYXMgYSBidXQgYW5kIGNhbm5vdCBiZSBjb25zdHJhaW5lZCBieSBkZWZhdWx0XG4gICAgICAgIG9wdGlvbnMucmVzb2x1dGlvbiA9IFNjcmVlblNoYXJlUHJlc2V0cy5oMTA4MGZwczMwLnJlc29sdXRpb247XG4gICAgICB9XG4gICAgICBjb25zdCBjb25zdHJhaW50cyA9IHNjcmVlbkNhcHR1cmVUb0Rpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICBjb25zdCB0cmFja3MgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgIGlmICh0cmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignbm8gdmlkZW8gdHJhY2sgZm91bmQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjcmVlblZpZGVvID0gbmV3IExvY2FsVmlkZW9UcmFjayh0cmFja3NbMF0sIHVuZGVmaW5lZCwgZmFsc2UsIHtcbiAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgfSk7XG4gICAgICBzY3JlZW5WaWRlby5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmU7XG4gICAgICBpZiAob3B0aW9ucy5jb250ZW50SGludCkge1xuICAgICAgICBzY3JlZW5WaWRlby5tZWRpYVN0cmVhbVRyYWNrLmNvbnRlbnRIaW50ID0gb3B0aW9ucy5jb250ZW50SGludDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvY2FsVHJhY2tzID0gW3NjcmVlblZpZGVvXTtcbiAgICAgIGlmIChzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQpO1xuICAgICAgICBjb25zdCBzY3JlZW5BdWRpbyA9IG5ldyBMb2NhbEF1ZGlvVHJhY2soc3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF0sIHVuZGVmaW5lZCwgZmFsc2UsIHRoaXMuYXVkaW9Db250ZXh0LCB7XG4gICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICBzY3JlZW5BdWRpby5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbztcbiAgICAgICAgbG9jYWxUcmFja3MucHVzaChzY3JlZW5BdWRpbyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9jYWxUcmFja3M7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYSBuZXcgdHJhY2sgdG8gdGhlIHJvb21cbiAgICogQHBhcmFtIHRyYWNrXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBwdWJsaXNoVHJhY2sodHJhY2ssIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIChfYSA9IHRoaXMucmVjb25uZWN0RnV0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvbWlzZTtcbiAgICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIExvY2FsVHJhY2sgJiYgdGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzLmhhcyh0cmFjaykpIHtcbiAgICAgICAgeWllbGQgdGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzLmdldCh0cmFjayk7XG4gICAgICB9XG4gICAgICBsZXQgZGVmYXVsdENvbnN0cmFpbnRzO1xuICAgICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICBkZWZhdWx0Q29uc3RyYWludHMgPSB0cmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2Ugd2FudCB0byBhY2Nlc3MgY29uc3RyYWludHMgZGlyZWN0bHkgYXMgYHRyYWNrLm1lZGlhU3RyZWFtVHJhY2tgXG4gICAgICAgIC8vIG1pZ2h0IGJlIHBvaW50aW5nIHRvIGEgbm9uLWRldmljZSB0cmFjayAoZS5nLiBwcm9jZXNzZWQgdHJhY2spIGFscmVhZHlcbiAgICAgICAgZGVmYXVsdENvbnN0cmFpbnRzID0gdHJhY2suY29uc3RyYWludHM7XG4gICAgICAgIGxldCBkZXZpY2VLaW5kID0gdW5kZWZpbmVkO1xuICAgICAgICBzd2l0Y2ggKHRyYWNrLnNvdXJjZSkge1xuICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLk1pY3JvcGhvbmU6XG4gICAgICAgICAgICBkZXZpY2VLaW5kID0gJ2F1ZGlvaW5wdXQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuQ2FtZXJhOlxuICAgICAgICAgICAgZGV2aWNlS2luZCA9ICd2aWRlb2lucHV0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV2aWNlS2luZCAmJiB0aGlzLmFjdGl2ZURldmljZU1hcC5oYXMoZGV2aWNlS2luZCkpIHtcbiAgICAgICAgICBkZWZhdWx0Q29uc3RyYWludHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDb25zdHJhaW50cyksIHtcbiAgICAgICAgICAgIGRldmljZUlkOiB0aGlzLmFjdGl2ZURldmljZU1hcC5nZXQoZGV2aWNlS2luZClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29udmVydCByYXcgbWVkaWEgdHJhY2sgaW50byBhdWRpbyBvciB2aWRlbyB0cmFja1xuICAgICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICBzd2l0Y2ggKHRyYWNrLmtpbmQpIHtcbiAgICAgICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgICAgICB0cmFjayA9IG5ldyBMb2NhbEF1ZGlvVHJhY2sodHJhY2ssIGRlZmF1bHRDb25zdHJhaW50cywgdHJ1ZSwgdGhpcy5hdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgICAgICB0cmFjayA9IG5ldyBMb2NhbFZpZGVvVHJhY2sodHJhY2ssIGRlZmF1bHRDb25zdHJhaW50cywgdHJ1ZSwge1xuICAgICAgICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoXCJ1bnN1cHBvcnRlZCBNZWRpYVN0cmVhbVRyYWNrIGtpbmQgXCIuY29uY2F0KHRyYWNrLmtpbmQpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhY2sudXBkYXRlTG9nZ2VyT3B0aW9ucyh7XG4gICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxBdWRpb1RyYWNrKSB7XG4gICAgICAgIHRyYWNrLnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XG4gICAgICB9XG4gICAgICAvLyBpcyBpdCBhbHJlYWR5IHB1Ymxpc2hlZD8gaWYgc28gc2tpcFxuICAgICAgbGV0IGV4aXN0aW5nUHVibGljYXRpb247XG4gICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHtcbiAgICAgICAgaWYgKCFwdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHVibGljYXRpb24udHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgZXhpc3RpbmdQdWJsaWNhdGlvbiA9IHB1YmxpY2F0aW9uO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChleGlzdGluZ1B1YmxpY2F0aW9uKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3RyYWNrIGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkLCBza2lwcGluZycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhleGlzdGluZ1B1YmxpY2F0aW9uKSkpO1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdQdWJsaWNhdGlvbjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzU3RlcmVvSW5wdXQgPSAnY2hhbm5lbENvdW50JyBpbiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkgJiZcbiAgICAgIC8vIEB0cy1pZ25vcmUgYGNoYW5uZWxDb3VudGAgb24gZ2V0U2V0dGluZ3MoKSBpcyBjdXJyZW50bHkgb25seSBhdmFpbGFibGUgZm9yIFNhZmFyaSwgYnV0IGlzIGdlbmVyYWxseSB0aGUgYmVzdCB3YXkgdG8gZGV0ZXJtaW5lIGEgc3RlcmVvIHRyYWNrIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVRyYWNrU2V0dGluZ3MvY2hhbm5lbENvdW50XG4gICAgICB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuY2hhbm5lbENvdW50ID09PSAyIHx8IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZ2V0Q29uc3RyYWludHMoKS5jaGFubmVsQ291bnQgPT09IDI7XG4gICAgICBjb25zdCBpc1N0ZXJlbyA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mb3JjZVN0ZXJlbykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogaXNTdGVyZW9JbnB1dDtcbiAgICAgIC8vIGRpc2FibGUgZHR4IGZvciBzdGVyZW8gdHJhY2sgaWYgbm90IGVuYWJsZWQgZXhwbGljaXRseVxuICAgICAgaWYgKGlzU3RlcmVvKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5kdHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMubG9nLmluZm8oXCJPcHVzIERUWCB3aWxsIGJlIGRpc2FibGVkIGZvciBzdGVyZW8gdHJhY2tzIGJ5IGRlZmF1bHQuIEVuYWJsZSB0aGVtIGV4cGxpY2l0bHkgdG8gbWFrZSBpdCB3b3JrLlwiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5pbmZvKFwiT3B1cyBSRUQgd2lsbCBiZSBkaXNhYmxlZCBmb3Igc3RlcmVvIHRyYWNrcyBieSBkZWZhdWx0LiBFbmFibGUgdGhlbSBleHBsaWNpdGx5IHRvIG1ha2UgaXQgd29yay5cIik7XG4gICAgICAgIH1cbiAgICAgICAgKF9jID0gb3B0aW9ucy5kdHgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG9wdGlvbnMuZHR4ID0gZmFsc2U7XG4gICAgICAgIChfZCA9IG9wdGlvbnMucmVkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBvcHRpb25zLnJlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5yb29tT3B0aW9ucy5wdWJsaXNoRGVmYXVsdHMpLCBvcHRpb25zKTtcbiAgICAgIC8vIGRpc2FibGUgc2ltdWxjYXN0IGlmIGUyZWUgaXMgc2V0IG9uIHNhZmFyaVxuICAgICAgaWYgKGlzU2FmYXJpKCkgJiYgdGhpcy5yb29tT3B0aW9ucy5lMmVlKSB7XG4gICAgICAgIHRoaXMubG9nLmluZm8oXCJFbmQtdG8tZW5kIGVuY3J5cHRpb24gaXMgc2V0IHVwLCBzaW11bGNhc3QgcHVibGlzaGluZyB3aWxsIGJlIGRpc2FibGVkIG9uIFNhZmFyaVwiLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpKTtcbiAgICAgICAgb3B0cy5zaW11bGNhc3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLnNvdXJjZSkge1xuICAgICAgICB0cmFjay5zb3VyY2UgPSBvcHRzLnNvdXJjZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1Ymxpc2hQcm9taXNlID0gdGhpcy5wdWJsaXNoKHRyYWNrLCBvcHRzLCBpc1N0ZXJlbyk7XG4gICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuc2V0KHRyYWNrLCBwdWJsaXNoUHJvbWlzZSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHlpZWxkIHB1Ymxpc2hQcm9taXNlO1xuICAgICAgICByZXR1cm4gcHVibGljYXRpb247XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuZGVsZXRlKHRyYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwdWJsaXNoKHRyYWNrLCBvcHRzLCBpc1N0ZXJlbykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbztcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZXhpc3RpbmdUcmFja09mU291cmNlID0gQXJyYXkuZnJvbSh0aGlzLnRyYWNrcy52YWx1ZXMoKSkuZmluZChwdWJsaXNoZWRUcmFjayA9PiB0cmFjayBpbnN0YW5jZW9mIExvY2FsVHJhY2sgJiYgcHVibGlzaGVkVHJhY2suc291cmNlID09PSB0cmFjay5zb3VyY2UpO1xuICAgICAgaWYgKGV4aXN0aW5nVHJhY2tPZlNvdXJjZSAmJiB0cmFjay5zb3VyY2UgIT09IFRyYWNrLlNvdXJjZS5Vbmtub3duKSB7XG4gICAgICAgIHRoaXMubG9nLmluZm8oXCJwdWJsaXNoaW5nIGEgc2Vjb25kIHRyYWNrIHdpdGggdGhlIHNhbWUgc291cmNlOiBcIi5jb25jYXQodHJhY2suc291cmNlKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMuc3RvcE1pY1RyYWNrT25NdXRlICYmIHRyYWNrIGluc3RhbmNlb2YgTG9jYWxBdWRpb1RyYWNrKSB7XG4gICAgICAgIHRyYWNrLnN0b3BPbk11dGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlICYmIGlzRmlyZUZveCgpKSB7XG4gICAgICAgIC8vIEZpcmVmb3ggZG9lcyBub3Qgd29yayB3ZWxsIHdpdGggc2ltdWxjYXN0ZWQgc2NyZWVuIHNoYXJlXG4gICAgICAgIC8vIHdlIGZyZXF1ZW50bHkgZ2V0IG5vIGRhdGEgb24gbGF5ZXIgMCB3aGVuIGVuYWJsZWRcbiAgICAgICAgb3B0cy5zaW11bGNhc3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIHJlcXVpcmUgZnVsbCBBVjEvVlA5IFNWQyBzdXBwb3J0IHByaW9yIHRvIHVzaW5nIGl0XG4gICAgICBpZiAob3B0cy52aWRlb0NvZGVjID09PSAnYXYxJyAmJiAhc3VwcG9ydHNBVjEoKSkge1xuICAgICAgICBvcHRzLnZpZGVvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAob3B0cy52aWRlb0NvZGVjID09PSAndnA5JyAmJiAhc3VwcG9ydHNWUDkoKSkge1xuICAgICAgICBvcHRzLnZpZGVvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAob3B0cy52aWRlb0NvZGVjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gZGVmYXVsdFZpZGVvQ29kZWM7XG4gICAgICB9XG4gICAgICBjb25zdCB2aWRlb0NvZGVjID0gb3B0cy52aWRlb0NvZGVjO1xuICAgICAgLy8gaGFuZGxlIHRyYWNrIGFjdGlvbnNcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMub25UcmFja011dGVkKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcy5vblRyYWNrVW5tdXRlZCk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5VcHN0cmVhbVBhdXNlZCwgdGhpcy5vblRyYWNrVXBzdHJlYW1QYXVzZWQpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5VcHN0cmVhbVJlc3VtZWQsIHRoaXMub25UcmFja1Vwc3RyZWFtUmVzdW1lZCk7XG4gICAgICAvLyBjcmVhdGUgdHJhY2sgcHVibGljYXRpb24gZnJvbSB0cmFja1xuICAgICAgY29uc3QgcmVxID0gbmV3IEFkZFRyYWNrUmVxdWVzdCh7XG4gICAgICAgIC8vIGdldCBsb2NhbCB0cmFjayBpZCBmb3IgdXNlIGR1cmluZyBwdWJsaXNoaW5nXG4gICAgICAgIGNpZDogdHJhY2subWVkaWFTdHJlYW1UcmFjay5pZCxcbiAgICAgICAgbmFtZTogb3B0cy5uYW1lLFxuICAgICAgICB0eXBlOiBUcmFjay5raW5kVG9Qcm90byh0cmFjay5raW5kKSxcbiAgICAgICAgbXV0ZWQ6IHRyYWNrLmlzTXV0ZWQsXG4gICAgICAgIHNvdXJjZTogVHJhY2suc291cmNlVG9Qcm90byh0cmFjay5zb3VyY2UpLFxuICAgICAgICBkaXNhYmxlRHR4OiAhKChfYSA9IG9wdHMuZHR4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlKSxcbiAgICAgICAgZW5jcnlwdGlvbjogdGhpcy5lbmNyeXB0aW9uVHlwZSxcbiAgICAgICAgc3RlcmVvOiBpc1N0ZXJlbyxcbiAgICAgICAgZGlzYWJsZVJlZDogdGhpcy5pc0UyRUVFbmFibGVkIHx8ICEoKF9iID0gb3B0cy5yZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUpLFxuICAgICAgICBzdHJlYW06IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zdHJlYW1cbiAgICAgIH0pO1xuICAgICAgLy8gY29tcHV0ZSBlbmNvZGluZ3MgYW5kIGxheWVycyBmb3IgdmlkZW9cbiAgICAgIGxldCBlbmNvZGluZ3M7XG4gICAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICBsZXQgZGltcyA9IHtcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkaW1zID0geWllbGQgdHJhY2sud2FpdEZvckRpbWVuc2lvbnMoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIHVzZSBkZWZhdWx0cywgaXQncyBxdWl0ZSBwYWluZnVsIGZvciBjb25nZXN0aW9uIGNvbnRyb2wgd2l0aG91dCBzaW11bGNhc3RcbiAgICAgICAgICAvLyBzbyB1c2luZyBkZWZhdWx0IGRpbXMgYWNjb3JkaW5nIHRvIHB1Ymxpc2ggc2V0dGluZ3NcbiAgICAgICAgICBjb25zdCBkZWZhdWx0UmVzID0gKF9kID0gKF9jID0gdGhpcy5yb29tT3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlc29sdXRpb24pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFZpZGVvUHJlc2V0cy5oNzIwLnJlc29sdXRpb247XG4gICAgICAgICAgZGltcyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBkZWZhdWx0UmVzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBkZWZhdWx0UmVzLmhlaWdodFxuICAgICAgICAgIH07XG4gICAgICAgICAgLy8gbG9nIGZhaWx1cmVcbiAgICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGRldGVybWluZSB0cmFjayBkaW1lbnNpb25zLCB1c2luZyBkZWZhdWx0cycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSksIHtcbiAgICAgICAgICAgIGRpbXNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBzaG91bGQgYmUgZGVmaW5lZCBmb3IgdmlkZW9cbiAgICAgICAgcmVxLndpZHRoID0gZGltcy53aWR0aDtcbiAgICAgICAgcmVxLmhlaWdodCA9IGRpbXMuaGVpZ2h0O1xuICAgICAgICAvLyBmb3Igc3ZjIGNvZGVjcywgZGlzYWJsZSBzaW11bGNhc3QgYW5kIHVzZSB2cDggZm9yIGJhY2t1cCBjb2RlY1xuICAgICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBMb2NhbFZpZGVvVHJhY2spIHtcbiAgICAgICAgICBpZiAoaXNTVkNDb2RlYyh2aWRlb0NvZGVjKSkge1xuICAgICAgICAgICAgLy8gdnA5IHN2YyB3aXRoIHNjcmVlbnNoYXJlIGhhcyBwcm9ibGVtIHRvIGVuY29kZSwgYWx3YXlzIHVzZSBMMVQzIGhlcmVcbiAgICAgICAgICAgIGlmICh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSAmJiB2aWRlb0NvZGVjID09PSAndnA5Jykge1xuICAgICAgICAgICAgICBvcHRzLnNjYWxhYmlsaXR5TW9kZSA9ICdMMVQzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBzY2FsYWJpbGl0eU1vZGUgdG8gJ0wzVDNfS0VZJyBieSBkZWZhdWx0XG4gICAgICAgICAgICBvcHRzLnNjYWxhYmlsaXR5TW9kZSA9IChfZSA9IG9wdHMuc2NhbGFiaWxpdHlNb2RlKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAnTDNUM19LRVknO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXEuc2ltdWxjYXN0Q29kZWNzID0gW25ldyBTaW11bGNhc3RDb2RlYyh7XG4gICAgICAgICAgICBjb2RlYzogdmlkZW9Db2RlYyxcbiAgICAgICAgICAgIGNpZDogdHJhY2subWVkaWFTdHJlYW1UcmFjay5pZFxuICAgICAgICAgIH0pXTtcbiAgICAgICAgICAvLyBzZXQgdXAgYmFja3VwXG4gICAgICAgICAgaWYgKG9wdHMuYmFja3VwQ29kZWMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG9wdHMuYmFja3VwQ29kZWMgPSB7XG4gICAgICAgICAgICAgIGNvZGVjOiBkZWZhdWx0VmlkZW9Db2RlY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdHMuYmFja3VwQ29kZWMgJiYgdmlkZW9Db2RlYyAhPT0gb3B0cy5iYWNrdXBDb2RlYy5jb2RlYyAmJlxuICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgb25jZSBlMmVlIGlzIHN1cHBvcnRlZCBmb3IgYmFja3VwIGNvZGVjc1xuICAgICAgICAgIHJlcS5lbmNyeXB0aW9uID09PSBFbmNyeXB0aW9uX1R5cGUuTk9ORSkge1xuICAgICAgICAgICAgLy8gbXVsdGktY29kZWMgc2ltdWxjYXN0IHJlcXVpcmVzIGR5bmFjYXN0XG4gICAgICAgICAgICBpZiAoIXRoaXMucm9vbU9wdGlvbnMuZHluYWNhc3QpIHtcbiAgICAgICAgICAgICAgdGhpcy5yb29tT3B0aW9ucy5keW5hY2FzdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXEuc2ltdWxjYXN0Q29kZWNzLnB1c2gobmV3IFNpbXVsY2FzdENvZGVjKHtcbiAgICAgICAgICAgICAgY29kZWM6IG9wdHMuYmFja3VwQ29kZWMuY29kZWMsXG4gICAgICAgICAgICAgIGNpZDogJydcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmdzID0gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlLCByZXEud2lkdGgsIHJlcS5oZWlnaHQsIG9wdHMpO1xuICAgICAgICByZXEubGF5ZXJzID0gdmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzKHJlcS53aWR0aCwgcmVxLmhlaWdodCwgZW5jb2RpbmdzLCBpc1NWQ0NvZGVjKG9wdHMudmlkZW9Db2RlYykpO1xuICAgICAgfSBlbHNlIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgIGVuY29kaW5ncyA9IFt7XG4gICAgICAgICAgbWF4Qml0cmF0ZTogKF9nID0gKF9mID0gb3B0cy5hdWRpb1ByZXNldCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLm1heEJpdHJhdGUpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IG9wdHMuYXVkaW9CaXRyYXRlLFxuICAgICAgICAgIHByaW9yaXR5OiAoX2ogPSAoX2ggPSBvcHRzLmF1ZGlvUHJlc2V0KSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2gucHJpb3JpdHkpICE9PSBudWxsICYmIF9qICE9PSB2b2lkIDAgPyBfaiA6ICdoaWdoJyxcbiAgICAgICAgICBuZXR3b3JrUHJpb3JpdHk6IChfbCA9IChfayA9IG9wdHMuYXVkaW9QcmVzZXQpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5wcmlvcml0eSkgIT09IG51bGwgJiYgX2wgIT09IHZvaWQgMCA/IF9sIDogJ2hpZ2gnXG4gICAgICAgIH1dO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmVuZ2luZSB8fCB0aGlzLmVuZ2luZS5pc0Nsb3NlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY2Fubm90IHB1Ymxpc2ggdHJhY2sgd2hlbiBub3QgY29ubmVjdGVkJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0aSA9IHlpZWxkIHRoaXMuZW5naW5lLmFkZFRyYWNrKHJlcSk7XG4gICAgICAvLyBzZXJ2ZXIgbWlnaHQgbm90IHN1cHBvcnQgdGhlIGNvZGVjIHRoZSBjbGllbnQgaGFzIHJlcXVlc3RlZCwgaW4gdGhhdCBjYXNlLCBmYWxsYmFja1xuICAgICAgLy8gdG8gYSBzdXBwb3J0ZWQgY29kZWNcbiAgICAgIGxldCBwcmltYXJ5Q29kZWNNaW1lO1xuICAgICAgdGkuY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgICAgICBpZiAocHJpbWFyeUNvZGVjTWltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJpbWFyeUNvZGVjTWltZSA9IGNvZGVjLm1pbWVUeXBlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChwcmltYXJ5Q29kZWNNaW1lICYmIHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZENvZGVjID0gbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcocHJpbWFyeUNvZGVjTWltZSk7XG4gICAgICAgIGlmICh1cGRhdGVkQ29kZWMgIT09IHZpZGVvQ29kZWMpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnZmFsbGluZyBiYWNrIHRvIHNlcnZlciBzZWxlY3RlZCBjb2RlYycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSksIHtcbiAgICAgICAgICAgIGNvZGVjOiB1cGRhdGVkQ29kZWNcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICAgIG9wdHMudmlkZW9Db2RlYyA9IHVwZGF0ZWRDb2RlYztcbiAgICAgICAgICAvLyByZWNvbXB1dGUgZW5jb2RpbmdzIHNpbmNlIGJpdHJhdGVzL2V0YyBjb3VsZCBoYXZlIGNoYW5nZWRcbiAgICAgICAgICBlbmNvZGluZ3MgPSBjb21wdXRlVmlkZW9FbmNvZGluZ3ModHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUsIHJlcS53aWR0aCwgcmVxLmhlaWdodCwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gbmV3IExvY2FsVHJhY2tQdWJsaWNhdGlvbih0cmFjay5raW5kLCB0aSwgdHJhY2ssIHtcbiAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgfSk7XG4gICAgICAvLyBzYXZlIG9wdGlvbnMgZm9yIHdoZW4gaXQgbmVlZHMgdG8gYmUgcmVwdWJsaXNoZWQgYWdhaW5cbiAgICAgIHB1YmxpY2F0aW9uLm9wdGlvbnMgPSBvcHRzO1xuICAgICAgdHJhY2suc2lkID0gdGkuc2lkO1xuICAgICAgaWYgKCF0aGlzLmVuZ2luZS5wY01hbmFnZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ3BjTWFuYWdlciBpcyBub3QgcmVhZHknKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmRlYnVnKFwicHVibGlzaGluZyBcIi5jb25jYXQodHJhY2sua2luZCwgXCIgd2l0aCBlbmNvZGluZ3NcIiksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBlbmNvZGluZ3MsXG4gICAgICAgIHRyYWNrSW5mbzogdGlcbiAgICAgIH0pKTtcbiAgICAgIHRyYWNrLnNlbmRlciA9IHlpZWxkIHRoaXMuZW5naW5lLmNyZWF0ZVNlbmRlcih0cmFjaywgb3B0cywgZW5jb2RpbmdzKTtcbiAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgaWYgKGlzRmlyZUZveCgpICYmIHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcbiAgICAgICAgICAvKiBSZWZlciB0byBSRkMgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM3NTg3I3NlY3Rpb24tNi4xLFxuICAgICAgICAgICAgIGxpdmVraXQtc2VydmVyIHVzZXMgbWF4YXZlcmFnZWJpdHJhdGU9NTEwMDAwIGluIHRoZSBhbnN3ZXIgc2RwIHRvIHBlcm1pdCBjbGllbnQgdG9cbiAgICAgICAgICAgICBwdWJsaXNoIGhpZ2ggcXVhbGl0eSBhdWRpbyB0cmFjay4gQnV0IGZpcmVmb3ggYWx3YXlzIHVzZXMgdGhpcyB2YWx1ZSBhcyB0aGUgYWN0dWFsXG4gICAgICAgICAgICAgYml0cmF0ZXMsIGNhdXNpbmcgdGhlIGF1ZGlvIGJpdHJhdGVzIHRvIHJpc2UgdG8gNTEwS2JwcyBpbiBhbnkgc3RlcmVvIGNhc2UgdW5leHBlY3RlZGx5LlxuICAgICAgICAgICAgIFNvIHRoZSBjbGllbnQgbmVlZCB0byBtb2RpZnkgbWF4YXZlcnJhZ2ViaXRyYXRlcyBpbiBhbnN3ZXIgc2RwIHRvIHVzZXIgcHJvdmlkZWQgdmFsdWUgdG9cbiAgICAgICAgICAgICBmaXggdGhlIGlzc3VlLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGxldCB0cmFja1RyYW5zY2VpdmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNjZWl2ZXIgb2YgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5nZXRUcmFuc2NlaXZlcnMoKSkge1xuICAgICAgICAgICAgaWYgKHRyYW5zY2VpdmVyLnNlbmRlciA9PT0gdHJhY2suc2VuZGVyKSB7XG4gICAgICAgICAgICAgIHRyYWNrVHJhbnNjZWl2ZXIgPSB0cmFuc2NlaXZlcjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0cmFja1RyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLnNldFRyYWNrQ29kZWNCaXRyYXRlKHtcbiAgICAgICAgICAgICAgdHJhbnNjZWl2ZXI6IHRyYWNrVHJhbnNjZWl2ZXIsXG4gICAgICAgICAgICAgIGNvZGVjOiAnb3B1cycsXG4gICAgICAgICAgICAgIG1heGJyOiAoKF9tID0gZW5jb2RpbmdzWzBdKSA9PT0gbnVsbCB8fCBfbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX20ubWF4Qml0cmF0ZSkgPyBlbmNvZGluZ3NbMF0ubWF4Qml0cmF0ZSAvIDEwMDAgOiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHJhY2suY29kZWMgJiYgaXNTVkNDb2RlYyh0cmFjay5jb2RlYykgJiYgKChfbyA9IGVuY29kaW5nc1swXSkgPT09IG51bGwgfHwgX28gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vLm1heEJpdHJhdGUpKSB7XG4gICAgICAgICAgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5zZXRUcmFja0NvZGVjQml0cmF0ZSh7XG4gICAgICAgICAgICBjaWQ6IHJlcS5jaWQsXG4gICAgICAgICAgICBjb2RlYzogdHJhY2suY29kZWMsXG4gICAgICAgICAgICBtYXhicjogZW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgLyAxMDAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLm5lZ290aWF0ZSgpO1xuICAgICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxWaWRlb1RyYWNrKSB7XG4gICAgICAgIHRyYWNrLnN0YXJ0TW9uaXRvcih0aGlzLmVuZ2luZS5jbGllbnQpO1xuICAgICAgfSBlbHNlIGlmICh0cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjaykge1xuICAgICAgICB0cmFjay5zdGFydE1vbml0b3IoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbik7XG4gICAgICAvLyBzZW5kIGV2ZW50IGZvciBwdWJsaWNhdGlvblxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgcHVibGljYXRpb24pO1xuICAgICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xuICAgIH0pO1xuICB9XG4gIGdldCBpc0xvY2FsKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKiBAaW50ZXJuYWxcbiAgICogcHVibGlzaCBhZGRpdGlvbmFsIGNvZGVjIHRvIGV4aXN0aW5nIHRyYWNrXG4gICAqL1xuICBwdWJsaXNoQWRkaXRpb25hbENvZGVjRm9yVHJhY2sodHJhY2ssIHZpZGVvQ29kZWMsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIFRPRE8gcmVtb3ZlIG9uY2UgZTJlZSBpcyBzdXBwb3J0ZWQgZm9yIGJhY2t1cCB0cmFja3NcbiAgICAgIGlmICh0aGlzLmVuY3J5cHRpb25UeXBlICE9PSBFbmNyeXB0aW9uX1R5cGUuTk9ORSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBpcyBpdCBub3QgcHVibGlzaGVkPyBpZiBzbyBza2lwXG4gICAgICBsZXQgZXhpc3RpbmdQdWJsaWNhdGlvbjtcbiAgICAgIHRoaXMudHJhY2tzLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xuICAgICAgICBpZiAoIXB1YmxpY2F0aW9uLnRyYWNrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwdWJsaWNhdGlvbi50cmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICBleGlzdGluZ1B1YmxpY2F0aW9uID0gcHVibGljYXRpb247XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFleGlzdGluZ1B1YmxpY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcigndHJhY2sgaXMgbm90IHB1Ymxpc2hlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKCEodHJhY2sgaW5zdGFuY2VvZiBMb2NhbFZpZGVvVHJhY2spKSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcigndHJhY2sgaXMgbm90IGEgdmlkZW8gdHJhY2snKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChfYSA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wdWJsaXNoRGVmYXVsdHMpLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IGVuY29kaW5ncyA9IGNvbXB1dGVUcmFja0JhY2t1cEVuY29kaW5ncyh0cmFjaywgdmlkZW9Db2RlYywgb3B0cyk7XG4gICAgICBpZiAoIWVuY29kaW5ncykge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKFwiYmFja3VwIGNvZGVjIGhhcyBiZWVuIGRpc2FibGVkLCBpZ25vcmluZyByZXF1ZXN0IHRvIGFkZCBhZGRpdGlvbmFsIGNvZGVjIGZvciB0cmFja1wiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpbXVsY2FzdFRyYWNrID0gdHJhY2suYWRkU2ltdWxjYXN0VHJhY2sodmlkZW9Db2RlYywgZW5jb2RpbmdzKTtcbiAgICAgIGNvbnN0IHJlcSA9IG5ldyBBZGRUcmFja1JlcXVlc3Qoe1xuICAgICAgICBjaWQ6IHNpbXVsY2FzdFRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXG4gICAgICAgIHR5cGU6IFRyYWNrLmtpbmRUb1Byb3RvKHRyYWNrLmtpbmQpLFxuICAgICAgICBtdXRlZDogdHJhY2suaXNNdXRlZCxcbiAgICAgICAgc291cmNlOiBUcmFjay5zb3VyY2VUb1Byb3RvKHRyYWNrLnNvdXJjZSksXG4gICAgICAgIHNpZDogdHJhY2suc2lkLFxuICAgICAgICBzaW11bGNhc3RDb2RlY3M6IFt7XG4gICAgICAgICAgY29kZWM6IG9wdHMudmlkZW9Db2RlYyxcbiAgICAgICAgICBjaWQ6IHNpbXVsY2FzdFRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWRcbiAgICAgICAgfV1cbiAgICAgIH0pO1xuICAgICAgcmVxLmxheWVycyA9IHZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyhyZXEud2lkdGgsIHJlcS5oZWlnaHQsIGVuY29kaW5ncyk7XG4gICAgICBpZiAoIXRoaXMuZW5naW5lIHx8IHRoaXMuZW5naW5lLmlzQ2xvc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjYW5ub3QgcHVibGlzaCB0cmFjayB3aGVuIG5vdCBjb25uZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRpID0geWllbGQgdGhpcy5lbmdpbmUuYWRkVHJhY2socmVxKTtcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNyZWF0ZVNpbXVsY2FzdFNlbmRlcih0cmFjaywgc2ltdWxjYXN0VHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5uZWdvdGlhdGUoKTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwicHVibGlzaGVkIFwiLmNvbmNhdCh2aWRlb0NvZGVjLCBcIiBmb3IgdHJhY2sgXCIpLmNvbmNhdCh0cmFjay5zaWQpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgZW5jb2RpbmdzLFxuICAgICAgICB0cmFja0luZm86IHRpXG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgdW5wdWJsaXNoVHJhY2sodHJhY2ssIHN0b3BPblVucHVibGlzaCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIGxvb2sgdGhyb3VnaCBhbGwgcHVibGlzaGVkIHRyYWNrcyB0byBmaW5kIHRoZSByaWdodCBvbmVzXG4gICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHRoaXMuZ2V0UHVibGljYXRpb25Gb3JUcmFjayh0cmFjayk7XG4gICAgICBjb25zdCBwdWJMb2dDb250ZXh0ID0gcHVibGljYXRpb24gPyBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1bnB1Ymxpc2hpbmcgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHB1YkxvZ0NvbnRleHQpKTtcbiAgICAgIGlmICghcHVibGljYXRpb24gfHwgIXB1YmxpY2F0aW9uLnRyYWNrKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3RyYWNrIHdhcyBub3QgdW5wdWJsaXNoZWQgYmVjYXVzZSBubyBwdWJsaWNhdGlvbiB3YXMgZm91bmQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHB1YkxvZ0NvbnRleHQpKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRyYWNrID0gcHVibGljYXRpb24udHJhY2s7XG4gICAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5NdXRlZCwgdGhpcy5vblRyYWNrTXV0ZWQpO1xuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcy5vblRyYWNrVW5tdXRlZCk7XG4gICAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVUcmFja0VuZGVkKTtcbiAgICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LlVwc3RyZWFtUGF1c2VkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVBhdXNlZCk7XG4gICAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5VcHN0cmVhbVJlc3VtZWQsIHRoaXMub25UcmFja1Vwc3RyZWFtUmVzdW1lZCk7XG4gICAgICBpZiAoc3RvcE9uVW5wdWJsaXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RvcE9uVW5wdWJsaXNoID0gKF9iID0gKF9hID0gdGhpcy5yb29tT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RvcE9uVW5wdWJsaXNoKSB7XG4gICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIGxldCBuZWdvdGlhdGlvbk5lZWRlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgdHJhY2tTZW5kZXIgPSB0cmFjay5zZW5kZXI7XG4gICAgICB0cmFjay5zZW5kZXIgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAodGhpcy5lbmdpbmUucGNNYW5hZ2VyICYmIHRoaXMuZW5naW5lLnBjTWFuYWdlci5jdXJyZW50U3RhdGUgPCBQQ1RyYW5zcG9ydFN0YXRlLkZBSUxFRCAmJiB0cmFja1NlbmRlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNjZWl2ZXIgb2YgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5nZXRUcmFuc2NlaXZlcnMoKSkge1xuICAgICAgICAgICAgLy8gaWYgc2VuZGVyIGlzIG5vdCBjdXJyZW50bHkgc2VuZGluZyAoYWZ0ZXIgcmVwbGFjZVRyYWNrKG51bGwpKVxuICAgICAgICAgICAgLy8gcmVtb3ZlVHJhY2sgd291bGQgaGF2ZSBubyBlZmZlY3QuXG4gICAgICAgICAgICAvLyB0byBlbnN1cmUgd2UgZW5kIHVwIHN1Y2Nlc3NmdWxseSByZW1vdmluZyB0aGUgdHJhY2ssIG1hbnVhbGx5IHNldFxuICAgICAgICAgICAgLy8gdGhlIHRyYW5zY2VpdmVyIHRvIGluYWN0aXZlXG4gICAgICAgICAgICBpZiAodHJhbnNjZWl2ZXIuc2VuZGVyID09PSB0cmFja1NlbmRlcikge1xuICAgICAgICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgICAgICBuZWdvdGlhdGlvbk5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmVuZ2luZS5yZW1vdmVUcmFjayh0cmFja1NlbmRlcikpIHtcbiAgICAgICAgICAgIG5lZ290aWF0aW9uTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxWaWRlb1RyYWNrKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFssIHRyYWNrSW5mb10gb2YgdHJhY2suc2ltdWxjYXN0Q29kZWNzKSB7XG4gICAgICAgICAgICAgIGlmICh0cmFja0luZm8uc2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5naW5lLnJlbW92ZVRyYWNrKHRyYWNrSW5mby5zZW5kZXIpKSB7XG4gICAgICAgICAgICAgICAgICBuZWdvdGlhdGlvbk5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYWNrSW5mby5zZW5kZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrLnNpbXVsY2FzdENvZGVjcy5jbGVhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2ZhaWxlZCB0byB1bnB1Ymxpc2ggdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgcHViTG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgZnJvbSBvdXIgbWFwc1xuICAgICAgdGhpcy50cmFja3MuZGVsZXRlKHB1YmxpY2F0aW9uLnRyYWNrU2lkKTtcbiAgICAgIHN3aXRjaCAocHVibGljYXRpb24ua2luZCkge1xuICAgICAgICBjYXNlIFRyYWNrLktpbmQuQXVkaW86XG4gICAgICAgICAgdGhpcy5hdWRpb1RyYWNrcy5kZWxldGUocHVibGljYXRpb24udHJhY2tTaWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRyYWNrLktpbmQuVmlkZW86XG4gICAgICAgICAgdGhpcy52aWRlb1RyYWNrcy5kZWxldGUocHVibGljYXRpb24udHJhY2tTaWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XG4gICAgICBwdWJsaWNhdGlvbi5zZXRUcmFjayh1bmRlZmluZWQpO1xuICAgICAgaWYgKG5lZ290aWF0aW9uTmVlZGVkKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLm5lZ290aWF0ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xuICAgIH0pO1xuICB9XG4gIHVucHVibGlzaFRyYWNrcyh0cmFja3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IHlpZWxkIFByb21pc2UuYWxsKHRyYWNrcy5tYXAodHJhY2sgPT4gdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjaykpKTtcbiAgICAgIHJldHVybiByZXN1bHRzLmZpbHRlcih0cmFjayA9PiB0cmFjayBpbnN0YW5jZW9mIExvY2FsVHJhY2tQdWJsaWNhdGlvbik7XG4gICAgfSk7XG4gIH1cbiAgcmVwdWJsaXNoQWxsVHJhY2tzKG9wdGlvbnMpIHtcbiAgICBsZXQgcmVzdGFydFRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgbG9jYWxQdWJzID0gW107XG4gICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKHB1YiA9PiB7XG4gICAgICAgIGlmIChwdWIudHJhY2spIHtcbiAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgcHViLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHB1Yi5vcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvY2FsUHVicy5wdXNoKHB1Yik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgUHJvbWlzZS5hbGwobG9jYWxQdWJzLm1hcChwdWIgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCB0cmFjayA9IHB1Yi50cmFjaztcbiAgICAgICAgeWllbGQgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjaywgZmFsc2UpO1xuICAgICAgICBpZiAocmVzdGFydFRyYWNrcyAmJiAhdHJhY2suaXNNdXRlZCAmJiB0cmFjay5zb3VyY2UgIT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSAmJiB0cmFjay5zb3VyY2UgIT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvICYmICh0cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjayB8fCB0cmFjayBpbnN0YW5jZW9mIExvY2FsVmlkZW9UcmFjaykgJiYgIXRyYWNrLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgICAgLy8gZ2VuZXJhbGx5IHdlIG5lZWQgdG8gcmVzdGFydCB0aGUgdHJhY2sgYmVmb3JlIHB1Ymxpc2hpbmcsIG9mdGVuIGEgZnVsbCByZWNvbm5lY3RcbiAgICAgICAgICAvLyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBjb21wdXRlciBoYWQgZ29uZSB0byBzbGVlcC5cbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVzdGFydGluZyBleGlzdGluZyB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgdHJhY2s6IHB1Yi50cmFja1NpZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB5aWVsZCB0cmFjay5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB0aGlzLnB1Ymxpc2hUcmFjayh0cmFjaywgcHViLm9wdGlvbnMpO1xuICAgICAgfSkpKTtcbiAgICB9KTtcbiAgfVxuICBwdWJsaXNoRGF0YShkYXRhLCBraW5kKSB7XG4gICAgbGV0IHB1Ymxpc2hPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZGVzdGluYXRpb24gPSBBcnJheS5pc0FycmF5KHB1Ymxpc2hPcHRpb25zKSA/IHB1Ymxpc2hPcHRpb25zIDogcHVibGlzaE9wdGlvbnMgPT09IG51bGwgfHwgcHVibGlzaE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHB1Ymxpc2hPcHRpb25zLmRlc3RpbmF0aW9uO1xuICAgICAgY29uc3QgZGVzdGluYXRpb25TaWRzID0gW107XG4gICAgICBjb25zdCB0b3BpYyA9ICFBcnJheS5pc0FycmF5KHB1Ymxpc2hPcHRpb25zKSA/IHB1Ymxpc2hPcHRpb25zLnRvcGljIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGRlc3RpbmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVzdGluYXRpb24uZm9yRWFjaCh2YWwgPT4ge1xuICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBSZW1vdGVQYXJ0aWNpcGFudCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25TaWRzLnB1c2godmFsLnNpZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uU2lkcy5wdXNoKHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgICAga2luZCxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBjYXNlOiAndXNlcicsXG4gICAgICAgICAgdmFsdWU6IG5ldyBVc2VyUGFja2V0KHtcbiAgICAgICAgICAgIHBhcnRpY2lwYW50U2lkOiB0aGlzLnNpZCxcbiAgICAgICAgICAgIHBheWxvYWQ6IGRhdGEsXG4gICAgICAgICAgICBkZXN0aW5hdGlvblNpZHM6IGRlc3RpbmF0aW9uU2lkcyxcbiAgICAgICAgICAgIHRvcGljXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5zZW5kRGF0YVBhY2tldChwYWNrZXQsIGtpbmQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDb250cm9sIHdobyBjYW4gc3Vic2NyaWJlIHRvIExvY2FsUGFydGljaXBhbnQncyBwdWJsaXNoZWQgdHJhY2tzLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBhbGwgcGFydGljaXBhbnRzIGNhbiBzdWJzY3JpYmUuIFRoaXMgYWxsb3dzIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXJcbiAgICogd2hvIGlzIGFibGUgdG8gc3Vic2NyaWJlIGF0IGEgcGFydGljaXBhbnQgYW5kIHRyYWNrIGxldmVsLlxuICAgKlxuICAgKiBOb3RlOiBpZiBhY2Nlc3MgaXMgZ2l2ZW4gYXQgYSB0cmFjay1sZXZlbCAoaS5lLiBib3RoIFthbGxQYXJ0aWNpcGFudHNBbGxvd2VkXSBhbmRcbiAgICogW1BhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uLmFsbFRyYWNrc0FsbG93ZWRdIGFyZSBmYWxzZSksIGFueSBuZXdlciBwdWJsaXNoZWQgdHJhY2tzXG4gICAqIHdpbGwgbm90IGdyYW50IHBlcm1pc3Npb25zIHRvIGFueSBwYXJ0aWNpcGFudHMgYW5kIHdpbGwgcmVxdWlyZSBhIHN1YnNlcXVlbnRcbiAgICogcGVybWlzc2lvbnMgdXBkYXRlIHRvIGFsbG93IHN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGFsbFBhcnRpY2lwYW50c0FsbG93ZWQgQWxsb3dzIGFsbCBwYXJ0aWNpcGFudHMgdG8gc3Vic2NyaWJlIGFsbCB0cmFja3MuXG4gICAqICBUYWtlcyBwcmVjZWRlbmNlIG92ZXIgW1twYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnNdXSBpZiBzZXQgdG8gdHJ1ZS5cbiAgICogIEJ5IGRlZmF1bHQgdGhpcyBpcyBzZXQgdG8gdHJ1ZS5cbiAgICogQHBhcmFtIHBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyBGdWxsIGxpc3Qgb2YgaW5kaXZpZHVhbCBwZXJtaXNzaW9ucyBwZXJcbiAgICogIHBhcnRpY2lwYW50L3RyYWNrLiBBbnkgb21pdHRlZCBwYXJ0aWNpcGFudHMgd2lsbCBub3QgcmVjZWl2ZSBhbnkgcGVybWlzc2lvbnMuXG4gICAqL1xuICBzZXRUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zKGFsbFBhcnRpY2lwYW50c0FsbG93ZWQpIHtcbiAgICBsZXQgcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICB0aGlzLnBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyA9IHBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucztcbiAgICB0aGlzLmFsbFBhcnRpY2lwYW50c0FsbG93ZWRUb1N1YnNjcmliZSA9IGFsbFBhcnRpY2lwYW50c0FsbG93ZWQ7XG4gICAgaWYgKCF0aGlzLmVuZ2luZS5jbGllbnQuaXNEaXNjb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucygpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbykge1xuICAgIGlmIChpbmZvLnNpZCAhPT0gdGhpcy5zaWQpIHtcbiAgICAgIC8vIGRyb3AgdXBkYXRlcyB0aGF0IHNwZWNpZnkgYSB3cm9uZyBzaWQuXG4gICAgICAvLyB0aGUgc2lkIGZvciBsb2NhbCBwYXJ0aWNpcGFudCBpcyBvbmx5IGV4cGxpY2l0bHkgc2V0IG9uIGpvaW4gYW5kIGZ1bGwgcmVjb25uZWN0XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghc3VwZXIudXBkYXRlSW5mbyhpbmZvKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyByZWNvbmNpbGUgdHJhY2sgbXV0ZSBzdGF0dXMuXG4gICAgLy8gaWYgc2VydmVyJ3MgdHJhY2sgbXV0ZSBzdGF0dXMgZG9lc24ndCBtYXRjaCBhY3R1YWwsIHdlJ2xsIGhhdmUgdG8gdXBkYXRlXG4gICAgLy8gdGhlIHNlcnZlcidzIGNvcHlcbiAgICBpbmZvLnRyYWNrcy5mb3JFYWNoKHRpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBwdWIgPSB0aGlzLnRyYWNrcy5nZXQodGkuc2lkKTtcbiAgICAgIGlmIChwdWIpIHtcbiAgICAgICAgY29uc3QgbXV0ZWRPblNlcnZlciA9IHB1Yi5pc011dGVkIHx8ICgoX2IgPSAoX2EgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1Vwc3RyZWFtUGF1c2VkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSk7XG4gICAgICAgIGlmIChtdXRlZE9uU2VydmVyICE9PSB0aS5tdXRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCd1cGRhdGluZyBzZXJ2ZXIgbXV0ZSBzdGF0ZSBhZnRlciByZWNvbmNpbGUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWIpKSwge1xuICAgICAgICAgICAgbXV0ZWRPblNlcnZlclxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZE11dGVUcmFjayh0aS5zaWQsIG11dGVkT25TZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0UHVibGljYXRpb25Gb3JUcmFjayh0cmFjaykge1xuICAgIGxldCBwdWJsaWNhdGlvbjtcbiAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKHB1YiA9PiB7XG4gICAgICBjb25zdCBsb2NhbFRyYWNrID0gcHViLnRyYWNrO1xuICAgICAgaWYgKCFsb2NhbFRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIHRoaXMgbG9va3Mgb3Zlcmx5IGNvbXBsaWNhdGVkIGR1ZSB0byB0aGlzIG9iamVjdCB0cmVlXG4gICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgIGlmIChsb2NhbFRyYWNrIGluc3RhbmNlb2YgTG9jYWxBdWRpb1RyYWNrIHx8IGxvY2FsVHJhY2sgaW5zdGFuY2VvZiBMb2NhbFZpZGVvVHJhY2spIHtcbiAgICAgICAgICBpZiAobG9jYWxUcmFjay5tZWRpYVN0cmVhbVRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgICAgcHVibGljYXRpb24gPSBwdWI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrID09PSBsb2NhbFRyYWNrKSB7XG4gICAgICAgIHB1YmxpY2F0aW9uID0gcHViO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgfVxufVxuXG52YXIgQ29ubmVjdGlvblN0YXRlO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uU3RhdGUpIHtcbiAgQ29ubmVjdGlvblN0YXRlW1wiRGlzY29ubmVjdGVkXCJdID0gXCJkaXNjb25uZWN0ZWRcIjtcbiAgQ29ubmVjdGlvblN0YXRlW1wiQ29ubmVjdGluZ1wiXSA9IFwiY29ubmVjdGluZ1wiO1xuICBDb25uZWN0aW9uU3RhdGVbXCJDb25uZWN0ZWRcIl0gPSBcImNvbm5lY3RlZFwiO1xuICBDb25uZWN0aW9uU3RhdGVbXCJSZWNvbm5lY3RpbmdcIl0gPSBcInJlY29ubmVjdGluZ1wiO1xufSkoQ29ubmVjdGlvblN0YXRlIHx8IChDb25uZWN0aW9uU3RhdGUgPSB7fSkpO1xuY29uc3QgY29ubmVjdGlvblJlY29uY2lsZUZyZXF1ZW5jeSA9IDIgKiAxMDAwO1xuLyoqIEBkZXByZWNhdGVkIFJvb21TdGF0ZSBoYXMgYmVlbiByZW5hbWVkIHRvIFtbQ29ubmVjdGlvblN0YXRlXV0gKi9cbmNvbnN0IFJvb21TdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZTtcbi8qKlxuICogSW4gTGl2ZUtpdCwgYSByb29tIGlzIHRoZSBsb2dpY2FsIGdyb3VwaW5nIGZvciBhIGxpc3Qgb2YgcGFydGljaXBhbnRzLlxuICogUGFydGljaXBhbnRzIGluIGEgcm9vbSBjYW4gcHVibGlzaCB0cmFja3MsIGFuZCBzdWJzY3JpYmUgdG8gb3RoZXJzJyB0cmFja3MuXG4gKlxuICogYSBSb29tIGZpcmVzIFtbUm9vbUV2ZW50IHwgUm9vbUV2ZW50c11dLlxuICpcbiAqIEBub0luaGVyaXREb2NcbiAqL1xuY2xhc3MgUm9vbSBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUm9vbSwgdGhlIHByaW1hcnkgY29uc3RydWN0IGZvciBhIExpdmVLaXQgc2Vzc2lvbi5cbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBzdXBlcigpO1xuICAgIF90aGlzID0gdGhpcztcbiAgICB0aGlzLnN0YXRlID0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZDtcbiAgICAvKipcbiAgICAgKiBsaXN0IG9mIHBhcnRpY2lwYW50cyB0aGF0IGFyZSBhY3RpdmVseSBzcGVha2luZy4gd2hlbiB0aGlzIGNoYW5nZXNcbiAgICAgKiBhIFtbUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZF1dIGV2ZW50IGlzIGZpcmVkXG4gICAgICovXG4gICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IFtdO1xuICAgIC8qKiByZWZsZWN0cyB0aGUgc2VuZGVyIGVuY3J5cHRpb24gc3RhdHVzIG9mIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCAqL1xuICAgIHRoaXMuaXNFMkVFRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuYXVkaW9FbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XG4gICAgdGhpcy5jb25uZWN0ID0gKHVybCwgdG9rZW4sIG9wdHMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYztcbiAgICAgIC8vIEluIGNhc2UgYSBkaXNjb25uZWN0IGNhbGxlZCBoYXBwZW5lZCByaWdodCBiZWZvcmUgdGhlIGNvbm5lY3QgY2FsbCwgbWFrZSBzdXJlIHRoZSBkaXNjb25uZWN0IGlzIGNvbXBsZXRlZCBmaXJzdCBieSBhd2FpdGluZyBpdHMgbG9ja1xuICAgICAgY29uc3QgdW5sb2NrRGlzY29ubmVjdCA9IHlpZWxkIHRoaXMuZGlzY29ubmVjdExvY2subG9jaygpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgLy8gd2hlbiB0aGUgc3RhdGUgaXMgcmVjb25uZWN0aW5nIG9yIGNvbm5lY3RlZCwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGltbWVkaWF0ZWx5XG4gICAgICAgIHRoaXMubG9nLmluZm8oXCJhbHJlYWR5IGNvbm5lY3RlZCB0byByb29tIFwiLmNvbmNhdCh0aGlzLm5hbWUpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB1bmxvY2tEaXNjb25uZWN0KCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbm5lY3RGdXR1cmUpIHtcbiAgICAgICAgdW5sb2NrRGlzY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0RnV0dXJlLnByb21pc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RpbmcpO1xuICAgICAgaWYgKCgoX2MgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0U2VydmVyVXJsKCkudG9TdHJpbmcoKSkgIT09IHVybCkge1xuICAgICAgICB0aGlzLnJlZ2lvblVybCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Nsb3VkKG5ldyBVUkwodXJsKSkpIHtcbiAgICAgICAgaWYgKHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPSBuZXcgUmVnaW9uVXJsUHJvdmlkZXIodXJsLCB0b2tlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci51cGRhdGVUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJpZ2dlciB0aGUgZmlyc3QgZmV0Y2ggd2l0aG91dCB3YWl0aW5nIGZvciBhIHJlc3BvbnNlXG4gICAgICAgIC8vIGlmIGluaXRpYWwgY29ubmVjdGlvbiBmYWlscywgdGhpcyB3aWxsIHNwZWVkIHVwIHBpY2tpbmcgcmVnaW9uYWwgdXJsXG4gICAgICAgIC8vIG9uIHN1YnNlcXVlbnQgcnVuc1xuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLmZldGNoUmVnaW9uU2V0dGluZ3MoKS5jYXRjaChlID0+IHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgZmV0Y2ggcmVnaW9uIHNldHRpbmdzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb25uZWN0Rm4gPSAocmVzb2x2ZSwgcmVqZWN0LCByZWdpb25VcmwpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9kO1xuICAgICAgICBpZiAodGhpcy5hYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4cGxpY2l0IGNyZWF0aW9uIGFzIGxvY2FsIHZhciBuZWVkZWQgdG8gc2F0aXNmeSBUUyBjb21waWxlciB3aGVuIHBhc3NpbmcgaXQgdG8gYGF0dGVtcHRDb25uZWN0aW9uYCBmdXJ0aGVyIGRvd25cbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IGFib3J0Q29udHJvbGxlcjtcbiAgICAgICAgLy8gYXQgdGhpcyBwb2ludCB0aGUgaW50ZW50aW9uIHRvIGNvbm5lY3QgaGFzIGJlZW4gc2lnbmFsbGVkIHNvIHdlIGNhbiBhbGxvdyBjYW5jZWxsaW5nIG9mIHRoZSBjb25uZWN0aW9uIHZpYSBkaXNjb25uZWN0KCkgYWdhaW5cbiAgICAgICAgdW5sb2NrRGlzY29ubmVjdCA9PT0gbnVsbCB8fCB1bmxvY2tEaXNjb25uZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bmxvY2tEaXNjb25uZWN0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5hdHRlbXB0Q29ubmVjdGlvbihyZWdpb25VcmwgIT09IG51bGwgJiYgcmVnaW9uVXJsICE9PSB2b2lkIDAgPyByZWdpb25VcmwgOiB1cmwsIHRva2VuLCBvcHRzLCBhYm9ydENvbnRyb2xsZXIpO1xuICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmICh0aGlzLnJlZ2lvblVybFByb3ZpZGVyICYmIGUgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgJiYgZS5yZWFzb24gIT09IDMgLyogQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCAqLyAmJiBlLnJlYXNvbiAhPT0gMCAvKiBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCAqLykge1xuICAgICAgICAgICAgbGV0IG5leHRVcmwgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbmV4dFVybCA9IHlpZWxkIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIuZ2V0TmV4dEJlc3RSZWdpb25VcmwoKF9kID0gdGhpcy5hYm9ydENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zaWduYWwpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIChlcnJvci5zdGF0dXMgPT09IDQwMSB8fCBlcnJvci5yZWFzb24gPT09IDMgLyogQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCAqLykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dFVybCkge1xuICAgICAgICAgICAgICB0aGlzLmxvZy5pbmZvKFwiSW5pdGlhbCBjb25uZWN0aW9uIGZhaWxlZCB3aXRoIENvbm5lY3Rpb25FcnJvcjogXCIuY29uY2F0KGUubWVzc2FnZSwgXCIuIFJldHJ5aW5nIHdpdGggYW5vdGhlciByZWdpb246IFwiKS5jb25jYXQobmV4dFVybCksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgICAgIHlpZWxkIGNvbm5lY3RGbihyZXNvbHZlLCByZWplY3QsIG5leHRVcmwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoKTtcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gpO1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZWdpb25VcmwgPSB0aGlzLnJlZ2lvblVybDtcbiAgICAgIHRoaXMucmVnaW9uVXJsID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5jb25uZWN0RnV0dXJlID0gbmV3IEZ1dHVyZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbm5lY3RGbihyZXNvbHZlLCByZWplY3QsIHJlZ2lvblVybCk7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uRnV0dXJlcygpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0RnV0dXJlLnByb21pc2U7XG4gICAgfSk7XG4gICAgdGhpcy5jb25uZWN0U2lnbmFsID0gKHVybCwgdG9rZW4sIGVuZ2luZSwgY29ubmVjdE9wdGlvbnMsIHJvb21PcHRpb25zLCBhYm9ydENvbnRyb2xsZXIpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfZSwgX2YsIF9nO1xuICAgICAgY29uc3Qgam9pblJlc3BvbnNlID0geWllbGQgZW5naW5lLmpvaW4odXJsLCB0b2tlbiwge1xuICAgICAgICBhdXRvU3Vic2NyaWJlOiBjb25uZWN0T3B0aW9ucy5hdXRvU3Vic2NyaWJlLFxuICAgICAgICBwdWJsaXNoT25seTogY29ubmVjdE9wdGlvbnMucHVibGlzaE9ubHksXG4gICAgICAgIGFkYXB0aXZlU3RyZWFtOiB0eXBlb2Ygcm9vbU9wdGlvbnMuYWRhcHRpdmVTdHJlYW0gPT09ICdvYmplY3QnID8gdHJ1ZSA6IHJvb21PcHRpb25zLmFkYXB0aXZlU3RyZWFtLFxuICAgICAgICBtYXhSZXRyaWVzOiBjb25uZWN0T3B0aW9ucy5tYXhSZXRyaWVzLFxuICAgICAgICBlMmVlRW5hYmxlZDogISF0aGlzLmUyZWVNYW5hZ2VyLFxuICAgICAgICB3ZWJzb2NrZXRUaW1lb3V0OiBjb25uZWN0T3B0aW9ucy53ZWJzb2NrZXRUaW1lb3V0XG4gICAgICB9LCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgIGxldCBzZXJ2ZXJJbmZvID0gam9pblJlc3BvbnNlLnNlcnZlckluZm87XG4gICAgICBpZiAoIXNlcnZlckluZm8pIHtcbiAgICAgICAgc2VydmVySW5mbyA9IHtcbiAgICAgICAgICB2ZXJzaW9uOiBqb2luUmVzcG9uc2Uuc2VydmVyVmVyc2lvbixcbiAgICAgICAgICByZWdpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmRlYnVnKFwiY29ubmVjdGVkIHRvIExpdmVraXQgU2VydmVyIFwiLmNvbmNhdChPYmplY3QuZW50cmllcyhzZXJ2ZXJJbmZvKS5tYXAoX3JlZiA9PiB7XG4gICAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmO1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoa2V5LCBcIjogXCIpLmNvbmNhdCh2YWx1ZSk7XG4gICAgICB9KS5qb2luKCcsICcpKSwge1xuICAgICAgICByb29tOiAoX2UgPSBqb2luUmVzcG9uc2Uucm9vbSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLm5hbWUsXG4gICAgICAgIHJvb21TaWQ6IChfZiA9IGpvaW5SZXNwb25zZS5yb29tKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc2lkLFxuICAgICAgICBpZGVudGl0eTogKF9nID0gam9pblJlc3BvbnNlLnBhcnRpY2lwYW50KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuaWRlbnRpdHlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFqb2luUmVzcG9uc2Uuc2VydmVyVmVyc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRTZXJ2ZXIoJ3Vua25vd24gc2VydmVyIHZlcnNpb24nKTtcbiAgICAgIH1cbiAgICAgIGlmIChqb2luUmVzcG9uc2Uuc2VydmVyVmVyc2lvbiA9PT0gJzAuMTUuMScgJiYgdGhpcy5vcHRpb25zLmR5bmFjYXN0KSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdkaXNhYmxpbmcgZHluYWNhc3QgZHVlIHRvIHNlcnZlciB2ZXJzaW9uJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgLy8gZHluYWNhc3QgaGFzIGEgYnVnIGluIDAuMTUuMSwgc28gd2UgY2Fubm90IHVzZSBpdCB0aGVuXG4gICAgICAgIHJvb21PcHRpb25zLmR5bmFjYXN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gam9pblJlc3BvbnNlO1xuICAgIH0pO1xuICAgIHRoaXMuYXBwbHlKb2luUmVzcG9uc2UgPSBqb2luUmVzcG9uc2UgPT4ge1xuICAgICAgY29uc3QgcGkgPSBqb2luUmVzcG9uc2UucGFydGljaXBhbnQ7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkID0gcGkuc2lkO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID0gcGkuaWRlbnRpdHk7XG4gICAgICAvLyBwb3B1bGF0ZSByZW1vdGUgcGFydGljaXBhbnRzLCB0aGVzZSBzaG91bGQgbm90IHRyaWdnZXIgbmV3IGV2ZW50c1xuICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudFVwZGF0ZXMoW3BpLCAuLi5qb2luUmVzcG9uc2Uub3RoZXJQYXJ0aWNpcGFudHNdKTtcbiAgICAgIGlmIChqb2luUmVzcG9uc2Uucm9vbSkge1xuICAgICAgICB0aGlzLmhhbmRsZVJvb21VcGRhdGUoam9pblJlc3BvbnNlLnJvb20pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lMmVlICYmIHRoaXMuZTJlZU1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5lMmVlTWFuYWdlci5zZXRTaWZUcmFpbGVyKGpvaW5SZXNwb25zZS5zaWZUcmFpbGVyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYXR0ZW1wdENvbm5lY3Rpb24gPSAodXJsLCB0b2tlbiwgb3B0cywgYWJvcnRDb250cm9sbGVyKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2gsIF9qO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgdGhpcy5sb2cuaW5mbygnUmVjb25uZWN0aW9uIGF0dGVtcHQgcmVwbGFjZWQgYnkgbmV3IGNvbm5lY3Rpb24gYXR0ZW1wdCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBjbG9zZSBhbmQgcmVjcmVhdGUgdGhlIGV4aXN0aW5nIGVuZ2luZSBpbiBvcmRlciB0byBnZXQgcmlkIG9mIGFueSBwb3RlbnRpYWxseSBvbmdvaW5nIHJlY29ubmVjdGlvbiBhdHRlbXB0c1xuICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjcmVhdGUgZW5naW5lIGlmIHByZXZpb3VzbHkgZGlzY29ubmVjdGVkXG4gICAgICAgIHRoaXMubWF5YmVDcmVhdGVFbmdpbmUoKTtcbiAgICAgIH1cbiAgICAgIGlmICgoX2ggPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guaXNDbG91ZCgpKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLnNldFJlZ2lvblVybFByb3ZpZGVyKHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3F1aXJlQXVkaW9Db250ZXh0KCk7XG4gICAgICB0aGlzLmNvbm5PcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzKSwgb3B0cyk7XG4gICAgICBpZiAodGhpcy5jb25uT3B0aW9ucy5ydGNDb25maWcpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUucnRjQ29uZmlnID0gdGhpcy5jb25uT3B0aW9ucy5ydGNDb25maWc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25uT3B0aW9ucy5wZWVyQ29ubmVjdGlvblRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUucGVlckNvbm5lY3Rpb25UaW1lb3V0ID0gdGhpcy5jb25uT3B0aW9ucy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBqb2luUmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNvbm5lY3RTaWduYWwodXJsLCB0b2tlbiwgdGhpcy5lbmdpbmUsIHRoaXMuY29ubk9wdGlvbnMsIHRoaXMub3B0aW9ucywgYWJvcnRDb250cm9sbGVyKTtcbiAgICAgICAgdGhpcy5hcHBseUpvaW5SZXNwb25zZShqb2luUmVzcG9uc2UpO1xuICAgICAgICAvLyBmb3J3YXJkIG1ldGFkYXRhIGNoYW5nZWQgZm9yIHRoZSBsb2NhbCBwYXJ0aWNpcGFudFxuICAgICAgICB0aGlzLnNldHVwTG9jYWxQYXJ0aWNpcGFudEV2ZW50cygpO1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlNpZ25hbENvbm5lY3RlZCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xuICAgICAgICBjb25zdCByZXN1bHRpbmdFcnJvciA9IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJjb3VsZCBub3QgZXN0YWJsaXNoIHNpZ25hbCBjb25uZWN0aW9uXCIpO1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXN1bHRpbmdFcnJvci5tZXNzYWdlID0gXCJcIi5jb25jYXQocmVzdWx0aW5nRXJyb3IubWVzc2FnZSwgXCI6IFwiKS5jb25jYXQoZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IpIHtcbiAgICAgICAgICByZXN1bHRpbmdFcnJvci5yZWFzb24gPSBlcnIucmVhc29uO1xuICAgICAgICAgIHJlc3VsdGluZ0Vycm9yLnN0YXR1cyA9IGVyci5zdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJlcnJvciB0cnlpbmcgdG8gZXN0YWJsaXNoIHNpZ25hbCBjb25uZWN0aW9uXCIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgfSkpO1xuICAgICAgICB0aHJvdyByZXN1bHRpbmdFcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xuICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKFwiQ29ubmVjdGlvbiBhdHRlbXB0IGFib3J0ZWRcIik7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS53YWl0Rm9yUENJbml0aWFsQ29ubmVjdGlvbih0aGlzLmNvbm5PcHRpb25zLnBlZXJDb25uZWN0aW9uVGltZW91dCwgYWJvcnRDb250cm9sbGVyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgLy8gYWxzbyBob29rIHVubG9hZCBldmVudFxuICAgICAgaWYgKGlzV2ViKCkgJiYgdGhpcy5vcHRpb25zLmRpc2Nvbm5lY3RPblBhZ2VMZWF2ZSkge1xuICAgICAgICAvLyBjYXB0dXJpbmcgYm90aCAncGFnZWhpZGUnIGFuZCAnYmVmb3JldW5sb2FkJyB0byBjYXB0dXJlIGJyb2FkZXN0IHNldCBvZiBicm93c2VyIGJlaGF2aW9yc1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZnJlZXplJywgdGhpcy5vblBhZ2VMZWF2ZSk7XG4gICAgICAgIChfaiA9IG5hdmlnYXRvci5tZWRpYURldmljZXMpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VjaGFuZ2UnLCB0aGlzLmhhbmRsZURldmljZUNoYW5nZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNvbm5lY3RlZCk7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIGRpc2Nvbm5lY3RzIHRoZSByb29tLCBlbWl0cyBbW1Jvb21FdmVudC5EaXNjb25uZWN0ZWRdXVxuICAgICAqL1xuICAgIHRoaXMuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBzdG9wVHJhY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfaywgX2wsIF9tLCBfbztcbiAgICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5kaXNjb25uZWN0TG9jay5sb2NrKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdhbHJlYWR5IGRpc2Nvbm5lY3RlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubG9nLmluZm8oJ2Rpc2Nvbm5lY3QgZnJvbSByb29tJywgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0aW5nIHx8IHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgIC8vIHRyeSBhYm9ydGluZyBwZW5kaW5nIGNvbm5lY3Rpb24gYXR0ZW1wdFxuICAgICAgICAgICAgdGhpcy5sb2cud2FybignYWJvcnQgY29ubmVjdGlvbiBhdHRlbXB0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgIChfayA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2suYWJvcnQoKTtcbiAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIGFib3J0IGNvbnRyb2xsZXIgZGlkbid0IG1hbmFnZSB0byBjYW5jZWwgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdCwgcmVqZWN0IHRoZSBjb25uZWN0IHByb21pc2UgZXhwbGljaXRseVxuICAgICAgICAgICAgKF9tID0gKF9sID0gdGhpcy5jb25uZWN0RnV0dXJlKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wucmVqZWN0KSA9PT0gbnVsbCB8fCBfbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX20uY2FsbChfbCwgbmV3IENvbm5lY3Rpb25FcnJvcignQ2xpZW50IGluaXRpYXRlZCBkaXNjb25uZWN0JykpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzZW5kIGxlYXZlXG4gICAgICAgICAgaWYgKCEoKF9vID0gdGhpcy5lbmdpbmUpID09PSBudWxsIHx8IF9vID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfby5jbGllbnQuaXNEaXNjb25uZWN0ZWQpKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZExlYXZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNsb3NlIGVuZ2luZSAoYWxzbyBjbG9zZXMgY2xpZW50KVxuICAgICAgICAgIGlmICh0aGlzLmVuZ2luZSkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHN0b3BUcmFja3MsIERpc2Nvbm5lY3RSZWFzb24uQ0xJRU5UX0lOSVRJQVRFRCk7XG4gICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICAgIHRoaXMuZW5naW5lID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHVubG9jaygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMub25QYWdlTGVhdmUgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBCcm93c2VycyBoYXZlIGRpZmZlcmVudCBwb2xpY2llcyByZWdhcmRpbmcgYXVkaW8gcGxheWJhY2suIE1vc3QgcmVxdWlyaW5nXG4gICAgICogc29tZSBmb3JtIG9mIHVzZXIgaW50ZXJhY3Rpb24gKGNsaWNrL3RhcC9ldGMpLlxuICAgICAqIEluIHRob3NlIGNhc2VzLCBhdWRpbyB3aWxsIGJlIHNpbGVudCB1bnRpbCBhIGNsaWNrL3RhcCB0cmlnZ2VyaW5nIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAgICogLSBgc3RhcnRBdWRpb2BcbiAgICAgKiAtIGBnZXRVc2VyTWVkaWFgXG4gICAgICovXG4gICAgdGhpcy5zdGFydEF1ZGlvID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgICBpZiAoYnJvd3NlciAmJiBicm93c2VyLm9zID09PSAnaU9TJykge1xuICAgICAgICAvKipcbiAgICAgICAgICogaU9TIGJsb2NrcyBhdWRpbyBlbGVtZW50IHBsYXliYWNrIGlmXG4gICAgICAgICAqIC0gdXNlciBpcyBub3QgcHVibGlzaGluZyBhdWRpbyB0aGVtc2VsdmVzIGFuZFxuICAgICAgICAgKiAtIG5vIG90aGVyIGF1ZGlvIHNvdXJjZSBpcyBwbGF5aW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIGFzIGEgd29ya2Fyb3VuZCwgd2UgY3JlYXRlIGFuIGF1ZGlvIGVsZW1lbnQgd2l0aCBhbiBlbXB0eSB0cmFjaywgc28gdGhhdFxuICAgICAgICAgKiBzaWxlbnQgYXVkaW8gaXMgYWx3YXlzIHBsYXlpbmdcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGF1ZGlvSWQgPSAnbGl2ZWtpdC1kdW1teS1hdWRpby1lbCc7XG4gICAgICAgIGxldCBkdW1teUF1ZGlvRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhdWRpb0lkKTtcbiAgICAgICAgaWYgKCFkdW1teUF1ZGlvRWwpIHtcbiAgICAgICAgICBkdW1teUF1ZGlvRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICAgICAgICAgIGR1bW15QXVkaW9FbC5pZCA9IGF1ZGlvSWQ7XG4gICAgICAgICAgZHVtbXlBdWRpb0VsLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgICBkdW1teUF1ZGlvRWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICBjb25zdCB0cmFjayA9IGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjaygpO1xuICAgICAgICAgIHRyYWNrLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbShbdHJhY2tdKTtcbiAgICAgICAgICBkdW1teUF1ZGlvRWwuc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWR1bW15QXVkaW9FbCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgdGhlIHNyY09iamVjdCB0byBudWxsIG9uIHBhZ2UgaGlkZSBpbiBvcmRlciB0byBwcmV2ZW50IGxvY2sgc2NyZWVuIGNvbnRyb2xzIHRvIHNob3cgdXAgZm9yIGl0XG4gICAgICAgICAgICBkdW1teUF1ZGlvRWwuc3JjT2JqZWN0ID0gZG9jdW1lbnQuaGlkZGVuID8gbnVsbCA6IHN0cmVhbTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChkdW1teUF1ZGlvRWwpO1xuICAgICAgICAgIHRoaXMub25jZShSb29tRXZlbnQuRGlzY29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICAgICAgICBkdW1teUF1ZGlvRWwgPT09IG51bGwgfHwgZHVtbXlBdWRpb0VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkdW1teUF1ZGlvRWwucmVtb3ZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudHMucHVzaChkdW1teUF1ZGlvRWwpO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJ0aWNpcGFudHMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgcC5hdWRpb1RyYWNrcy5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgIGlmICh0LnRyYWNrKSB7XG4gICAgICAgICAgICB0LnRyYWNrLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKFt0aGlzLmFjcXVpcmVBdWRpb0NvbnRleHQoKSwgLi4uZWxlbWVudHMubWFwKGUgPT4ge1xuICAgICAgICAgIGUubXV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZS5wbGF5KCk7XG4gICAgICAgIH0pXSk7XG4gICAgICAgIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja1N0YXJ0ZWQoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tGYWlsZWQoZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc3RhcnRWaWRlbyA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5wYXJ0aWNpcGFudHMudmFsdWVzKCkpIHtcbiAgICAgICAgcC52aWRlb1RyYWNrcy5mb3JFYWNoKHRyID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgKF9hID0gdHIudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50cy5pbmNsdWRlcyhlbCkpIHtcbiAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgeWllbGQgUHJvbWlzZS5hbGwoZWxlbWVudHMubWFwKGVsID0+IGVsLnBsYXkoKSkpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkKCk7XG4gICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgaWYgKGUubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tGYWlsZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdSZXN1bWluZyB2aWRlbyBwbGF5YmFjayBmYWlsZWQsIG1ha2Ugc3VyZSB5b3UgY2FsbCBgc3RhcnRWaWRlb2AgZGlyZWN0bHkgaW4gYSB1c2VyIGdlc3R1cmUgaGFuZGxlcicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlUmVzdGFydGluZyA9ICgpID0+IHtcbiAgICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgICAvLyBhbHNvIHVud2luZCBleGlzdGluZyBwYXJ0aWNpcGFudHMgJiBleGlzdGluZyBzdWJzY3JpcHRpb25zXG4gICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5wYXJ0aWNpcGFudHMudmFsdWVzKCkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChwLnNpZCwgcCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcpKSB7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUmVjb25uZWN0aW5nKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlU2lnbmFsUmVzdGFydGVkID0gam9pblJlc3BvbnNlID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwic2lnbmFsIHJlY29ubmVjdGVkIHRvIHNlcnZlciwgcmVnaW9uIFwiLmNvbmNhdChqb2luUmVzcG9uc2Uuc2VydmVyUmVnaW9uKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIHJlZ2lvbjogam9pblJlc3BvbnNlLnNlcnZlclJlZ2lvblxuICAgICAgfSkpO1xuICAgICAgdGhpcy5jYWNoZWRQYXJ0aWNpcGFudFNpZHMgPSBbXTtcbiAgICAgIHRoaXMuYXBwbHlKb2luUmVzcG9uc2Uoam9pblJlc3BvbnNlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIHVucHVibGlzaCAmIHJlcHVibGlzaCB0cmFja3NcbiAgICAgICAgeWllbGQgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnJlcHVibGlzaEFsbFRyYWNrcyh1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2Vycm9yIHRyeWluZyB0byByZS1wdWJsaXNoIHRyYWNrcyBhZnRlciByZWNvbm5lY3Rpb24nLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlcnJvclxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS53YWl0Rm9yUmVzdGFydGVkKCk7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwiZnVsbHkgcmVjb25uZWN0ZWQgdG8gc2VydmVyXCIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIHJlZ2lvbjogam9pblJlc3BvbnNlLnNlcnZlclJlZ2lvblxuICAgICAgICB9KSk7XG4gICAgICB9IGNhdGNoIChfcCkge1xuICAgICAgICAvLyByZWNvbm5lY3Rpb24gZmFpbGVkLCBoYW5kbGVEaXNjb25uZWN0IGlzIGJlaW5nIGludm9rZWQgYWxyZWFkeSwganVzdCByZXR1cm4gaGVyZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlJlY29ubmVjdGVkKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgICAvLyBlbWl0IHBhcnRpY2lwYW50IGNvbm5lY3RlZCBldmVudHMgYWZ0ZXIgY29ubmVjdGlvbiBoYXMgYmVlbiByZS1lc3RhYmxpc2hlZFxuICAgICAgdGhpcy5wYXJ0aWNpcGFudHMuZm9yRWFjaChwYXJ0aWNpcGFudCA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRDb25uZWN0ZWQsIHBhcnRpY2lwYW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzID0gcGFydGljaXBhbnRJbmZvcyA9PiB7XG4gICAgICAvLyBoYW5kbGUgY2hhbmdlcyB0byBwYXJ0aWNpcGFudCBzdGF0ZSwgYW5kIHNlbmQgZXZlbnRzXG4gICAgICBwYXJ0aWNpcGFudEluZm9zLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICAgIGlmIChpbmZvLmlkZW50aXR5ID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpIHtcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudXBkYXRlSW5mbyhpbmZvKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5zdXJlIGlkZW50aXR5IDw9PiBzaWQgbWFwcGluZ1xuICAgICAgICBjb25zdCBzaWQgPSB0aGlzLmlkZW50aXR5VG9TaWQuZ2V0KGluZm8uaWRlbnRpdHkpO1xuICAgICAgICBpZiAoc2lkICYmIHNpZCAhPT0gaW5mby5zaWQpIHtcbiAgICAgICAgICAvLyBzaWQgaGFkIGNoYW5nZWQsIG5lZWQgdG8gcmVtb3ZlIHByZXZpb3VzIHBhcnRpY2lwYW50XG4gICAgICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChzaWQsIHRoaXMucGFydGljaXBhbnRzLmdldChzaWQpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVtb3RlUGFydGljaXBhbnQgPSB0aGlzLnBhcnRpY2lwYW50cy5nZXQoaW5mby5zaWQpO1xuICAgICAgICBjb25zdCBpc05ld1BhcnRpY2lwYW50ID0gIXJlbW90ZVBhcnRpY2lwYW50O1xuICAgICAgICAvLyB3aGVuIGl0J3MgZGlzY29ubmVjdGVkLCBzZW5kIHVwZGF0ZXNcbiAgICAgICAgaWYgKGluZm8uc3RhdGUgPT09IFBhcnRpY2lwYW50SW5mb19TdGF0ZS5ESVNDT05ORUNURUQpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKGluZm8uc2lkLCByZW1vdGVQYXJ0aWNpcGFudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3JlYXRlIHBhcnRpY2lwYW50IGlmIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICByZW1vdGVQYXJ0aWNpcGFudCA9IHRoaXMuZ2V0T3JDcmVhdGVQYXJ0aWNpcGFudChpbmZvLnNpZCwgaW5mbyk7XG4gICAgICAgICAgaWYgKCFpc05ld1BhcnRpY2lwYW50KSB7XG4gICAgICAgICAgICAvLyBqdXN0IHVwZGF0ZSwgbm8gZXZlbnRzXG4gICAgICAgICAgICByZW1vdGVQYXJ0aWNpcGFudC51cGRhdGVJbmZvKGluZm8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB1cGRhdGVzIGFyZSBzZW50IG9ubHkgd2hlbiB0aGVyZSdzIGEgY2hhbmdlIHRvIHNwZWFrZXIgb3JkZXJpbmdcbiAgICB0aGlzLmhhbmRsZUFjdGl2ZVNwZWFrZXJzVXBkYXRlID0gc3BlYWtlcnMgPT4ge1xuICAgICAgY29uc3QgYWN0aXZlU3BlYWtlcnMgPSBbXTtcbiAgICAgIGNvbnN0IHNlZW5TaWRzID0ge307XG4gICAgICBzcGVha2Vycy5mb3JFYWNoKHNwZWFrZXIgPT4ge1xuICAgICAgICBzZWVuU2lkc1tzcGVha2VyLnNpZF0gPSB0cnVlO1xuICAgICAgICBpZiAoc3BlYWtlci5zaWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9MZXZlbCA9IHNwZWFrZXIubGV2ZWw7XG4gICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldElzU3BlYWtpbmcodHJ1ZSk7XG4gICAgICAgICAgYWN0aXZlU3BlYWtlcnMucHVzaCh0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLnBhcnRpY2lwYW50cy5nZXQoc3BlYWtlci5zaWQpO1xuICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBwLmF1ZGlvTGV2ZWwgPSBzcGVha2VyLmxldmVsO1xuICAgICAgICAgICAgcC5zZXRJc1NwZWFraW5nKHRydWUpO1xuICAgICAgICAgICAgYWN0aXZlU3BlYWtlcnMucHVzaChwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFzZWVuU2lkc1t0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkXSkge1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9MZXZlbCA9IDA7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRJc1NwZWFraW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFydGljaXBhbnRzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIGlmICghc2VlblNpZHNbcC5zaWRdKSB7XG4gICAgICAgICAgcC5hdWRpb0xldmVsID0gMDtcbiAgICAgICAgICBwLnNldElzU3BlYWtpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBhY3RpdmVTcGVha2VycztcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCwgYWN0aXZlU3BlYWtlcnMpO1xuICAgIH07XG4gICAgLy8gcHJvY2VzcyBsaXN0IG9mIGNoYW5nZWQgc3BlYWtlcnNcbiAgICB0aGlzLmhhbmRsZVNwZWFrZXJzQ2hhbmdlZCA9IHNwZWFrZXJVcGRhdGVzID0+IHtcbiAgICAgIGNvbnN0IGxhc3RTcGVha2VycyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgbGFzdFNwZWFrZXJzLnNldChwLnNpZCwgcCk7XG4gICAgICB9KTtcbiAgICAgIHNwZWFrZXJVcGRhdGVzLmZvckVhY2goc3BlYWtlciA9PiB7XG4gICAgICAgIGxldCBwID0gdGhpcy5wYXJ0aWNpcGFudHMuZ2V0KHNwZWFrZXIuc2lkKTtcbiAgICAgICAgaWYgKHNwZWFrZXIuc2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XG4gICAgICAgICAgcCA9IHRoaXMubG9jYWxQYXJ0aWNpcGFudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcC5hdWRpb0xldmVsID0gc3BlYWtlci5sZXZlbDtcbiAgICAgICAgcC5zZXRJc1NwZWFraW5nKHNwZWFrZXIuYWN0aXZlKTtcbiAgICAgICAgaWYgKHNwZWFrZXIuYWN0aXZlKSB7XG4gICAgICAgICAgbGFzdFNwZWFrZXJzLnNldChzcGVha2VyLnNpZCwgcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdFNwZWFrZXJzLmRlbGV0ZShzcGVha2VyLnNpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgYWN0aXZlU3BlYWtlcnMgPSBBcnJheS5mcm9tKGxhc3RTcGVha2Vycy52YWx1ZXMoKSk7XG4gICAgICBhY3RpdmVTcGVha2Vycy5zb3J0KChhLCBiKSA9PiBiLmF1ZGlvTGV2ZWwgLSBhLmF1ZGlvTGV2ZWwpO1xuICAgICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IGFjdGl2ZVNwZWFrZXJzO1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuQWN0aXZlU3BlYWtlcnNDaGFuZ2VkLCBhY3RpdmVTcGVha2Vycyk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVN0cmVhbVN0YXRlVXBkYXRlID0gc3RyZWFtU3RhdGVVcGRhdGUgPT4ge1xuICAgICAgc3RyZWFtU3RhdGVVcGRhdGUuc3RyZWFtU3RhdGVzLmZvckVhY2goc3RyZWFtU3RhdGUgPT4ge1xuICAgICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmdldChzdHJlYW1TdGF0ZS5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHViID0gcGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbihzdHJlYW1TdGF0ZS50cmFja1NpZCk7XG4gICAgICAgIGlmICghcHViIHx8ICFwdWIudHJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHViLnRyYWNrLnN0cmVhbVN0YXRlID0gVHJhY2suc3RyZWFtU3RhdGVGcm9tUHJvdG8oc3RyZWFtU3RhdGUuc3RhdGUpO1xuICAgICAgICBwYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQsIHB1YiwgcHViLnRyYWNrLnN0cmVhbVN0YXRlKTtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQsIHB1YiwgcHViLnRyYWNrLnN0cmVhbVN0YXRlLCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSA9IHVwZGF0ZSA9PiB7XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmdldCh1cGRhdGUucGFydGljaXBhbnRTaWQpO1xuICAgICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwdWIgPSBwYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9uKHVwZGF0ZS50cmFja1NpZCk7XG4gICAgICBpZiAoIXB1Yikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwdWIuc2V0QWxsb3dlZCh1cGRhdGUuYWxsb3dlZCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbkVycm9yID0gdXBkYXRlID0+IHtcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gQXJyYXkuZnJvbSh0aGlzLnBhcnRpY2lwYW50cy52YWx1ZXMoKSkuZmluZChwID0+IHAudHJhY2tzLmhhcyh1cGRhdGUudHJhY2tTaWQpKTtcbiAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcHViID0gcGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbih1cGRhdGUudHJhY2tTaWQpO1xuICAgICAgaWYgKCFwdWIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcHViLnNldFN1YnNjcmlwdGlvbkVycm9yKHVwZGF0ZS5lcnIpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVEYXRhUGFja2V0ID0gKHVzZXJQYWNrZXQsIGtpbmQpID0+IHtcbiAgICAgIC8vIGZpbmQgdGhlIHBhcnRpY2lwYW50XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmdldCh1c2VyUGFja2V0LnBhcnRpY2lwYW50U2lkKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuRGF0YVJlY2VpdmVkLCB1c2VyUGFja2V0LnBheWxvYWQsIHBhcnRpY2lwYW50LCBraW5kLCB1c2VyUGFja2V0LnRvcGljKTtcbiAgICAgIC8vIGFsc28gZW1pdCBvbiB0aGUgcGFydGljaXBhbnRcbiAgICAgIHBhcnRpY2lwYW50ID09PSBudWxsIHx8IHBhcnRpY2lwYW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuRGF0YVJlY2VpdmVkLCB1c2VyUGFja2V0LnBheWxvYWQsIGtpbmQpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrU3RhcnRlZCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNhblBsYXliYWNrQXVkaW8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hdWRpb0VuYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgdHJ1ZSk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tGYWlsZWQgPSBlID0+IHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBwbGF5YmFjayBhdWRpbycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBlcnJvcjogZVxuICAgICAgfSkpO1xuICAgICAgaWYgKCF0aGlzLmNhblBsYXliYWNrQXVkaW8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hdWRpb0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIGZhbHNlKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlVmlkZW9QbGF5YmFja1N0YXJ0ZWQgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkKSB7XG4gICAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlVmlkZW9QbGF5YmFja0ZhaWxlZCA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkKSB7XG4gICAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrQmxvY2tlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlRGV2aWNlQ2hhbmdlID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5NZWRpYURldmljZXNDaGFuZ2VkKTtcbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZVJvb21VcGRhdGUgPSByb29tID0+IHtcbiAgICAgIGNvbnN0IG9sZFJvb20gPSB0aGlzLnJvb21JbmZvO1xuICAgICAgdGhpcy5yb29tSW5mbyA9IHJvb207XG4gICAgICBpZiAob2xkUm9vbSAmJiBvbGRSb29tLm1ldGFkYXRhICE9PSByb29tLm1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlJvb21NZXRhZGF0YUNoYW5nZWQsIHJvb20ubWV0YWRhdGEpO1xuICAgICAgfVxuICAgICAgaWYgKChvbGRSb29tID09PSBudWxsIHx8IG9sZFJvb20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZFJvb20uYWN0aXZlUmVjb3JkaW5nKSAhPT0gcm9vbS5hY3RpdmVSZWNvcmRpbmcpIHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUmVjb3JkaW5nU3RhdHVzQ2hhbmdlZCwgcm9vbS5hY3RpdmVSZWNvcmRpbmcpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSA9IHVwZGF0ZSA9PiB7XG4gICAgICB1cGRhdGUudXBkYXRlcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICBpZiAoaW5mby5wYXJ0aWNpcGFudFNpZCA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCkge1xuICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRDb25uZWN0aW9uUXVhbGl0eShpbmZvLnF1YWxpdHkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmdldChpbmZvLnBhcnRpY2lwYW50U2lkKTtcbiAgICAgICAgaWYgKHBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgcGFydGljaXBhbnQuc2V0Q29ubmVjdGlvblF1YWxpdHkoaW5mby5xdWFsaXR5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCA9IG1ldGFkYXRhID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIG1ldGFkYXRhLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbkxvY2FsUGFydGljaXBhbnROYW1lQ2hhbmdlZCA9IG5hbWUgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCBuYW1lLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbkxvY2FsVHJhY2tNdXRlZCA9IHB1YiA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrTXV0ZWQsIHB1YiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbFRyYWNrVW5tdXRlZCA9IHB1YiA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrVW5tdXRlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQgPSBwdWIgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9xO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBwdWIsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgICBpZiAocHViLnRyYWNrIGluc3RhbmNlb2YgTG9jYWxBdWRpb1RyYWNrKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrSXNTaWxlbnQgPSB5aWVsZCBwdWIudHJhY2suY2hlY2tGb3JTaWxlbmNlKCk7XG4gICAgICAgIGlmICh0cmFja0lzU2lsZW50KSB7XG4gICAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5Mb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkLCBwdWIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBkZXZpY2VJZCA9IHlpZWxkIChfcSA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX3EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9xLmdldERldmljZUlkKCk7XG4gICAgICBjb25zdCBkZXZpY2VLaW5kID0gc291cmNlVG9LaW5kKHB1Yi5zb3VyY2UpO1xuICAgICAgaWYgKGRldmljZUtpbmQgJiYgZGV2aWNlSWQgJiYgZGV2aWNlSWQgIT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuZ2V0KGRldmljZUtpbmQpKSB7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KGRldmljZUtpbmQsIGRldmljZUlkKTtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBkZXZpY2VLaW5kLCBkZXZpY2VJZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9IHB1YiA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbkxvY2FsQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkID0gcXVhbGl0eSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgcXVhbGl0eSwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMub25NZWRpYURldmljZXNFcnJvciA9IGUgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5NZWRpYURldmljZXNFcnJvciwgZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCA9IHByZXZQZXJtaXNzaW9ucyA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xuICAgIHRoaXMucGFydGljaXBhbnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY2FjaGVkUGFydGljaXBhbnRTaWRzID0gW107XG4gICAgdGhpcy5pZGVudGl0eVRvU2lkID0gbmV3IE1hcCgpO1xuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcm9vbU9wdGlvbkRlZmF1bHRzKSwgb3B0aW9ucyk7XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlJvb20pO1xuICAgIHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXVkaW9EZWZhdWx0cyksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cyk7XG4gICAgdGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2aWRlb0RlZmF1bHRzKSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzKTtcbiAgICB0aGlzLm9wdGlvbnMucHVibGlzaERlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwdWJsaXNoRGVmYXVsdHMpLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHVibGlzaERlZmF1bHRzKTtcbiAgICB0aGlzLm1heWJlQ3JlYXRlRW5naW5lKCk7XG4gICAgdGhpcy5kaXNjb25uZWN0TG9jayA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudCA9IG5ldyBMb2NhbFBhcnRpY2lwYW50KCcnLCAnJywgdGhpcy5lbmdpbmUsIHRoaXMub3B0aW9ucyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCkge1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoJ3ZpZGVvaW5wdXQnLCB1bndyYXBDb25zdHJhaW50KHRoaXMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkKSB7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLnNldCgnYXVkaW9pbnB1dCcsIHVud3JhcENvbnN0cmFpbnQodGhpcy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkKSk7XG4gICAgfVxuICAgIGlmICgoX2IgPSB0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZXZpY2VJZCkge1xuICAgICAgdGhpcy5zd2l0Y2hBY3RpdmVEZXZpY2UoJ2F1ZGlvb3V0cHV0JywgdW53cmFwQ29uc3RyYWludCh0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQuZGV2aWNlSWQpKS5jYXRjaChlID0+IHRoaXMubG9nLndhcm4oXCJDb3VsZCBub3Qgc2V0IGF1ZGlvIG91dHB1dDogXCIuY29uY2F0KGUubWVzc2FnZSksIHRoaXMubG9nQ29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmUyZWUpIHtcbiAgICAgIHRoaXMuc2V0dXBFMkVFKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBzZXRFMkVFRW5hYmxlZChlbmFibGVkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLmUyZWVNYW5hZ2VyKSB7XG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKFt0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0RTJFRUVuYWJsZWQoZW5hYmxlZCldKTtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSAhPT0gJycpIHtcbiAgICAgICAgICB0aGlzLmUyZWVNYW5hZ2VyLnNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQoZW5hYmxlZCwgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2UyZWUgbm90IGNvbmZpZ3VyZWQsIHBsZWFzZSBzZXQgZTJlZSBzZXR0aW5ncyB3aXRoaW4gdGhlIHJvb20gb3B0aW9ucycpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldHVwRTJFRSgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lMmVlKSB7XG4gICAgICB0aGlzLmUyZWVNYW5hZ2VyID0gbmV3IEUyRUVNYW5hZ2VyKHRoaXMub3B0aW9ucy5lMmVlKTtcbiAgICAgIHRoaXMuZTJlZU1hbmFnZXIub24oRW5jcnlwdGlvbkV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsIChlbmFibGVkLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICBpZiAocGFydGljaXBhbnQgaW5zdGFuY2VvZiBMb2NhbFBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgdGhpcy5pc0UyRUVFbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsIGVuYWJsZWQsIHBhcnRpY2lwYW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lMmVlTWFuYWdlci5vbihFbmNyeXB0aW9uRXZlbnQuRW5jcnlwdGlvbkVycm9yLCBlcnJvciA9PiB0aGlzLmVtaXQoUm9vbUV2ZW50LkVuY3J5cHRpb25FcnJvciwgZXJyb3IpKTtcbiAgICAgIChfYSA9IHRoaXMuZTJlZU1hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXR1cCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb206IHRoaXMubmFtZSxcbiAgICAgIHJvb21TaWQ6IHRoaXMuc2lkLFxuICAgICAgaWRlbnRpdHk6IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIGlmIHRoZSBjdXJyZW50IHJvb20gaGFzIGEgcGFydGljaXBhbnQgd2l0aCBgcmVjb3JkZXI6IHRydWVgIGluIGl0cyBKV1QgZ3JhbnRcbiAgICoqL1xuICBnZXQgaXNSZWNvcmRpbmcoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5yb29tSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGl2ZVJlY29yZGluZykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gIH1cbiAgLyoqIHNlcnZlciBhc3NpZ25lZCB1bmlxdWUgcm9vbSBpZCAqL1xuICBnZXQgc2lkKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICB9XG4gIC8qKiB1c2VyIGFzc2lnbmVkIG5hbWUsIGRlcml2ZWQgZnJvbSBKV1QgdG9rZW4gKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5yb29tSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICB9XG4gIC8qKiByb29tIG1ldGFkYXRhICovXG4gIGdldCBtZXRhZGF0YSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXRhZGF0YTtcbiAgfVxuICBnZXQgbnVtUGFydGljaXBhbnRzKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5udW1QYXJ0aWNpcGFudHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG4gIH1cbiAgZ2V0IG51bVB1Ymxpc2hlcnMoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5yb29tSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm51bVB1Ymxpc2hlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG4gIH1cbiAgbWF5YmVDcmVhdGVFbmdpbmUoKSB7XG4gICAgaWYgKHRoaXMuZW5naW5lICYmICF0aGlzLmVuZ2luZS5pc0Nsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVuZ2luZSA9IG5ldyBSVENFbmdpbmUodGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLmVuZ2luZS5vbihFbmdpbmVFdmVudC5QYXJ0aWNpcGFudFVwZGF0ZSwgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudFVwZGF0ZXMpLm9uKEVuZ2luZUV2ZW50LlJvb21VcGRhdGUsIHRoaXMuaGFuZGxlUm9vbVVwZGF0ZSkub24oRW5naW5lRXZlbnQuU3BlYWtlcnNDaGFuZ2VkLCB0aGlzLmhhbmRsZVNwZWFrZXJzQ2hhbmdlZCkub24oRW5naW5lRXZlbnQuU3RyZWFtU3RhdGVDaGFuZ2VkLCB0aGlzLmhhbmRsZVN0cmVhbVN0YXRlVXBkYXRlKS5vbihFbmdpbmVFdmVudC5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZSwgdGhpcy5oYW5kbGVDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSkub24oRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uRXJyb3IsIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uRXJyb3IpLm9uKEVuZ2luZUV2ZW50LlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUsIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSkub24oRW5naW5lRXZlbnQuTWVkaWFUcmFja0FkZGVkLCAobWVkaWFUcmFjaywgc3RyZWFtLCByZWNlaXZlcikgPT4ge1xuICAgICAgdGhpcy5vblRyYWNrQWRkZWQobWVkaWFUcmFjaywgc3RyZWFtLCByZWNlaXZlcik7XG4gICAgfSkub24oRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoLCByZWFzb24pO1xuICAgIH0pLm9uKEVuZ2luZUV2ZW50LkFjdGl2ZVNwZWFrZXJzVXBkYXRlLCB0aGlzLmhhbmRsZUFjdGl2ZVNwZWFrZXJzVXBkYXRlKS5vbihFbmdpbmVFdmVudC5EYXRhUGFja2V0UmVjZWl2ZWQsIHRoaXMuaGFuZGxlRGF0YVBhY2tldCkub24oRW5naW5lRXZlbnQuUmVzdW1pbmcsICgpID0+IHtcbiAgICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgICBpZiAodGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcpKSB7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUmVjb25uZWN0aW5nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGVkUGFydGljaXBhbnRTaWRzID0gQXJyYXkuZnJvbSh0aGlzLnBhcnRpY2lwYW50cy5rZXlzKCkpO1xuICAgIH0pLm9uKEVuZ2luZUV2ZW50LlJlc3VtZWQsICgpID0+IHtcbiAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUmVjb25uZWN0ZWQpO1xuICAgICAgdGhpcy5yZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICAgIHRoaXMudXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgLy8gb25jZSByZWNvbm5lY3RlZCwgZmlndXJlIG91dCBpZiBhbnkgcGFydGljaXBhbnRzIGNvbm5lY3RlZCBkdXJpbmcgcmVjb25uZWN0IGFuZCBlbWl0IGV2ZW50cyBmb3IgaXRcbiAgICAgIGNvbnN0IGRpZmZQYXJ0aWNpcGFudHMgPSBBcnJheS5mcm9tKHRoaXMucGFydGljaXBhbnRzLnZhbHVlcygpKS5maWx0ZXIocCA9PiAhdGhpcy5jYWNoZWRQYXJ0aWNpcGFudFNpZHMuaW5jbHVkZXMocC5zaWQpKTtcbiAgICAgIGRpZmZQYXJ0aWNpcGFudHMuZm9yRWFjaChwID0+IHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRDb25uZWN0ZWQsIHApKTtcbiAgICAgIHRoaXMuY2FjaGVkUGFydGljaXBhbnRTaWRzID0gW107XG4gICAgfSkub24oRW5naW5lRXZlbnQuU2lnbmFsUmVzdW1lZCwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgdGhpcy5zZW5kU3luY1N0YXRlKCk7XG4gICAgICB9XG4gICAgfSkub24oRW5naW5lRXZlbnQuUmVzdGFydGluZywgdGhpcy5oYW5kbGVSZXN0YXJ0aW5nKS5vbihFbmdpbmVFdmVudC5TaWduYWxSZXN0YXJ0ZWQsIHRoaXMuaGFuZGxlU2lnbmFsUmVzdGFydGVkKS5vbihFbmdpbmVFdmVudC5EQ0J1ZmZlclN0YXR1c0NoYW5nZWQsIChzdGF0dXMsIGtpbmQpID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuRENCdWZmZXJTdGF0dXNDaGFuZ2VkLCBzdGF0dXMsIGtpbmQpO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmxvY2FsUGFydGljaXBhbnQpIHtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXR1cEVuZ2luZSh0aGlzLmVuZ2luZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmUyZWVNYW5hZ2VyKSB7XG4gICAgICB0aGlzLmUyZWVNYW5hZ2VyLnNldHVwRW5naW5lKHRoaXMuZW5naW5lKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIGdldExvY2FsRGV2aWNlcyBhYnN0cmFjdHMgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzLlxuICAgKiBJbiBwYXJ0aWN1bGFyLCBpdCBoYW5kbGVzIENocm9tZSdzIHVuaXF1ZSBiZWhhdmlvciBvZiBjcmVhdGluZyBgZGVmYXVsdGBcbiAgICogZGV2aWNlcy4gV2hlbiBlbmNvdW50ZXJlZCwgaXQnbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBsaXN0IG9mIGRldmljZXMuXG4gICAqIFRoZSBhY3R1YWwgZGVmYXVsdCBkZXZpY2Ugd2lsbCBiZSBwbGFjZWQgYXQgdG9wLlxuICAgKiBAcGFyYW0ga2luZFxuICAgKiBAcmV0dXJucyBhIGxpc3Qgb2YgYXZhaWxhYmxlIGxvY2FsIGRldmljZXNcbiAgICovXG4gIHN0YXRpYyBnZXRMb2NhbERldmljZXMoa2luZCkge1xuICAgIGxldCByZXF1ZXN0UGVybWlzc2lvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgcmV0dXJuIERldmljZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXREZXZpY2VzKGtpbmQsIHJlcXVlc3RQZXJtaXNzaW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIHByZXBhcmVDb25uZWN0aW9uIHNob3VsZCBiZSBjYWxsZWQgYXMgc29vbiBhcyB0aGUgcGFnZSBpcyBsb2FkZWQsIGluIG9yZGVyXG4gICAqIHRvIHNwZWVkIHVwIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQuIFRoaXMgZnVuY3Rpb24gd2lsbFxuICAgKiAtIHBlcmZvcm0gRE5TIHJlc29sdXRpb24gYW5kIHByZS13YXJtIHRoZSBETlMgY2FjaGVcbiAgICogLSBlc3RhYmxpc2ggVExTIGNvbm5lY3Rpb24gYW5kIGNhY2hlIFRMUyBrZXlzXG4gICAqXG4gICAqIFdpdGggTGl2ZUtpdCBDbG91ZCwgaXQgd2lsbCBhbHNvIGRldGVybWluZSB0aGUgYmVzdCBlZGdlIGRhdGEgY2VudGVyIGZvclxuICAgKiB0aGUgY3VycmVudCBjbGllbnQgdG8gY29ubmVjdCB0byBpZiBhIHRva2VuIGlzIHByb3ZpZGVkLlxuICAgKi9cbiAgcHJlcGFyZUNvbm5lY3Rpb24odXJsLCB0b2tlbikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInByZXBhcmVDb25uZWN0aW9uIHRvIFwiLmNvbmNhdCh1cmwpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGlzQ2xvdWQobmV3IFVSTCh1cmwpKSAmJiB0b2tlbikge1xuICAgICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPSBuZXcgUmVnaW9uVXJsUHJvdmlkZXIodXJsLCB0b2tlbik7XG4gICAgICAgICAgY29uc3QgcmVnaW9uVXJsID0geWllbGQgdGhpcy5yZWdpb25VcmxQcm92aWRlci5nZXROZXh0QmVzdFJlZ2lvblVybCgpO1xuICAgICAgICAgIC8vIHdlIHdpbGwgbm90IHJlcGxhY2UgdGhlIHJlZ2lvblVybCBpZiBhbiBhdHRlbXB0IGhhZCBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgICAgICAvLyB0byBhdm9pZCBvdmVycmlkaW5nIHJlZ2lvblVybCBhZnRlciBhIG5ldyBjb25uZWN0aW9uIGF0dGVtcHQgaGFkIHN0YXJ0ZWRcbiAgICAgICAgICBpZiAocmVnaW9uVXJsICYmIHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaW9uVXJsID0gcmVnaW9uVXJsO1xuICAgICAgICAgICAgeWllbGQgZmV0Y2godG9IdHRwVXJsKHJlZ2lvblVybCksIHtcbiAgICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJwcmVwYXJlZCBjb25uZWN0aW9uIHRvIFwiLmNvbmNhdChyZWdpb25VcmwpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCBmZXRjaCh0b0h0dHBVcmwodXJsKSwge1xuICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgcHJlcGFyZSBjb25uZWN0aW9uJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiByZXRyaWV2ZXMgYSBwYXJ0aWNpcGFudCBieSBpZGVudGl0eVxuICAgKiBAcGFyYW0gaWRlbnRpdHlcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFBhcnRpY2lwYW50QnlJZGVudGl0eShpZGVudGl0eSkge1xuICAgIGlmICh0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkgPT09IGlkZW50aXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2NhbFBhcnRpY2lwYW50O1xuICAgIH1cbiAgICBjb25zdCBzaWQgPSB0aGlzLmlkZW50aXR5VG9TaWQuZ2V0KGlkZW50aXR5KTtcbiAgICBpZiAoc2lkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJ0aWNpcGFudHMuZ2V0KHNpZCk7XG4gICAgfVxuICB9XG4gIGNsZWFyQ29ubmVjdGlvbkZ1dHVyZXMoKSB7XG4gICAgdGhpcy5jb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgZm9yIHRlc3RpbmdcbiAgICovXG4gIHNpbXVsYXRlU2NlbmFyaW8oc2NlbmFyaW8sIGFyZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsZXQgcG9zdEFjdGlvbiA9ICgpID0+IHt9O1xuICAgICAgbGV0IHJlcTtcbiAgICAgIHN3aXRjaCAoc2NlbmFyaW8pIHtcbiAgICAgICAgY2FzZSAnc2lnbmFsLXJlY29ubmVjdCc6XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBwcml2YXRlXG4gICAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LmhhbmRsZU9uQ2xvc2UoJ3NpbXVsYXRlIGRpc2Nvbm5lY3QnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3BlYWtlcic6XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ3NwZWFrZXJVcGRhdGUnLFxuICAgICAgICAgICAgICB2YWx1ZTogM1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdub2RlLWZhaWx1cmUnOlxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdub2RlRmFpbHVyZScsXG4gICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlcnZlci1sZWF2ZSc6XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ3NlcnZlckxlYXZlJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWlncmF0aW9uJzpcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgICBjYXNlOiAnbWlncmF0aW9uJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmVzdW1lLXJlY29ubmVjdCc6XG4gICAgICAgICAgdGhpcy5lbmdpbmUuZmFpbE5leHQoKTtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIHByaXZhdGVcbiAgICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgcmVzdW1lLWRpc2Nvbm5lY3QnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGlzY29ubmVjdC1zaWduYWwtb24tcmVzdW1lJzpcbiAgICAgICAgICBwb3N0QWN0aW9uID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBwcml2YXRlXG4gICAgICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgcmVzdW1lLWRpc2Nvbm5lY3QnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgICBjYXNlOiAnZGlzY29ubmVjdFNpZ25hbE9uUmVzdW1lJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGlzY29ubmVjdC1zaWduYWwtb24tcmVzdW1lLW5vLW1lc3NhZ2VzJzpcbiAgICAgICAgICBwb3N0QWN0aW9uID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBwcml2YXRlXG4gICAgICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgcmVzdW1lLWRpc2Nvbm5lY3QnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgICBjYXNlOiAnZGlzY29ubmVjdFNpZ25hbE9uUmVzdW1lTm9NZXNzYWdlcycsXG4gICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Z1bGwtcmVjb25uZWN0JzpcbiAgICAgICAgICB0aGlzLmVuZ2luZS5mdWxsUmVjb25uZWN0T25OZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIHByaXZhdGVcbiAgICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgZnVsbC1yZWNvbm5lY3QnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZm9yY2UtdGNwJzpcbiAgICAgICAgY2FzZSAnZm9yY2UtdGxzJzpcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgICBjYXNlOiAnc3dpdGNoQ2FuZGlkYXRlUHJvdG9jb2wnLFxuICAgICAgICAgICAgICB2YWx1ZTogc2NlbmFyaW8gPT09ICdmb3JjZS10bHMnID8gMiA6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3N0QWN0aW9uID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb25MZWF2ZSA9IHRoaXMuZW5naW5lLmNsaWVudC5vbkxlYXZlO1xuICAgICAgICAgICAgaWYgKG9uTGVhdmUpIHtcbiAgICAgICAgICAgICAgb25MZWF2ZShuZXcgTGVhdmVSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICByZWFzb246IERpc2Nvbm5lY3RSZWFzb24uQ0xJRU5UX0lOSVRJQVRFRCxcbiAgICAgICAgICAgICAgICBjYW5SZWNvbm5lY3Q6IHRydWVcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdWJzY3JpYmVyLWJhbmR3aWR0aCc6XG4gICAgICAgICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBhcmcgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1YnNjcmliZXItYmFuZHdpZHRoIHJlcXVpcmVzIGEgbnVtYmVyIGFzIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdzdWJzY3JpYmVyQmFuZHdpZHRoJyxcbiAgICAgICAgICAgICAgdmFsdWU6IEJpZ0ludChhcmcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAocmVxKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5zZW5kU2ltdWxhdGVTY2VuYXJpbyhyZXEpO1xuICAgICAgICB5aWVsZCBwb3N0QWN0aW9uKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhdWRpbyBwbGF5YmFjayBpcyBlbmFibGVkXG4gICAqL1xuICBnZXQgY2FuUGxheWJhY2tBdWRpbygpIHtcbiAgICByZXR1cm4gdGhpcy5hdWRpb0VuYWJsZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB2aWRlbyBwbGF5YmFjayBpcyBlbmFibGVkXG4gICAqL1xuICBnZXQgY2FuUGxheWJhY2tWaWRlbygpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNWaWRlb1BsYXliYWNrQmxvY2tlZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWN0aXZlIGF1ZGlvIG91dHB1dCBkZXZpY2UgdXNlZCBpbiB0aGlzIHJvb20uXG4gICAqIEByZXR1cm4gdGhlIHByZXZpb3VzbHkgc3VjY2Vzc2Z1bGx5IHNldCBhdWRpbyBvdXRwdXQgZGV2aWNlIElEIG9yIGFuIGVtcHR5IHN0cmluZyBpZiB0aGUgZGVmYXVsdCBkZXZpY2UgaXMgdXNlZC5cbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBnZXRBY3RpdmVEZXZpY2UoJ2F1ZGlvb3V0cHV0JylgIGluc3RlYWRcbiAgICovXG4gIGdldEFjdGl2ZUF1ZGlvT3V0cHV0RGV2aWNlKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5hdWRpb091dHB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRldmljZUlkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbiAgfVxuICBnZXRBY3RpdmVEZXZpY2Uoa2luZCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLmdldChraW5kKTtcbiAgfVxuICAvKipcbiAgICogU3dpdGNoZXMgYWxsIGFjdGl2ZSBkZXZpY2VzIHVzZWQgaW4gdGhpcyByb29tIHRvIHRoZSBnaXZlbiBkZXZpY2UuXG4gICAqXG4gICAqIE5vdGU6IHNldHRpbmcgQXVkaW9PdXRwdXQgaXMgbm90IHN1cHBvcnRlZCBvbiBzb21lIGJyb3dzZXJzLiBTZWUgW3NldFNpbmtJZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvc2V0U2lua0lkI2Jyb3dzZXJfY29tcGF0aWJpbGl0eSlcbiAgICpcbiAgICogQHBhcmFtIGtpbmQgdXNlIGB2aWRlb2lucHV0YCBmb3IgY2FtZXJhIHRyYWNrLFxuICAgKiAgYGF1ZGlvaW5wdXRgIGZvciBtaWNyb3Bob25lIHRyYWNrLFxuICAgKiAgYGF1ZGlvb3V0cHV0YCB0byBzZXQgc3BlYWtlciBmb3IgYWxsIGluY29taW5nIGF1ZGlvIHRyYWNrc1xuICAgKiBAcGFyYW0gZGV2aWNlSWRcbiAgICovXG4gIHN3aXRjaEFjdGl2ZURldmljZShraW5kLCBkZXZpY2VJZCkge1xuICAgIGxldCBleGFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgX2M7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGxldCBkZXZpY2VIYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICBsZXQgc3VjY2VzcyA9IHRydWU7XG4gICAgICBjb25zdCBkZXZpY2VDb25zdHJhaW50ID0gZXhhY3QgPyB7XG4gICAgICAgIGV4YWN0OiBkZXZpY2VJZFxuICAgICAgfSA6IGRldmljZUlkO1xuICAgICAgaWYgKGtpbmQgPT09ICdhdWRpb2lucHV0Jykge1xuICAgICAgICBjb25zdCBwcmV2RGV2aWNlSWQgPSB0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQ7XG4gICAgICAgIHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCA9IGRldmljZUNvbnN0cmFpbnQ7XG4gICAgICAgIGRldmljZUhhc0NoYW5nZWQgPSBwcmV2RGV2aWNlSWQgIT09IGRldmljZUNvbnN0cmFpbnQ7XG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IEFycmF5LmZyb20odGhpcy5sb2NhbFBhcnRpY2lwYW50LmF1ZGlvVHJhY2tzLnZhbHVlcygpKS5maWx0ZXIodHJhY2sgPT4gdHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3VjY2VzcyA9ICh5aWVsZCBQcm9taXNlLmFsbCh0cmFja3MubWFwKHQgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHQuYXVkaW9UcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldERldmljZUlkKGRldmljZUNvbnN0cmFpbnQpO1xuICAgICAgICAgIH0pKSkuZXZlcnkodmFsID0+IHZhbCA9PT0gdHJ1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQgPSBwcmV2RGV2aWNlSWQ7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChraW5kID09PSAndmlkZW9pbnB1dCcpIHtcbiAgICAgICAgY29uc3QgcHJldkRldmljZUlkID0gdGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkO1xuICAgICAgICB0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQgPSBkZXZpY2VDb25zdHJhaW50O1xuICAgICAgICBkZXZpY2VIYXNDaGFuZ2VkID0gcHJldkRldmljZUlkICE9PSBkZXZpY2VDb25zdHJhaW50O1xuICAgICAgICBjb25zdCB0cmFja3MgPSBBcnJheS5mcm9tKHRoaXMubG9jYWxQYXJ0aWNpcGFudC52aWRlb1RyYWNrcy52YWx1ZXMoKSkuZmlsdGVyKHRyYWNrID0+IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3VjY2VzcyA9ICh5aWVsZCBQcm9taXNlLmFsbCh0cmFja3MubWFwKHQgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHQudmlkZW9UcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldERldmljZUlkKGRldmljZUNvbnN0cmFpbnQpO1xuICAgICAgICAgIH0pKSkuZXZlcnkodmFsID0+IHZhbCA9PT0gdHJ1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQgPSBwcmV2RGV2aWNlSWQ7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChraW5kID09PSAnYXVkaW9vdXRwdXQnKSB7XG4gICAgICAgIGlmICghc3VwcG9ydHNTZXRTaW5rSWQoKSAmJiAhdGhpcy5vcHRpb25zLmV4cFdlYkF1ZGlvTWl4IHx8IHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peCAmJiB0aGlzLmF1ZGlvQ29udGV4dCAmJiAhKCdzZXRTaW5rSWQnIGluIHRoaXMuYXVkaW9Db250ZXh0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHN3aXRjaCBhdWRpbyBvdXRwdXQsIHNldFNpbmtJZCBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gKF9jID0gdGhpcy5vcHRpb25zKS5hdWRpb091dHB1dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogX2MuYXVkaW9PdXRwdXQgPSB7fTtcbiAgICAgICAgY29uc3QgcHJldkRldmljZUlkID0gdGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0LmRldmljZUlkO1xuICAgICAgICB0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQuZGV2aWNlSWQgPSBkZXZpY2VJZDtcbiAgICAgICAgZGV2aWNlSGFzQ2hhbmdlZCA9IHByZXZEZXZpY2VJZCAhPT0gZGV2aWNlQ29uc3RyYWludDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4cFdlYkF1ZGlvTWl4KSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHNldFNpbmtJZCBpcyBub3QgeWV0IGluIHRoZSB0eXBlc2NyaXB0IHR5cGUgb2YgQXVkaW9Db250ZXh0XG4gICAgICAgICAgICAoX2IgPSB0aGlzLmF1ZGlvQ29udGV4dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNldFNpbmtJZChkZXZpY2VJZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKEFycmF5LmZyb20odGhpcy5wYXJ0aWNpcGFudHMudmFsdWVzKCkpLm1hcChwID0+IHAuc2V0QXVkaW9PdXRwdXQoe1xuICAgICAgICAgICAgICBkZXZpY2VJZFxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQuZGV2aWNlSWQgPSBwcmV2RGV2aWNlSWQ7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRldmljZUhhc0NoYW5nZWQgJiYgc3VjY2Vzcykge1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLnNldChraW5kLCBkZXZpY2VJZCk7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQWN0aXZlRGV2aWNlQ2hhbmdlZCwga2luZCwgZGV2aWNlSWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgfSk7XG4gIH1cbiAgc2V0dXBMb2NhbFBhcnRpY2lwYW50RXZlbnRzKCkge1xuICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCkub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkKS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrTXV0ZWQsIHRoaXMub25Mb2NhbFRyYWNrTXV0ZWQpLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbm11dGVkLCB0aGlzLm9uTG9jYWxUcmFja1VubXV0ZWQpLm9uKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQpLm9uKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCB0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkKS5vbihQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgdGhpcy5vbkxvY2FsQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkKS5vbihQYXJ0aWNpcGFudEV2ZW50Lk1lZGlhRGV2aWNlc0Vycm9yLCB0aGlzLm9uTWVkaWFEZXZpY2VzRXJyb3IpLm9uKFBhcnRpY2lwYW50RXZlbnQuQXVkaW9TdHJlYW1BY3F1aXJlZCwgdGhpcy5zdGFydEF1ZGlvKS5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCk7XG4gIH1cbiAgcmVjcmVhdGVFbmdpbmUoKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuZW5naW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAvKiBAdHMtaWdub3JlICovXG4gICAgdGhpcy5lbmdpbmUgPSB1bmRlZmluZWQ7XG4gICAgLy8gY2xlYXIgb3V0IGV4aXN0aW5nIHJlbW90ZSBwYXJ0aWNpcGFudHMsIHNpbmNlIHRoZXkgbWF5IGhhdmUgYXR0YWNoZWRcbiAgICAvLyB0aGUgb2xkIGVuZ2luZVxuICAgIHRoaXMucGFydGljaXBhbnRzLmNsZWFyKCk7XG4gICAgdGhpcy5tYXliZUNyZWF0ZUVuZ2luZSgpO1xuICB9XG4gIG9uVHJhY2tBZGRlZChtZWRpYVRyYWNrLCBzdHJlYW0sIHJlY2VpdmVyKSB7XG4gICAgLy8gZG9uJ3QgZmlyZSBvblN1YnNjcmliZWQgd2hlbiBjb25uZWN0aW5nXG4gICAgLy8gV2ViUlRDIGZpcmVzIG9uVHJhY2sgYXMgc29vbiBhcyBzZXRSZW1vdGVEZXNjcmlwdGlvbiBpcyBjYWxsZWQgb24gdGhlIG9mZmVyXG4gICAgLy8gYXQgdGhhdCB0aW1lLCBJQ0UgY29ubmVjdGl2aXR5IGhhcyBub3QgYmVlbiBlc3RhYmxpc2hlZCBzbyB0aGUgdHJhY2sgaXMgbm90XG4gICAgLy8gdGVjaG5pY2FsbHkgc3Vic2NyaWJlZC5cbiAgICAvLyBXZSdsbCBkZWZlciB0aGVzZSBldmVudHMgdW50aWwgd2hlbiB0aGUgcm9vbSBpcyBjb25uZWN0ZWQgb3IgZXZlbnR1YWxseSBkaXNjb25uZWN0ZWQuXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0aW5nIHx8IHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcpIHtcbiAgICAgIGNvbnN0IHJlY29ubmVjdGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5vblRyYWNrQWRkZWQobWVkaWFUcmFjaywgc3RyZWFtLCByZWNlaXZlcik7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICB0aGlzLm9mZihSb29tRXZlbnQuUmVjb25uZWN0ZWQsIHJlY29ubmVjdGVkSGFuZGxlcik7XG4gICAgICAgIHRoaXMub2ZmKFJvb21FdmVudC5Db25uZWN0ZWQsIHJlY29ubmVjdGVkSGFuZGxlcik7XG4gICAgICAgIHRoaXMub2ZmKFJvb21FdmVudC5EaXNjb25uZWN0ZWQsIGNsZWFudXApO1xuICAgICAgfTtcbiAgICAgIHRoaXMub25jZShSb29tRXZlbnQuUmVjb25uZWN0ZWQsIHJlY29ubmVjdGVkSGFuZGxlcik7XG4gICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LkNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcbiAgICAgIHRoaXMub25jZShSb29tRXZlbnQuRGlzY29ubmVjdGVkLCBjbGVhbnVwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3NraXBwaW5nIGluY29taW5nIHRyYWNrIGFmdGVyIFJvb20gZGlzY29ubmVjdGVkJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSB1bnBhY2tTdHJlYW1JZChzdHJlYW0uaWQpO1xuICAgIGNvbnN0IHBhcnRpY2lwYW50SWQgPSBwYXJ0c1swXTtcbiAgICBsZXQgc3RyZWFtSWQgPSBwYXJ0c1sxXTtcbiAgICBsZXQgdHJhY2tJZCA9IG1lZGlhVHJhY2suaWQ7XG4gICAgLy8gZmlyZWZveCB3aWxsIGdldCBzdHJlYW1JZCAocElEfHRyYWNrSWQpIGluc3RlYWQgb2YgKHBJRHxzdHJlYW1JZCkgYXMgaXQgZG9lc24ndCBzdXBwb3J0IHN5bmMgdHJhY2tzIGJ5IHN0cmVhbVxuICAgIC8vIGFuZCBnZW5lcmF0ZXMgaXRzIG93biB0cmFjayBpZCBpbnN0ZWFkIG9mIGluZmVyIGZyb20gc2RwIHRyYWNrIGlkLlxuICAgIGlmIChzdHJlYW1JZCAmJiBzdHJlYW1JZC5zdGFydHNXaXRoKCdUUicpKSB0cmFja0lkID0gc3RyZWFtSWQ7XG4gICAgaWYgKHBhcnRpY2lwYW50SWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3RyaWVkIHRvIGNyZWF0ZSBSZW1vdGVQYXJ0aWNpcGFudCBmb3IgbG9jYWwgcGFydGljaXBhbnQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmdldChwYXJ0aWNpcGFudElkKTtcbiAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICB0aGlzLmxvZy5lcnJvcihcIlRyaWVkIHRvIGFkZCBhIHRyYWNrIGZvciBhIHBhcnRpY2lwYW50LCB0aGF0J3Mgbm90IHByZXNlbnQuIFNpZDogXCIuY29uY2F0KHBhcnRpY2lwYW50SWQpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncztcbiAgICBpZiAodGhpcy5vcHRpb25zLmFkYXB0aXZlU3RyZWFtKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hZGFwdGl2ZVN0cmVhbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyA9IHRoaXMub3B0aW9ucy5hZGFwdGl2ZVN0cmVhbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgPSB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGFydGljaXBhbnQuYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2sobWVkaWFUcmFjaywgdHJhY2tJZCwgc3RyZWFtLCByZWNlaXZlciwgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyk7XG4gIH1cbiAgaGFuZGxlRGlzY29ubmVjdCgpIHtcbiAgICBsZXQgc2hvdWxkU3RvcFRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICBsZXQgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWdpb25VcmwgPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucGFydGljaXBhbnRzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIHAudHJhY2tzLmZvckVhY2gocHViID0+IHtcbiAgICAgICAgICBwLnVucHVibGlzaFRyYWNrKHB1Yi50cmFja1NpZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudHJhY2tzLmZvckVhY2gocHViID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHB1Yi50cmFjaykge1xuICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC51bnB1Ymxpc2hUcmFjayhwdWIudHJhY2ssIHNob3VsZFN0b3BUcmFja3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRTdG9wVHJhY2tzKSB7XG4gICAgICAgICAgKF9hID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGV0YWNoKCk7XG4gICAgICAgICAgKF9iID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5vZmYoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgdGhpcy5vbkxvY2FsUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TmFtZUNoYW5nZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrTXV0ZWQsIHRoaXMub25Mb2NhbFRyYWNrTXV0ZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5tdXRlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbm11dGVkKS5vZmYoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCB0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkKS5vZmYoUGFydGljaXBhbnRFdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHRoaXMub25Mb2NhbENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIHRoaXMub25NZWRpYURldmljZXNFcnJvcikub2ZmKFBhcnRpY2lwYW50RXZlbnQuQXVkaW9TdHJlYW1BY3F1aXJlZCwgdGhpcy5zdGFydEF1ZGlvKS5vZmYoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgdGhpcy5vbkxvY2FsUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQpO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnRyYWNrcy5jbGVhcigpO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnZpZGVvVHJhY2tzLmNsZWFyKCk7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9UcmFja3MuY2xlYXIoKTtcbiAgICAgIHRoaXMucGFydGljaXBhbnRzLmNsZWFyKCk7XG4gICAgICB0aGlzLmFjdGl2ZVNwZWFrZXJzID0gW107XG4gICAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0LmNsb3NlKCk7XG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZyZWV6ZScsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgICAoX2EgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgcmVhc29uKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQoc2lkLCBwYXJ0aWNpcGFudCkge1xuICAgIC8vIHJlbW92ZSBhbmQgc2VuZCBldmVudFxuICAgIHRoaXMucGFydGljaXBhbnRzLmRlbGV0ZShzaWQpO1xuICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pZGVudGl0eVRvU2lkLmRlbGV0ZShwYXJ0aWNpcGFudC5pZGVudGl0eSk7XG4gICAgcGFydGljaXBhbnQudHJhY2tzLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xuICAgICAgcGFydGljaXBhbnQudW5wdWJsaXNoVHJhY2socHVibGljYXRpb24udHJhY2tTaWQsIHRydWUpO1xuICAgIH0pO1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnREaXNjb25uZWN0ZWQsIHBhcnRpY2lwYW50KTtcbiAgfVxuICBhY3F1aXJlQXVkaW9Db250ZXh0KCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmV4cFdlYkF1ZGlvTWl4ICE9PSAnYm9vbGVhbicgJiYgdGhpcy5vcHRpb25zLmV4cFdlYkF1ZGlvTWl4LmF1ZGlvQ29udGV4dCkge1xuICAgICAgICAvLyBvdmVycmlkZSBhdWRpbyBjb250ZXh0IHdpdGggY3VzdG9tIGF1ZGlvIGNvbnRleHQgaWYgc3VwcGxpZWQgYnkgdXNlclxuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peC5hdWRpb0NvbnRleHQ7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmF1ZGlvQ29udGV4dCB8fCB0aGlzLmF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgLy8gYnkgdXNpbmcgYW4gQXVkaW9Db250ZXh0LCBpdCByZWR1Y2VzIGxhZyBvbiBhdWRpbyBlbGVtZW50c1xuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85ODExNDI5L2h0bWw1LWF1ZGlvLXRhZy1vbi1zYWZhcmktaGFzLWEtZGVsYXkvNTQxMTk4NTQjNTQxMTk4NTRcbiAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQgPSAoX2EgPSBnZXROZXdBdWRpb0NvbnRleHQoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0ICYmIHRoaXMuYXVkaW9Db250ZXh0LnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuICAgICAgICAvLyBmb3IgaU9TIGEgbmV3bHkgY3JlYXRlZCBBdWRpb0NvbnRleHQgaXMgYWx3YXlzIGluIGBzdXNwZW5kZWRgIHN0YXRlLlxuICAgICAgICAvLyB3ZSB0cnkgb3VyIGJlc3QgdG8gcmVzdW1lIHRoZSBjb250ZXh0IGhlcmUsIGlmIHRoYXQgZG9lc24ndCB3b3JrLCB3ZSBqdXN0IGNvbnRpbnVlIHdpdGggcmVndWxhciBwcm9jZXNzaW5nXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5hdWRpb0NvbnRleHQucmVzdW1lKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdDb3VsZCBub3QgcmVzdW1lIGF1ZGlvIGNvbnRleHQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4cFdlYkF1ZGlvTWl4KSB7XG4gICAgICAgIHRoaXMucGFydGljaXBhbnRzLmZvckVhY2gocGFydGljaXBhbnQgPT4gcGFydGljaXBhbnQuc2V0QXVkaW9Db250ZXh0KHRoaXMuYXVkaW9Db250ZXh0KSk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0QXVkaW9Db250ZXh0KHRoaXMuYXVkaW9Db250ZXh0KTtcbiAgICAgIGNvbnN0IG5ld0NvbnRleHRJc1J1bm5pbmcgPSAoKF9iID0gdGhpcy5hdWRpb0NvbnRleHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGF0ZSkgPT09ICdydW5uaW5nJztcbiAgICAgIGlmIChuZXdDb250ZXh0SXNSdW5uaW5nICE9PSB0aGlzLmNhblBsYXliYWNrQXVkaW8pIHtcbiAgICAgICAgdGhpcy5hdWRpb0VuYWJsZWQgPSBuZXdDb250ZXh0SXNSdW5uaW5nO1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLCBuZXdDb250ZXh0SXNSdW5uaW5nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjcmVhdGVQYXJ0aWNpcGFudChpZCwgaW5mbykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgcGFydGljaXBhbnQ7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHBhcnRpY2lwYW50ID0gUmVtb3RlUGFydGljaXBhbnQuZnJvbVBhcnRpY2lwYW50SW5mbyh0aGlzLmVuZ2luZS5jbGllbnQsIGluZm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0aWNpcGFudCA9IG5ldyBSZW1vdGVQYXJ0aWNpcGFudCh0aGlzLmVuZ2luZS5jbGllbnQsIGlkLCAnJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIGxvZ2dlck5hbWU6IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peCkge1xuICAgICAgcGFydGljaXBhbnQuc2V0QXVkaW9Db250ZXh0KHRoaXMuYXVkaW9Db250ZXh0KTtcbiAgICB9XG4gICAgaWYgKChfYSA9IHRoaXMub3B0aW9ucy5hdWRpb091dHB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRldmljZUlkKSB7XG4gICAgICBwYXJ0aWNpcGFudC5zZXRBdWRpb091dHB1dCh0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQpLmNhdGNoKGUgPT4gdGhpcy5sb2cud2FybihcIkNvdWxkIG5vdCBzZXQgYXVkaW8gb3V0cHV0OiBcIi5jb25jYXQoZS5tZXNzYWdlKSwgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWNpcGFudDtcbiAgfVxuICBnZXRPckNyZWF0ZVBhcnRpY2lwYW50KGlkLCBpbmZvKSB7XG4gICAgaWYgKHRoaXMucGFydGljaXBhbnRzLmhhcyhpZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRpY2lwYW50cy5nZXQoaWQpO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuY3JlYXRlUGFydGljaXBhbnQoaWQsIGluZm8pO1xuICAgIHRoaXMucGFydGljaXBhbnRzLnNldChpZCwgcGFydGljaXBhbnQpO1xuICAgIHRoaXMuaWRlbnRpdHlUb1NpZC5zZXQoaW5mby5pZGVudGl0eSwgaW5mby5zaWQpO1xuICAgIC8vIGlmIHdlIGhhdmUgdmFsaWQgaW5mbyBhbmQgdGhlIHBhcnRpY2lwYW50IHdhc24ndCBpbiB0aGUgbWFwIGJlZm9yZSwgd2UgY2FuIGFzc3VtZSB0aGUgcGFydGljaXBhbnQgaXMgbmV3XG4gICAgLy8gZmlyaW5nIGhlcmUgdG8gbWFrZSBzdXJlIHRoYXQgYFBhcnRpY2lwYW50Q29ubmVjdGVkYCBmaXJlcyBiZWZvcmUgdGhlIGluaXRpYWwgdHJhY2sgZXZlbnRzXG4gICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnRDb25uZWN0ZWQsIHBhcnRpY2lwYW50KTtcbiAgICAvLyBhbHNvIGZvcndhcmQgZXZlbnRzXG4gICAgLy8gdHJhY2tQdWJsaXNoZWQgaXMgb25seSBmaXJlZCBmb3IgdHJhY2tzIGFkZGVkIGFmdGVyIGJvdGggbG9jYWwgcGFydGljaXBhbnRcbiAgICAvLyBhbmQgcmVtb3RlIHBhcnRpY2lwYW50IGpvaW5lZCB0aGUgcm9vbVxuICAgIHBhcnRpY2lwYW50Lm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tQdWJsaXNoZWQsIHRyYWNrUHVibGljYXRpb24gPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tQdWJsaXNoZWQsIHRyYWNrUHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaWJlZCwgKHRyYWNrLCBwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgLy8gbW9uaXRvciBwbGF5YmFjayBzdGF0dXNcbiAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja1N0YXJ0ZWQsIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja1N0YXJ0ZWQpO1xuICAgICAgICB0cmFjay5vbihUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQsIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja0ZhaWxlZCk7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrRmFpbGVkLCB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tGYWlsZWQpO1xuICAgICAgICB0cmFjay5vbihUcmFja0V2ZW50LlZpZGVvUGxheWJhY2tTdGFydGVkLCB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tTdWJzY3JpYmVkLCB0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5wdWJsaXNoZWQsIHB1YmxpY2F0aW9uID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCwgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCAodHJhY2ssIHB1YmxpY2F0aW9uKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCB0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBzaWQgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgc2lkLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCBwdWIgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tNdXRlZCwgcHViLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHB1YiA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja1VubXV0ZWQsIHB1YiwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIG1ldGFkYXRhID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCBtZXRhZGF0YSwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgbmFtZSA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCBuYW1lLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHF1YWxpdHkgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCBxdWFsaXR5LCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgcHJldlBlcm1pc3Npb25zID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMsIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgKHB1Yiwgc3RhdHVzKSA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIHB1Yiwgc3RhdHVzLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgKHRyYWNrU2lkLCBlcnJvcikgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgdHJhY2tTaWQsIHBhcnRpY2lwYW50LCBlcnJvcik7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCAocHViLCBzdGF0dXMpID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIHB1Yiwgc3RhdHVzLCBwYXJ0aWNpcGFudCk7XG4gICAgfSk7XG4gICAgLy8gdXBkYXRlIGluZm8gYXQgdGhlIGVuZCBhZnRlciBjYWxsYmFja3MgaGF2ZSBiZWVuIHNldCB1cFxuICAgIGlmIChpbmZvKSB7XG4gICAgICBwYXJ0aWNpcGFudC51cGRhdGVJbmZvKGluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gcGFydGljaXBhbnQ7XG4gIH1cbiAgc2VuZFN5bmNTdGF0ZSgpIHtcbiAgICBjb25zdCByZW1vdGVUcmFja3MgPSBBcnJheS5mcm9tKHRoaXMucGFydGljaXBhbnRzLnZhbHVlcygpKS5yZWR1Y2UoKGFjYywgcGFydGljaXBhbnQpID0+IHtcbiAgICAgIGFjYy5wdXNoKC4uLnBhcnRpY2lwYW50LmdldFRyYWNrcygpKTsgLy8gRklYTUUgd291bGQgYmUgbmljZSB0byBoYXZlIHRoaXMgcmV0dXJuIFJlbW90ZVRyYWNrUHVibGljYXRpb25zIGRpcmVjdGx5IGluc3RlYWQgb2YgdGhlIHR5cGUgY2FzdFxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgbG9jYWxUcmFja3MgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQuZ2V0VHJhY2tzKCk7IC8vIEZJWE1FIHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSB0aGlzIHJldHVybiBMb2NhbFRyYWNrUHVibGljYXRpb25zIGRpcmVjdGx5IGluc3RlYWQgb2YgdGhlIHR5cGUgY2FzdFxuICAgIHRoaXMuZW5naW5lLnNlbmRTeW5jU3RhdGUocmVtb3RlVHJhY2tzLCBsb2NhbFRyYWNrcyk7XG4gIH1cbiAgLyoqXG4gICAqIEFmdGVyIHJlc3VtaW5nLCB3ZSdsbCBuZWVkIHRvIG5vdGlmeSB0aGUgc2VydmVyIG9mIHRoZSBjdXJyZW50XG4gICAqIHN1YnNjcmlwdGlvbiBzZXR0aW5ncy5cbiAgICovXG4gIHVwZGF0ZVN1YnNjcmlwdGlvbnMoKSB7XG4gICAgZm9yIChjb25zdCBwIG9mIHRoaXMucGFydGljaXBhbnRzLnZhbHVlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IHB1YiBvZiBwLnZpZGVvVHJhY2tzLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChwdWIuaXNTdWJzY3JpYmVkICYmIHB1YiBpbnN0YW5jZW9mIFJlbW90ZVRyYWNrUHVibGljYXRpb24pIHtcbiAgICAgICAgICBwdWIuZW1pdFRyYWNrVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCkge1xuICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgbGV0IGNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgIHRoaXMuY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsID0gQ3JpdGljYWxUaW1lcnMuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgLy8gZW5zdXJlIHdlIGRpZG4ndCB0ZWFyIGl0IGRvd25cbiAgICAgICF0aGlzLmVuZ2luZSB8fFxuICAgICAgLy8gZW5naW5lIGRldGVjdGVkIGNsb3NlLCBidXQgUm9vbSBtaXNzZWQgaXRcbiAgICAgIHRoaXMuZW5naW5lLmlzQ2xvc2VkIHx8XG4gICAgICAvLyB0cmFuc3BvcnRzIGZhaWxlZCB3aXRob3V0IG5vdGlmeWluZyBlbmdpbmVcbiAgICAgICF0aGlzLmVuZ2luZS52ZXJpZnlUcmFuc3BvcnQoKSkge1xuICAgICAgICBjb25zZWN1dGl2ZUZhaWx1cmVzKys7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2RldGVjdGVkIGNvbm5lY3Rpb24gc3RhdGUgbWlzbWF0Y2gnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBudW1GYWlsdXJlczogY29uc2VjdXRpdmVGYWlsdXJlcyxcbiAgICAgICAgICBlbmdpbmU6IHtcbiAgICAgICAgICAgIGNsb3NlZDogdGhpcy5lbmdpbmUuaXNDbG9zZWQsXG4gICAgICAgICAgICB0cmFuc3BvcnRzQ29ubmVjdGVkOiB0aGlzLmVuZ2luZS52ZXJpZnlUcmFuc3BvcnQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAoY29uc2VjdXRpdmVGYWlsdXJlcyA+PSAzKSB7XG4gICAgICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xuICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCwgRGlzY29ubmVjdFJlYXNvbi5TVEFURV9NSVNNQVRDSCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgICAgfVxuICAgIH0sIGNvbm5lY3Rpb25SZWNvbmNpbGVGcmVxdWVuY3kpO1xuICB9XG4gIGNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSgpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uUmVjb25jaWxlSW50ZXJ2YWwpIHtcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFySW50ZXJ2YWwodGhpcy5jb25uZWN0aW9uUmVjb25jaWxlSW50ZXJ2YWwpO1xuICAgIH1cbiAgfVxuICBzZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlID09PSB0aGlzLnN0YXRlKSB7XG4gICAgICAvLyB1bmNoYW5nZWRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCwgdGhpcy5zdGF0ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZW1pdFdoZW5Db25uZWN0ZWQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93cyB0byBwb3B1bGF0ZSBhIHJvb20gd2l0aCBzaW11bGF0ZWQgcGFydGljaXBhbnRzLlxuICAgKiBObyBhY3R1YWwgY29ubmVjdGlvbiB0byBhIHNlcnZlciB3aWxsIGJlIGVzdGFibGlzaGVkLCBhbGwgc3RhdGUgaXNcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc2ltdWxhdGVQYXJ0aWNpcGFudHMob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHB1Ymxpc2hPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGF1ZGlvOiB0cnVlLFxuICAgICAgICB2aWRlbzogdHJ1ZSxcbiAgICAgICAgdXNlUmVhbFRyYWNrczogZmFsc2VcbiAgICAgIH0sIG9wdGlvbnMucHVibGlzaCk7XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY291bnQ6IDksXG4gICAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgICAgdmlkZW86IHRydWUsXG4gICAgICAgIGFzcGVjdFJhdGlvczogWzEuNjYsIDEuNywgMS4zXVxuICAgICAgfSwgb3B0aW9ucy5wYXJ0aWNpcGFudHMpO1xuICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLnJvb21JbmZvID0gbmV3IFJvb20kMSh7XG4gICAgICAgIHNpZDogJ1JNX1NJTVVMQVRFRCcsXG4gICAgICAgIG5hbWU6ICdzaW11bGF0ZWQtcm9vbScsXG4gICAgICAgIGVtcHR5VGltZW91dDogMCxcbiAgICAgICAgbWF4UGFydGljaXBhbnRzOiAwLFxuICAgICAgICBjcmVhdGlvblRpbWU6IHByb3RvSW50NjQucGFyc2UobmV3IERhdGUoKS5nZXRUaW1lKCkpLFxuICAgICAgICBtZXRhZGF0YTogJycsXG4gICAgICAgIG51bVBhcnRpY2lwYW50czogMSxcbiAgICAgICAgbnVtUHVibGlzaGVyczogMSxcbiAgICAgICAgdHVyblBhc3N3b3JkOiAnJyxcbiAgICAgICAgZW5hYmxlZENvZGVjczogW10sXG4gICAgICAgIGFjdGl2ZVJlY29yZGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnVwZGF0ZUluZm8obmV3IFBhcnRpY2lwYW50SW5mbyh7XG4gICAgICAgIGlkZW50aXR5OiAnc2ltdWxhdGVkLWxvY2FsJyxcbiAgICAgICAgbmFtZTogJ2xvY2FsLW5hbWUnXG4gICAgICB9KSk7XG4gICAgICB0aGlzLnNldHVwTG9jYWxQYXJ0aWNpcGFudEV2ZW50cygpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5TaWduYWxDb25uZWN0ZWQpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5Db25uZWN0ZWQpO1xuICAgICAgdGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpO1xuICAgICAgaWYgKHB1Ymxpc2hPcHRpb25zLnZpZGVvKSB7XG4gICAgICAgIGNvbnN0IGNhbVB1YiA9IG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb24oVHJhY2suS2luZC5WaWRlbywgbmV3IFRyYWNrSW5mbyh7XG4gICAgICAgICAgc291cmNlOiBUcmFja1NvdXJjZS5DQU1FUkEsXG4gICAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkudG9TdHJpbmcoKSxcbiAgICAgICAgICB0eXBlOiBUcmFja1R5cGUuQVVESU8sXG4gICAgICAgICAgbmFtZTogJ3ZpZGVvLWR1bW15J1xuICAgICAgICB9KSwgbmV3IExvY2FsVmlkZW9UcmFjayhwdWJsaXNoT3B0aW9ucy51c2VSZWFsVHJhY2tzID8gKHlpZWxkIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICAgICAgdmlkZW86IHRydWVcbiAgICAgICAgfSkpLmdldFZpZGVvVHJhY2tzKClbMF0gOiBjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2soMTYwICogKChfYSA9IHBhcnRpY2lwYW50T3B0aW9ucy5hc3BlY3RSYXRpb3NbMF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpLCAxNjAsIHRydWUsIHRydWUpLCB1bmRlZmluZWQsIGZhbHNlLCB7XG4gICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICAgICAgfSksIHtcbiAgICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWRkVHJhY2tQdWJsaWNhdGlvbihjYW1QdWIpO1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIGNhbVB1Yik7XG4gICAgICB9XG4gICAgICBpZiAocHVibGlzaE9wdGlvbnMuYXVkaW8pIHtcbiAgICAgICAgY29uc3QgYXVkaW9QdWIgPSBuZXcgTG9jYWxUcmFja1B1YmxpY2F0aW9uKFRyYWNrLktpbmQuQXVkaW8sIG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuTUlDUk9QSE9ORSxcbiAgICAgICAgICBzaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgIHR5cGU6IFRyYWNrVHlwZS5BVURJT1xuICAgICAgICB9KSwgbmV3IExvY2FsQXVkaW9UcmFjayhwdWJsaXNoT3B0aW9ucy51c2VSZWFsVHJhY2tzID8gKHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcbiAgICAgICAgICBhdWRpbzogdHJ1ZVxuICAgICAgICB9KSkuZ2V0QXVkaW9UcmFja3MoKVswXSA6IGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjaygpLCB1bmRlZmluZWQsIGZhbHNlLCB0aGlzLmF1ZGlvQ29udGV4dCwge1xuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFkZFRyYWNrUHVibGljYXRpb24oYXVkaW9QdWIpO1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIGF1ZGlvUHViKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydGljaXBhbnRPcHRpb25zLmNvdW50IC0gMTsgaSArPSAxKSB7XG4gICAgICAgIGxldCBpbmZvID0gbmV3IFBhcnRpY2lwYW50SW5mbyh7XG4gICAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkudG9TdHJpbmcoKSxcbiAgICAgICAgICBpZGVudGl0eTogXCJzaW11bGF0ZWQtXCIuY29uY2F0KGkpLFxuICAgICAgICAgIHN0YXRlOiBQYXJ0aWNpcGFudEluZm9fU3RhdGUuQUNUSVZFLFxuICAgICAgICAgIHRyYWNrczogW10sXG4gICAgICAgICAgam9pbmVkQXQ6IHByb3RvSW50NjQucGFyc2UoRGF0ZS5ub3coKSlcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmdldE9yQ3JlYXRlUGFydGljaXBhbnQoaW5mby5pZGVudGl0eSwgaW5mbyk7XG4gICAgICAgIGlmIChwYXJ0aWNpcGFudE9wdGlvbnMudmlkZW8pIHtcbiAgICAgICAgICBjb25zdCBkdW1teVZpZGVvID0gY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKDE2MCAqICgoX2IgPSBwYXJ0aWNpcGFudE9wdGlvbnMuYXNwZWN0UmF0aW9zW2kgJSBwYXJ0aWNpcGFudE9wdGlvbnMuYXNwZWN0UmF0aW9zLmxlbmd0aF0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDEpLCAxNjAsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICBjb25zdCB2aWRlb1RyYWNrID0gbmV3IFRyYWNrSW5mbyh7XG4gICAgICAgICAgICBzb3VyY2U6IFRyYWNrU291cmNlLkNBTUVSQSxcbiAgICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB0eXBlOiBUcmFja1R5cGUuQVVESU9cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwLmFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKGR1bW15VmlkZW8sIHZpZGVvVHJhY2suc2lkLCBuZXcgTWVkaWFTdHJlYW0oW2R1bW15VmlkZW9dKSk7XG4gICAgICAgICAgaW5mby50cmFja3MgPSBbLi4uaW5mby50cmFja3MsIHZpZGVvVHJhY2tdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWNpcGFudE9wdGlvbnMuYXVkaW8pIHtcbiAgICAgICAgICBjb25zdCBkdW1teVRyYWNrID0gZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrKCk7XG4gICAgICAgICAgY29uc3QgYXVkaW9UcmFjayA9IG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgICAgc291cmNlOiBUcmFja1NvdXJjZS5NSUNST1BIT05FLFxuICAgICAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHR5cGU6IFRyYWNrVHlwZS5BVURJT1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHAuYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2soZHVtbXlUcmFjaywgYXVkaW9UcmFjay5zaWQsIG5ldyBNZWRpYVN0cmVhbShbZHVtbXlUcmFja10pKTtcbiAgICAgICAgICBpbmZvLnRyYWNrcyA9IFsuLi5pbmZvLnRyYWNrcywgYXVkaW9UcmFja107XG4gICAgICAgIH1cbiAgICAgICAgcC51cGRhdGVJbmZvKGluZm8pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8vIC8qKiBAaW50ZXJuYWwgKi9cbiAgZW1pdChldmVudCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICAvLyBhY3RpdmUgc3BlYWtlciB1cGRhdGVzIGFyZSB0b28gc3BhbW15XG4gICAgaWYgKGV2ZW50ICE9PSBSb29tRXZlbnQuQWN0aXZlU3BlYWtlcnNDaGFuZ2VkKSB7XG4gICAgICAvLyBvbmx5IGV4dHJhY3QgbG9nQ29udGV4dCBmcm9tIGFyZ3VtZW50cyBpbiBvcmRlciB0byBhdm9pZCBsb2dnaW5nIHRoZSB3aG9sZSBvYmplY3QgdHJlZVxuICAgICAgY29uc3QgbWluaW1pemVkQXJncyA9IG1hcEFyZ3MoYXJncykuZmlsdGVyKGFyZyA9PiBhcmcgIT09IHVuZGVmaW5lZCk7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInJvb20gZXZlbnQgXCIuY29uY2F0KGV2ZW50KSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICBhcmdzOiBtaW5pbWl6ZWRBcmdzXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gbWFwQXJncyhhcmdzKSB7XG4gIHJldHVybiBhcmdzLm1hcChhcmcgPT4ge1xuICAgIGlmICghYXJnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgIHJldHVybiBtYXBBcmdzKGFyZyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuICdsb2dDb250ZXh0JyBpbiBhcmcgJiYgYXJnLmxvZ0NvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiBhcmc7XG4gIH0pO1xufVxuXG52YXIgQ2hlY2tTdGF0dXM7XG4oZnVuY3Rpb24gKENoZWNrU3RhdHVzKSB7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiSURMRVwiXSA9IDBdID0gXCJJRExFXCI7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiUlVOTklOR1wiXSA9IDFdID0gXCJSVU5OSU5HXCI7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiU0tJUFBFRFwiXSA9IDJdID0gXCJTS0lQUEVEXCI7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiU1VDQ0VTU1wiXSA9IDNdID0gXCJTVUNDRVNTXCI7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiRkFJTEVEXCJdID0gNF0gPSBcIkZBSUxFRFwiO1xufSkoQ2hlY2tTdGF0dXMgfHwgKENoZWNrU3RhdHVzID0ge30pKTtcbmNsYXNzIENoZWNrZXIgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHVybCwgdG9rZW4pIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnN0YXR1cyA9IENoZWNrU3RhdHVzLklETEU7XG4gICAgdGhpcy5sb2dzID0gW107XG4gICAgdGhpcy5lcnJvcnNBc1dhcm5pbmdzID0gZmFsc2U7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB0aGlzLnJvb20gPSBuZXcgUm9vbShvcHRpb25zLnJvb21PcHRpb25zKTtcbiAgICB0aGlzLmNvbm5lY3RPcHRpb25zID0gb3B0aW9ucy5jb25uZWN0T3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5lcnJvcnNBc1dhcm5pbmdzKSB7XG4gICAgICB0aGlzLmVycm9yc0FzV2FybmluZ3MgPSBvcHRpb25zLmVycm9yc0FzV2FybmluZ3M7XG4gICAgfVxuICB9XG4gIHJ1bihvbkNvbXBsZXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQ2hlY2tTdGF0dXMuSURMRSkge1xuICAgICAgICB0aHJvdyBFcnJvcignY2hlY2sgaXMgcnVubmluZyBhbHJlYWR5Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXR1cyhDaGVja1N0YXR1cy5SVU5OSU5HKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGlmICh0aGlzLmVycm9yc0FzV2FybmluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhlcnIubWVzc2FnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAvLyBzbGVlcCBmb3IgYSBiaXQgdG8gZW5zdXJlIGRpc2Nvbm5lY3RcbiAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQ2hlY2tTdGF0dXMuU0tJUFBFRCkge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyh0aGlzLmlzU3VjY2VzcygpID8gQ2hlY2tTdGF0dXMuU1VDQ0VTUyA6IENoZWNrU3RhdHVzLkZBSUxFRCk7XG4gICAgICB9XG4gICAgICBpZiAob25Db21wbGV0ZSkge1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbmZvKCk7XG4gICAgfSk7XG4gIH1cbiAgaXNTdWNjZXNzKCkge1xuICAgIHJldHVybiAhdGhpcy5sb2dzLnNvbWUobCA9PiBsLmxldmVsID09PSAnZXJyb3InKTtcbiAgfVxuICBjb25uZWN0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5yb29tLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb207XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLnJvb20uY29ubmVjdCh0aGlzLnVybCwgdGhpcy50b2tlbik7XG4gICAgICByZXR1cm4gdGhpcy5yb29tO1xuICAgIH0pO1xuICB9XG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnJvb20gJiYgdGhpcy5yb29tLnN0YXRlICE9PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucm9vbS5kaXNjb25uZWN0KCk7XG4gICAgICAgIC8vIHdhaXQgZm9yIGl0IHRvIGdvIHRocm91Z2hcbiAgICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNraXAoKSB7XG4gICAgdGhpcy5zZXRTdGF0dXMoQ2hlY2tTdGF0dXMuU0tJUFBFRCk7XG4gIH1cbiAgYXBwZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgdGhpcy5sb2dzLnB1c2goe1xuICAgICAgbGV2ZWw6ICdpbmZvJyxcbiAgICAgIG1lc3NhZ2VcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0SW5mbygpKTtcbiAgfVxuICBhcHBlbmRXYXJuaW5nKG1lc3NhZ2UpIHtcbiAgICB0aGlzLmxvZ3MucHVzaCh7XG4gICAgICBsZXZlbDogJ3dhcm5pbmcnLFxuICAgICAgbWVzc2FnZVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5nZXRJbmZvKCkpO1xuICB9XG4gIGFwcGVuZEVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLmxvZ3MucHVzaCh7XG4gICAgICBsZXZlbDogJ2Vycm9yJyxcbiAgICAgIG1lc3NhZ2VcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0SW5mbygpKTtcbiAgfVxuICBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldEluZm8oKSk7XG4gIH1cbiAgZ2V0IGVuZ2luZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuZ2luZTtcbiAgfVxuICBnZXRJbmZvKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2dzOiB0aGlzLmxvZ3MsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb25cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGxvY2FsIHZpZGVvIGFuZCBhdWRpbyB0cmFjayBhdCB0aGUgc2FtZSB0aW1lLiBXaGVuIGFjcXVpcmluZyBib3RoXG4gKiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzIHRvZ2V0aGVyLCBpdCdsbCBkaXNwbGF5IGEgc2luZ2xlIHBlcm1pc3Npb24gcHJvbXB0IHRvXG4gKiB0aGUgdXNlciBpbnN0ZWFkIG9mIHR3byBzZXBhcmF0ZSBvbmVzLlxuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYWxUcmFja3Mob3B0aW9ucykge1xuICB2YXIgX2EsIF9iO1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnMgdG8gdHJ1ZVxuICAgIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IG9wdGlvbnMgPSB7fTtcbiAgICAoX2EgPSBvcHRpb25zLmF1ZGlvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBvcHRpb25zLmF1ZGlvID0gdHJ1ZTtcbiAgICAoX2IgPSBvcHRpb25zLnZpZGVvKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBvcHRpb25zLnZpZGVvID0gdHJ1ZTtcbiAgICBjb25zdCBvcHRzID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCBhdWRpb0RlZmF1bHRzLCB2aWRlb0RlZmF1bHRzKTtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzRm9yT3B0aW9ucyhvcHRzKTtcbiAgICAvLyBLZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBwcm9taXNlIG9uIERldmljZU1hbmFnZXIgYW5kIGF3YWl0IGl0IGluIGdldExvY2FsRGV2aWNlcygpXG4gICAgLy8gd29ya3MgYXJvdW5kIGlPUyBTYWZhcmkgQnVnIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzkzNjNcbiAgICBjb25zdCBtZWRpYVByb21pc2UgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgaWYgKG9wdGlvbnMuYXVkaW8pIHtcbiAgICAgIERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5zZXQoJ2F1ZGlvaW5wdXQnLCBtZWRpYVByb21pc2UpO1xuICAgICAgbWVkaWFQcm9taXNlLmNhdGNoKCgpID0+IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5kZWxldGUoJ2F1ZGlvaW5wdXQnKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnZpZGVvKSB7XG4gICAgICBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2V0KCd2aWRlb2lucHV0JywgbWVkaWFQcm9taXNlKTtcbiAgICAgIG1lZGlhUHJvbWlzZS5jYXRjaCgoKSA9PiBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuZGVsZXRlKCd2aWRlb2lucHV0JykpO1xuICAgIH1cbiAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBtZWRpYVByb21pc2U7XG4gICAgcmV0dXJuIHN0cmVhbS5nZXRUcmFja3MoKS5tYXAobWVkaWFTdHJlYW1UcmFjayA9PiB7XG4gICAgICBjb25zdCBpc0F1ZGlvID0gbWVkaWFTdHJlYW1UcmFjay5raW5kID09PSAnYXVkaW8nO1xuICAgICAgaXNBdWRpbyA/IG9wdGlvbnMuYXVkaW8gOiBvcHRpb25zLnZpZGVvO1xuICAgICAgbGV0IHRyYWNrQ29uc3RyYWludHM7XG4gICAgICBjb25zdCBjb25PckJvb2wgPSBpc0F1ZGlvID8gY29uc3RyYWludHMuYXVkaW8gOiBjb25zdHJhaW50cy52aWRlbztcbiAgICAgIGlmICh0eXBlb2YgY29uT3JCb29sICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdHJhY2tDb25zdHJhaW50cyA9IGNvbk9yQm9vbDtcbiAgICAgIH1cbiAgICAgIC8vIHVwZGF0ZSB0aGUgY29uc3RyYWludHMgd2l0aCB0aGUgZGV2aWNlIGlkIHRoZSB1c2VyIGdhdmUgcGVybWlzc2lvbnMgdG8gaW4gdGhlIHBlcm1pc3Npb24gcHJvbXB0XG4gICAgICAvLyBvdGhlcndpc2UgZWFjaCB0cmFjayByZXN0YXJ0IChlLmcuIG11dGUgLSB1bm11dGUpIHdpbGwgdHJ5IHRvIGluaXRpYWxpemUgdGhlIGRldmljZSBhZ2FpbiAtPiBjYXVzaW5nIGFkZGl0aW9uYWwgcGVybWlzc2lvbiBwcm9tcHRzXG4gICAgICBpZiAodHJhY2tDb25zdHJhaW50cykge1xuICAgICAgICB0cmFja0NvbnN0cmFpbnRzLmRldmljZUlkID0gbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhY2tDb25zdHJhaW50cyA9IHtcbiAgICAgICAgICBkZXZpY2VJZDogbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFjayA9IG1lZGlhVHJhY2tUb0xvY2FsVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgdHJhY2tDb25zdHJhaW50cyk7XG4gICAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICB0cmFjay5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuQ2FtZXJhO1xuICAgICAgfSBlbHNlIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xuICAgICAgfVxuICAgICAgdHJhY2subWVkaWFTdHJlYW0gPSBzdHJlYW07XG4gICAgICByZXR1cm4gdHJhY2s7XG4gICAgfSk7XG4gIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgW1tMb2NhbFZpZGVvVHJhY2tdXSB3aXRoIGdldFVzZXJNZWRpYSgpXG4gKiBAcGFyYW0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjcmVhdGVMb2NhbFZpZGVvVHJhY2sob3B0aW9ucykge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHRyYWNrcyA9IHlpZWxkIGNyZWF0ZUxvY2FsVHJhY2tzKHtcbiAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgIHZpZGVvOiBvcHRpb25zXG4gICAgfSk7XG4gICAgcmV0dXJuIHRyYWNrc1swXTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVMb2NhbEF1ZGlvVHJhY2sob3B0aW9ucykge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHRyYWNrcyA9IHlpZWxkIGNyZWF0ZUxvY2FsVHJhY2tzKHtcbiAgICAgIGF1ZGlvOiBvcHRpb25zLFxuICAgICAgdmlkZW86IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRyYWNrc1swXTtcbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBzY3JlZW4gY2FwdHVyZSB0cmFja3Mgd2l0aCBnZXREaXNwbGF5TWVkaWEoKS5cbiAqIEEgTG9jYWxWaWRlb1RyYWNrIGlzIGFsd2F5cyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAqIElmIHsgYXVkaW86IHRydWUgfSwgYW5kIHRoZSBicm93c2VyIHN1cHBvcnRzIGF1ZGlvIGNhcHR1cmUsIGEgTG9jYWxBdWRpb1RyYWNrIGlzIGFsc28gY3JlYXRlZC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYWxTY3JlZW5UcmFja3Mob3B0aW9ucykge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiA9PT0gdW5kZWZpbmVkICYmICFpc1NhZmFyaTE3KCkpIHtcbiAgICAgIG9wdGlvbnMucmVzb2x1dGlvbiA9IFNjcmVlblNoYXJlUHJlc2V0cy5oMTA4MGZwczMwLnJlc29sdXRpb247XG4gICAgfVxuICAgIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcignZ2V0RGlzcGxheU1lZGlhIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBzY3JlZW5DYXB0dXJlVG9EaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICBjb25zdCB0cmFja3MgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgICBpZiAodHJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCdubyB2aWRlbyB0cmFjayBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBzY3JlZW5WaWRlbyA9IG5ldyBMb2NhbFZpZGVvVHJhY2sodHJhY2tzWzBdLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICBzY3JlZW5WaWRlby5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmU7XG4gICAgY29uc3QgbG9jYWxUcmFja3MgPSBbc2NyZWVuVmlkZW9dO1xuICAgIGlmIChzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBzY3JlZW5BdWRpbyA9IG5ldyBMb2NhbEF1ZGlvVHJhY2soc3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF0sIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgc2NyZWVuQXVkaW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW87XG4gICAgICBsb2NhbFRyYWNrcy5wdXNoKHNjcmVlbkF1ZGlvKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsVHJhY2tzO1xuICB9KTtcbn1cblxuY2xhc3MgUHVibGlzaEF1ZGlvQ2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiAnQ2FuIHB1Ymxpc2ggYXVkaW8nO1xuICB9XG4gIHBlcmZvcm0oKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCByb29tID0geWllbGQgdGhpcy5jb25uZWN0KCk7XG4gICAgICBjb25zdCB0cmFjayA9IHlpZWxkIGNyZWF0ZUxvY2FsQXVkaW9UcmFjaygpO1xuICAgICAgcm9vbS5sb2NhbFBhcnRpY2lwYW50LnB1Ymxpc2hUcmFjayh0cmFjayk7XG4gICAgICAvLyB3YWl0IGZvciBhIGZldyBzZWNvbmRzIHRvIHB1Ymxpc2hcbiAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDAwKSk7XG4gICAgICAvLyB2ZXJpZnkgUlRDIHN0YXRzIHRoYXQgaXQncyBwdWJsaXNoaW5nXG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIChfYSA9IHRyYWNrLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKCk7XG4gICAgICBpZiAoIXN0YXRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBSVENTdGF0cycpO1xuICAgICAgfVxuICAgICAgbGV0IG51bVBhY2tldHMgPSAwO1xuICAgICAgc3RhdHMuZm9yRWFjaChzdGF0ID0+IHtcbiAgICAgICAgaWYgKHN0YXQudHlwZSA9PT0gJ291dGJvdW5kLXJ0cCcgJiYgc3RhdC5tZWRpYVR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICBudW1QYWNrZXRzID0gc3RhdC5wYWNrZXRzU2VudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAobnVtUGFja2V0cyA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgcGFja2V0cyBhcmUgc2VudCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwicHVibGlzaGVkIFwiLmNvbmNhdChudW1QYWNrZXRzLCBcIiBhdWRpbyBwYWNrZXRzXCIpKTtcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBQdWJsaXNoVmlkZW9DaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdDYW4gcHVibGlzaCB2aWRlbyc7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHJvb20gPSB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgIGNvbnN0IHRyYWNrID0geWllbGQgY3JlYXRlTG9jYWxWaWRlb1RyYWNrKCk7XG4gICAgICByb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKHRyYWNrKTtcbiAgICAgIC8vIHdhaXQgZm9yIGEgZmV3IHNlY29uZHMgdG8gcHVibGlzaFxuICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMDApKTtcbiAgICAgIC8vIHZlcmlmeSBSVEMgc3RhdHMgdGhhdCBpdCdzIHB1Ymxpc2hpbmdcbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgKF9hID0gdHJhY2suc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMoKTtcbiAgICAgIGlmICghc3RhdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IFJUQ1N0YXRzJyk7XG4gICAgICB9XG4gICAgICBsZXQgbnVtUGFja2V0cyA9IDA7XG4gICAgICBzdGF0cy5mb3JFYWNoKHN0YXQgPT4ge1xuICAgICAgICBpZiAoc3RhdC50eXBlID09PSAnb3V0Ym91bmQtcnRwJyAmJiBzdGF0Lm1lZGlhVHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgIG51bVBhY2tldHMgPSBzdGF0LnBhY2tldHNTZW50O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChudW1QYWNrZXRzID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRldGVybWluZSBwYWNrZXRzIGFyZSBzZW50Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJwdWJsaXNoZWQgXCIuY29uY2F0KG51bVBhY2tldHMsIFwiIHZpZGVvIHBhY2tldHNcIikpO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFJlY29ubmVjdENoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ1Jlc3VtaW5nIGNvbm5lY3Rpb24gYWZ0ZXIgaW50ZXJydXB0aW9uJztcbiAgfVxuICBwZXJmb3JtKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3Qgcm9vbSA9IHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgbGV0IHJlY29ubmVjdGluZ1RyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgbGV0IHJlY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICBsZXQgcmVjb25uZWN0UmVzb2x2ZXI7XG4gICAgICBjb25zdCByZWNvbm5lY3RUaW1lb3V0ID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCk7XG4gICAgICAgIHJlY29ubmVjdFJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgICAgcm9vbS5vbihSb29tRXZlbnQuUmVjb25uZWN0aW5nLCAoKSA9PiB7XG4gICAgICAgIHJlY29ubmVjdGluZ1RyaWdnZXJlZCA9IHRydWU7XG4gICAgICB9KS5vbihSb29tRXZlbnQuUmVjb25uZWN0ZWQsICgpID0+IHtcbiAgICAgICAgcmVjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZWNvbm5lY3RSZXNvbHZlcih0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgKF9hID0gcm9vbS5lbmdpbmUuY2xpZW50LndzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAgIGNvbnN0IG9uQ2xvc2UgPSByb29tLmVuZ2luZS5jbGllbnQub25DbG9zZTtcbiAgICAgIGlmIChvbkNsb3NlKSB7XG4gICAgICAgIG9uQ2xvc2UoJycpO1xuICAgICAgfVxuICAgICAgeWllbGQgcmVjb25uZWN0VGltZW91dDtcbiAgICAgIGlmICghcmVjb25uZWN0aW5nVHJpZ2dlcmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGlkIG5vdCBhdHRlbXB0IHRvIHJlY29ubmVjdCcpO1xuICAgICAgfSBlbHNlIGlmICghcmVjb25uZWN0ZWQgfHwgcm9vbS5zdGF0ZSAhPT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ3JlY29ubmVjdGlvbiBpcyBvbmx5IHBvc3NpYmxlIGluIFJlZGlzLWJhc2VkIGNvbmZpZ3VyYXRpb25zJyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGFibGUgdG8gcmVjb25uZWN0Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgVFVSTkNoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ0NhbiBjb25uZWN0IHZpYSBUVVJOJztcbiAgfVxuICBwZXJmb3JtKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHNpZ25hbENsaWVudCA9IG5ldyBTaWduYWxDbGllbnQoKTtcbiAgICAgIGNvbnN0IGpvaW5SZXMgPSB5aWVsZCBzaWduYWxDbGllbnQuam9pbih0aGlzLnVybCwgdGhpcy50b2tlbiwge1xuICAgICAgICBhdXRvU3Vic2NyaWJlOiB0cnVlLFxuICAgICAgICBtYXhSZXRyaWVzOiAwLFxuICAgICAgICBlMmVlRW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHdlYnNvY2tldFRpbWVvdXQ6IDE1MDAwXG4gICAgICB9KTtcbiAgICAgIGxldCBoYXNUTFMgPSBmYWxzZTtcbiAgICAgIGxldCBoYXNUVVJOID0gZmFsc2U7XG4gICAgICBsZXQgaGFzU1RVTiA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaWNlU2VydmVyIG9mIGpvaW5SZXMuaWNlU2VydmVycykge1xuICAgICAgICBmb3IgKGxldCB1cmwgb2YgaWNlU2VydmVyLnVybHMpIHtcbiAgICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ3R1cm46JykpIHtcbiAgICAgICAgICAgIGhhc1RVUk4gPSB0cnVlO1xuICAgICAgICAgICAgaGFzU1RVTiA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICh1cmwuc3RhcnRzV2l0aCgndHVybnM6JykpIHtcbiAgICAgICAgICAgIGhhc1RVUk4gPSB0cnVlO1xuICAgICAgICAgICAgaGFzU1RVTiA9IHRydWU7XG4gICAgICAgICAgICBoYXNUTFMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ3N0dW46JykpIHtcbiAgICAgICAgICAgIGhhc1NUVU4gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFoYXNTVFVOKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnTm8gU1RVTiBzZXJ2ZXJzIGNvbmZpZ3VyZWQgb24gc2VydmVyIHNpZGUuJyk7XG4gICAgICB9IGVsc2UgaWYgKGhhc1RVUk4gJiYgIWhhc1RMUykge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ1RVUk4gaXMgY29uZmlndXJlZCBzZXJ2ZXIgc2lkZSwgYnV0IFRVUk4vVExTIGlzIHVuYXZhaWxhYmxlLicpO1xuICAgICAgfVxuICAgICAgeWllbGQgc2lnbmFsQ2xpZW50LmNsb3NlKCk7XG4gICAgICBpZiAoKChfYiA9IChfYSA9IHRoaXMuY29ubmVjdE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ydGNDb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pY2VTZXJ2ZXJzKSB8fCBoYXNUVVJOKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucm9vbS5jb25uZWN0KHRoaXMudXJsLCB0aGlzLnRva2VuLCB7XG4gICAgICAgICAgcnRjQ29uZmlnOiB7XG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdyZWxheSdcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdObyBUVVJOIHNlcnZlcnMgY29uZmlndXJlZC4nKTtcbiAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgV2ViUlRDQ2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiAnRXN0YWJsaXNoaW5nIFdlYlJUQyBjb25uZWN0aW9uJztcbiAgfVxuICBwZXJmb3JtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsZXQgaGFzVGNwID0gZmFsc2U7XG4gICAgICBsZXQgaGFzSXB2NFVkcCA9IGZhbHNlO1xuICAgICAgdGhpcy5yb29tLm9uKFJvb21FdmVudC5TaWduYWxDb25uZWN0ZWQsICgpID0+IHtcbiAgICAgICAgY29uc3QgcHJldlRyaWNrbGUgPSB0aGlzLnJvb20uZW5naW5lLmNsaWVudC5vblRyaWNrbGU7XG4gICAgICAgIHRoaXMucm9vbS5lbmdpbmUuY2xpZW50Lm9uVHJpY2tsZSA9IChzZCwgdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgaWYgKHNkLmNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbmV3IFJUQ0ljZUNhbmRpZGF0ZShzZCk7XG4gICAgICAgICAgICBsZXQgc3RyID0gXCJcIi5jb25jYXQoY2FuZGlkYXRlLnByb3RvY29sLCBcIiBcIikuY29uY2F0KGNhbmRpZGF0ZS5hZGRyZXNzLCBcIjpcIikuY29uY2F0KGNhbmRpZGF0ZS5wb3J0LCBcIiBcIikuY29uY2F0KGNhbmRpZGF0ZS50eXBlKTtcbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGUuYWRkcmVzcykge1xuICAgICAgICAgICAgICBpZiAoaXNJUFByaXZhdGUoY2FuZGlkYXRlLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICcgKHByaXZhdGUpJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlLnByb3RvY29sID09PSAndGNwJyAmJiBjYW5kaWRhdGUudGNwVHlwZSA9PT0gJ3Bhc3NpdmUnKSB7XG4gICAgICAgICAgICAgICAgICBoYXNUY3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgc3RyICs9ICcgKHBhc3NpdmUpJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5wcm90b2NvbCA9PT0gJ3VkcCcpIHtcbiAgICAgICAgICAgICAgICAgIGhhc0lwdjRVZHAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKHN0cik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2VHJpY2tsZSkge1xuICAgICAgICAgICAgcHJldlRyaWNrbGUoc2QsIHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5yb29tLmVuZ2luZS5wY01hbmFnZXIpIHtcbiAgICAgICAgICB0aGlzLnJvb20uZW5naW5lLnBjTWFuYWdlci5zdWJzY3JpYmVyLm9uSWNlQ2FuZGlkYXRlRXJyb3IgPSBldiA9PiB7XG4gICAgICAgICAgICBpZiAoZXYgaW5zdGFuY2VvZiBSVENQZWVyQ29ubmVjdGlvbkljZUVycm9yRXZlbnQpIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKFwiZXJyb3Igd2l0aCBJQ0UgY2FuZGlkYXRlOiBcIi5jb25jYXQoZXYuZXJyb3JDb2RlLCBcIiBcIikuY29uY2F0KGV2LmVycm9yVGV4dCwgXCIgXCIpLmNvbmNhdChldi51cmwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmluZm8oJ25vdyB0aGUgcm9vbSBpcyBjb25uZWN0ZWQnKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ3BvcnRzIG5lZWQgdG8gYmUgb3BlbiBvbiBmaXJld2FsbCBpbiBvcmRlciB0byBjb25uZWN0LicpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc1RjcCkge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ1NlcnZlciBpcyBub3QgY29uZmlndXJlZCBmb3IgSUNFL1RDUCcpO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNJcHY0VWRwKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnTm8gcHVibGljIElQdjQgVURQIGNhbmRpZGF0ZXMgd2VyZSBmb3VuZC4gWW91ciBzZXJ2ZXIgaXMgbGlrZWx5IG5vdCBjb25maWd1cmVkIGNvcnJlY3RseScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBpc0lQUHJpdmF0ZShhZGRyZXNzKSB7XG4gIGNvbnN0IHBhcnRzID0gYWRkcmVzcy5zcGxpdCgnLicpO1xuICBpZiAocGFydHMubGVuZ3RoID09PSA0KSB7XG4gICAgaWYgKHBhcnRzWzBdID09PSAnMTAnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBhcnRzWzBdID09PSAnMTkyJyAmJiBwYXJ0c1sxXSA9PT0gJzE2OCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocGFydHNbMF0gPT09ICcxNzInKSB7XG4gICAgICBjb25zdCBzZWNvbmQgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApO1xuICAgICAgaWYgKHNlY29uZCA+PSAxNiAmJiBzZWNvbmQgPD0gMzEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuY2xhc3MgV2ViU29ja2V0Q2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiAnQ29ubmVjdGluZyB0byBzaWduYWwgY29ubmVjdGlvbiB2aWEgV2ViU29ja2V0JztcbiAgfVxuICBwZXJmb3JtKCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy51cmwuc3RhcnRzV2l0aCgnd3M6JykgfHwgdGhpcy51cmwuc3RhcnRzV2l0aCgnaHR0cDonKSkge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ1NlcnZlciBpcyBpbnNlY3VyZSwgY2xpZW50cyBtYXkgYmxvY2sgY29ubmVjdGlvbnMgdG8gaXQnKTtcbiAgICAgIH1cbiAgICAgIGxldCBzaWduYWxDbGllbnQgPSBuZXcgU2lnbmFsQ2xpZW50KCk7XG4gICAgICBjb25zdCBqb2luUmVzID0geWllbGQgc2lnbmFsQ2xpZW50LmpvaW4odGhpcy51cmwsIHRoaXMudG9rZW4sIHtcbiAgICAgICAgYXV0b1N1YnNjcmliZTogdHJ1ZSxcbiAgICAgICAgbWF4UmV0cmllczogMCxcbiAgICAgICAgZTJlZUVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB3ZWJzb2NrZXRUaW1lb3V0OiAxNTAwMFxuICAgICAgfSk7XG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJDb25uZWN0ZWQgdG8gc2VydmVyLCB2ZXJzaW9uIFwiLmNvbmNhdChqb2luUmVzLnNlcnZlclZlcnNpb24sIFwiLlwiKSk7XG4gICAgICBpZiAoKChfYSA9IGpvaW5SZXMuc2VydmVySW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVkaXRpb24pID09PSBTZXJ2ZXJJbmZvX0VkaXRpb24uQ2xvdWQgJiYgKChfYiA9IGpvaW5SZXMuc2VydmVySW5mbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlZ2lvbikpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwiTGl2ZUtpdCBDbG91ZDogXCIuY29uY2F0KChfYyA9IGpvaW5SZXMuc2VydmVySW5mbykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlZ2lvbikpO1xuICAgICAgfVxuICAgICAgeWllbGQgc2lnbmFsQ2xpZW50LmNsb3NlKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgQ29ubmVjdGlvbkNoZWNrIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwsIHRva2VuKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNoZWNrUmVzdWx0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gIH1cbiAgZ2V0TmV4dENoZWNrSWQoKSB7XG4gICAgY29uc3QgbmV4dElkID0gdGhpcy5jaGVja1Jlc3VsdHMuc2l6ZTtcbiAgICB0aGlzLmNoZWNrUmVzdWx0cy5zZXQobmV4dElkLCB7XG4gICAgICBsb2dzOiBbXSxcbiAgICAgIHN0YXR1czogQ2hlY2tTdGF0dXMuSURMRSxcbiAgICAgIG5hbWU6ICcnLFxuICAgICAgZGVzY3JpcHRpb246ICcnXG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHRJZDtcbiAgfVxuICB1cGRhdGVDaGVjayhjaGVja0lkLCBpbmZvKSB7XG4gICAgdGhpcy5jaGVja1Jlc3VsdHMuc2V0KGNoZWNrSWQsIGluZm8pO1xuICAgIHRoaXMuZW1pdCgnY2hlY2tVcGRhdGUnLCBjaGVja0lkLCBpbmZvKTtcbiAgfVxuICBpc1N1Y2Nlc3MoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jaGVja1Jlc3VsdHMudmFsdWVzKCkpLmV2ZXJ5KHIgPT4gci5zdGF0dXMgIT09IENoZWNrU3RhdHVzLkZBSUxFRCk7XG4gIH1cbiAgZ2V0UmVzdWx0cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNoZWNrUmVzdWx0cy52YWx1ZXMoKSk7XG4gIH1cbiAgY3JlYXRlQW5kUnVuQ2hlY2soY2hlY2spIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgY2hlY2tJZCA9IHRoaXMuZ2V0TmV4dENoZWNrSWQoKTtcbiAgICAgIGNvbnN0IHRlc3QgPSBuZXcgY2hlY2sodGhpcy51cmwsIHRoaXMudG9rZW4pO1xuICAgICAgY29uc3QgaGFuZGxlVXBkYXRlID0gaW5mbyA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hlY2soY2hlY2tJZCwgaW5mbyk7XG4gICAgICB9O1xuICAgICAgdGVzdC5vbigndXBkYXRlJywgaGFuZGxlVXBkYXRlKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRlc3QucnVuKCk7XG4gICAgICB0ZXN0Lm9mZigndXBkYXRlJywgaGFuZGxlVXBkYXRlKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tXZWJzb2NrZXQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFdlYlNvY2tldENoZWNrKTtcbiAgICB9KTtcbiAgfVxuICBjaGVja1dlYlJUQygpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soV2ViUlRDQ2hlY2spO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrVFVSTigpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soVFVSTkNoZWNrKTtcbiAgICB9KTtcbiAgfVxuICBjaGVja1JlY29ubmVjdCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soUmVjb25uZWN0Q2hlY2spO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrUHVibGlzaEF1ZGlvKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhQdWJsaXNoQXVkaW9DaGVjayk7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tQdWJsaXNoVmlkZW8oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFB1Ymxpc2hWaWRlb0NoZWNrKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFRyeSB0byBhbmFseXplIHRoZSBsb2NhbCB0cmFjayB0byBkZXRlcm1pbmUgdGhlIGZhY2luZyBtb2RlIG9mIGEgdHJhY2suXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZXJlIGlzIG5vIHByb3BlcnR5IHN1cHBvcnRlZCBieSBhbGwgYnJvd3NlcnMgdG8gZGV0ZWN0IHdoZXRoZXIgYSB2aWRlbyB0cmFjayBvcmlnaW5hdGVkIGZyb20gYSB1c2VyLSBvciBlbnZpcm9ubWVudC1mYWNpbmcgY2FtZXJhIGRldmljZS5cbiAqIEZvciB0aGlzIHJlYXNvbiwgd2UgdXNlIHRoZSBgZmFjaW5nTW9kZWAgcHJvcGVydHkgd2hlbiBhdmFpbGFibGUsIGJ1dCB3aWxsIGZhbGwgYmFjayBvbiBhIHN0cmluZy1iYXNlZCBhbmFseXNpcyBvZiB0aGUgZGV2aWNlIGxhYmVsIHRvIGRldGVybWluZSB0aGUgZmFjaW5nIG1vZGUuXG4gKiBJZiBib3RoIG1ldGhvZHMgZmFpbCwgdGhlIGRlZmF1bHQgZmFjaW5nIG1vZGUgd2lsbCBiZSB1c2VkLlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVRyYWNrQ29uc3RyYWludHMvZmFjaW5nTW9kZSB8IE1ETiBkb2NzIG9uIGZhY2luZ01vZGV9XG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmZ1bmN0aW9uIGZhY2luZ01vZGVGcm9tTG9jYWxUcmFjayhsb2NhbFRyYWNrKSB7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIF9hO1xuICBjb25zdCB0cmFjayA9IGxvY2FsVHJhY2sgaW5zdGFuY2VvZiBMb2NhbFRyYWNrID8gbG9jYWxUcmFjay5tZWRpYVN0cmVhbVRyYWNrIDogbG9jYWxUcmFjaztcbiAgY29uc3QgdHJhY2tTZXR0aW5ncyA9IHRyYWNrLmdldFNldHRpbmdzKCk7XG4gIGxldCByZXN1bHQgPSB7XG4gICAgZmFjaW5nTW9kZTogKF9hID0gb3B0aW9ucy5kZWZhdWx0RmFjaW5nTW9kZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3VzZXInLFxuICAgIGNvbmZpZGVuY2U6ICdsb3cnXG4gIH07XG4gIC8vIDEuIFRyeSB0byBnZXQgZmFjaW5nTW9kZSBmcm9tIHRyYWNrIHNldHRpbmdzLlxuICBpZiAoJ2ZhY2luZ01vZGUnIGluIHRyYWNrU2V0dGluZ3MpIHtcbiAgICBjb25zdCByYXdGYWNpbmdNb2RlID0gdHJhY2tTZXR0aW5ncy5mYWNpbmdNb2RlO1xuICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3Jhd0ZhY2luZ01vZGUnLCB7XG4gICAgICByYXdGYWNpbmdNb2RlXG4gICAgfSk7XG4gICAgaWYgKHJhd0ZhY2luZ01vZGUgJiYgdHlwZW9mIHJhd0ZhY2luZ01vZGUgPT09ICdzdHJpbmcnICYmIGlzRmFjaW5nTW9kZVZhbHVlKHJhd0ZhY2luZ01vZGUpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIGZhY2luZ01vZGU6IHJhd0ZhY2luZ01vZGUsXG4gICAgICAgIGNvbmZpZGVuY2U6ICdoaWdoJ1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLy8gMi4gSWYgd2UgZG9uJ3QgaGF2ZSBhIGhpZ2ggY29uZmlkZW5jZSB3ZSB0cnkgdG8gZ2V0IHRoZSBmYWNpbmcgbW9kZSBmcm9tIHRoZSBkZXZpY2UgbGFiZWwuXG4gIGlmIChbJ2xvdycsICdtZWRpdW0nXS5pbmNsdWRlcyhyZXN1bHQuY29uZmlkZW5jZSkpIHtcbiAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwiVHJ5IHRvIGdldCBmYWNpbmcgbW9kZSBmcm9tIGRldmljZSBsYWJlbDogKFwiLmNvbmNhdCh0cmFjay5sYWJlbCwgXCIpXCIpKTtcbiAgICBjb25zdCBsYWJlbEFuYWx5c2lzUmVzdWx0ID0gZmFjaW5nTW9kZUZyb21EZXZpY2VMYWJlbCh0cmFjay5sYWJlbCk7XG4gICAgaWYgKGxhYmVsQW5hbHlzaXNSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0ID0gbGFiZWxBbmFseXNpc1Jlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGtub3duRGV2aWNlTGFiZWxzID0gbmV3IE1hcChbWydvYnMgdmlydHVhbCBjYW1lcmEnLCB7XG4gIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsXG4gIGNvbmZpZGVuY2U6ICdtZWRpdW0nXG59XV0pO1xuY29uc3Qga25vd25EZXZpY2VMYWJlbFNlY3Rpb25zID0gbmV3IE1hcChbWydpcGhvbmUnLCB7XG4gIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsXG4gIGNvbmZpZGVuY2U6ICdtZWRpdW0nXG59XSwgWydpcGFkJywge1xuICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLFxuICBjb25maWRlbmNlOiAnbWVkaXVtJ1xufV1dKTtcbi8qKlxuICogQXR0ZW1wdCB0byBhbmFseXplIHRoZSBkZXZpY2UgbGFiZWwgdG8gZGV0ZXJtaW5lIHRoZSBmYWNpbmcgbW9kZS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmZ1bmN0aW9uIGZhY2luZ01vZGVGcm9tRGV2aWNlTGFiZWwoZGV2aWNlTGFiZWwpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBsYWJlbCA9IGRldmljZUxhYmVsLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAvLyBFbXB0eSBzdHJpbmcgaXMgYSB2YWxpZCBkZXZpY2UgbGFiZWwgYnV0IHdlIGNhbid0IGluZmVyIGFueXRoaW5nIGZyb20gaXQuXG4gIGlmIChsYWJlbCA9PT0gJycpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIC8vIENhbiB3ZSBtYXRjaCBhZ2FpbnN0IHdpZGVseSBrbm93biBkZXZpY2UgbGFiZWxzLlxuICBpZiAoa25vd25EZXZpY2VMYWJlbHMuaGFzKGxhYmVsKSkge1xuICAgIHJldHVybiBrbm93bkRldmljZUxhYmVscy5nZXQobGFiZWwpO1xuICB9XG4gIC8vIENhbiB3ZSBtYXRjaCBhZ2FpbnN0IHNlY3Rpb25zIG9mIHRoZSBkZXZpY2UgbGFiZWwuXG4gIHJldHVybiAoX2EgPSBBcnJheS5mcm9tKGtub3duRGV2aWNlTGFiZWxTZWN0aW9ucy5lbnRyaWVzKCkpLmZpbmQoX3JlZiA9PiB7XG4gICAgbGV0IFtzZWN0aW9uXSA9IF9yZWY7XG4gICAgcmV0dXJuIGxhYmVsLmluY2x1ZGVzKHNlY3Rpb24pO1xuICB9KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzFdO1xufVxuZnVuY3Rpb24gaXNGYWNpbmdNb2RlVmFsdWUoaXRlbSkge1xuICBjb25zdCBhbGxvd2VkVmFsdWVzID0gWyd1c2VyJywgJ2Vudmlyb25tZW50JywgJ2xlZnQnLCAncmlnaHQnXTtcbiAgcmV0dXJuIGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBhbGxvd2VkVmFsdWVzLmluY2x1ZGVzKGl0ZW0pO1xufVxuXG5leHBvcnQgeyBBdWRpb1ByZXNldHMsIEJhc2VLZXlQcm92aWRlciwgQ29ubmVjdGlvbkNoZWNrLCBDb25uZWN0aW9uRXJyb3IsIENvbm5lY3Rpb25RdWFsaXR5LCBDb25uZWN0aW9uU3RhdGUsIENyaXRpY2FsVGltZXJzLCBDcnlwdG9yRXZlbnQsIERhdGFQYWNrZXRfS2luZCwgRGVmYXVsdFJlY29ubmVjdFBvbGljeSwgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvciwgRGlzY29ubmVjdFJlYXNvbiwgRW5jcnlwdGlvbkV2ZW50LCBFbmdpbmVFdmVudCwgRXh0ZXJuYWxFMkVFS2V5UHJvdmlkZXIsIEtleUhhbmRsZXJFdmVudCwgS2V5UHJvdmlkZXJFdmVudCwgTGl2ZWtpdEVycm9yLCBMb2NhbEF1ZGlvVHJhY2ssIExvY2FsUGFydGljaXBhbnQsIExvY2FsVHJhY2ssIExvY2FsVHJhY2tQdWJsaWNhdGlvbiwgTG9jYWxWaWRlb1RyYWNrLCBMb2dMZXZlbCwgTWVkaWFEZXZpY2VGYWlsdXJlLCBOZWdvdGlhdGlvbkVycm9yLCBQYXJ0aWNpcGFudCwgUGFydGljaXBhbnRFdmVudCwgUHVibGlzaERhdGFFcnJvciwgUmVtb3RlQXVkaW9UcmFjaywgUmVtb3RlUGFydGljaXBhbnQsIFJlbW90ZVRyYWNrLCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uLCBSZW1vdGVWaWRlb1RyYWNrLCBSb29tLCBSb29tRXZlbnQsIFJvb21TdGF0ZSwgU2NyZWVuU2hhcmVQcmVzZXRzLCBUcmFjaywgVHJhY2tFdmVudCwgVHJhY2tJbnZhbGlkRXJyb3IsIFRyYWNrUHVibGljYXRpb24sIFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUsIFVuc3VwcG9ydGVkU2VydmVyLCBWaWRlb1ByZXNldCwgVmlkZW9QcmVzZXRzLCBWaWRlb1ByZXNldHM0MywgVmlkZW9RdWFsaXR5LCBhdHRhY2hUb0VsZW1lbnQsIGNyZWF0ZUF1ZGlvQW5hbHlzZXIsIGNyZWF0ZUUyRUVLZXksIGNyZWF0ZUtleU1hdGVyaWFsRnJvbUJ1ZmZlciwgY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nLCBjcmVhdGVMb2NhbEF1ZGlvVHJhY2ssIGNyZWF0ZUxvY2FsU2NyZWVuVHJhY2tzLCBjcmVhdGVMb2NhbFRyYWNrcywgY3JlYXRlTG9jYWxWaWRlb1RyYWNrLCBkZXJpdmVLZXlzLCBkZXRhY2hUcmFjaywgZmFjaW5nTW9kZUZyb21EZXZpY2VMYWJlbCwgZmFjaW5nTW9kZUZyb21Mb2NhbFRyYWNrLCBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2ssIGdldEVtcHR5VmlkZW9TdHJlYW1UcmFjaywgZ2V0TG9nZ2VyLCBpbXBvcnRLZXksIGlzQmFja3VwQ29kZWMsIGlzQnJvd3NlclN1cHBvcnRlZCwgaXNFMkVFU3VwcG9ydGVkLCBpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQsIGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkLCBpc1ZpZGVvRnJhbWUsIG5lZWRzUmJzcFVuZXNjYXBpbmcsIHBhcnNlUmJzcCwgcHJvdG9jb2xWZXJzaW9uLCByYXRjaGV0LCBzZXRMb2dFeHRlbnNpb24sIHNldExvZ0xldmVsLCBzdXBwb3J0c0FWMSwgc3VwcG9ydHNBZGFwdGl2ZVN0cmVhbSwgc3VwcG9ydHNEeW5hY2FzdCwgc3VwcG9ydHNWUDksIHZlcnNpb24sIHZpZGVvQ29kZWNzLCB3cml0ZVJic3AgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpdmVraXQtY2xpZW50LmVzbS5tanMubWFwXG4iXSwibmFtZXMiOlsiX21lcmdlTmFtZXNwYWNlcyIsIm4iLCJtIiwiZm9yRWFjaCIsImUiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJrZXlzIiwiayIsImQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImVudW1lcmFibGUiLCJmcmVlemUiLCJjb21tb25qc0dsb2JhbCIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwiZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMiLCJ4IiwiX19lc01vZHVsZSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImxvZ2xldmVsIiwiZXhwb3J0cyIsIm1vZHVsZSIsInJvb3QiLCJkZWZpbml0aW9uIiwibG9nIiwibm9vcCIsInVuZGVmaW5lZFR5cGUiLCJpc0lFIiwibmF2aWdhdG9yIiwidGVzdCIsInVzZXJBZ2VudCIsImxvZ01ldGhvZHMiLCJiaW5kTWV0aG9kIiwib2JqIiwibWV0aG9kTmFtZSIsIm1ldGhvZCIsImJpbmQiLCJGdW5jdGlvbiIsImFwcGx5IiwiYXJndW1lbnRzIiwidHJhY2VGb3JJRSIsImNvbnNvbGUiLCJ0cmFjZSIsInJlYWxNZXRob2QiLCJ1bmRlZmluZWQiLCJyZXBsYWNlTG9nZ2luZ01ldGhvZHMiLCJsZXZlbCIsImxvZ2dlck5hbWUiLCJpIiwibGVuZ3RoIiwibWV0aG9kRmFjdG9yeSIsImRlYnVnIiwiZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyIsImRlZmF1bHRNZXRob2RGYWN0b3J5IiwiTG9nZ2VyIiwibmFtZSIsImRlZmF1bHRMZXZlbCIsImZhY3RvcnkiLCJjdXJyZW50TGV2ZWwiLCJzdG9yYWdlS2V5IiwicGVyc2lzdExldmVsSWZQb3NzaWJsZSIsImxldmVsTnVtIiwibGV2ZWxOYW1lIiwidG9VcHBlckNhc2UiLCJsb2NhbFN0b3JhZ2UiLCJpZ25vcmUiLCJkb2N1bWVudCIsImNvb2tpZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImdldFBlcnNpc3RlZExldmVsIiwic3RvcmVkTGV2ZWwiLCJsb2NhdGlvbiIsImluZGV4T2YiLCJleGVjIiwic2xpY2UiLCJsZXZlbHMiLCJjbGVhclBlcnNpc3RlZExldmVsIiwicmVtb3ZlSXRlbSIsImdldExldmVsIiwic2V0TGV2ZWwiLCJwZXJzaXN0IiwiU0lMRU5UIiwic2V0RGVmYXVsdExldmVsIiwicmVzZXRMZXZlbCIsImVuYWJsZUFsbCIsIlRSQUNFIiwiZGlzYWJsZUFsbCIsImluaXRpYWxMZXZlbCIsImRlZmF1bHRMb2dnZXIiLCJfbG9nZ2Vyc0J5TmFtZSIsImdldExvZ2dlciIsIlR5cGVFcnJvciIsImxvZ2dlciIsIl9sb2ciLCJub0NvbmZsaWN0IiwiZ2V0TG9nZ2VycyIsImxvZ2xldmVsRXhwb3J0cyIsIkxvZ0xldmVsIiwiTG9nZ2VyTmFtZXMiLCJsaXZla2l0TG9nZ2VyIiwiaW5mbyIsInNldExvZ0xldmVsIiwiZW50cmllcyIsImZpbHRlciIsIl9yZWYiLCJsb2dyTmFtZSIsInN0YXJ0c1dpdGgiLCJtYXAiLCJfcmVmMiIsImxvZ3IiLCJzZXRMb2dFeHRlbnNpb24iLCJleHRlbnNpb24iLCJvcmlnaW5hbEZhY3RvcnkiLCJjb25maWdMZXZlbCIsInJhd01ldGhvZCIsImxvZ0xldmVsIiwibmVlZExvZyIsInNpbGVudCIsIm1zZyIsImNvbnRleHQiLCJhc3NlcnQiLCJjb25kaXRpb24iLCJFcnJvciIsIkZMT0FUMzJfTUFYIiwiRkxPQVQzMl9NSU4iLCJVSU5UMzJfTUFYIiwiSU5UMzJfTUFYIiwiSU5UMzJfTUlOIiwiYXNzZXJ0SW50MzIiLCJhcmciLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJhc3NlcnRVSW50MzIiLCJhc3NlcnRGbG9hdDMyIiwiaXNGaW5pdGUiLCJlbnVtVHlwZVN5bWJvbCIsIlN5bWJvbCIsImdldEVudW1UeXBlIiwiZW51bU9iamVjdCIsInQiLCJzZXRFbnVtVHlwZSIsInR5cGVOYW1lIiwidmFsdWVzIiwib3B0IiwibWFrZUVudW1UeXBlIiwidiIsIm5vIiwibG9jYWxOYW1lIiwiX29wdCIsIm5hbWVzIiwiY3JlYXRlIiwibnVtYmVycyIsIm5vcm1hbFZhbHVlcyIsInZhbHVlIiwibm9ybWFsaXplRW51bVZhbHVlIiwicHVzaCIsImZpbmROYW1lIiwiZmluZE51bWJlciIsIm1ha2VFbnVtIiwiYXNzaWduIiwiTWVzc2FnZSIsImVxdWFscyIsIm90aGVyIiwiZ2V0VHlwZSIsInJ1bnRpbWUiLCJ1dGlsIiwiY2xvbmUiLCJmcm9tQmluYXJ5IiwiYnl0ZXMiLCJvcHRpb25zIiwidHlwZSIsImZvcm1hdCIsImJpbiIsIm1ha2VSZWFkT3B0aW9ucyIsInJlYWRNZXNzYWdlIiwicmVhZGVyRmFjdG9yeSIsImJ5dGVMZW5ndGgiLCJmcm9tSnNvbiIsImpzb25WYWx1ZSIsImpzb24iLCJmcm9tSnNvblN0cmluZyIsImpzb25TdHJpbmciLCJKU09OIiwicGFyc2UiLCJjb25jYXQiLCJtZXNzYWdlIiwiU3RyaW5nIiwidG9CaW5hcnkiLCJtYWtlV3JpdGVPcHRpb25zIiwid3JpdGVyIiwid3JpdGVyRmFjdG9yeSIsIndyaXRlTWVzc2FnZSIsImZpbmlzaCIsInRvSnNvbiIsInRvSnNvblN0cmluZyIsIl9hIiwic3RyaW5naWZ5IiwicHJldHR5U3BhY2VzIiwidG9KU09OIiwiZW1pdERlZmF1bHRWYWx1ZXMiLCJnZXRQcm90b3R5cGVPZiIsImNvbnN0cnVjdG9yIiwibWFrZU1lc3NhZ2VUeXBlIiwiZmllbGRzIiwic3Vic3RyaW5nIiwibGFzdEluZGV4T2YiLCJkYXRhIiwiaW5pdEZpZWxkcyIsImluaXRQYXJ0aWFsIiwic2V0UHJvdG90eXBlT2YiLCJuZXdGaWVsZExpc3QiLCJhIiwiYiIsIm1ha2VQcm90b1J1bnRpbWUiLCJzeW50YXgiLCJTY2FsYXJUeXBlIiwiTG9uZ1R5cGUiLCJ2YXJpbnQ2NHJlYWQiLCJsb3dCaXRzIiwiaGlnaEJpdHMiLCJzaGlmdCIsImJ1ZiIsInBvcyIsImFzc2VydEJvdW5kcyIsIm1pZGRsZUJ5dGUiLCJ2YXJpbnQ2NHdyaXRlIiwibG8iLCJoaSIsImhhc05leHQiLCJieXRlIiwic3BsaXRCaXRzIiwiaGFzTW9yZUJpdHMiLCJUV09fUFdSXzMyX0RCTCIsImludDY0RnJvbVN0cmluZyIsImRlYyIsIm1pbnVzIiwiYmFzZSIsImFkZDFlNmRpZ2l0IiwiYmVnaW4iLCJlbmQiLCJkaWdpdDFlNiIsIm5lZ2F0ZSIsIm5ld0JpdHMiLCJpbnQ2NFRvU3RyaW5nIiwiYml0cyIsIm5lZ2F0aXZlIiwicmVzdWx0IiwidUludDY0VG9TdHJpbmciLCJ0b1Vuc2lnbmVkIiwibG93IiwibWlkIiwiaGlnaCIsImRpZ2l0QSIsImRpZ2l0QiIsImRpZ2l0QyIsIk1hdGgiLCJmbG9vciIsInRvU3RyaW5nIiwiZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zIiwiZGlnaXQxZTciLCJwYXJ0aWFsIiwidmFyaW50MzJ3cml0ZSIsInZhcmludDMycmVhZCIsInJlYWRCeXRlcyIsIm1ha2VJbnQ2NFN1cHBvcnQiLCJkdiIsIkRhdGFWaWV3IiwiQXJyYXlCdWZmZXIiLCJvayIsIkJpZ0ludCIsImdldEJpZ0ludDY0IiwiZ2V0QmlnVWludDY0Iiwic2V0QmlnSW50NjQiLCJzZXRCaWdVaW50NjQiLCJwcm9jZXNzIiwiZW52IiwiQlVGX0JJR0lOVF9ESVNBQkxFIiwiTUlOIiwiTUFYIiwiVU1JTiIsIlVNQVgiLCJ6ZXJvIiwic3VwcG9ydGVkIiwiYmkiLCJ1UGFyc2UiLCJlbmMiLCJnZXRJbnQzMiIsInVFbmMiLCJzZXRJbnQzMiIsInVEZWMiLCJhc3NlcnRJbnQ2NFN0cmluZyIsImFzc2VydFVJbnQ2NFN0cmluZyIsInByb3RvSW50NjQiLCJXaXJlVHlwZSIsIkJpbmFyeVdyaXRlciIsInRleHRFbmNvZGVyIiwic3RhY2siLCJUZXh0RW5jb2RlciIsImNodW5rcyIsIlVpbnQ4QXJyYXkiLCJsZW4iLCJvZmZzZXQiLCJzZXQiLCJmb3JrIiwiam9pbiIsImNodW5rIiwicHJldiIsInBvcCIsInVpbnQzMiIsInJhdyIsInRhZyIsImZpZWxkTm8iLCJpbnQzMiIsImJvb2wiLCJzdHJpbmciLCJlbmNvZGUiLCJmbG9hdCIsImJ1ZmZlciIsInNldEZsb2F0MzIiLCJkb3VibGUiLCJzZXRGbG9hdDY0IiwiZml4ZWQzMiIsInNldFVpbnQzMiIsInNmaXhlZDMyIiwic2ludDMyIiwic2ZpeGVkNjQiLCJ2aWV3IiwidGMiLCJmaXhlZDY0IiwiaW50NjQiLCJzaW50NjQiLCJzaWduIiwidWludDY0IiwiQmluYXJ5UmVhZGVyIiwidGV4dERlY29kZXIiLCJ2YXJpbnQ2NCIsImJ5dGVPZmZzZXQiLCJUZXh0RGVjb2RlciIsIndpcmVUeXBlIiwic2tpcCIsInN0YXJ0IiwiVmFyaW50IiwiQml0NjQiLCJCaXQzMiIsIkxlbmd0aERlbGltaXRlZCIsIlN0YXJ0R3JvdXAiLCJFbmRHcm91cCIsInN1YmFycmF5IiwiUmFuZ2VFcnJvciIsInp6ZSIsInMiLCJnZXRVaW50MzIiLCJnZXRGbG9hdDMyIiwiZ2V0RmxvYXQ2NCIsImRlY29kZSIsIndyYXBGaWVsZCIsImZpZWxkV3JhcHBlciIsIkRPVUJMRSIsIkZMT0FUIiwiSU5UNjQiLCJVSU5UNjQiLCJJTlQzMiIsIlVJTlQzMiIsIkJPT0wiLCJTVFJJTkciLCJCWVRFUyIsInNjYWxhckVxdWFscyIsIkZJWEVENjQiLCJTRklYRUQ2NCIsIlNJTlQ2NCIsInNjYWxhckRlZmF1bHRWYWx1ZSIsImxvbmdUeXBlIiwic2NhbGFyVHlwZUluZm8iLCJpc1VuZGVmaW5lZCIsImlzSW50cmluc2ljRGVmYXVsdCIsIkZJWEVEMzIiLCJTRklYRUQzMiIsInRvTG93ZXJDYXNlIiwidW5rbm93bkZpZWxkc1N5bWJvbCIsInJlYWREZWZhdWx0cyIsInJlYWRVbmtub3duRmllbGRzIiwid3JpdGVEZWZhdWx0cyIsIndyaXRlVW5rbm93bkZpZWxkcyIsIm1ha2VSZWFkT3B0aW9ucyQxIiwibWFrZVdyaXRlT3B0aW9ucyQxIiwibWFrZUJpbmFyeUZvcm1hdENvbW1vbiIsImxpc3RVbmtub3duRmllbGRzIiwiZGlzY2FyZFVua25vd25GaWVsZHMiLCJjIiwiZiIsIm9uVW5rbm93bkZpZWxkIiwicmVhZGVyIiwiZmllbGQiLCJmaW5kIiwidGFyZ2V0IiwicmVwZWF0ZWQiLCJvbmVvZiIsImNhc2UiLCJraW5kIiwic2NhbGFyVHlwZSIsIlQiLCJyZWFkIiwicmVhZFNjYWxhciQxIiwiTCIsInJlYWRTY2FsYXJMVFN0cmluZyIsImFyciIsIm1lc3NhZ2VUeXBlIiwicmVhZE1lc3NhZ2VGaWVsZCIsInVud3JhcEZpZWxkIiwibWFwS2V5IiwibWFwVmFsIiwicmVhZE1hcEVudHJ5Iiwia2V5IiwidmFsIiwiSyIsIlYiLCJrZXlSYXciLCJCSUdJTlQiLCJTSU5UMzIiLCJ3cml0ZU1hcEVudHJ5Iiwia2V5VmFsdWUiLCJwYXJzZUludCIsIndyaXRlU2NhbGFyJDEiLCJ3cml0ZU1lc3NhZ2VGaWVsZCIsImVtaXRJbnRyaW5zaWNEZWZhdWx0Iiwid3JpdGVQYWNrZWQiLCJtYWtlQmluYXJ5Rm9ybWF0UHJvdG8zIiwiYnlOdW1iZXIiLCJwYWNrZWQiLCJpdGVtIiwiZW5jVGFibGUiLCJzcGxpdCIsImRlY1RhYmxlIiwiY2hhckNvZGVBdCIsInByb3RvQmFzZTY0IiwiYmFzZTY0U3RyIiwiZXMiLCJieXRlUG9zIiwiZ3JvdXBQb3MiLCJwIiwiYmFzZTY0IiwianNvblJlYWREZWZhdWx0cyIsImlnbm9yZVVua25vd25GaWVsZHMiLCJqc29uV3JpdGVEZWZhdWx0cyIsImVudW1Bc0ludGVnZXIiLCJ1c2VQcm90b0ZpZWxkTmFtZSIsIm1ha2VKc29uRm9ybWF0Q29tbW9uIiwibWFrZVdyaXRlRmllbGQiLCJ3cml0ZUZpZWxkIiwid3JpdGVFbnVtIiwid3JpdGVTY2FsYXIiLCJvbmVvZlNlZW4iLCJqc29uS2V5IiwiZmluZEpzb25OYW1lIiwic2VlbiIsInRhcmdldEFycmF5IiwianNvbkl0ZW0iLCJyZWFkRW51bSIsInJlYWRTY2FsYXIiLCJ0YXJnZXRNYXAiLCJqc29uTWFwS2V5IiwianNvbk1hcFZhbHVlIiwiZW51bVZhbHVlIiwibWVtYmVyIiwiYnlNZW1iZXIiLCJmaW5kRmllbGQiLCJqc29uTmFtZSIsInIiLCJkZWJ1Z0pzb25WYWx1ZSIsIk5hTiIsIlBPU0lUSVZFX0lORklOSVRZIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJ0cmltIiwiaXNOYU4iLCJsb25nIiwidUxvbmciLCJtYWtlSnNvbkZvcm1hdFByb3RvMyIsImpzb25PYmoiLCJlbnRyeUtleSIsImVudHJ5VmFsdWUiLCJlbnVtVHlwZSIsImpzb25BcnIiLCJtYWtlVXRpbENvbW1vbiIsInNvdXJjZSIsInNrIiwic291cmNlRmllbGQiLCJ0b1U4QXJyIiwiY29weSIsIm10IiwiZXZlcnkiLCJ2YSIsInZiIiwiYW55IiwiY2xvbmVTaW5ndWxhckZpZWxkIiwiaW5wdXQiLCJJbnRlcm5hbEZpZWxkTGlzdCIsIm5vcm1hbGl6ZXIiLCJfZmllbGRzIiwiX25vcm1hbGl6ZXIiLCJqc29uTmFtZXMiLCJsaXN0IiwiYWxsIiwibnVtYmVyc0FzYyIsInNvcnQiLCJtZW1iZXJzIiwibyIsImxvY2FsRmllbGROYW1lIiwicHJvdG9OYW1lIiwiaW5PbmVvZiIsInByb3RvQ2FtZWxDYXNlIiwic2FmZU9iamVjdFByb3BlcnR5Iiwic2FmZU1lc3NhZ2VQcm9wZXJ0eSIsImxvY2FsT25lb2ZOYW1lIiwiZmllbGRKc29uTmFtZSIsInNuYWtlQ2FzZSIsImNhcE5leHQiLCJjaGFyQXQiLCJyZXNlcnZlZE9iamVjdFByb3BlcnRpZXMiLCJTZXQiLCJyZXNlcnZlZE1lc3NhZ2VQcm9wZXJ0aWVzIiwiZmFsbGJhY2siLCJoYXMiLCJJbnRlcm5hbE9uZW9mSW5mbyIsImRlZmF1bHQiLCJhZGRGaWVsZCIsIl9sb29rdXAiLCJwcm90bzMiLCJub3JtYWxpemVGaWVsZEluZm9zUHJvdG8zIiwiZmllbGRJbmZvcyIsIl9iIiwiX2MiLCJfZCIsIm9vbmFtZSIsIlRpbWVzdGFtcCIsInNlY29uZHMiLCJuYW5vcyIsIm1hdGNoZXMiLCJtYXRjaCIsIm1zIiwiRGF0ZSIsInJlcGVhdCIsInoiLCJuYW5vc1N0ciIsInRvSVNPU3RyaW5nIiwicmVwbGFjZSIsInRvRGF0ZSIsImNlaWwiLCJub3ciLCJmcm9tRGF0ZSIsImRhdGUiLCJnZXRUaW1lIiwiQXVkaW9Db2RlYyIsIlZpZGVvQ29kZWMiLCJJbWFnZUNvZGVjIiwiVHJhY2tUeXBlIiwiVHJhY2tTb3VyY2UiLCJWaWRlb1F1YWxpdHkiLCJDb25uZWN0aW9uUXVhbGl0eSQxIiwiQ29ubmVjdGlvblF1YWxpdHkiLCJDbGllbnRDb25maWdTZXR0aW5nIiwiRGlzY29ubmVjdFJlYXNvbiIsIlJlY29ubmVjdFJlYXNvbiIsIlN1YnNjcmlwdGlvbkVycm9yIiwiUm9vbSQxIiwiUm9vbSIsInNpZCIsImVtcHR5VGltZW91dCIsIm1heFBhcnRpY2lwYW50cyIsImNyZWF0aW9uVGltZSIsInR1cm5QYXNzd29yZCIsImVuYWJsZWRDb2RlY3MiLCJtZXRhZGF0YSIsIm51bVBhcnRpY2lwYW50cyIsIm51bVB1Ymxpc2hlcnMiLCJhY3RpdmVSZWNvcmRpbmciLCJDb2RlYyIsIm1pbWUiLCJmbXRwTGluZSIsIlBsYXlvdXREZWxheSIsImVuYWJsZWQiLCJtaW4iLCJtYXgiLCJQYXJ0aWNpcGFudFBlcm1pc3Npb24iLCJjYW5TdWJzY3JpYmUiLCJjYW5QdWJsaXNoIiwiY2FuUHVibGlzaERhdGEiLCJjYW5QdWJsaXNoU291cmNlcyIsImhpZGRlbiIsInJlY29yZGVyIiwiY2FuVXBkYXRlTWV0YWRhdGEiLCJhZ2VudCIsIlBhcnRpY2lwYW50SW5mbyIsImlkZW50aXR5Iiwic3RhdGUiLCJQYXJ0aWNpcGFudEluZm9fU3RhdGUiLCJKT0lOSU5HIiwidHJhY2tzIiwiam9pbmVkQXQiLCJ2ZXJzaW9uIiwicmVnaW9uIiwiaXNQdWJsaXNoZXIiLCJUcmFja0luZm8iLCJFbmNyeXB0aW9uIiwiRW5jcnlwdGlvbl9UeXBlIiwiU2ltdWxjYXN0Q29kZWNJbmZvIiwibWltZVR5cGUiLCJjaWQiLCJsYXllcnMiLCJWaWRlb0xheWVyIiwiQVVESU8iLCJtdXRlZCIsIndpZHRoIiwiaGVpZ2h0Iiwic2ltdWxjYXN0IiwiZGlzYWJsZUR0eCIsIlVOS05PV04iLCJjb2RlY3MiLCJzdGVyZW8iLCJkaXNhYmxlUmVkIiwiZW5jcnlwdGlvbiIsIk5PTkUiLCJzdHJlYW0iLCJxdWFsaXR5IiwiTE9XIiwiYml0cmF0ZSIsInNzcmMiLCJEYXRhUGFja2V0IiwiRGF0YVBhY2tldF9LaW5kIiwiUkVMSUFCTEUiLCJVc2VyUGFja2V0IiwiQWN0aXZlU3BlYWtlclVwZGF0ZSIsInNwZWFrZXJzIiwiU3BlYWtlckluZm8iLCJhY3RpdmUiLCJwYXJ0aWNpcGFudFNpZCIsInBhcnRpY2lwYW50SWRlbnRpdHkiLCJwYXlsb2FkIiwiZGVzdGluYXRpb25TaWRzIiwiZGVzdGluYXRpb25JZGVudGl0aWVzIiwiUGFydGljaXBhbnRUcmFja3MiLCJ0cmFja1NpZHMiLCJTZXJ2ZXJJbmZvIiwiZWRpdGlvbiIsIlNlcnZlckluZm9fRWRpdGlvbiIsIlN0YW5kYXJkIiwicHJvdG9jb2wiLCJub2RlSWQiLCJkZWJ1Z0luZm8iLCJDbGllbnRJbmZvIiwic2RrIiwiQ2xpZW50SW5mb19TREsiLCJvcyIsIm9zVmVyc2lvbiIsImRldmljZU1vZGVsIiwiYnJvd3NlciIsImJyb3dzZXJWZXJzaW9uIiwiYWRkcmVzcyIsIm5ldHdvcmsiLCJDbGllbnRDb25maWd1cmF0aW9uIiwicmVzdW1lQ29ubmVjdGlvbiIsIlVOU0VUIiwiZm9yY2VSZWxheSIsIlZpZGVvQ29uZmlndXJhdGlvbiIsIkRpc2FibGVkQ29kZWNzIiwiaGFyZHdhcmVFbmNvZGVyIiwicHVibGlzaCIsIlJUUERyaWZ0IiwiZHVyYXRpb24iLCJzdGFydFRpbWVzdGFtcCIsImVuZFRpbWVzdGFtcCIsInJ0cENsb2NrVGlja3MiLCJkcmlmdFNhbXBsZXMiLCJkcmlmdE1zIiwiY2xvY2tSYXRlIiwiUlRQU3RhdHMiLCJwYWNrZXRzIiwicGFja2V0UmF0ZSIsImhlYWRlckJ5dGVzIiwicGFja2V0c0xvc3QiLCJwYWNrZXRMb3NzUmF0ZSIsInBhY2tldExvc3NQZXJjZW50YWdlIiwicGFja2V0c0R1cGxpY2F0ZSIsInBhY2tldER1cGxpY2F0ZVJhdGUiLCJieXRlc0R1cGxpY2F0ZSIsImhlYWRlckJ5dGVzRHVwbGljYXRlIiwiYml0cmF0ZUR1cGxpY2F0ZSIsInBhY2tldHNQYWRkaW5nIiwicGFja2V0UGFkZGluZ1JhdGUiLCJieXRlc1BhZGRpbmciLCJoZWFkZXJCeXRlc1BhZGRpbmciLCJiaXRyYXRlUGFkZGluZyIsInBhY2tldHNPdXRPZk9yZGVyIiwiZnJhbWVzIiwiZnJhbWVSYXRlIiwiaml0dGVyQ3VycmVudCIsImppdHRlck1heCIsImdhcEhpc3RvZ3JhbSIsIm5hY2tzIiwibmFja0Fja3MiLCJuYWNrTWlzc2VzIiwibmFja1JlcGVhdGVkIiwicGxpcyIsImZpcnMiLCJydHRDdXJyZW50IiwicnR0TWF4Iiwia2V5RnJhbWVzIiwibGF5ZXJMb2NrUGxpcyIsIlRpbWVkVmVyc2lvbiIsInVuaXhNaWNybyIsInRpY2tzIiwibWF4UmV0cnlEZWxheSIsIkRFRkFVTFRfUkVUUllfREVMQVlTX0lOX01TIiwiRGVmYXVsdFJlY29ubmVjdFBvbGljeSIsInJldHJ5RGVsYXlzIiwiX3JldHJ5RGVsYXlzIiwibmV4dFJldHJ5RGVsYXlJbk1zIiwicmV0cnlDb3VudCIsInJldHJ5RGVsYXkiLCJyYW5kb20iLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJyZWplY3RlZCIsImRvbmUiLCJ0aGVuIiwiX192YWx1ZXMiLCJpdGVyYXRvciIsIl9fYXN5bmNWYWx1ZXMiLCJhc3luY0l0ZXJhdG9yIiwidmVyYiIsInNldHRsZSIsIlN1cHByZXNzZWRFcnJvciIsImVycm9yIiwic3VwcHJlc3NlZCIsImV2ZW50cyIsIlIiLCJSZWZsZWN0IiwiUmVmbGVjdEFwcGx5IiwicmVjZWl2ZXIiLCJhcmdzIiwiUmVmbGVjdE93bktleXMiLCJvd25LZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIlByb2Nlc3NFbWl0V2FybmluZyIsIndhcm5pbmciLCJ3YXJuIiwiTnVtYmVySXNOYU4iLCJFdmVudEVtaXR0ZXIiLCJpbml0Iiwib25jZSIsIl9ldmVudHMiLCJfZXZlbnRzQ291bnQiLCJfbWF4TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsImNoZWNrTGlzdGVuZXIiLCJsaXN0ZW5lciIsInNldE1heExpc3RlbmVycyIsIl9nZXRNYXhMaXN0ZW5lcnMiLCJ0aGF0IiwiZ2V0TWF4TGlzdGVuZXJzIiwiZW1pdCIsImRvRXJyb3IiLCJlciIsImVyciIsImhhbmRsZXIiLCJsaXN0ZW5lcnMiLCJhcnJheUNsb25lIiwiX2FkZExpc3RlbmVyIiwicHJlcGVuZCIsImV4aXN0aW5nIiwibmV3TGlzdGVuZXIiLCJ1bnNoaWZ0Iiwid2FybmVkIiwidyIsImVtaXR0ZXIiLCJjb3VudCIsImFkZExpc3RlbmVyIiwib24iLCJwcmVwZW5kTGlzdGVuZXIiLCJvbmNlV3JhcHBlciIsImZpcmVkIiwicmVtb3ZlTGlzdGVuZXIiLCJ3cmFwRm4iLCJfb25jZVdyYXAiLCJ3cmFwcGVkIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsInBvc2l0aW9uIiwib3JpZ2luYWxMaXN0ZW5lciIsInNwbGljZU9uZSIsIm9mZiIsInJlbW92ZUFsbExpc3RlbmVycyIsIl9saXN0ZW5lcnMiLCJ1bndyYXAiLCJldmxpc3RlbmVyIiwidW53cmFwTGlzdGVuZXJzIiwicmF3TGlzdGVuZXJzIiwibGlzdGVuZXJDb3VudCIsImV2ZW50TmFtZXMiLCJpbmRleCIsInJldCIsImVycm9yTGlzdGVuZXIiLCJyZXNvbHZlciIsImV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lciIsImFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyIiwiZmxhZ3MiLCJhZGRFdmVudExpc3RlbmVyIiwid3JhcExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50c0V4cG9ydHMiLCJsb2dEaXNhYmxlZF8iLCJkZXByZWNhdGlvbldhcm5pbmdzXyIsImV4dHJhY3RWZXJzaW9uIiwidWFzdHJpbmciLCJleHByIiwid3JhcFBlZXJDb25uZWN0aW9uRXZlbnQiLCJldmVudE5hbWVUb1dyYXAiLCJ3cmFwcGVyIiwiUlRDUGVlckNvbm5lY3Rpb24iLCJwcm90byIsIm5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIiLCJuYXRpdmVFdmVudE5hbWUiLCJjYiIsIndyYXBwZWRDYWxsYmFjayIsIm1vZGlmaWVkRXZlbnQiLCJoYW5kbGVFdmVudCIsIl9ldmVudE1hcCIsIk1hcCIsIm5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1bndyYXBwZWRDYiIsImRlbGV0ZSIsInNpemUiLCJjb25maWd1cmFibGUiLCJkaXNhYmxlTG9nIiwiZGlzYWJsZVdhcm5pbmdzIiwiZGVwcmVjYXRlZCIsIm9sZE1ldGhvZCIsIm5ld01ldGhvZCIsImRldGVjdEJyb3dzZXIiLCJtb3pHZXRVc2VyTWVkaWEiLCJ3ZWJraXRHZXRVc2VyTWVkaWEiLCJpc1NlY3VyZUNvbnRleHQiLCJ3ZWJraXRSVENQZWVyQ29ubmVjdGlvbiIsInN1cHBvcnRzVW5pZmllZFBsYW4iLCJSVENSdHBUcmFuc2NlaXZlciIsImlzT2JqZWN0IiwiY29tcGFjdE9iamVjdCIsInJlZHVjZSIsImFjY3VtdWxhdG9yIiwiaXNPYmoiLCJpc0VtcHR5T2JqZWN0Iiwid2Fsa1N0YXRzIiwic3RhdHMiLCJyZXN1bHRTZXQiLCJpZCIsImVuZHNXaXRoIiwiZmlsdGVyU3RhdHMiLCJ0cmFjayIsIm91dGJvdW5kIiwic3RyZWFtU3RhdHNUeXBlIiwiZmlsdGVyZWRSZXN1bHQiLCJ0cmFja1N0YXRzIiwidHJhY2tJZGVudGlmaWVyIiwidHJhY2tTdGF0IiwidHJhY2tJZCIsImxvZ2dpbmciLCJzaGltR2V0VXNlck1lZGlhJDIiLCJicm93c2VyRGV0YWlscyIsIm1lZGlhRGV2aWNlcyIsImNvbnN0cmFpbnRzVG9DaHJvbWVfIiwibWFuZGF0b3J5Iiwib3B0aW9uYWwiLCJjYyIsImlkZWFsIiwiZXhhY3QiLCJvbGRuYW1lXyIsInByZWZpeCIsIm9jIiwibWl4IiwiYWR2YW5jZWQiLCJzaGltQ29uc3RyYWludHNfIiwiY29uc3RyYWludHMiLCJmdW5jIiwiYXVkaW8iLCJyZW1hcCIsInZpZGVvIiwiZmFjZSIsImZhY2luZ01vZGUiLCJnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcyIsImdldFN1cHBvcnRlZENvbnN0cmFpbnRzIiwiZW51bWVyYXRlRGV2aWNlcyIsImRldmljZXMiLCJkZXYiLCJzb21lIiwibGFiZWwiLCJpbmNsdWRlcyIsImRldmljZUlkIiwic2hpbUVycm9yXyIsIlBlcm1pc3Npb25EZW5pZWRFcnJvciIsIlBlcm1pc3Npb25EaXNtaXNzZWRFcnJvciIsIkludmFsaWRTdGF0ZUVycm9yIiwiRGV2aWNlc05vdEZvdW5kRXJyb3IiLCJDb25zdHJhaW50Tm90U2F0aXNmaWVkRXJyb3IiLCJUcmFja1N0YXJ0RXJyb3IiLCJNZWRpYURldmljZUZhaWxlZER1ZVRvU2h1dGRvd24iLCJNZWRpYURldmljZUtpbGxTd2l0Y2hPbiIsIlRhYkNhcHR1cmVFcnJvciIsIlNjcmVlbkNhcHR1cmVFcnJvciIsIkRldmljZUNhcHR1cmVFcnJvciIsImNvbnN0cmFpbnQiLCJjb25zdHJhaW50TmFtZSIsImdldFVzZXJNZWRpYV8iLCJvblN1Y2Nlc3MiLCJvbkVycm9yIiwiZ2V0VXNlck1lZGlhIiwib3JpZ0dldFVzZXJNZWRpYSIsImNzIiwiZ2V0QXVkaW9UcmFja3MiLCJnZXRWaWRlb1RyYWNrcyIsImdldFRyYWNrcyIsInN0b3AiLCJET01FeGNlcHRpb24iLCJzaGltR2V0RGlzcGxheU1lZGlhJDEiLCJnZXRTb3VyY2VJZCIsImdldERpc3BsYXlNZWRpYSIsInNvdXJjZUlkIiwid2lkdGhTcGVjaWZpZWQiLCJoZWlnaHRTcGVjaWZpZWQiLCJmcmFtZVJhdGVTcGVjaWZpZWQiLCJjaHJvbWVNZWRpYVNvdXJjZSIsImNocm9tZU1lZGlhU291cmNlSWQiLCJtYXhGcmFtZVJhdGUiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsInNoaW1NZWRpYVN0cmVhbSIsIk1lZGlhU3RyZWFtIiwid2Via2l0TWVkaWFTdHJlYW0iLCJzaGltT25UcmFjayQxIiwiX29udHJhY2siLCJvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24iLCJzZXRSZW1vdGVEZXNjcmlwdGlvbiIsIl9vbnRyYWNrcG9seSIsInRlIiwiZ2V0UmVjZWl2ZXJzIiwiZXZlbnQiLCJFdmVudCIsInRyYW5zY2VpdmVyIiwic3RyZWFtcyIsImRpc3BhdGNoRXZlbnQiLCJzaGltR2V0U2VuZGVyc1dpdGhEdG1mIiwic2hpbVNlbmRlcldpdGhEdG1mIiwicGMiLCJkdG1mIiwiX2R0bWYiLCJjcmVhdGVEVE1GU2VuZGVyIiwiX3BjIiwiZ2V0U2VuZGVycyIsIl9zZW5kZXJzIiwib3JpZ0FkZFRyYWNrIiwiYWRkVHJhY2siLCJzZW5kZXIiLCJvcmlnUmVtb3ZlVHJhY2siLCJyZW1vdmVUcmFjayIsImlkeCIsInNwbGljZSIsIm9yaWdBZGRTdHJlYW0iLCJhZGRTdHJlYW0iLCJvcmlnUmVtb3ZlU3RyZWFtIiwicmVtb3ZlU3RyZWFtIiwiUlRDUnRwU2VuZGVyIiwib3JpZ0dldFNlbmRlcnMiLCJzZW5kZXJzIiwic2hpbUdldFN0YXRzIiwib3JpZ0dldFN0YXRzIiwiZ2V0U3RhdHMiLCJzZWxlY3RvciIsIm9uU3VjYyIsIm9uRXJyIiwiZml4Q2hyb21lU3RhdHNfIiwicmVzcG9uc2UiLCJzdGFuZGFyZFJlcG9ydCIsInJlcG9ydHMiLCJyZXBvcnQiLCJzdGFuZGFyZFN0YXRzIiwidGltZXN0YW1wIiwibG9jYWxjYW5kaWRhdGUiLCJyZW1vdGVjYW5kaWRhdGUiLCJzdGF0IiwibWFrZU1hcFN0YXRzIiwic3VjY2Vzc0NhbGxiYWNrV3JhcHBlcl8iLCJzaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0cyIsIlJUQ1J0cFJlY2VpdmVyIiwib3JpZ0dldFJlY2VpdmVycyIsInJlY2VpdmVycyIsInNyY0VsZW1lbnQiLCJNZWRpYVN0cmVhbVRyYWNrIiwic2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlIiwiZ2V0TG9jYWxTdHJlYW1zIiwiX3NoaW1tZWRMb2NhbFN0cmVhbXMiLCJzdHJlYW1JZCIsImFscmVhZHlFeGlzdHMiLCJleGlzdGluZ1NlbmRlcnMiLCJuZXdTZW5kZXJzIiwibmV3U2VuZGVyIiwic2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2siLCJvcmlnR2V0TG9jYWxTdHJlYW1zIiwibmF0aXZlU3RyZWFtcyIsIl9yZXZlcnNlU3RyZWFtcyIsIl9zdHJlYW1zIiwibmV3U3RyZWFtIiwic2lnbmFsaW5nU3RhdGUiLCJvbGRTdHJlYW0iLCJyZXBsYWNlSW50ZXJuYWxTdHJlYW1JZCIsImRlc2NyaXB0aW9uIiwic2RwIiwiaW50ZXJuYWxJZCIsImV4dGVybmFsU3RyZWFtIiwiaW50ZXJuYWxTdHJlYW0iLCJSZWdFeHAiLCJSVENTZXNzaW9uRGVzY3JpcHRpb24iLCJyZXBsYWNlRXh0ZXJuYWxTdHJlYW1JZCIsIm5hdGl2ZU1ldGhvZCIsIm1ldGhvZE9iaiIsImlzTGVnYWN5Q2FsbCIsImRlc2MiLCJvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbiIsInNldExvY2FsRGVzY3JpcHRpb24iLCJvcmlnTG9jYWxEZXNjcmlwdGlvbiIsImlzTG9jYWwiLCJzdHJlYW1pZCIsImhhc1RyYWNrIiwic2hpbVBlZXJDb25uZWN0aW9uJDEiLCJSVENJY2VDYW5kaWRhdGUiLCJmaXhOZWdvdGlhdGlvbk5lZWRlZCIsImdldENvbmZpZ3VyYXRpb24iLCJzZHBTZW1hbnRpY3MiLCJjaHJvbWVTaGltIiwiX19wcm90b19fIiwic2hpbUdldERpc3BsYXlNZWRpYSIsInNoaW1HZXRVc2VyTWVkaWEiLCJzaGltT25UcmFjayIsInNoaW1QZWVyQ29ubmVjdGlvbiIsInNoaW1HZXRVc2VyTWVkaWEkMSIsIm5hdGl2ZUdldFVzZXJNZWRpYSIsImdldFNldHRpbmdzIiwibmF0aXZlR2V0U2V0dGluZ3MiLCJhcHBseUNvbnN0cmFpbnRzIiwibmF0aXZlQXBwbHlDb25zdHJhaW50cyIsInByZWZlcnJlZE1lZGlhU291cmNlIiwiY29kZSIsIm1lZGlhU291cmNlIiwiUlRDVHJhY2tFdmVudCIsIm1velJUQ1BlZXJDb25uZWN0aW9uIiwibW9kZXJuU3RhdHNUeXBlcyIsImluYm91bmRydHAiLCJvdXRib3VuZHJ0cCIsImNhbmRpZGF0ZXBhaXIiLCJuYXRpdmVHZXRTdGF0cyIsInNoaW1TZW5kZXJHZXRTdGF0cyIsInNoaW1SZWNlaXZlckdldFN0YXRzIiwic2hpbVJlbW92ZVN0cmVhbSIsInNoaW1SVENEYXRhQ2hhbm5lbCIsIkRhdGFDaGFubmVsIiwiUlRDRGF0YUNoYW5uZWwiLCJzaGltQWRkVHJhbnNjZWl2ZXIiLCJvcmlnQWRkVHJhbnNjZWl2ZXIiLCJhZGRUcmFuc2NlaXZlciIsInNldFBhcmFtZXRlcnNQcm9taXNlcyIsInNlbmRFbmNvZGluZ3MiLCJzaG91bGRQZXJmb3JtQ2hlY2siLCJlbmNvZGluZ1BhcmFtIiwicmlkUmVnZXgiLCJyaWQiLCJwYXJzZUZsb2F0Iiwic2NhbGVSZXNvbHV0aW9uRG93bkJ5IiwibWF4RnJhbWVyYXRlIiwicGFyYW1zIiwiZ2V0UGFyYW1ldGVycyIsImVuY29kaW5ncyIsInNldFBhcmFtZXRlcnMiLCJjYXRjaCIsInNoaW1HZXRQYXJhbWV0ZXJzIiwib3JpZ0dldFBhcmFtZXRlcnMiLCJzaGltQ3JlYXRlT2ZmZXIiLCJvcmlnQ3JlYXRlT2ZmZXIiLCJjcmVhdGVPZmZlciIsImZpbmFsbHkiLCJzaGltQ3JlYXRlQW5zd2VyIiwib3JpZ0NyZWF0ZUFuc3dlciIsImNyZWF0ZUFuc3dlciIsImZpcmVmb3hTaGltIiwic2hpbUxvY2FsU3RyZWFtc0FQSSIsIl9sb2NhbFN0cmVhbXMiLCJfYWRkVHJhY2siLCJfbGVuIiwiX2tleSIsInNoaW1SZW1vdGVTdHJlYW1zQVBJIiwiZ2V0UmVtb3RlU3RyZWFtcyIsIl9yZW1vdGVTdHJlYW1zIiwiX29uYWRkc3RyZWFtIiwiX29uYWRkc3RyZWFtcG9seSIsInNoaW1DYWxsYmFja3NBUEkiLCJhZGRJY2VDYW5kaWRhdGUiLCJzdWNjZXNzQ2FsbGJhY2siLCJmYWlsdXJlQ2FsbGJhY2siLCJwcm9taXNlIiwid2l0aENhbGxiYWNrIiwiY2FuZGlkYXRlIiwiX2dldFVzZXJNZWRpYSIsInNoaW1Db25zdHJhaW50cyIsImVycmNiIiwic2hpbVJUQ0ljZVNlcnZlclVybHMiLCJPcmlnUGVlckNvbm5lY3Rpb24iLCJwY0NvbmZpZyIsInBjQ29uc3RyYWludHMiLCJpY2VTZXJ2ZXJzIiwibmV3SWNlU2VydmVycyIsInNlcnZlciIsInVybHMiLCJ1cmwiLCJnZW5lcmF0ZUNlcnRpZmljYXRlIiwic2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlciIsInNoaW1DcmVhdGVPZmZlckxlZ2FjeSIsIm9mZmVyT3B0aW9ucyIsIm9mZmVyVG9SZWNlaXZlQXVkaW8iLCJhdWRpb1RyYW5zY2VpdmVyIiwiZ2V0VHJhbnNjZWl2ZXJzIiwiZGlyZWN0aW9uIiwic2V0RGlyZWN0aW9uIiwib2ZmZXJUb1JlY2VpdmVWaWRlbyIsInZpZGVvVHJhbnNjZWl2ZXIiLCJzaGltQXVkaW9Db250ZXh0IiwiQXVkaW9Db250ZXh0Iiwid2Via2l0QXVkaW9Db250ZXh0Iiwic2FmYXJpU2hpbSIsInNkcCQxIiwiU0RQVXRpbHMiLCJnZW5lcmF0ZUlkZW50aWZpZXIiLCJsb2NhbENOYW1lIiwic3BsaXRMaW5lcyIsImJsb2IiLCJsaW5lIiwic3BsaXRTZWN0aW9ucyIsInBhcnRzIiwicGFydCIsImdldERlc2NyaXB0aW9uIiwic2VjdGlvbnMiLCJnZXRNZWRpYVNlY3Rpb25zIiwibWF0Y2hQcmVmaXgiLCJwYXJzZUNhbmRpZGF0ZSIsImZvdW5kYXRpb24iLCJjb21wb25lbnQiLCJwcmlvcml0eSIsImlwIiwicG9ydCIsInJlbGF0ZWRBZGRyZXNzIiwicmVsYXRlZFBvcnQiLCJ0Y3BUeXBlIiwidWZyYWciLCJ1c2VybmFtZUZyYWdtZW50Iiwid3JpdGVDYW5kaWRhdGUiLCJwYXJzZUljZU9wdGlvbnMiLCJwYXJzZVJ0cE1hcCIsInBhcnNlZCIsInBheWxvYWRUeXBlIiwiY2hhbm5lbHMiLCJudW1DaGFubmVscyIsIndyaXRlUnRwTWFwIiwiY29kZWMiLCJwdCIsInByZWZlcnJlZFBheWxvYWRUeXBlIiwicGFyc2VFeHRtYXAiLCJ1cmkiLCJhdHRyaWJ1dGVzIiwid3JpdGVFeHRtYXAiLCJoZWFkZXJFeHRlbnNpb24iLCJwcmVmZXJyZWRJZCIsInBhcnNlRm10cCIsImt2IiwiaiIsIndyaXRlRm10cCIsInBhcmFtZXRlcnMiLCJwYXJhbSIsInBhcnNlUnRjcEZiIiwicGFyYW1ldGVyIiwid3JpdGVSdGNwRmIiLCJsaW5lcyIsInJ0Y3BGZWVkYmFjayIsImZiIiwicGFyc2VTc3JjTWVkaWEiLCJzcCIsImNvbG9uIiwiYXR0cmlidXRlIiwicGFyc2VTc3JjR3JvdXAiLCJzZW1hbnRpY3MiLCJzc3JjcyIsImdldE1pZCIsIm1lZGlhU2VjdGlvbiIsInBhcnNlRmluZ2VycHJpbnQiLCJhbGdvcml0aG0iLCJnZXREdGxzUGFyYW1ldGVycyIsInNlc3Npb25wYXJ0Iiwicm9sZSIsImZpbmdlcnByaW50cyIsIndyaXRlRHRsc1BhcmFtZXRlcnMiLCJzZXR1cFR5cGUiLCJmcCIsInBhcnNlQ3J5cHRvTGluZSIsImNyeXB0b1N1aXRlIiwia2V5UGFyYW1zIiwic2Vzc2lvblBhcmFtcyIsIndyaXRlQ3J5cHRvTGluZSIsIndyaXRlQ3J5cHRvS2V5UGFyYW1zIiwicGFyc2VDcnlwdG9LZXlQYXJhbXMiLCJrZXlNZXRob2QiLCJrZXlTYWx0IiwibGlmZVRpbWUiLCJta2lWYWx1ZSIsIm1raUxlbmd0aCIsImdldENyeXB0b1BhcmFtZXRlcnMiLCJnZXRJY2VQYXJhbWV0ZXJzIiwicHdkIiwicGFzc3dvcmQiLCJ3cml0ZUljZVBhcmFtZXRlcnMiLCJpY2VMaXRlIiwicGFyc2VSdHBQYXJhbWV0ZXJzIiwiaGVhZGVyRXh0ZW5zaW9ucyIsImZlY01lY2hhbmlzbXMiLCJydGNwIiwibWxpbmUiLCJwcm9maWxlIiwicnRwbWFwbGluZSIsImZtdHBzIiwid2lsZGNhcmRSdGNwRmIiLCJkdXBsaWNhdGUiLCJleGlzdGluZ0ZlZWRiYWNrIiwid3JpdGVSdHBEZXNjcmlwdGlvbiIsImNhcHMiLCJtYXhwdGltZSIsInBhcnNlUnRwRW5jb2RpbmdQYXJhbWV0ZXJzIiwiZW5jb2RpbmdQYXJhbWV0ZXJzIiwiaGFzUmVkIiwiaGFzVWxwZmVjIiwicHJpbWFyeVNzcmMiLCJzZWNvbmRhcnlTc3JjIiwiZmxvd3MiLCJhcHQiLCJlbmNQYXJhbSIsImNvZGVjUGF5bG9hZFR5cGUiLCJydHgiLCJmZWMiLCJtZWNoYW5pc20iLCJiYW5kd2lkdGgiLCJtYXhCaXRyYXRlIiwicGFyc2VSdGNwUGFyYW1ldGVycyIsInJ0Y3BQYXJhbWV0ZXJzIiwicmVtb3RlU3NyYyIsImNuYW1lIiwicnNpemUiLCJyZWR1Y2VkU2l6ZSIsImNvbXBvdW5kIiwibXV4Iiwid3JpdGVSdGNwUGFyYW1ldGVycyIsInBhcnNlTXNpZCIsInNwZWMiLCJwbGFuQiIsIm1zaWRQYXJ0cyIsInBhcnNlU2N0cERlc2NyaXB0aW9uIiwicGFyc2VNTGluZSIsIm1heFNpemVMaW5lIiwibWF4TWVzc2FnZVNpemUiLCJzY3RwUG9ydCIsImZtdCIsInNjdHBNYXBMaW5lcyIsIndyaXRlU2N0cERlc2NyaXB0aW9uIiwibWVkaWEiLCJzY3RwIiwib3V0cHV0IiwiZ2VuZXJhdGVTZXNzaW9uSWQiLCJzdWJzdHIiLCJ3cml0ZVNlc3Npb25Cb2lsZXJwbGF0ZSIsInNlc3NJZCIsInNlc3NWZXIiLCJzZXNzVXNlciIsInNlc3Npb25JZCIsInVzZXIiLCJnZXREaXJlY3Rpb24iLCJnZXRLaW5kIiwiaXNSZWplY3RlZCIsInBhcnNlT0xpbmUiLCJ1c2VybmFtZSIsInNlc3Npb25WZXJzaW9uIiwibmV0VHlwZSIsImFkZHJlc3NUeXBlIiwiaXNWYWxpZFNEUCIsInNkcEV4cG9ydHMiLCJzaGltUlRDSWNlQ2FuZGlkYXRlIiwiTmF0aXZlUlRDSWNlQ2FuZGlkYXRlIiwibmF0aXZlQ2FuZGlkYXRlIiwicGFyc2VkQ2FuZGlkYXRlIiwic2RwTWlkIiwic2RwTUxpbmVJbmRleCIsIndyaXRhYmxlIiwic2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wiLCJyZWxheVByb3RvY29sIiwic2hpbU1heE1lc3NhZ2VTaXplIiwiX3NjdHAiLCJzY3RwSW5EZXNjcmlwdGlvbiIsIm1MaW5lIiwiZ2V0UmVtb3RlRmlyZWZveFZlcnNpb24iLCJnZXRDYW5TZW5kTWF4TWVzc2FnZVNpemUiLCJyZW1vdGVJc0ZpcmVmb3giLCJjYW5TZW5kTWF4TWVzc2FnZVNpemUiLCJnZXRNYXhNZXNzYWdlU2l6ZSIsImlzRmlyZWZveCIsImNhblNlbmRNTVMiLCJyZW1vdGVNTVMiLCJzaGltU2VuZFRocm93VHlwZUVycm9yIiwid3JhcERjU2VuZCIsImRjIiwib3JpZ0RhdGFDaGFubmVsU2VuZCIsInNlbmQiLCJyZWFkeVN0YXRlIiwib3JpZ0NyZWF0ZURhdGFDaGFubmVsIiwiY3JlYXRlRGF0YUNoYW5uZWwiLCJkYXRhQ2hhbm5lbCIsImNoYW5uZWwiLCJzaGltQ29ubmVjdGlvblN0YXRlIiwiY29tcGxldGVkIiwiY2hlY2tpbmciLCJpY2VDb25uZWN0aW9uU3RhdGUiLCJfb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UiLCJvcmlnTWV0aG9kIiwiX2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZXBvbHkiLCJfbGFzdENvbm5lY3Rpb25TdGF0ZSIsImNvbm5lY3Rpb25TdGF0ZSIsIm5ld0V2ZW50IiwicmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCIsIm5hdGl2ZVNSRCIsInNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSIsIm5hdGl2ZUFkZEljZUNhbmRpZGF0ZSIsInNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbiIsIm5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24iLCJjb21tb25TaGltIiwiYWRhcHRlckZhY3RvcnkiLCJzaGltQ2hyb21lIiwic2hpbUZpcmVmb3giLCJzaGltU2FmYXJpIiwiYWRhcHRlciIsImJyb3dzZXJTaGltIiwiRU5DUllQVElPTl9BTEdPUklUSE0iLCJERUNSWVBUSU9OX0ZBSUxVUkVfVE9MRVJBTkNFIiwiRTJFRV9GTEFHIiwiU0FMVCIsIktFWV9QUk9WSURFUl9ERUZBVUxUUyIsInNoYXJlZEtleSIsInJhdGNoZXRTYWx0IiwicmF0Y2hldFdpbmRvd1NpemUiLCJmYWlsdXJlVG9sZXJhbmNlIiwiS2V5UHJvdmlkZXJFdmVudCIsIktleUhhbmRsZXJFdmVudCIsIkVuY3J5cHRpb25FdmVudCIsIkNyeXB0b3JFdmVudCIsImlzRTJFRVN1cHBvcnRlZCIsImlzSW5zZXJ0YWJsZVN0cmVhbVN1cHBvcnRlZCIsImlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkIiwiUlRDUnRwU2NyaXB0VHJhbnNmb3JtIiwiY3JlYXRlRW5jb2RlZFN0cmVhbXMiLCJpc1ZpZGVvRnJhbWUiLCJmcmFtZSIsImltcG9ydEtleSIsImtleUJ5dGVzIiwidXNhZ2UiLCJjcnlwdG8iLCJzdWJ0bGUiLCJjcmVhdGVLZXlNYXRlcmlhbEZyb21TdHJpbmciLCJrZXlNYXRlcmlhbCIsImNyZWF0ZUtleU1hdGVyaWFsRnJvbUJ1ZmZlciIsImNyeXB0b0J1ZmZlciIsImdldEFsZ29PcHRpb25zIiwiYWxnb3JpdGhtTmFtZSIsInNhbHQiLCJlbmNvZGVkU2FsdCIsImhhc2giLCJpdGVyYXRpb25zIiwiZGVyaXZlS2V5cyIsIm1hdGVyaWFsIiwiYWxnb3JpdGhtT3B0aW9ucyIsImVuY3J5cHRpb25LZXkiLCJkZXJpdmVLZXkiLCJjcmVhdGVFMkVFS2V5IiwiZ2V0UmFuZG9tVmFsdWVzIiwicmF0Y2hldCIsImRlcml2ZUJpdHMiLCJuZWVkc1Jic3BVbmVzY2FwaW5nIiwiZnJhbWVEYXRhIiwicGFyc2VSYnNwIiwiZGF0YU91dCIsImtaZXJvc0luU3RhcnRTZXF1ZW5jZSIsImtFbXVsYXRpb25CeXRlIiwid3JpdGVSYnNwIiwiZGF0YV9pbiIsIm51bUNvbnNlY3V0aXZlWmVyb3MiLCJCYXNlS2V5UHJvdmlkZXIiLCJvbktleVJhdGNoZXRlZCIsImtleUluZGV4Iiwia2V5SW5mb01hcCIsIktleVJhdGNoZXRlZCIsIm9uU2V0RW5jcnlwdGlvbktleSIsImtleUluZm8iLCJTZXRLZXkiLCJnZXRLZXlzIiwiZnJvbSIsImdldE9wdGlvbnMiLCJyYXRjaGV0S2V5IiwiUmF0Y2hldFJlcXVlc3QiLCJFeHRlcm5hbEUyRUVLZXlQcm92aWRlciIsIm9wdHMiLCJzZXRLZXkiLCJkZXJpdmVkS2V5IiwiTGl2ZWtpdEVycm9yIiwiQ29ubmVjdGlvbkVycm9yIiwicmVhc29uIiwic3RhdHVzIiwiRGV2aWNlVW5zdXBwb3J0ZWRFcnJvciIsIlRyYWNrSW52YWxpZEVycm9yIiwiVW5zdXBwb3J0ZWRTZXJ2ZXIiLCJVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlIiwiTmVnb3RpYXRpb25FcnJvciIsIlB1Ymxpc2hEYXRhRXJyb3IiLCJNZWRpYURldmljZUZhaWx1cmUiLCJnZXRGYWlsdXJlIiwiTm90Rm91bmQiLCJQZXJtaXNzaW9uRGVuaWVkIiwiRGV2aWNlSW5Vc2UiLCJPdGhlciIsIlJvb21FdmVudCIsIlBhcnRpY2lwYW50RXZlbnQiLCJFbmdpbmVFdmVudCIsIlRyYWNrRXZlbnQiLCJpc0ltbWVkaWF0ZSIsInUiLCJjYWxsYmFjayIsIm1heFdhaXQiLCJsIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImNhbmNlbCIsImNvbW1vblZlcnNpb25JZGVudGlmaWVyIiwiZ2V0QnJvd3NlciIsImZvcmNlIiwidWEiLCJicm93c2Vyc0xpc3QiLCJkZXNjcmliZSIsImdldE1hdGNoIiwiZXhwIiwidmVyc2lvbiQxIiwicHJvdG9jb2xWZXJzaW9uIiwiQ3JpdGljYWxUaW1lcnMiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJWaWRlb1ByZXNldCIsImVuY29kaW5nIiwicmVzb2x1dGlvbiIsImFzcGVjdFJhdGlvIiwiYmFja3VwQ29kZWNzIiwidmlkZW9Db2RlY3MiLCJpc0JhY2t1cENvZGVjIiwiYmFja3VwIiwiQXVkaW9QcmVzZXRzIiwidGVsZXBob25lIiwic3BlZWNoIiwibXVzaWMiLCJtdXNpY1N0ZXJlbyIsIm11c2ljSGlnaFF1YWxpdHkiLCJtdXNpY0hpZ2hRdWFsaXR5U3RlcmVvIiwiVmlkZW9QcmVzZXRzIiwiaDkwIiwiaDE4MCIsImgyMTYiLCJoMzYwIiwiaDU0MCIsImg3MjAiLCJoMTA4MCIsImgxNDQwIiwiaDIxNjAiLCJWaWRlb1ByZXNldHM0MyIsImgxMjAiLCJoMjQwIiwiaDQ4MCIsIlNjcmVlblNoYXJlUHJlc2V0cyIsImgzNjBmcHMzIiwiaDM2MGZwczE1IiwiaDcyMGZwczUiLCJoNzIwZnBzMTUiLCJoNzIwZnBzMzAiLCJoMTA4MGZwczE1IiwiaDEwODBmcHMzMCIsIm9yaWdpbmFsIiwiU2lnbmFsVGFyZ2V0IiwiU3RyZWFtU3RhdGUiLCJDYW5kaWRhdGVQcm90b2NvbCIsIlNpZ25hbFJlcXVlc3QiLCJTZXNzaW9uRGVzY3JpcHRpb24iLCJUcmlja2xlUmVxdWVzdCIsIkFkZFRyYWNrUmVxdWVzdCIsIk11dGVUcmFja1JlcXVlc3QiLCJVcGRhdGVTdWJzY3JpcHRpb24iLCJVcGRhdGVUcmFja1NldHRpbmdzIiwiTGVhdmVSZXF1ZXN0IiwiVXBkYXRlVmlkZW9MYXllcnMiLCJTdWJzY3JpcHRpb25QZXJtaXNzaW9uIiwiU3luY1N0YXRlIiwiU2ltdWxhdGVTY2VuYXJpbyIsIlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEiLCJQaW5nIiwiU2lnbmFsUmVzcG9uc2UiLCJKb2luUmVzcG9uc2UiLCJQYXJ0aWNpcGFudFVwZGF0ZSIsIlRyYWNrUHVibGlzaGVkUmVzcG9uc2UiLCJTcGVha2Vyc0NoYW5nZWQiLCJSb29tVXBkYXRlIiwiQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUiLCJTdHJlYW1TdGF0ZVVwZGF0ZSIsIlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlIiwiU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSIsIlRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSIsIlJlY29ubmVjdFJlc3BvbnNlIiwiUG9uZyIsIlN1YnNjcmlwdGlvblJlc3BvbnNlIiwiU2ltdWxjYXN0Q29kZWMiLCJzaW11bGNhc3RDb2RlY3MiLCJjYW5kaWRhdGVJbml0IiwiUFVCTElTSEVSIiwib3RoZXJQYXJ0aWNpcGFudHMiLCJzZXJ2ZXJWZXJzaW9uIiwic3Vic2NyaWJlclByaW1hcnkiLCJhbHRlcm5hdGl2ZVVybCIsInNlcnZlclJlZ2lvbiIsInBpbmdUaW1lb3V0IiwicGluZ0ludGVydmFsIiwic2lmVHJhaWxlciIsIklDRVNlcnZlciIsInRyYWNrU2lkIiwicGFydGljaXBhbnRzIiwic3Vic2NyaWJlIiwicGFydGljaXBhbnRUcmFja3MiLCJkaXNhYmxlZCIsImZwcyIsImNhblJlY29ubmVjdCIsIlVOS05PV05fUkVBU09OIiwiY3JlZGVudGlhbCIsIkNvbm5lY3Rpb25RdWFsaXR5SW5mbyIsIlBPT1IiLCJzY29yZSIsInVwZGF0ZXMiLCJTdHJlYW1TdGF0ZUluZm8iLCJBQ1RJVkUiLCJzdHJlYW1TdGF0ZXMiLCJTdWJzY3JpYmVkUXVhbGl0eSIsIlN1YnNjcmliZWRDb2RlYyIsInF1YWxpdGllcyIsInN1YnNjcmliZWRRdWFsaXRpZXMiLCJzdWJzY3JpYmVkQ29kZWNzIiwiVHJhY2tQZXJtaXNzaW9uIiwiYWxsVHJhY2tzIiwiYWxsUGFydGljaXBhbnRzIiwidHJhY2tQZXJtaXNzaW9ucyIsImFsbG93ZWQiLCJwdWJsaXNoVHJhY2tzIiwiZGF0YUNoYW5uZWxzIiwiRGF0YUNoYW5uZWxJbmZvIiwic2NlbmFyaW8iLCJydHQiLCJsYXN0UGluZ1RpbWVzdGFtcCIsIlJlZ2lvblNldHRpbmdzIiwicmVnaW9ucyIsIlJlZ2lvbkluZm8iLCJkaXN0YW5jZSIsIlNFX1VOS05PV04iLCJjbG9uZURlZXAiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJCQUNLR1JPVU5EX1JFQUNUSU9OX0RFTEFZIiwicmVjeWNsZWRFbGVtZW50cyIsIlRyYWNrIiwibWVkaWFUcmFjayIsImxvZ2dlck9wdGlvbnMiLCJhdHRhY2hlZEVsZW1lbnRzIiwiaXNNdXRlZCIsInN0cmVhbVN0YXRlIiwiQWN0aXZlIiwiaXNJbkJhY2tncm91bmQiLCJfY3VycmVudEJpdHJhdGUiLCJhcHBWaXNpYmlsaXR5Q2hhbmdlZExpc3RlbmVyIiwiYmFja2dyb3VuZFRpbWVvdXQiLCJ2aXNpYmlsaXR5U3RhdGUiLCJoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCIsImxvZ2dlckNvbnRleHRDYiIsIl9tZWRpYVN0cmVhbVRyYWNrIiwiX21lZGlhU3RyZWFtSUQiLCJTb3VyY2UiLCJVbmtub3duIiwibG9nQ29udGV4dCIsImdldExvZ0NvbnRleHRGcm9tVHJhY2siLCJjdXJyZW50Qml0cmF0ZSIsIm1lZGlhU3RyZWFtVHJhY2siLCJtZWRpYVN0cmVhbUlEIiwiYXR0YWNoIiwiZWxlbWVudCIsImVsZW1lbnRUeXBlIiwiS2luZCIsIlZpZGVvIiwiYWRkQXBwVmlzaWJpbGl0eUxpc3RlbmVyIiwicGFyZW50RWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJhdHRhY2hUb0VsZW1lbnQiLCJhbGxNZWRpYVN0cmVhbVRyYWNrcyIsInNyY09iamVjdCIsImhhc0F1ZGlvIiwidHIiLCJwbGF5IiwiQXVkaW9QbGF5YmFja1N0YXJ0ZWQiLCJWaWRlb1BsYXliYWNrU3RhcnRlZCIsIkF1ZGlvUGxheWJhY2tGYWlsZWQiLCJWaWRlb1BsYXliYWNrRmFpbGVkIiwiRWxlbWVudEF0dGFjaGVkIiwiZGV0YWNoIiwiZGV0YWNoVHJhY2siLCJyZWN5Y2xlRWxlbWVudCIsIkVsZW1lbnREZXRhY2hlZCIsImRldGFjaGVkIiwiZWxtIiwicmVtb3ZlQXBwVmlzaWJpbGl0eUxpc3RlbmVyIiwic3RvcE1vbml0b3IiLCJlbmFibGUiLCJkaXNhYmxlIiwibW9uaXRvckludGVydmFsIiwidXBkYXRlTG9nZ2VyT3B0aW9ucyIsIkhUTUxBdWRpb0VsZW1lbnQiLCJzaG91bGRDYWNoZSIsInBhdXNlIiwiaXNXZWIiLCJtZWRpYVN0cmVhbSIsImV4aXN0aW5nVHJhY2tzIiwiZXQiLCJpc1NhZmFyaSIsIkhUTUxWaWRlb0VsZW1lbnQiLCJhdXRvcGxheSIsInBsYXlzSW5saW5lIiwiaXNGaXJlRm94IiwiU3RyZWFtU3RhdGUkMSIsImtpbmRUb1Byb3RvIiwiQXVkaW8iLCJWSURFTyIsIkRBVEEiLCJraW5kRnJvbVByb3RvIiwic291cmNlVG9Qcm90byIsIkNhbWVyYSIsIkNBTUVSQSIsIk1pY3JvcGhvbmUiLCJNSUNST1BIT05FIiwiU2NyZWVuU2hhcmUiLCJTQ1JFRU5fU0hBUkUiLCJTY3JlZW5TaGFyZUF1ZGlvIiwiU0NSRUVOX1NIQVJFX0FVRElPIiwic291cmNlRnJvbVByb3RvIiwic3RyZWFtU3RhdGVGcm9tUHJvdG8iLCJQQVVTRUQiLCJQYXVzZWQiLCJtZXJnZURlZmF1bHRPcHRpb25zIiwiYXVkaW9EZWZhdWx0cyIsInZpZGVvRGVmYXVsdHMiLCJtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyIsIm1haW5PYmplY3QiLCJvYmplY3RUb01lcmdlIiwiY29uc3RyYWludHNGb3JPcHRpb25zIiwidmlkZW9PcHRpb25zIiwiZGV0ZWN0U2lsZW5jZSIsInRpbWVPZmZzZXQiLCJjdHgiLCJnZXROZXdBdWRpb0NvbnRleHQiLCJhbmFseXNlciIsImNyZWF0ZUFuYWx5c2VyIiwiZmZ0U2l6ZSIsImJ1ZmZlckxlbmd0aCIsImZyZXF1ZW5jeUJpbkNvdW50IiwiZGF0YUFycmF5IiwiY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UiLCJjb25uZWN0Iiwic2xlZXAiLCJnZXRCeXRlVGltZURvbWFpbkRhdGEiLCJzb21lTm9pc2UiLCJzYW1wbGUiLCJjbG9zZSIsImxhdGVuY3lIaW50Iiwic291cmNlVG9LaW5kIiwic2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyIsInZpZGVvQ29uc3RyYWludHMiLCJjb250cm9sbGVyIiwic2VsZkJyb3dzZXJTdXJmYWNlIiwic3VyZmFjZVN3aXRjaGluZyIsInN5c3RlbUF1ZGlvIiwibWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmciLCJnZXRUcmFja1B1YmxpY2F0aW9uSW5mbyIsImluZm9zIiwidHJhY2tJbmZvIiwidHJhY2tTb3VyY2UiLCJ0cmFja011dGVkIiwidHJhY2tFbmFibGVkIiwidHJhY2tLaW5kIiwidHJhY2tOYW1lIiwiaXNFbmFibGVkIiwidHJhY2tFbmNyeXB0ZWQiLCJpc0VuY3J5cHRlZCIsInRyYWNrTWltZVR5cGUiLCJzZXBhcmF0b3IiLCJkZEV4dGVuc2lvblVSSSIsInVucGFja1N0cmVhbUlkIiwic3VwcG9ydHNUcmFuc2NlaXZlciIsInN1cHBvcnRzQWRkVHJhY2siLCJzdXBwb3J0c0FkYXB0aXZlU3RyZWFtIiwiUmVzaXplT2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsInN1cHBvcnRzRHluYWNhc3QiLCJzdXBwb3J0c0FWMSIsImNhcGFiaWxpdGllcyIsImdldENhcGFiaWxpdGllcyIsImhhc0FWMSIsInN1cHBvcnRzVlA5IiwiY29tcGFyZVZlcnNpb25zIiwiaGFzVlA5IiwiaXNTVkNDb2RlYyIsInN1cHBvcnRzU2V0U2lua0lkIiwic2V0Q29kZWNQcmVmZXJlbmNlc1ZlcnNpb25zIiwiQ2hyb21lIiwiU2FmYXJpIiwiRmlyZWZveCIsInN1cHBvcnRzU2V0Q29kZWNQcmVmZXJlbmNlcyIsImlzQnJvd3NlclN1cHBvcnRlZCIsImlzQ2hyb21pdW1CYXNlZCIsImlzU2FmYXJpMTciLCJpc01vYmlsZSIsImlzUmVhY3ROYXRpdmUiLCJwcm9kdWN0IiwiaXNDbG91ZCIsInNlcnZlclVybCIsImhvc3RuYW1lIiwiZ2V0TEtSZWFjdE5hdGl2ZUluZm8iLCJMaXZlS2l0UmVhY3ROYXRpdmVHbG9iYWwiLCJnZXRSZWFjdE5hdGl2ZU9zIiwicGxhdGZvcm0iLCJnZXREZXZpY2VQaXhlbFJhdGlvIiwiZGV2aWNlUGl4ZWxSYXRpbyIsInYxIiwidjIiLCJwYXJ0czEiLCJwYXJ0czIiLCJwMSIsInAyIiwicm9EaXNwYXRjaENhbGxiYWNrIiwiZW50cnkiLCJoYW5kbGVSZXNpemUiLCJpb0Rpc3BhdGNoQ2FsbGJhY2siLCJoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCIsInJlc2l6ZU9ic2VydmVyIiwiZ2V0UmVzaXplT2JzZXJ2ZXIiLCJpbnRlcnNlY3Rpb25PYnNlcnZlciIsImdldEludGVyc2VjdGlvbk9ic2VydmVyIiwicm9vdE1hcmdpbiIsImdldENsaWVudEluZm8iLCJKUyIsImVtcHR5VmlkZW9TdHJlYW1UcmFjayIsImdldEVtcHR5VmlkZW9TdHJlYW1UcmFjayIsImNyZWF0ZUR1bW15VmlkZW9TdHJlYW1UcmFjayIsInBhaW50Q29udGVudCIsImNhbnZhcyIsImdldENvbnRleHQiLCJmaWxsUmVjdCIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiY2xvc2VQYXRoIiwiZmlsbFN0eWxlIiwiZmlsbCIsImR1bW15U3RyZWFtIiwiY2FwdHVyZVN0cmVhbSIsImR1bW15VHJhY2siLCJlbXB0eUF1ZGlvU3RyZWFtVHJhY2siLCJnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2siLCJvc2NpbGxhdG9yIiwiY3JlYXRlT3NjaWxsYXRvciIsImdhaW4iLCJjcmVhdGVHYWluIiwic2V0VmFsdWVBdFRpbWUiLCJkc3QiLCJjcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uIiwiRnV0dXJlIiwiZnV0dXJlQmFzZSIsIm9uRmluYWxseSIsImNyZWF0ZUF1ZGlvQW5hbHlzZXIiLCJjbG9uZVRyYWNrIiwic21vb3RoaW5nVGltZUNvbnN0YW50IiwibWluRGVjaWJlbHMiLCJtYXhEZWNpYmVscyIsImF1ZGlvQ29udGV4dCIsInN0cmVhbVRyYWNrIiwibWVkaWFTdHJlYW1Tb3VyY2UiLCJjYWxjdWxhdGVWb2x1bWUiLCJnZXRCeXRlRnJlcXVlbmN5RGF0YSIsInN1bSIsImFtcGxpdHVkZSIsInBvdyIsInZvbHVtZSIsInNxcnQiLCJjbGVhbnVwIiwiTXV0ZXgiLCJfbG9ja2luZyIsIl9sb2NrcyIsImlzTG9ja2VkIiwibG9jayIsInVubG9ja05leHQiLCJ3aWxsTG9jayIsIndpbGxVbmxvY2siLCJpc1ZpZGVvQ29kZWMiLCJtYXliZUNvZGVjIiwidW53cmFwQ29uc3RyYWludCIsInRvV2Vic29ja2V0VXJsIiwidG9IdHRwVXJsIiwiZGVmYXVsdElkIiwiRGV2aWNlTWFuYWdlciIsImdldEluc3RhbmNlIiwiaW5zdGFuY2UiLCJnZXREZXZpY2VzIiwicmVxdWVzdFBlcm1pc3Npb25zIiwidXNlck1lZGlhUHJvbWlzZU1hcCIsImhhc0RldmljZUluVXNlIiwiaXNEdW1teURldmljZU9yRW1wdHkiLCJkZXZpY2UiLCJub0xhYmVsIiwiaXNSZWxldmFudCIsInBlcm1pc3Npb25zVG9BY3F1aXJlIiwibm9ybWFsaXplRGV2aWNlSWQiLCJncm91cElkIiwibWVkaWFEZXZpY2VLaW5kcyIsImRlZmF1bHREaW1lbnNpb25zVGltZW91dCIsIkxvY2FsVHJhY2siLCJfY29uc3RyYWludHMiLCJ1c2VyUHJvdmlkZWRUcmFjayIsIl9pc1Vwc3RyZWFtUGF1c2VkIiwiaGFuZGxlVHJhY2tNdXRlRXZlbnQiLCJkZWJvdW5jZWRUcmFja011dGVIYW5kbGVyIiwicGF1c2VVcHN0cmVhbSIsImhhbmRsZVRyYWNrVW5tdXRlRXZlbnQiLCJyZXN1bWVVcHN0cmVhbSIsImhhbmRsZUVuZGVkIiwicmVhY3F1aXJlVHJhY2siLCJFbmRlZCIsInByb3ZpZGVkQnlVc2VyIiwibXV0ZUxvY2siLCJwYXVzZVVwc3RyZWFtTG9jayIsInByb2Nlc3NvckxvY2siLCJzZXRNZWRpYVN0cmVhbVRyYWNrIiwiZ2V0Q29uc3RyYWludHMiLCJkaW1lbnNpb25zIiwiaXNVcHN0cmVhbVBhdXNlZCIsImlzVXNlclByb3ZpZGVkIiwicHJvY2Vzc29yIiwicHJvY2Vzc2VkVHJhY2siLCJuZXdUcmFjayIsImVsIiwicHJvY2Vzc29yRWxlbWVudCIsInJlc3RhcnQiLCJyZXBsYWNlVHJhY2siLCJ3YWl0Rm9yRGltZW5zaW9ucyIsInRpbWVvdXQiLCJzdGFydGVkIiwiZGltcyIsImdldERldmljZUlkIiwibXV0ZSIsInNldFRyYWNrTXV0ZWQiLCJ1bm11dGUiLCJzdG9wUHJvY2Vzc29yIiwic3RyZWFtQ29uc3RyYWludHMiLCJSZXN0YXJ0ZWQiLCJNdXRlZCIsIlVubXV0ZWQiLCJuZWVkc1JlQWNxdWlzaXRpb24iLCJfc3VwZXIiLCJkZXN0cm95IiwidW5sb2NrIiwiVXBzdHJlYW1QYXVzZWQiLCJVcHN0cmVhbVJlc3VtZWQiLCJnZXRSVENTdGF0c1JlcG9ydCIsInN0YXRzUmVwb3J0Iiwic2V0UHJvY2Vzc29yIiwic2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkiLCJwcm9jZXNzb3JPcHRpb25zIiwiZ2V0UHJvY2Vzc29yIiwicmVtb3ZlIiwiRTJFRU1hbmFnZXIiLCJvbldvcmtlck1lc3NhZ2UiLCJldiIsIkVuY3J5cHRpb25FcnJvciIsImtleVByb3ZpZGVyIiwicG9zdEtleSIsImVuY3J5cHRpb25FbmFibGVkIiwicm9vbSIsImxvY2FsUGFydGljaXBhbnQiLCJQYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkIiwicGFydGljaXBhbnQiLCJnZXRQYXJ0aWNpcGFudEJ5SWRlbnRpdHkiLCJvbldvcmtlckVycm9yIiwid29ya2VyIiwic2V0dXAiLCJzZXR1cEV2ZW50TGlzdGVuZXJzIiwia2V5UHJvdmlkZXJPcHRpb25zIiwib25tZXNzYWdlIiwib25lcnJvciIsInBvc3RNZXNzYWdlIiwic2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZCIsInBvc3RFbmFibGUiLCJzZXRTaWZUcmFpbGVyIiwidHJhaWxlciIsInBvc3RTaWZUcmFpbGVyIiwic2V0dXBFbmdpbmUiLCJlbmdpbmUiLCJSVFBWaWRlb01hcFVwZGF0ZSIsInJ0cE1hcCIsInBvc3RSVFBNYXAiLCJUcmFja1B1Ymxpc2hlZCIsInB1YiIsIkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQiLCJDb25uZWN0aW9uU3RhdGUiLCJDb25uZWN0ZWQiLCJUcmFja1Vuc3Vic2NyaWJlZCIsIl8iLCJUcmFja1N1YnNjcmliZWQiLCJzZXR1cEUyRUVSZWNlaXZlciIsIlNpZ25hbENvbm5lY3RlZCIsImlzRTJFRUVuYWJsZWQiLCJMb2NhbFRyYWNrUHVibGlzaGVkIiwicHVibGljYXRpb24iLCJzZXR1cEUyRUVTZW5kZXIiLCJwYXJ0aWNpcGFudElkIiwicG9zdFJhdGNoZXRSZXF1ZXN0IiwiZW5hYmxlTXNnIiwiUmVmZXJlbmNlRXJyb3IiLCJyZW1vdGVJZCIsImhhbmRsZVJlY2VpdmVyIiwiaGFuZGxlU2VuZGVyIiwidHJhbnNmb3JtIiwid3JpdGFibGVTdHJlYW0iLCJyZWFkYWJsZSIsInJlYWRhYmxlU3RyZWFtIiwicmVjZWl2ZXJTdHJlYW1zIiwic2VuZGVyU3RyZWFtcyIsIlF1ZXVlVGFza1N0YXR1cyIsIkFzeW5jUXVldWUiLCJwZW5kaW5nVGFza3MiLCJ0YXNrTXV0ZXgiLCJuZXh0VGFza0luZGV4IiwicnVuIiwidGFzayIsInRhc2tJbmZvIiwiZW5xdWV1ZWRBdCIsIldBSVRJTkciLCJleGVjdXRlZEF0IiwiUlVOTklORyIsIkNPTVBMRVRFRCIsImZsdXNoIiwic25hcHNob3QiLCJwYXNzVGhyb3VnaFF1ZXVlU2lnbmFscyIsImNhblBhc3NUaHJvdWdoUXVldWUiLCJyZXEiLCJjYW5QYXNzIiwiU2lnbmFsQ29ubmVjdGlvblN0YXRlIiwiU2lnbmFsQ2xpZW50IiwiY3VycmVudFN0YXRlIiwiaXNEaXNjb25uZWN0ZWQiLCJESVNDT05ORUNUSU5HIiwiRElTQ09OTkVDVEVEIiwiaXNFc3RhYmxpc2hpbmdDb25uZWN0aW9uIiwiQ09OTkVDVElORyIsIlJFQ09OTkVDVElORyIsInVzZUpTT04iLCJyZXNldENhbGxiYWNrcyIsIm9uQW5zd2VyIiwib25MZWF2ZSIsIm9uTG9jYWxUcmFja1B1Ymxpc2hlZCIsIm9uTG9jYWxUcmFja1VucHVibGlzaGVkIiwib25OZWdvdGlhdGVSZXF1ZXN0ZWQiLCJvbk9mZmVyIiwib25SZW1vdGVNdXRlQ2hhbmdlZCIsIm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUiLCJvblRva2VuUmVmcmVzaCIsIm9uVHJpY2tsZSIsIm9uQ2xvc2UiLCJTaWduYWwiLCJyZXF1ZXN0UXVldWUiLCJxdWV1ZWRSZXF1ZXN0cyIsImNsb3NpbmdMb2NrIiwiY29ubmVjdGlvbkxvY2siLCJ0b2tlbiIsImFib3J0U2lnbmFsIiwicmVzIiwicmVjb25uZWN0IiwiY2xlYXJQaW5nSW50ZXJ2YWwiLCJyZWNvbm5lY3RSZWFzb24iLCJjb25uZWN0T3B0aW9ucyIsImNsaWVudEluZm8iLCJjcmVhdGVDb25uZWN0aW9uUGFyYW1zIiwiYWJvcnRIYW5kbGVyIiwid3NUaW1lb3V0Iiwid2Vic29ja2V0VGltZW91dCIsImFib3J0ZWQiLCJ3cyIsIldlYlNvY2tldCIsImJpbmFyeVR5cGUiLCJvbm9wZW4iLCJDT05ORUNURUQiLCJyZXNwIiwiZmV0Y2giLCJ0b0ZpeGVkIiwidGV4dCIsImhhbmRsZVdTRXJyb3IiLCJzaG91bGRQcm9jZXNzTWVzc2FnZSIsInBpbmdUaW1lb3V0RHVyYXRpb24iLCJwaW5nSW50ZXJ2YWxEdXJhdGlvbiIsImludGVydmFsIiwic3RhcnRQaW5nSW50ZXJ2YWwiLCJzaWduYWxMYXRlbmN5IiwiaGFuZGxlU2lnbmFsUmVzcG9uc2UiLCJvbmNsb3NlIiwiaGFuZGxlT25DbG9zZSIsImNsb3NlUHJvbWlzZSIsIkNMT1NJTkciLCJyYWNlIiwic2VuZE9mZmVyIiwib2ZmZXIiLCJvZmZlclNkcCIsInNlbmRSZXF1ZXN0IiwidG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbiIsInNlbmRBbnN3ZXIiLCJhbnN3ZXIiLCJhbnN3ZXJTZHAiLCJzZW5kSWNlQ2FuZGlkYXRlIiwic2VuZE11dGVUcmFjayIsInNlbmRBZGRUcmFjayIsInNlbmRVcGRhdGVMb2NhbE1ldGFkYXRhIiwic2VuZFVwZGF0ZVRyYWNrU2V0dGluZ3MiLCJzZXR0aW5ncyIsInNlbmRVcGRhdGVTdWJzY3JpcHRpb24iLCJzdWIiLCJzZW5kU3luY1N0YXRlIiwic3luYyIsInNlbmRVcGRhdGVWaWRlb0xheWVycyIsInNlbmRVcGRhdGVTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyIsInNlbmRTaW11bGF0ZVNjZW5hcmlvIiwic2VuZFBpbmciLCJzZW5kTGVhdmUiLCJDTElFTlRfSU5JVElBVEVEIiwiZnJvbVF1ZXVlIiwiY2FuUXVldWUiLCJPUEVOIiwicGluZ0hhbmRsZWQiLCJzZCIsImZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbiIsIm9uUGFydGljaXBhbnRVcGRhdGUiLCJvblNwZWFrZXJzQ2hhbmdlZCIsIm9uUm9vbVVwZGF0ZSIsIm9uQ29ubmVjdGlvblF1YWxpdHkiLCJvblN0cmVhbVN0YXRlVXBkYXRlIiwib25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlIiwib25TdWJzY3JpcHRpb25FcnJvciIsInJlc2V0UGluZ1RpbWVvdXQiLCJtc2dDYXNlIiwic2V0UmVjb25uZWN0ZWQiLCJvbkNsb3NlQ2FsbGJhY2siLCJjbGVhclBpbmdUaW1lb3V0IiwidG9VVENTdHJpbmciLCJyc2QiLCJVUkxTZWFyY2hQYXJhbXMiLCJhdXRvU3Vic2NyaWJlIiwicHVibGlzaE9ubHkiLCJhZGFwdGl2ZVN0cmVhbSIsImNvbm5lY3Rpb24iLCJwYXJzZXIkMSIsImdyYW1tYXIkMiIsImdyYW1tYXIkMSIsInJlZyIsInJhdGUiLCJzdWJ0eXBlIiwiY29uZmlnIiwic2Vzc2lvbkNvbmZpZyIsInN0ciIsInJhZGRyIiwidGNwdHlwZSIsImdlbmVyYXRpb24iLCJkaXIyIiwiY2xrc3JjRXh0IiwibWVkaWFDbG9ja1ZhbHVlIiwicmF0ZU51bWVyYXRvciIsInJhdGVEZW5vbWluYXRvciIsIm9ianMiLCJncmFtbWFyRXhwb3J0cyIsInRvSW50SWZJbnQiLCJhdHRhY2hQcm9wZXJ0aWVzIiwicmF3TmFtZSIsInBhcnNlUmVnIiwiY29udGVudCIsIm5lZWRzQmxhbmsiLCJrZXlMb2NhdGlvbiIsImdyYW1tYXIiLCJ2YWxpZExpbmUiLCJzZXNzaW9uIiwicnRwIiwiZm10cCIsInBhcmFtUmVkdWNlciIsImFjYyIsInBhcnNlUGFyYW1zIiwicGFyc2VGbXRwQ29uZmlnIiwicGFyc2VQYXlsb2FkcyIsInBhcnNlUmVtb3RlQ2FuZGlkYXRlcyIsImNhbmRpZGF0ZXMiLCJwYXJzZUltYWdlQXR0cmlidXRlcyIsInBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdCIsInNjaWQiLCJwYXVzZWQiLCJmb3JtYXRSZWdFeHAiLCJmb3JtYXRTdHIiLCJtYWtlTGluZSIsImRlZmF1bHRPdXRlck9yZGVyIiwiZGVmYXVsdElubmVyT3JkZXIiLCJ3cml0ZXIkMSIsInBheWxvYWRzIiwib3V0ZXJPcmRlciIsImlubmVyT3JkZXIiLCJwYXJzZXIiLCJ3cml0ZSIsInN0YXJ0Qml0cmF0ZUZvclNWQyIsIlBDRXZlbnRzIiwiTmVnb3RpYXRpb25TdGFydGVkIiwiTmVnb3RpYXRpb25Db21wbGV0ZSIsIlJUUFZpZGVvUGF5bG9hZFR5cGVzIiwiUENUcmFuc3BvcnQiLCJjcmVhdGVQQyIsIm1lZGlhQ29uc3RyYWludHMiLCJwZW5kaW5nQ2FuZGlkYXRlcyIsInJlc3RhcnRpbmdJY2UiLCJyZW5lZ290aWF0ZSIsInRyYWNrQml0cmF0ZXMiLCJyZW1vdGVTdGVyZW9NaWRzIiwicmVtb3RlTmFja01pZHMiLCJuZWdvdGlhdGUiLCJjcmVhdGVBbmRTZW5kT2ZmZXIiLCJvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsIm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlIiwib25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSIsIm9uZGF0YWNoYW5uZWwiLCJvbm5lZ290aWF0aW9ubmVlZGVkIiwib25zaWduYWxpbmdzdGF0ZWNoYW5nZSIsIm9uaWNlY2FuZGlkYXRlIiwib250cmFjayIsIm9uSWNlQ2FuZGlkYXRlIiwib25pY2VjYW5kaWRhdGVlcnJvciIsIm9uSWNlQ2FuZGlkYXRlRXJyb3IiLCJvbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSIsIm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2UiLCJvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSIsIm9uRGF0YUNoYW5uZWwiLCJvblRyYWNrIiwiaXNJQ0VDb25uZWN0ZWQiLCJyZW1vdGVEZXNjcmlwdGlvbiIsIm11bmdlZFNEUCIsInN0ZXJlb01pZHMiLCJuYWNrTWlkcyIsImV4dHJhY3RTdGVyZW9BbmROYWNrQXVkaW9Gcm9tT2ZmZXIiLCJzZHBQYXJzZWQiLCJ0cmFja2JyIiwiY29kZWNQYXlsb2FkIiwiZm10cEZvdW5kIiwiYXR0ciIsIm1heGJyIiwic2V0TXVuZ2VkU0RQIiwiaWNlUmVzdGFydCIsImN1cnJlbnRTRCIsImVuc3VyZUF1ZGlvTmFja0FuZFN0ZXJlbyIsImVuc3VyZVZpZGVvRERFeHRlbnNpb25Gb3JTVkMiLCJtc2lkIiwicm91bmQiLCJjcmVhdGVBbmRTZXRBbnN3ZXIiLCJkYXRhQ2hhbm5lbERpY3QiLCJ0cmFuc2NlaXZlckluaXQiLCJzZXRUcmFja0NvZGVjQml0cmF0ZSIsInNldENvbmZpZ3VyYXRpb24iLCJydGNDb25maWciLCJjYW5SZW1vdmVUcmFjayIsImdldENvbm5lY3Rpb25TdGF0ZSIsImdldElDRUNvbm5lY3Rpb25TdGF0ZSIsImdldFNpZ25hbGxpbmdTdGF0ZSIsImdldExvY2FsRGVzY3JpcHRpb24iLCJsb2NhbERlc2NyaXB0aW9uIiwiZ2V0UmVtb3RlRGVzY3JpcHRpb24iLCJnZXRDb25uZWN0ZWRBZGRyZXNzIiwic2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQiLCJjYW5kaWRhdGVQYWlycyIsInNlbGVjdGVkIiwic2VsZWN0ZWRJRCIsInJlbW90ZUNhbmRpZGF0ZUlkIiwibXVuZ2VkIiwicmVtb3RlIiwib3JpZ2luYWxTZHAiLCJyZW1vdGVTZHAiLCJvcHVzUGF5bG9hZCIsInJ0Y3BGYiIsIm1heElEIiwiZGRGb3VuZCIsImV4dCIsImRlZmF1bHRWaWRlb0NvZGVjIiwicHVibGlzaERlZmF1bHRzIiwiYXVkaW9CaXRyYXRlIiwiYXVkaW9QcmVzZXQiLCJkdHgiLCJyZWQiLCJmb3JjZVN0ZXJlbyIsInNjcmVlblNoYXJlRW5jb2RpbmciLCJzdG9wTWljVHJhY2tPbk11dGUiLCJ2aWRlb0NvZGVjIiwiYmFja3VwQ29kZWMiLCJhdXRvR2FpbkNvbnRyb2wiLCJlY2hvQ2FuY2VsbGF0aW9uIiwibm9pc2VTdXBwcmVzc2lvbiIsInJvb21PcHRpb25EZWZhdWx0cyIsImR5bmFjYXN0Iiwic3RvcExvY2FsVHJhY2tPblVucHVibGlzaCIsInJlY29ubmVjdFBvbGljeSIsImRpc2Nvbm5lY3RPblBhZ2VMZWF2ZSIsImV4cFdlYkF1ZGlvTWl4Iiwicm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cyIsIm1heFJldHJpZXMiLCJwZWVyQ29ubmVjdGlvblRpbWVvdXQiLCJQQ1RyYW5zcG9ydFN0YXRlIiwiUENUcmFuc3BvcnRNYW5hZ2VyIiwibmVlZHNQdWJsaXNoZXIiLCJpc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCIsIm5lZWRzU3Vic2NyaWJlciIsImlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZCIsInVwZGF0ZVN0YXRlIiwicHJldmlvdXNTdGF0ZSIsImNvbm5lY3Rpb25TdGF0ZXMiLCJyZXF1aXJlZFRyYW5zcG9ydHMiLCJzdCIsIkZBSUxFRCIsIkNMT1NFRCIsIk5FVyIsIm9uU3RhdGVDaGFuZ2UiLCJwdWJsaXNoZXIiLCJzdWJzY3JpYmVyIiwiUENNYW5hZ2VyIiwiZ29vZ0NvbnN0cmFpbnRzIiwiZ29vZ0RzY3AiLCJTVUJTQ1JJQkVSIiwib25QdWJsaXNoZXJPZmZlciIsInJlcXVpcmVQdWJsaXNoZXIiLCJyZXF1aXJlIiwicmVxdWlyZVN1YnNjcmliZXIiLCJjcmVhdGVBbmRTZW5kUHVibGlzaGVyT2ZmZXIiLCJzZXRQdWJsaXNoZXJBbnN3ZXIiLCJ0cmlnZ2VySWNlUmVzdGFydCIsImNyZWF0ZVN1YnNjcmliZXJBbnN3ZXJGcm9tT2ZmZXIiLCJSVENTZHBUeXBlIiwidXBkYXRlQ29uZmlndXJhdGlvbiIsImVuc3VyZVBDVHJhbnNwb3J0Q29ubmVjdGlvbiIsImFib3J0Q29udHJvbGxlciIsInRyYW5zcG9ydCIsImVuc3VyZVRyYW5zcG9ydENvbm5lY3RlZCIsIm5lZ290aWF0aW9uVGltZW91dCIsInNpZ25hbCIsImFkZFB1Ymxpc2hlclRyYW5zY2VpdmVyIiwiYWRkUHVibGlzaGVyVHJhY2siLCJjcmVhdGVQdWJsaXNoZXJEYXRhQ2hhbm5lbCIsInRyYW5zcG9ydHMiLCJwY1RyYW5zcG9ydCIsImNvbm5lY3RUaW1lb3V0IiwibG9zc3lEYXRhQ2hhbm5lbCIsInJlbGlhYmxlRGF0YUNoYW5uZWwiLCJtaW5SZWNvbm5lY3RXYWl0IiwibGVhdmVSZWNvbm5lY3QiLCJQQ1N0YXRlIiwiUlRDRW5naW5lIiwiaXNDbG9zZWQiLCJfaXNDbG9zZWQiLCJmdWxsUmVjb25uZWN0T25OZXh0IiwicGNTdGF0ZSIsIk5ldyIsInBlbmRpbmdUcmFja1Jlc29sdmVycyIsInJlY29ubmVjdEF0dGVtcHRzIiwicmVjb25uZWN0U3RhcnQiLCJhdHRlbXB0aW5nUmVjb25uZWN0Iiwiam9pbkF0dGVtcHRzIiwibWF4Sm9pbkF0dGVtcHRzIiwic2hvdWxkRmFpbE5leHQiLCJoYW5kbGVEYXRhQ2hhbm5lbCIsInJlbGlhYmxlRENTdWIiLCJsb3NzeURDU3ViIiwiaGFuZGxlRGF0YU1lc3NhZ2UiLCJkYXRhUHJvY2Vzc0xvY2siLCJCbG9iIiwiYXJyYXlCdWZmZXIiLCJkcCIsIkFjdGl2ZVNwZWFrZXJzVXBkYXRlIiwiRGF0YVBhY2tldFJlY2VpdmVkIiwiaGFuZGxlRGF0YUVycm9yIiwiY3VycmVudFRhcmdldCIsImNoYW5uZWxLaW5kIiwibWF4UmV0cmFuc21pdHMiLCJFcnJvckV2ZW50IiwiaGFuZGxlQnVmZmVyZWRBbW91bnRMb3ciLCJMT1NTWSIsInVwZGF0ZUFuZEVtaXREQ0J1ZmZlclN0YXR1cyIsImhhbmRsZURpc2Nvbm5lY3QiLCJkaXNjb25uZWN0UmVhc29uIiwiZGlzY29ubmVjdCIsIkRpc2Nvbm5lY3RlZCIsImRlbGF5IiwiZ2V0TmV4dFJldHJ5RGVsYXkiLCJlbGFwc2VkTXMiLCJjbGVhclJlY29ubmVjdFRpbWVvdXQiLCJyZWdpb25VcmxQcm92aWRlciIsInVwZGF0ZVRva2VuIiwicmVjb25uZWN0VGltZW91dCIsImF0dGVtcHRSZWNvbm5lY3QiLCJ3YWl0Rm9yUmVzdGFydGVkIiwib25SZXN0YXJ0ZWQiLCJvbkRpc2Nvbm5lY3RlZCIsImlzQnVmZmVyU3RhdHVzTG93IiwiZGNCdWZmZXJTdGF0dXMiLCJEQ0J1ZmZlclN0YXR1c0NoYW5nZWQiLCJkYXRhQ2hhbm5lbEZvcktpbmQiLCJidWZmZXJlZEFtb3VudCIsImJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkIiwiaGFuZGxlQnJvd3Nlck9uTGluZSIsImNsaWVudCIsIlJSX1NJR05BTF9ESVNDT05ORUNURUQiLCJFbmdpbmUiLCJleHBTaWduYWxMYXRlbmN5IiwicmVnaXN0ZXJPbkxpbmVMaXN0ZW5lciIsInVwZGF0ZSIsIlN0cmVhbVN0YXRlQ2hhbmdlZCIsIl9lIiwiX2YiLCJsYXRlc3RKb2luUmVzcG9uc2UiLCJyb29tU2lkIiwic2lnbmFsT3B0cyIsInNldHVwU2lnbmFsQ2xpZW50Q2FsbGJhY2tzIiwiam9pblJlc3BvbnNlIiwicGNNYW5hZ2VyIiwiY29uZmlndXJlIiwiY2xpZW50Q29uZmlndXJhdGlvbiIsIkNsb3NpbmciLCJkZXJlZ2lzdGVyT25MaW5lTGlzdGVuZXIiLCJjbGVhclBlbmRpbmdSZWNvbm5lY3QiLCJjbGVhbnVwUGVlckNvbm5lY3Rpb25zIiwiY2xlYW51cENsaWVudCIsImRjQ2xlYW51cCIsIm9uYnVmZmVyZWRhbW91bnRsb3ciLCJvbmNsb3NpbmciLCJsb3NzeURDIiwicmVsaWFibGVEQyIsInB1YmxpY2F0aW9uVGltZW91dCIsInVwZGF0ZU11dGVTdGF0dXMiLCJkYXRhU3Vic2NyaWJlclJlYWR5U3RhdGUiLCJnZXRDb25uZWN0ZWRTZXJ2ZXJBZGRyZXNzIiwic2V0UmVnaW9uVXJsUHJvdmlkZXIiLCJwcm92aWRlciIsIm1ha2VSVENDb25maWd1cmF0aW9uIiwiVHJhbnNwb3J0c0NyZWF0ZWQiLCJwdWJsaXNoZXJTdGF0ZSIsInN1YnNjcmliZXJTdGF0ZSIsInNob3VsZEVtaXQiLCJSUl9TVUJTQ1JJQkVSX0ZBSUxFRCIsIlJSX1BVQkxJU0hFUl9GQUlMRUQiLCJNZWRpYVRyYWNrQWRkZWQiLCJjcmVhdGVEYXRhQ2hhbm5lbHMiLCJMb2NhbFRyYWNrVW5wdWJsaXNoZWQiLCJSZW1vdGVNdXRlIiwibGVhdmUiLCJzZXJ2ZXJSZXNwb25zZSIsImUyZWVFbmFibGVkIiwiZW5jb2RlZEluc2VydGFibGVTdHJlYW1zIiwicnRjSWNlU2VydmVycyIsImljZVNlcnZlciIsInJ0Y0ljZVNlcnZlciIsIkVOQUJMRUQiLCJpY2VUcmFuc3BvcnRQb2xpY3kiLCJjb250aW51YWxHYXRoZXJpbmdQb2xpY3kiLCJvcmRlcmVkIiwic2V0UHJlZmVycmVkQ29kZWMiLCJjYXAiLCJtYXRjaGVkIiwicGFydGlhbE1hdGNoZWQiLCJ1bm1hdGNoZWQiLCJtYXRjaGVzVmlkZW9Db2RlYyIsInNkcEZtdHBMaW5lIiwic2V0Q29kZWNQcmVmZXJlbmNlcyIsImNyZWF0ZVNlbmRlciIsImNyZWF0ZVRyYW5zY2VpdmVyUlRDUnRwU2VuZGVyIiwiY3JlYXRlUlRDUnRwU2VuZGVyIiwiY3JlYXRlU2ltdWxjYXN0U2VuZGVyIiwic2ltdWxjYXN0VHJhY2siLCJjcmVhdGVTaW11bGNhc3RUcmFuc2NlaXZlclNlbmRlciIsInNldFNpbXVsY2FzdFRyYWNrU2VuZGVyIiwiRElTQUJMRUQiLCJyZXN0YXJ0Q29ubmVjdGlvbiIsInJlY292ZXJhYmxlIiwiU2lnbmFsUmVjb25uZWN0RXJyb3IiLCJSUl9VTktOT1dOIiwicmVnaW9uVXJsIiwiUmVzdGFydGluZyIsIlNpZ25hbFJlc3RhcnRlZCIsIndhaXRGb3JQQ1JlY29ubmVjdGVkIiwicmVzZXRBdHRlbXB0cyIsIm5leHRSZWdpb25VcmwiLCJnZXROZXh0QmVzdFJlZ2lvblVybCIsIlJlc3VtaW5nIiwiU2lnbmFsUmVzdW1lZCIsIlJlc3VtZWQiLCJ3YWl0Rm9yUENJbml0aWFsQ29ubmVjdGlvbiIsIlJlY29ubmVjdGluZyIsInNlbmREYXRhUGFja2V0IiwicGFja2V0IiwiZW5zdXJlUHVibGlzaGVyQ29ubmVjdGVkIiwiZW5zdXJlRGF0YVRyYW5zcG9ydENvbm5lY3RlZCIsInRyYW5zcG9ydE5hbWUiLCJ0YXJnZXRDaGFubmVsIiwiZW5kVGltZSIsInZlcmlmeVRyYW5zcG9ydCIsIkFib3J0Q29udHJvbGxlciIsImhhbmRsZUNsb3NlZCIsImFib3J0IiwicnRwVHlwZXMiLCJyZW1vdGVUcmFja3MiLCJsb2NhbFRyYWNrcyIsInByZXZpb3VzQW5zd2VyIiwicHJldmlvdXNPZmZlciIsImlzRGVzaXJlZCIsInN1YnNjcmlwdGlvbiIsImRhdGFDaGFubmVsc0luZm8iLCJmYWlsTmV4dCIsImdldEluZm8iLCJSZWdpb25VcmxQcm92aWRlciIsImxhc3RVcGRhdGVBdCIsInNldHRpbmdzQ2FjaGVUaW1lIiwiYXR0ZW1wdGVkUmVnaW9ucyIsIlVSTCIsImdldFNlcnZlclVybCIsInJlZ2lvblNldHRpbmdzIiwiZmV0Y2hSZWdpb25TZXR0aW5ncyIsInJlZ2lvbnNMZWZ0IiwiYXR0ZW1wdGVkIiwibmV4dFJlZ2lvbiIsInJlZ2lvblNldHRpbmdzUmVzcG9uc2UiLCJnZXRDbG91ZENvbmZpZ1VybCIsImhlYWRlcnMiLCJhdXRob3JpemF0aW9uIiwic3RhdHVzVGV4dCIsImhvc3QiLCJtb25pdG9yRnJlcXVlbmN5IiwiY29tcHV0ZUJpdHJhdGUiLCJjdXJyZW50U3RhdHMiLCJwcmV2U3RhdHMiLCJieXRlc05vdyIsImJ5dGVzUHJldiIsImJ5dGVzUmVjZWl2ZWQiLCJieXRlc1NlbnQiLCJMb2NhbEF1ZGlvVHJhY2siLCJzdG9wT25NdXRlIiwibW9uaXRvclNlbmRlciIsImdldFNlbmRlclN0YXRzIiwiY2hlY2tGb3JTaWxlbmNlIiwic2V0RGV2aWNlSWQiLCJyZXN0YXJ0VHJhY2siLCJkZXZpY2VIYXNDaGFuZ2VkIiwic3RhcnRNb25pdG9yIiwic2V0QXVkaW9Db250ZXh0IiwiYXVkaW9TdGF0cyIsInBhY2tldHNTZW50Iiwicm91bmRUcmlwVGltZSIsImppdHRlciIsInRyYWNrSXNTaWxlbnQiLCJBdWRpb1NpbGVuY2VEZXRlY3RlZCIsIm1lZGlhVHJhY2tUb0xvY2FsVHJhY2siLCJMb2NhbFZpZGVvVHJhY2siLCJwcmVzZXRzMTY5IiwicHJlc2V0czQzIiwicHJlc2V0c1NjcmVlblNoYXJlIiwiZGVmYXVsdFNpbXVsY2FzdFByZXNldHMxNjkiLCJkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czQzIiwiY29tcHV0ZURlZmF1bHRTY3JlZW5TaGFyZVNpbXVsY2FzdFByZXNldHMiLCJmcm9tUHJlc2V0IiwidmlkZW9SaWRzIiwiY29tcHV0ZVZpZGVvRW5jb2RpbmdzIiwiaXNTY3JlZW5TaGFyZSIsInZpZGVvRW5jb2RpbmciLCJ1c2VTaW11bGNhc3QiLCJzY2FsYWJpbGl0eU1vZGUiLCJkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nIiwic20iLCJTY2FsYWJpbGl0eU1vZGUiLCJzcGF0aWFsIiwicHJlc2V0cyIsInNvcnRQcmVzZXRzIiwic2NyZWVuU2hhcmVTaW11bGNhc3RMYXllcnMiLCJkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzIiwidmlkZW9TaW11bGNhc3RMYXllcnMiLCJtaWRQcmVzZXQiLCJsb3dQcmVzZXQiLCJlbmNvZGluZ3NGcm9tUHJlc2V0cyIsImNvbXB1dGVUcmFja0JhY2t1cEVuY29kaW5ncyIsInNlcnZlclJlcXVlc3RlZCIsInByZXNldHNGb3JSZXNvbHV0aW9uIiwicHJlc2V0IiwiYXNwZWN0IiwiYWJzIiwiY2FuU2V0UHJpb3JpdHkiLCJuZXR3b3JrUHJpb3JpdHkiLCJ0b3BGcmFtZXJhdGUiLCJub3RpZnlPbmNlIiwiYUVuYyIsImJFbmMiLCJyZXN1bHRzIiwidGVtcG9yYWwiLCJzdWZmaXgiLCJyZWZyZXNoU3Vic2NyaWJlZENvZGVjQWZ0ZXJOZXdDb2RlYyIsInN0YXRzTWFwIiwidG90YWxCaXRyYXRlIiwic2VuZGVyTG9jayIsImlzU2ltdWxjYXN0Iiwic2lnbmFsQ2xpZW50IiwiZV8xIiwiX2ciLCJzYyIsImVfMV8xIiwicmV0dXJuIiwiZV8yIiwiZV8yXzEiLCJpdGVtcyIsInZzIiwiZnJhbWVIZWlnaHQiLCJmcmFtZVdpZHRoIiwiZmlyQ291bnQiLCJwbGlDb3VudCIsIm5hY2tDb3VudCIsImZyYW1lc1NlbnQiLCJyZXRyYW5zbWl0dGVkUGFja2V0c1NlbnQiLCJxdWFsaXR5TGltaXRhdGlvblJlYXNvbiIsInF1YWxpdHlMaW1pdGF0aW9uUmVzb2x1dGlvbkNoYW5nZXMiLCJzZXRQdWJsaXNoaW5nUXVhbGl0eSIsIm1heFF1YWxpdHkiLCJxIiwiSElHSCIsInNldFB1Ymxpc2hpbmdMYXllcnMiLCJlXzMiLCJlXzNfMSIsImVfNCIsIl9oIiwiZV80XzEiLCJhZGRTaW11bGNhc3RUcmFjayIsInNpbXVsY2FzdENvZGVjSW5mbyIsInNldFB1Ymxpc2hpbmdDb2RlY3MiLCJjb2RlY3NfMSIsImNvZGVjc18xXzEiLCJlXzUiLCJjdXJyZW50Q29kZWMiLCJuZXdDb2RlY3MiLCJzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyIiwiZV81XzEiLCJzZW5kZXJFbmNvZGluZ3MiLCJoYXNDaGFuZ2VkIiwiY2xvc2FibGVTcGF0aWFsIiwidmlkZW9RdWFsaXR5Rm9yUmlkIiwic3Vic2NyaWJlZFF1YWxpdHkiLCJNRURJVU0iLCJ2aWRlb0xheWVyc0Zyb21FbmNvZGluZ3MiLCJzdmMiLCJlbmNvZGluZ1NNIiwic2NhbGUiLCJSZW1vdGVUcmFjayIsInNldE11dGVkIiwic2V0TWVkaWFTdHJlYW0iLCJvblJlbW92ZVRyYWNrIiwibW9uaXRvclJlY2VpdmVyIiwiUmVtb3RlQXVkaW9UcmFjayIsImF1ZGlvT3V0cHV0IiwiZ2V0UmVjZWl2ZXJTdGF0cyIsIndlYkF1ZGlvUGx1Z2luTm9kZXMiLCJzaW5rSWQiLCJzZXRWb2x1bWUiLCJnYWluTm9kZSIsInNldFRhcmdldEF0VGltZSIsIl9zZXRWb2x1bWUiLCJlbGVtZW50Vm9sdW1lIiwiZ2V0Vm9sdW1lIiwiaGlnaGVzdFZvbHVtZSIsInNldFNpbmtJZCIsIm5lZWRzTmV3V2ViQXVkaW9Db25uZWN0aW9uIiwiY29ubmVjdFdlYkF1ZGlvIiwiZGlzY29ubmVjdFdlYkF1ZGlvIiwic2V0V2ViQXVkaW9QbHVnaW5zIiwibm9kZXMiLCJzb3VyY2VOb2RlIiwibGFzdE5vZGUiLCJub2RlIiwiZGVzdGluYXRpb24iLCJyZXN1bWUiLCJyZWNlaXZlclN0YXRzIiwiY29uY2VhbGVkU2FtcGxlcyIsImNvbmNlYWxtZW50RXZlbnRzIiwic2lsZW50Q29uY2VhbGVkU2FtcGxlcyIsInNpbGVudENvbmNlYWxtZW50RXZlbnRzIiwidG90YWxBdWRpb0VuZXJneSIsInRvdGFsU2FtcGxlc0R1cmF0aW9uIiwiUkVBQ1RJT05fREVMQVkiLCJSZW1vdGVWaWRlb1RyYWNrIiwiYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyIsImVsZW1lbnRJbmZvcyIsImRlYm91bmNlZEhhbmRsZVJlc2l6ZSIsInVwZGF0ZURpbWVuc2lvbnMiLCJpc0FkYXB0aXZlU3RyZWFtIiwiZWxlbWVudEluZm8iLCJIVE1MRWxlbWVudEluZm8iLCJvYnNlcnZlRWxlbWVudEluZm8iLCJ1cGRhdGVWaXNpYmlsaXR5Iiwib2JzZXJ2ZSIsInN0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyIsInN0b3BFbGVtZW50SW5mb3MiLCJzdG9wT2JzZXJ2aW5nIiwiZGV0YWNoZWRFbGVtZW50cyIsInN0b3BPYnNlcnZpbmdFbGVtZW50IiwiZ2V0RGVjb2RlckltcGxlbWVudGF0aW9uIiwiZGVjb2RlckltcGxlbWVudGF0aW9uIiwiY29kZWNJRCIsImNvZGVjSWQiLCJmcmFtZXNEZWNvZGVkIiwiZnJhbWVzRHJvcHBlZCIsImZyYW1lc1JlY2VpdmVkIiwicGFja2V0c1JlY2VpdmVkIiwibGFzdFZpc2liaWxpdHlDaGFuZ2UiLCJ2aXNpYmlsaXR5Q2hhbmdlZEF0IiwiYmFja2dyb3VuZFBhdXNlIiwicGF1c2VWaWRlb0luQmFja2dyb3VuZCIsImlzUGlQTW9kZSIsInBpY3R1cmVJblBpY3R1cmUiLCJpc1Zpc2libGUiLCJ2aXNpYmxlIiwibGFzdFZpc2libGUiLCJWaXNpYmlsaXR5Q2hhbmdlZCIsInBpeGVsRGVuc2l0eSIsImdldFBpeGVsRGVuc2l0eSIsImN1cnJlbnRFbGVtZW50V2lkdGgiLCJjdXJyZW50RWxlbWVudEhlaWdodCIsImxhc3REaW1lbnNpb25zIiwiVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCIsImlzUGlQIiwiaXNJbnRlcnNlY3RpbmciLCJvblZpc2liaWxpdHlDaGFuZ2VkIiwib25FbnRlclBpUCIsIm9uTGVhdmVQaVAiLCJpc0VsZW1lbnRJblZpZXdwb3J0IiwicGljdHVyZUluUGljdHVyZUVsZW1lbnQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsInVub2JzZXJ2ZSIsInRvcCIsIm9mZnNldFRvcCIsImxlZnQiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJvcGFjaXR5IiwiZGlzcGxheSIsImdldENvbXB1dGVkU3R5bGUiLCJvZmZzZXRQYXJlbnQiLCJwYWdlWU9mZnNldCIsImlubmVySGVpZ2h0IiwicGFnZVhPZmZzZXQiLCJpbm5lcldpZHRoIiwiVHJhY2tQdWJsaWNhdGlvbiIsIm1ldGFkYXRhTXV0ZWQiLCJoYW5kbGVNdXRlZCIsImhhbmRsZVVubXV0ZWQiLCJQdWJsaWNhdGlvbiIsInNldFRyYWNrIiwiaXNTdWJzY3JpYmVkIiwiYXVkaW9UcmFjayIsInZpZGVvVHJhY2siLCJ1cGRhdGVJbmZvIiwic2ltdWxjYXN0ZWQiLCJTdWJzY3JpcHRpb25TdGF0dXMiLCJQZXJtaXNzaW9uU3RhdHVzIiwiTG9jYWxUcmFja1B1YmxpY2F0aW9uIiwidGkiLCJoYW5kbGVUcmFja0VuZGVkIiwicXVhbGl0eUZyb21Qcm90byIsIkVYQ0VMTEVOVCIsIkV4Y2VsbGVudCIsIkdPT0QiLCJHb29kIiwiUG9vciIsIkxPU1QiLCJMb3N0IiwiUGFydGljaXBhbnQiLCJpc0FnZW50IiwicGVybWlzc2lvbnMiLCJhdWRpb0xldmVsIiwiaXNTcGVha2luZyIsIl9jb25uZWN0aW9uUXVhbGl0eSIsImF1ZGlvVHJhY2tzIiwidmlkZW9UcmFja3MiLCJnZXRUcmFjayIsImdldFRyYWNrQnlOYW1lIiwiY29ubmVjdGlvblF1YWxpdHkiLCJpc0NhbWVyYUVuYWJsZWQiLCJpc01pY3JvcGhvbmVFbmFibGVkIiwiaXNTY3JlZW5TaGFyZUVuYWJsZWQiLCJwYXJ0aWNpcGFudEluZm8iLCJfc2V0TmFtZSIsIl9zZXRNZXRhZGF0YSIsInBlcm1pc3Npb24iLCJzZXRQZXJtaXNzaW9ucyIsIm1kIiwiY2hhbmdlZCIsInByZXZNZXRhZGF0YSIsIlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkIiwiUGFydGljaXBhbnROYW1lQ2hhbmdlZCIsInByZXZQZXJtaXNzaW9ucyIsIlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkIiwic2V0SXNTcGVha2luZyIsInNwZWFraW5nIiwibGFzdFNwb2tlQXQiLCJJc1NwZWFraW5nQ2hhbmdlZCIsInNldENvbm5lY3Rpb25RdWFsaXR5IiwicHJldlF1YWxpdHkiLCJDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQiLCJhZGRUcmFja1B1YmxpY2F0aW9uIiwiVHJhY2tNdXRlZCIsIlRyYWNrVW5tdXRlZCIsInRyYWNrUGVybWlzc2lvblRvUHJvdG8iLCJwZXJtcyIsImFsbG93QWxsIiwiYWxsb3dlZFRyYWNrU2lkcyIsIlJlbW90ZVRyYWNrUHVibGljYXRpb24iLCJjdXJyZW50VmlkZW9RdWFsaXR5IiwiaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSIsImVtaXRUcmFja1VwZGF0ZSIsImhhbmRsZVZpZGVvRGltZW5zaW9uc0NoYW5nZSIsInZpZGVvRGltZW5zaW9ucyIsInN1YnNjcmliZWQiLCJzZXRTdWJzY3JpYmVkIiwicHJldlN0YXR1cyIsInN1YnNjcmlwdGlvblN0YXR1cyIsInByZXZQZXJtaXNzaW9uIiwicGVybWlzc2lvblN0YXR1cyIsImVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQiLCJlbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZCIsIlVuc3Vic2NyaWJlZCIsIkRlc2lyZWQiLCJTdWJzY3JpYmVkIiwiQWxsb3dlZCIsIk5vdEFsbG93ZWQiLCJzZXRFbmFibGVkIiwiaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkIiwic2V0VmlkZW9RdWFsaXR5Iiwic2V0VmlkZW9EaW1lbnNpb25zIiwic2V0VmlkZW9GUFMiLCJ2aWRlb1F1YWxpdHkiLCJwcmV2VHJhY2siLCJzZXRBbGxvd2VkIiwic2V0U3Vic2NyaXB0aW9uRXJyb3IiLCJTdWJzY3JpcHRpb25GYWlsZWQiLCJwcmV2TWV0YWRhdGFNdXRlZCIsInByZXZpb3VzU3RhdHVzIiwiY3VycmVudFN0YXR1cyIsIlN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQiLCJwcmV2aW91c1Blcm1pc3Npb25TdGF0dXMiLCJjdXJyZW50UGVybWlzc2lvblN0YXR1cyIsIlN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkIiwiVXBkYXRlU2V0dGluZ3MiLCJSZW1vdGVQYXJ0aWNpcGFudCIsImZyb21QYXJ0aWNpcGFudEluZm8iLCJwaSIsInZvbHVtZU1hcCIsIlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQiLCJUcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQiLCJwcmV2aW91c1RyYWNrIiwiVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQiLCJhdWRpb1B1YmxpY2F0aW9uIiwiYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2siLCJ0cmllc0xlZnQiLCJnZXRUcmFja1B1YmxpY2F0aW9uIiwiaXNWaWRlbyIsImhhc01ldGFkYXRhIiwidmFsaWRUcmFja3MiLCJuZXdUcmFja3MiLCJleGlzdGluZ1RyYWNrT2ZTb3VyY2UiLCJwdWJsaXNoZWRUcmFjayIsIm9sZFRyYWNrIiwidW5wdWJsaXNoVHJhY2siLCJzZW5kVW5wdWJsaXNoIiwiVHJhY2tVbnB1Ymxpc2hlZCIsInNldEF1ZGlvT3V0cHV0IiwicHJvbWlzZXMiLCJMb2NhbFBhcnRpY2lwYW50IiwicGVuZGluZ1B1Ymxpc2hpbmciLCJwZW5kaW5nUHVibGlzaFByb21pc2VzIiwicGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zIiwiYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlIiwiZW5jcnlwdGlvblR5cGUiLCJoYW5kbGVSZWNvbm5lY3RpbmciLCJyZWNvbm5lY3RGdXR1cmUiLCJoYW5kbGVSZWNvbm5lY3RlZCIsInVwZGF0ZVRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMiLCJoYW5kbGVEaXNjb25uZWN0ZWQiLCJhbGxQYXJ0aWNpcGFudHNBbGxvd2VkIiwib25UcmFja1VubXV0ZWQiLCJvblRyYWNrTXV0ZWQiLCJvblRyYWNrVXBzdHJlYW1QYXVzZWQiLCJvblRyYWNrVXBzdHJlYW1SZXN1bWVkIiwiaGFuZGxlU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUiLCJyb29tT3B0aW9ucyIsIm5ld0NvZGVjc18xIiwibmV3Q29kZWNzXzFfMSIsInB1Ymxpc2hBZGRpdGlvbmFsQ29kZWNGb3JUcmFjayIsImhhbmRsZUxvY2FsVHJhY2tVbnB1Ymxpc2hlZCIsInVucHVibGlzaGVkIiwiY3VycmVudFBlcm1pc3Npb25zIiwicXVlcnkiLCJvbmNoYW5nZSIsImFjdGl2ZURldmljZU1hcCIsImxhc3RDYW1lcmFFcnJvciIsImNhbWVyYUVycm9yIiwibGFzdE1pY3JvcGhvbmVFcnJvciIsIm1pY3JvcGhvbmVFcnJvciIsInNldE1ldGFkYXRhIiwic2V0TmFtZSIsInNldENhbWVyYUVuYWJsZWQiLCJwdWJsaXNoT3B0aW9ucyIsInNldFRyYWNrRW5hYmxlZCIsInNldE1pY3JvcGhvbmVFbmFibGVkIiwic2V0U2NyZWVuU2hhcmVFbmFibGVkIiwic2V0RTJFRUVuYWJsZWQiLCJHQ00iLCJyZXB1Ymxpc2hBbGxUcmFja3MiLCJhZGQiLCJjcmVhdGVUcmFja3MiLCJjcmVhdGVTY3JlZW5UcmFja3MiLCJwdWJsaXNoUHJvbWlzZXMiLCJsb2NhbFRyYWNrIiwicHVibGlzaFRyYWNrIiwicHVibGlzaGVkVHJhY2tzIiwiTWVkaWFEZXZpY2VzRXJyb3IiLCJzY3JlZW5BdWRpb1RyYWNrIiwiZW5hYmxlQ2FtZXJhQW5kTWljcm9waG9uZSIsImF1ZGlvQ2FwdHVyZURlZmF1bHRzIiwidmlkZW9DYXB0dXJlRGVmYXVsdHMiLCJBdWRpb1N0cmVhbUFjcXVpcmVkIiwiaXNBdWRpbyIsInRyYWNrQ29uc3RyYWludHMiLCJjb25PckJvb2wiLCJzY3JlZW5WaWRlbyIsImNvbnRlbnRIaW50Iiwic2NyZWVuQXVkaW8iLCJkZWZhdWx0Q29uc3RyYWludHMiLCJkZXZpY2VLaW5kIiwiZXhpc3RpbmdQdWJsaWNhdGlvbiIsImlzU3RlcmVvSW5wdXQiLCJjaGFubmVsQ291bnQiLCJpc1N0ZXJlbyIsImUyZWUiLCJwdWJsaXNoUHJvbWlzZSIsIl9qIiwiX2siLCJfbCIsIl9tIiwiX28iLCJkZWZhdWx0UmVzIiwicHJpbWFyeUNvZGVjTWltZSIsInVwZGF0ZWRDb2RlYyIsInRyYWNrVHJhbnNjZWl2ZXIiLCJzdG9wT25VbnB1Ymxpc2giLCJnZXRQdWJsaWNhdGlvbkZvclRyYWNrIiwicHViTG9nQ29udGV4dCIsIm5lZ290aWF0aW9uTmVlZGVkIiwidHJhY2tTZW5kZXIiLCJjbGVhciIsInVucHVibGlzaFRyYWNrcyIsInJlc3RhcnRUcmFja3MiLCJsb2NhbFB1YnMiLCJwdWJsaXNoRGF0YSIsInRvcGljIiwic2V0VHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyIsIm11dGVkT25TZXJ2ZXIiLCJjb25uZWN0aW9uUmVjb25jaWxlRnJlcXVlbmN5IiwiUm9vbVN0YXRlIiwiX3RoaXMiLCJhY3RpdmVTcGVha2VycyIsImF1ZGlvRW5hYmxlZCIsImlzVmlkZW9QbGF5YmFja0Jsb2NrZWQiLCJ1bmxvY2tEaXNjb25uZWN0IiwiZGlzY29ubmVjdExvY2siLCJjb25uZWN0RnV0dXJlIiwic2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZSIsIkNvbm5lY3RpbmciLCJjb25uZWN0Rm4iLCJhdHRlbXB0Q29ubmVjdGlvbiIsIm5leHRVcmwiLCJjbGVhckNvbm5lY3Rpb25GdXR1cmVzIiwiY29ubmVjdFNpZ25hbCIsImUyZWVNYW5hZ2VyIiwic2VydmVySW5mbyIsImFwcGx5Sm9pblJlc3BvbnNlIiwiaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzIiwiaGFuZGxlUm9vbVVwZGF0ZSIsInJlY3JlYXRlRW5naW5lIiwibWF5YmVDcmVhdGVFbmdpbmUiLCJhY3F1aXJlQXVkaW9Db250ZXh0IiwiY29ubk9wdGlvbnMiLCJzZXR1cExvY2FsUGFydGljaXBhbnRFdmVudHMiLCJyZXN1bHRpbmdFcnJvciIsIm9uUGFnZUxlYXZlIiwiaGFuZGxlRGV2aWNlQ2hhbmdlIiwicmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlIiwic3RvcFRyYWNrcyIsInN0YXJ0QXVkaW8iLCJlbGVtZW50cyIsImF1ZGlvSWQiLCJkdW1teUF1ZGlvRWwiLCJnZXRFbGVtZW50QnlJZCIsImJvZHkiLCJhcHBlbmQiLCJoYW5kbGVBdWRpb1BsYXliYWNrU3RhcnRlZCIsImhhbmRsZUF1ZGlvUGxheWJhY2tGYWlsZWQiLCJzdGFydFZpZGVvIiwiaGFuZGxlVmlkZW9QbGF5YmFja1N0YXJ0ZWQiLCJoYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkIiwiaGFuZGxlUmVzdGFydGluZyIsImNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSIsImhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkIiwiaGFuZGxlU2lnbmFsUmVzdGFydGVkIiwiY2FjaGVkUGFydGljaXBhbnRTaWRzIiwiX3AiLCJSZWNvbm5lY3RlZCIsIlBhcnRpY2lwYW50Q29ubmVjdGVkIiwicGFydGljaXBhbnRJbmZvcyIsImlkZW50aXR5VG9TaWQiLCJyZW1vdGVQYXJ0aWNpcGFudCIsImlzTmV3UGFydGljaXBhbnQiLCJnZXRPckNyZWF0ZVBhcnRpY2lwYW50IiwiaGFuZGxlQWN0aXZlU3BlYWtlcnNVcGRhdGUiLCJzZWVuU2lkcyIsInNwZWFrZXIiLCJlbWl0V2hlbkNvbm5lY3RlZCIsIkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCIsImhhbmRsZVNwZWFrZXJzQ2hhbmdlZCIsInNwZWFrZXJVcGRhdGVzIiwibGFzdFNwZWFrZXJzIiwiaGFuZGxlU3RyZWFtU3RhdGVVcGRhdGUiLCJzdHJlYW1TdGF0ZVVwZGF0ZSIsIlRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkIiwiaGFuZGxlU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSIsImhhbmRsZVN1YnNjcmlwdGlvbkVycm9yIiwiaGFuZGxlRGF0YVBhY2tldCIsInVzZXJQYWNrZXQiLCJEYXRhUmVjZWl2ZWQiLCJjYW5QbGF5YmFja0F1ZGlvIiwiQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQiLCJWaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCIsIk1lZGlhRGV2aWNlc0NoYW5nZWQiLCJvbGRSb29tIiwicm9vbUluZm8iLCJSb29tTWV0YWRhdGFDaGFuZ2VkIiwiUmVjb3JkaW5nU3RhdHVzQ2hhbmdlZCIsImhhbmRsZUNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlIiwib25Mb2NhbFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkIiwib25Mb2NhbFBhcnRpY2lwYW50TmFtZUNoYW5nZWQiLCJvbkxvY2FsVHJhY2tNdXRlZCIsIm9uTG9jYWxUcmFja1VubXV0ZWQiLCJfcSIsIkxvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWQiLCJBY3RpdmVEZXZpY2VDaGFuZ2VkIiwib25Mb2NhbENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCIsIm9uTWVkaWFEZXZpY2VzRXJyb3IiLCJvbkxvY2FsUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQiLCJzd2l0Y2hBY3RpdmVEZXZpY2UiLCJzZXR1cEUyRUUiLCJpc1JlY29yZGluZyIsIm9uVHJhY2tBZGRlZCIsInVwZGF0ZVN1YnNjcmlwdGlvbnMiLCJkaWZmUGFydGljaXBhbnRzIiwiZ2V0TG9jYWxEZXZpY2VzIiwicHJlcGFyZUNvbm5lY3Rpb24iLCJzaW11bGF0ZVNjZW5hcmlvIiwicG9zdEFjdGlvbiIsImNhblBsYXliYWNrVmlkZW8iLCJnZXRBY3RpdmVBdWRpb091dHB1dERldmljZSIsImdldEFjdGl2ZURldmljZSIsInN1Y2Nlc3MiLCJkZXZpY2VDb25zdHJhaW50IiwicHJldkRldmljZUlkIiwicmVjb25uZWN0ZWRIYW5kbGVyIiwic2hvdWxkU3RvcFRyYWNrcyIsIlBhcnRpY2lwYW50RGlzY29ubmVjdGVkIiwibmV3Q29udGV4dElzUnVubmluZyIsImNyZWF0ZVBhcnRpY2lwYW50IiwidHJhY2tQdWJsaWNhdGlvbiIsImNvbnNlY3V0aXZlRmFpbHVyZXMiLCJjb25uZWN0aW9uUmVjb25jaWxlSW50ZXJ2YWwiLCJudW1GYWlsdXJlcyIsImNsb3NlZCIsInRyYW5zcG9ydHNDb25uZWN0ZWQiLCJTVEFURV9NSVNNQVRDSCIsInNpbXVsYXRlUGFydGljaXBhbnRzIiwidXNlUmVhbFRyYWNrcyIsInBhcnRpY2lwYW50T3B0aW9ucyIsImFzcGVjdFJhdGlvcyIsImNhbVB1YiIsImF1ZGlvUHViIiwiZHVtbXlWaWRlbyIsIl9sZW4yIiwiX2tleTIiLCJtaW5pbWl6ZWRBcmdzIiwibWFwQXJncyIsIkNoZWNrU3RhdHVzIiwiQ2hlY2tlciIsIklETEUiLCJsb2dzIiwiZXJyb3JzQXNXYXJuaW5ncyIsIm9uQ29tcGxldGUiLCJzZXRTdGF0dXMiLCJwZXJmb3JtIiwiYXBwZW5kV2FybmluZyIsImFwcGVuZEVycm9yIiwiU0tJUFBFRCIsImlzU3VjY2VzcyIsIlNVQ0NFU1MiLCJhcHBlbmRNZXNzYWdlIiwiY3JlYXRlTG9jYWxUcmFja3MiLCJtZWRpYVByb21pc2UiLCJjcmVhdGVMb2NhbFZpZGVvVHJhY2siLCJjcmVhdGVMb2NhbEF1ZGlvVHJhY2siLCJjcmVhdGVMb2NhbFNjcmVlblRyYWNrcyIsIlB1Ymxpc2hBdWRpb0NoZWNrIiwibnVtUGFja2V0cyIsIm1lZGlhVHlwZSIsIlB1Ymxpc2hWaWRlb0NoZWNrIiwiUmVjb25uZWN0Q2hlY2siLCJyZWNvbm5lY3RpbmdUcmlnZ2VyZWQiLCJyZWNvbm5lY3RlZCIsInJlY29ubmVjdFJlc29sdmVyIiwiVFVSTkNoZWNrIiwiam9pblJlcyIsImhhc1RMUyIsImhhc1RVUk4iLCJoYXNTVFVOIiwiV2ViUlRDQ2hlY2siLCJoYXNUY3AiLCJoYXNJcHY0VWRwIiwicHJldlRyaWNrbGUiLCJpc0lQUHJpdmF0ZSIsIlJUQ1BlZXJDb25uZWN0aW9uSWNlRXJyb3JFdmVudCIsImVycm9yQ29kZSIsImVycm9yVGV4dCIsInNlY29uZCIsIldlYlNvY2tldENoZWNrIiwiQ2xvdWQiLCJDb25uZWN0aW9uQ2hlY2siLCJjaGVja1Jlc3VsdHMiLCJnZXROZXh0Q2hlY2tJZCIsIm5leHRJZCIsInVwZGF0ZUNoZWNrIiwiY2hlY2tJZCIsImdldFJlc3VsdHMiLCJjcmVhdGVBbmRSdW5DaGVjayIsImNoZWNrIiwiaGFuZGxlVXBkYXRlIiwiY2hlY2tXZWJzb2NrZXQiLCJjaGVja1dlYlJUQyIsImNoZWNrVFVSTiIsImNoZWNrUmVjb25uZWN0IiwiY2hlY2tQdWJsaXNoQXVkaW8iLCJjaGVja1B1Ymxpc2hWaWRlbyIsImZhY2luZ01vZGVGcm9tTG9jYWxUcmFjayIsInRyYWNrU2V0dGluZ3MiLCJkZWZhdWx0RmFjaW5nTW9kZSIsImNvbmZpZGVuY2UiLCJyYXdGYWNpbmdNb2RlIiwiaXNGYWNpbmdNb2RlVmFsdWUiLCJsYWJlbEFuYWx5c2lzUmVzdWx0IiwiZmFjaW5nTW9kZUZyb21EZXZpY2VMYWJlbCIsImtub3duRGV2aWNlTGFiZWxzIiwia25vd25EZXZpY2VMYWJlbFNlY3Rpb25zIiwiZGV2aWNlTGFiZWwiLCJzZWN0aW9uIiwiYWxsb3dlZFZhbHVlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\n");

/***/ })

};
;